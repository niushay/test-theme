/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@terraformer/arcgis/dist/t-arcgis.esm.js":
/*!***************************************************************!*\
  !*** ./node_modules/@terraformer/arcgis/dist/t-arcgis.esm.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"arcgisToGeoJSON\": () => (/* binding */ arcgisToGeoJSON),\n/* harmony export */   \"geojsonToArcGIS\": () => (/* binding */ geojsonToArcGIS)\n/* harmony export */ });\n/* @preserve\n* @terraformer/arcgis - v2.1.1 - MIT\n* Copyright (c) 2012-2022 Environmental Systems Research Institute, Inc.\n* Tue Aug 02 2022 14:23:48 GMT-0700 (Pacific Daylight Time)\n*/\n/* Copyright (c) 2012-2019 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nvar edgeIntersectsEdge = function edgeIntersectsEdge(a1, a2, b1, b2) {\n  var uaT = (b2[0] - b1[0]) * (a1[1] - b1[1]) - (b2[1] - b1[1]) * (a1[0] - b1[0]);\n  var ubT = (a2[0] - a1[0]) * (a1[1] - b1[1]) - (a2[1] - a1[1]) * (a1[0] - b1[0]);\n  var uB = (b2[1] - b1[1]) * (a2[0] - a1[0]) - (b2[0] - b1[0]) * (a2[1] - a1[1]);\n\n  if (uB !== 0) {\n    var ua = uaT / uB;\n    var ub = ubT / uB;\n\n    if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {\n      return true;\n    }\n  }\n\n  return false;\n};\nvar coordinatesContainPoint = function coordinatesContainPoint(coordinates, point) {\n  var contains = false;\n\n  for (var i = -1, l = coordinates.length, j = l - 1; ++i < l; j = i) {\n    if ((coordinates[i][1] <= point[1] && point[1] < coordinates[j][1] || coordinates[j][1] <= point[1] && point[1] < coordinates[i][1]) && point[0] < (coordinates[j][0] - coordinates[i][0]) * (point[1] - coordinates[i][1]) / (coordinates[j][1] - coordinates[i][1]) + coordinates[i][0]) {\n      contains = !contains;\n    }\n  }\n\n  return contains;\n};\nvar pointsEqual = function pointsEqual(a, b) {\n  for (var i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n};\nvar arrayIntersectsArray = function arrayIntersectsArray(a, b) {\n  for (var i = 0; i < a.length - 1; i++) {\n    for (var j = 0; j < b.length - 1; j++) {\n      if (edgeIntersectsEdge(a[i], a[i + 1], b[j], b[j + 1])) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\n/* Copyright (c) 2012-2019 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nvar closeRing = function closeRing(coordinates) {\n  if (!pointsEqual(coordinates[0], coordinates[coordinates.length - 1])) {\n    coordinates.push(coordinates[0]);\n  }\n\n  return coordinates;\n}; // determine if polygon ring coordinates are clockwise. clockwise signifies outer ring, counter-clockwise an inner ring\n// or hole. this logic was found at http://stackoverflow.com/questions/1165647/how-to-determine-if-a-list-of-polygon-\n// points-are-in-clockwise-order\n\nvar ringIsClockwise = function ringIsClockwise(ringToTest) {\n  var total = 0;\n  var i = 0;\n  var rLength = ringToTest.length;\n  var pt1 = ringToTest[i];\n  var pt2;\n\n  for (i; i < rLength - 1; i++) {\n    pt2 = ringToTest[i + 1];\n    total += (pt2[0] - pt1[0]) * (pt2[1] + pt1[1]);\n    pt1 = pt2;\n  }\n\n  return total >= 0;\n}; // This function ensures that rings are oriented in the right directions\n// from http://jsperf.com/cloning-an-object/2\n\nvar shallowClone = function shallowClone(obj) {\n  var target = {};\n\n  for (var i in obj) {\n    // both arcgis attributes and geojson props are just hardcoded keys\n    if (obj.hasOwnProperty(i)) {\n      // eslint-disable-line no-prototype-builtins\n      target[i] = obj[i];\n    }\n  }\n\n  return target;\n};\n\n/* Copyright (c) 2012-2019 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nvar coordinatesContainCoordinates = function coordinatesContainCoordinates(outer, inner) {\n  var intersects = arrayIntersectsArray(outer, inner);\n  var contains = coordinatesContainPoint(outer, inner[0]);\n\n  if (!intersects && contains) {\n    return true;\n  }\n\n  return false;\n}; // do any polygons in this array contain any other polygons in this array?\n// used for checking for holes in arcgis rings\n\n\nvar convertRingsToGeoJSON = function convertRingsToGeoJSON(rings) {\n  var outerRings = [];\n  var holes = [];\n  var x; // iterator\n\n  var outerRing; // current outer ring being evaluated\n\n  var hole; // current hole being evaluated\n  // for each ring\n\n  for (var r = 0; r < rings.length; r++) {\n    var ring = closeRing(rings[r].slice(0));\n\n    if (ring.length < 4) {\n      continue;\n    } // is this ring an outer ring? is it clockwise?\n\n\n    if (ringIsClockwise(ring)) {\n      var polygon = [ring.slice().reverse()]; // wind outer rings counterclockwise for RFC 7946 compliance\n\n      outerRings.push(polygon); // push to outer rings\n    } else {\n      holes.push(ring.slice().reverse()); // wind inner rings clockwise for RFC 7946 compliance\n    }\n  }\n\n  var uncontainedHoles = []; // while there are holes left...\n\n  while (holes.length) {\n    // pop a hole off out stack\n    hole = holes.pop(); // loop over all outer rings and see if they contain our hole.\n\n    var contained = false;\n\n    for (x = outerRings.length - 1; x >= 0; x--) {\n      outerRing = outerRings[x][0];\n\n      if (coordinatesContainCoordinates(outerRing, hole)) {\n        // the hole is contained push it into our polygon\n        outerRings[x].push(hole);\n        contained = true;\n        break;\n      }\n    } // ring is not contained in any outer ring\n    // sometimes this happens https://github.com/Esri/esri-leaflet/issues/320\n\n\n    if (!contained) {\n      uncontainedHoles.push(hole);\n    }\n  } // if we couldn't match any holes using contains we can try intersects...\n\n\n  while (uncontainedHoles.length) {\n    // pop a hole off out stack\n    hole = uncontainedHoles.pop(); // loop over all outer rings and see if any intersect our hole.\n\n    var intersects = false;\n\n    for (x = outerRings.length - 1; x >= 0; x--) {\n      outerRing = outerRings[x][0];\n\n      if (arrayIntersectsArray(outerRing, hole)) {\n        // the hole is contained push it into our polygon\n        outerRings[x].push(hole);\n        intersects = true;\n        break;\n      }\n    }\n\n    if (!intersects) {\n      outerRings.push([hole.reverse()]);\n    }\n  }\n\n  if (outerRings.length === 1) {\n    return {\n      type: 'Polygon',\n      coordinates: outerRings[0]\n    };\n  } else {\n    return {\n      type: 'MultiPolygon',\n      coordinates: outerRings\n    };\n  }\n};\n\nvar getId = function getId(attributes, idAttribute) {\n  var keys = idAttribute ? [idAttribute, 'OBJECTID', 'FID'] : ['OBJECTID', 'FID'];\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n\n    if (key in attributes && (typeof attributes[key] === 'string' || typeof attributes[key] === 'number')) {\n      return attributes[key];\n    }\n  }\n\n  throw Error('No valid id attribute found');\n};\n\nvar arcgisToGeoJSON = function arcgisToGeoJSON(arcgis, idAttribute) {\n  var geojson = {};\n\n  if (arcgis.features) {\n    geojson.type = 'FeatureCollection';\n    geojson.features = [];\n\n    for (var i = 0; i < arcgis.features.length; i++) {\n      geojson.features.push(arcgisToGeoJSON(arcgis.features[i], idAttribute));\n    }\n  }\n\n  if (typeof arcgis.x === 'number' && typeof arcgis.y === 'number') {\n    geojson.type = 'Point';\n    geojson.coordinates = [arcgis.x, arcgis.y];\n\n    if (typeof arcgis.z === 'number') {\n      geojson.coordinates.push(arcgis.z);\n    }\n  }\n\n  if (arcgis.points) {\n    geojson.type = 'MultiPoint';\n    geojson.coordinates = arcgis.points.slice(0);\n  }\n\n  if (arcgis.paths) {\n    if (arcgis.paths.length === 1) {\n      geojson.type = 'LineString';\n      geojson.coordinates = arcgis.paths[0].slice(0);\n    } else {\n      geojson.type = 'MultiLineString';\n      geojson.coordinates = arcgis.paths.slice(0);\n    }\n  }\n\n  if (arcgis.rings) {\n    geojson = convertRingsToGeoJSON(arcgis.rings.slice(0));\n  }\n\n  if (typeof arcgis.xmin === 'number' && typeof arcgis.ymin === 'number' && typeof arcgis.xmax === 'number' && typeof arcgis.ymax === 'number') {\n    geojson.type = 'Polygon';\n    geojson.coordinates = [[[arcgis.xmax, arcgis.ymax], [arcgis.xmin, arcgis.ymax], [arcgis.xmin, arcgis.ymin], [arcgis.xmax, arcgis.ymin], [arcgis.xmax, arcgis.ymax]]];\n  }\n\n  if (arcgis.geometry || arcgis.attributes) {\n    geojson.type = 'Feature';\n    geojson.geometry = arcgis.geometry ? arcgisToGeoJSON(arcgis.geometry) : null;\n    geojson.properties = arcgis.attributes ? shallowClone(arcgis.attributes) : null;\n\n    if (arcgis.attributes) {\n      try {\n        geojson.id = getId(arcgis.attributes, idAttribute);\n      } catch (err) {// don't set an id\n      }\n    }\n  } // if no valid geometry was encountered\n\n\n  if (JSON.stringify(geojson.geometry) === JSON.stringify({})) {\n    geojson.geometry = null;\n  }\n\n  if (arcgis.spatialReference && arcgis.spatialReference.wkid && arcgis.spatialReference.wkid !== 4326) {\n    console.warn('Object converted in non-standard crs - ' + JSON.stringify(arcgis.spatialReference));\n  }\n\n  return geojson;\n};\n\n/* Copyright (c) 2012-2019 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n// outer rings are clockwise, holes are counterclockwise\n// used for converting GeoJSON Polygons to ArcGIS Polygons\n\nvar orientRings = function orientRings(poly) {\n  var output = [];\n  var polygon = poly.slice(0);\n  var outerRing = closeRing(polygon.shift().slice(0));\n\n  if (outerRing.length >= 4) {\n    if (!ringIsClockwise(outerRing)) {\n      outerRing.reverse();\n    }\n\n    output.push(outerRing);\n\n    for (var i = 0; i < polygon.length; i++) {\n      var hole = closeRing(polygon[i].slice(0));\n\n      if (hole.length >= 4) {\n        if (ringIsClockwise(hole)) {\n          hole.reverse();\n        }\n\n        output.push(hole);\n      }\n    }\n  }\n\n  return output;\n}; // This function flattens holes in multipolygons to one array of polygons\n// used for converting GeoJSON Polygons to ArcGIS Polygons\n\n\nvar flattenMultiPolygonRings = function flattenMultiPolygonRings(rings) {\n  var output = [];\n\n  for (var i = 0; i < rings.length; i++) {\n    var polygon = orientRings(rings[i]);\n\n    for (var x = polygon.length - 1; x >= 0; x--) {\n      var ring = polygon[x].slice(0);\n      output.push(ring);\n    }\n  }\n\n  return output;\n};\n\nvar geojsonToArcGIS = function geojsonToArcGIS(geojson, idAttribute) {\n  idAttribute = idAttribute || 'OBJECTID';\n  var spatialReference = {\n    wkid: 4326\n  };\n  var result = {};\n  var i;\n\n  switch (geojson.type) {\n    case 'Point':\n      result.x = geojson.coordinates[0];\n      result.y = geojson.coordinates[1];\n\n      if (geojson.coordinates[2] != null) {\n        result.z = geojson.coordinates[2];\n      }\n\n      result.spatialReference = spatialReference;\n      break;\n\n    case 'MultiPoint':\n      result.points = geojson.coordinates.slice(0);\n\n      if (geojson.coordinates[0][2] != null) {\n        result.hasZ = true;\n      }\n\n      result.spatialReference = spatialReference;\n      break;\n\n    case 'LineString':\n      result.paths = [geojson.coordinates.slice(0)];\n\n      if (geojson.coordinates[0][2] != null) {\n        result.hasZ = true;\n      }\n\n      result.spatialReference = spatialReference;\n      break;\n\n    case 'MultiLineString':\n      result.paths = geojson.coordinates.slice(0);\n\n      if (geojson.coordinates[0][0][2] != null) {\n        result.hasZ = true;\n      }\n\n      result.spatialReference = spatialReference;\n      break;\n\n    case 'Polygon':\n      result.rings = orientRings(geojson.coordinates.slice(0));\n\n      if (geojson.coordinates[0][0][2] != null) {\n        result.hasZ = true;\n      }\n\n      result.spatialReference = spatialReference;\n      break;\n\n    case 'MultiPolygon':\n      result.rings = flattenMultiPolygonRings(geojson.coordinates.slice(0));\n\n      if (geojson.coordinates[0][0][0][2] != null) {\n        result.hasZ = true;\n      }\n\n      result.spatialReference = spatialReference;\n      break;\n\n    case 'Feature':\n      if (geojson.geometry) {\n        result.geometry = geojsonToArcGIS(geojson.geometry, idAttribute);\n      }\n\n      result.attributes = geojson.properties ? shallowClone(geojson.properties) : {};\n\n      if (geojson.id) {\n        result.attributes[idAttribute] = geojson.id;\n      }\n\n      break;\n\n    case 'FeatureCollection':\n      result = [];\n\n      for (i = 0; i < geojson.features.length; i++) {\n        result.push(geojsonToArcGIS(geojson.features[i], idAttribute));\n      }\n\n      break;\n\n    case 'GeometryCollection':\n      result = [];\n\n      for (i = 0; i < geojson.geometries.length; i++) {\n        result.push(geojsonToArcGIS(geojson.geometries[i], idAttribute));\n      }\n\n      break;\n  }\n\n  return result;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRlcnJhZm9ybWVyL2FyY2dpcy9kaXN0L3QtYXJjZ2lzLmVzbS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzREFBc0QsU0FBUztBQUMvRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxpQkFBaUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVCxpQkFBaUI7O0FBRWpCLFlBQVk7QUFDWjs7QUFFQSxrQkFBa0Isa0JBQWtCO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBLDhDQUE4Qzs7QUFFOUMsZ0NBQWdDO0FBQ2hDLE1BQU07QUFDTiwwQ0FBMEM7QUFDMUM7QUFDQTs7QUFFQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCOztBQUVBLG9DQUFvQyxRQUFRO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkM7O0FBRUEsb0NBQW9DLFFBQVE7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsaUJBQWlCO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGFBQWE7QUFDckI7QUFDQTtBQUNBLElBQUk7OztBQUdKLDREQUE0RDtBQUM1RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9CQUFvQixvQkFBb0I7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7O0FBRUEsa0JBQWtCLGtCQUFrQjtBQUNwQzs7QUFFQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsNkJBQTZCO0FBQy9DO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsK0JBQStCO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUU0QyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdGVycmFmb3JtZXIvYXJjZ2lzL2Rpc3QvdC1hcmNnaXMuZXNtLmpzP2Q3MGUiXSwic291cmNlc0NvbnRlbnQiOlsiLyogQHByZXNlcnZlXG4qIEB0ZXJyYWZvcm1lci9hcmNnaXMgLSB2Mi4xLjEgLSBNSVRcbiogQ29weXJpZ2h0IChjKSAyMDEyLTIwMjIgRW52aXJvbm1lbnRhbCBTeXN0ZW1zIFJlc2VhcmNoIEluc3RpdHV0ZSwgSW5jLlxuKiBUdWUgQXVnIDAyIDIwMjIgMTQ6MjM6NDggR01ULTA3MDAgKFBhY2lmaWMgRGF5bGlnaHQgVGltZSlcbiovXG4vKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxOSBFbnZpcm9ubWVudGFsIFN5c3RlbXMgUmVzZWFyY2ggSW5zdGl0dXRlLCBJbmMuXG4gKiBBcGFjaGUtMi4wICovXG5cbnZhciBlZGdlSW50ZXJzZWN0c0VkZ2UgPSBmdW5jdGlvbiBlZGdlSW50ZXJzZWN0c0VkZ2UoYTEsIGEyLCBiMSwgYjIpIHtcbiAgdmFyIHVhVCA9IChiMlswXSAtIGIxWzBdKSAqIChhMVsxXSAtIGIxWzFdKSAtIChiMlsxXSAtIGIxWzFdKSAqIChhMVswXSAtIGIxWzBdKTtcbiAgdmFyIHViVCA9IChhMlswXSAtIGExWzBdKSAqIChhMVsxXSAtIGIxWzFdKSAtIChhMlsxXSAtIGExWzFdKSAqIChhMVswXSAtIGIxWzBdKTtcbiAgdmFyIHVCID0gKGIyWzFdIC0gYjFbMV0pICogKGEyWzBdIC0gYTFbMF0pIC0gKGIyWzBdIC0gYjFbMF0pICogKGEyWzFdIC0gYTFbMV0pO1xuXG4gIGlmICh1QiAhPT0gMCkge1xuICAgIHZhciB1YSA9IHVhVCAvIHVCO1xuICAgIHZhciB1YiA9IHViVCAvIHVCO1xuXG4gICAgaWYgKHVhID49IDAgJiYgdWEgPD0gMSAmJiB1YiA+PSAwICYmIHViIDw9IDEpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG52YXIgY29vcmRpbmF0ZXNDb250YWluUG9pbnQgPSBmdW5jdGlvbiBjb29yZGluYXRlc0NvbnRhaW5Qb2ludChjb29yZGluYXRlcywgcG9pbnQpIHtcbiAgdmFyIGNvbnRhaW5zID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IC0xLCBsID0gY29vcmRpbmF0ZXMubGVuZ3RoLCBqID0gbCAtIDE7ICsraSA8IGw7IGogPSBpKSB7XG4gICAgaWYgKChjb29yZGluYXRlc1tpXVsxXSA8PSBwb2ludFsxXSAmJiBwb2ludFsxXSA8IGNvb3JkaW5hdGVzW2pdWzFdIHx8IGNvb3JkaW5hdGVzW2pdWzFdIDw9IHBvaW50WzFdICYmIHBvaW50WzFdIDwgY29vcmRpbmF0ZXNbaV1bMV0pICYmIHBvaW50WzBdIDwgKGNvb3JkaW5hdGVzW2pdWzBdIC0gY29vcmRpbmF0ZXNbaV1bMF0pICogKHBvaW50WzFdIC0gY29vcmRpbmF0ZXNbaV1bMV0pIC8gKGNvb3JkaW5hdGVzW2pdWzFdIC0gY29vcmRpbmF0ZXNbaV1bMV0pICsgY29vcmRpbmF0ZXNbaV1bMF0pIHtcbiAgICAgIGNvbnRhaW5zID0gIWNvbnRhaW5zO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb250YWlucztcbn07XG52YXIgcG9pbnRzRXF1YWwgPSBmdW5jdGlvbiBwb2ludHNFcXVhbChhLCBiKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIGFycmF5SW50ZXJzZWN0c0FycmF5ID0gZnVuY3Rpb24gYXJyYXlJbnRlcnNlY3RzQXJyYXkoYSwgYikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBiLmxlbmd0aCAtIDE7IGorKykge1xuICAgICAgaWYgKGVkZ2VJbnRlcnNlY3RzRWRnZShhW2ldLCBhW2kgKyAxXSwgYltqXSwgYltqICsgMV0pKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qIENvcHlyaWdodCAoYykgMjAxMi0yMDE5IEVudmlyb25tZW50YWwgU3lzdGVtcyBSZXNlYXJjaCBJbnN0aXR1dGUsIEluYy5cbiAqIEFwYWNoZS0yLjAgKi9cblxudmFyIGNsb3NlUmluZyA9IGZ1bmN0aW9uIGNsb3NlUmluZyhjb29yZGluYXRlcykge1xuICBpZiAoIXBvaW50c0VxdWFsKGNvb3JkaW5hdGVzWzBdLCBjb29yZGluYXRlc1tjb29yZGluYXRlcy5sZW5ndGggLSAxXSkpIHtcbiAgICBjb29yZGluYXRlcy5wdXNoKGNvb3JkaW5hdGVzWzBdKTtcbiAgfVxuXG4gIHJldHVybiBjb29yZGluYXRlcztcbn07IC8vIGRldGVybWluZSBpZiBwb2x5Z29uIHJpbmcgY29vcmRpbmF0ZXMgYXJlIGNsb2Nrd2lzZS4gY2xvY2t3aXNlIHNpZ25pZmllcyBvdXRlciByaW5nLCBjb3VudGVyLWNsb2Nrd2lzZSBhbiBpbm5lciByaW5nXG4vLyBvciBob2xlLiB0aGlzIGxvZ2ljIHdhcyBmb3VuZCBhdCBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzExNjU2NDcvaG93LXRvLWRldGVybWluZS1pZi1hLWxpc3Qtb2YtcG9seWdvbi1cbi8vIHBvaW50cy1hcmUtaW4tY2xvY2t3aXNlLW9yZGVyXG5cbnZhciByaW5nSXNDbG9ja3dpc2UgPSBmdW5jdGlvbiByaW5nSXNDbG9ja3dpc2UocmluZ1RvVGVzdCkge1xuICB2YXIgdG90YWwgPSAwO1xuICB2YXIgaSA9IDA7XG4gIHZhciByTGVuZ3RoID0gcmluZ1RvVGVzdC5sZW5ndGg7XG4gIHZhciBwdDEgPSByaW5nVG9UZXN0W2ldO1xuICB2YXIgcHQyO1xuXG4gIGZvciAoaTsgaSA8IHJMZW5ndGggLSAxOyBpKyspIHtcbiAgICBwdDIgPSByaW5nVG9UZXN0W2kgKyAxXTtcbiAgICB0b3RhbCArPSAocHQyWzBdIC0gcHQxWzBdKSAqIChwdDJbMV0gKyBwdDFbMV0pO1xuICAgIHB0MSA9IHB0MjtcbiAgfVxuXG4gIHJldHVybiB0b3RhbCA+PSAwO1xufTsgLy8gVGhpcyBmdW5jdGlvbiBlbnN1cmVzIHRoYXQgcmluZ3MgYXJlIG9yaWVudGVkIGluIHRoZSByaWdodCBkaXJlY3Rpb25zXG4vLyBmcm9tIGh0dHA6Ly9qc3BlcmYuY29tL2Nsb25pbmctYW4tb2JqZWN0LzJcblxudmFyIHNoYWxsb3dDbG9uZSA9IGZ1bmN0aW9uIHNoYWxsb3dDbG9uZShvYmopIHtcbiAgdmFyIHRhcmdldCA9IHt9O1xuXG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgLy8gYm90aCBhcmNnaXMgYXR0cmlidXRlcyBhbmQgZ2VvanNvbiBwcm9wcyBhcmUganVzdCBoYXJkY29kZWQga2V5c1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICB0YXJnZXRbaV0gPSBvYmpbaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbi8qIENvcHlyaWdodCAoYykgMjAxMi0yMDE5IEVudmlyb25tZW50YWwgU3lzdGVtcyBSZXNlYXJjaCBJbnN0aXR1dGUsIEluYy5cbiAqIEFwYWNoZS0yLjAgKi9cblxudmFyIGNvb3JkaW5hdGVzQ29udGFpbkNvb3JkaW5hdGVzID0gZnVuY3Rpb24gY29vcmRpbmF0ZXNDb250YWluQ29vcmRpbmF0ZXMob3V0ZXIsIGlubmVyKSB7XG4gIHZhciBpbnRlcnNlY3RzID0gYXJyYXlJbnRlcnNlY3RzQXJyYXkob3V0ZXIsIGlubmVyKTtcbiAgdmFyIGNvbnRhaW5zID0gY29vcmRpbmF0ZXNDb250YWluUG9pbnQob3V0ZXIsIGlubmVyWzBdKTtcblxuICBpZiAoIWludGVyc2VjdHMgJiYgY29udGFpbnMpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07IC8vIGRvIGFueSBwb2x5Z29ucyBpbiB0aGlzIGFycmF5IGNvbnRhaW4gYW55IG90aGVyIHBvbHlnb25zIGluIHRoaXMgYXJyYXk/XG4vLyB1c2VkIGZvciBjaGVja2luZyBmb3IgaG9sZXMgaW4gYXJjZ2lzIHJpbmdzXG5cblxudmFyIGNvbnZlcnRSaW5nc1RvR2VvSlNPTiA9IGZ1bmN0aW9uIGNvbnZlcnRSaW5nc1RvR2VvSlNPTihyaW5ncykge1xuICB2YXIgb3V0ZXJSaW5ncyA9IFtdO1xuICB2YXIgaG9sZXMgPSBbXTtcbiAgdmFyIHg7IC8vIGl0ZXJhdG9yXG5cbiAgdmFyIG91dGVyUmluZzsgLy8gY3VycmVudCBvdXRlciByaW5nIGJlaW5nIGV2YWx1YXRlZFxuXG4gIHZhciBob2xlOyAvLyBjdXJyZW50IGhvbGUgYmVpbmcgZXZhbHVhdGVkXG4gIC8vIGZvciBlYWNoIHJpbmdcblxuICBmb3IgKHZhciByID0gMDsgciA8IHJpbmdzLmxlbmd0aDsgcisrKSB7XG4gICAgdmFyIHJpbmcgPSBjbG9zZVJpbmcocmluZ3Nbcl0uc2xpY2UoMCkpO1xuXG4gICAgaWYgKHJpbmcubGVuZ3RoIDwgNCkge1xuICAgICAgY29udGludWU7XG4gICAgfSAvLyBpcyB0aGlzIHJpbmcgYW4gb3V0ZXIgcmluZz8gaXMgaXQgY2xvY2t3aXNlP1xuXG5cbiAgICBpZiAocmluZ0lzQ2xvY2t3aXNlKHJpbmcpKSB7XG4gICAgICB2YXIgcG9seWdvbiA9IFtyaW5nLnNsaWNlKCkucmV2ZXJzZSgpXTsgLy8gd2luZCBvdXRlciByaW5ncyBjb3VudGVyY2xvY2t3aXNlIGZvciBSRkMgNzk0NiBjb21wbGlhbmNlXG5cbiAgICAgIG91dGVyUmluZ3MucHVzaChwb2x5Z29uKTsgLy8gcHVzaCB0byBvdXRlciByaW5nc1xuICAgIH0gZWxzZSB7XG4gICAgICBob2xlcy5wdXNoKHJpbmcuc2xpY2UoKS5yZXZlcnNlKCkpOyAvLyB3aW5kIGlubmVyIHJpbmdzIGNsb2Nrd2lzZSBmb3IgUkZDIDc5NDYgY29tcGxpYW5jZVxuICAgIH1cbiAgfVxuXG4gIHZhciB1bmNvbnRhaW5lZEhvbGVzID0gW107IC8vIHdoaWxlIHRoZXJlIGFyZSBob2xlcyBsZWZ0Li4uXG5cbiAgd2hpbGUgKGhvbGVzLmxlbmd0aCkge1xuICAgIC8vIHBvcCBhIGhvbGUgb2ZmIG91dCBzdGFja1xuICAgIGhvbGUgPSBob2xlcy5wb3AoKTsgLy8gbG9vcCBvdmVyIGFsbCBvdXRlciByaW5ncyBhbmQgc2VlIGlmIHRoZXkgY29udGFpbiBvdXIgaG9sZS5cblxuICAgIHZhciBjb250YWluZWQgPSBmYWxzZTtcblxuICAgIGZvciAoeCA9IG91dGVyUmluZ3MubGVuZ3RoIC0gMTsgeCA+PSAwOyB4LS0pIHtcbiAgICAgIG91dGVyUmluZyA9IG91dGVyUmluZ3NbeF1bMF07XG5cbiAgICAgIGlmIChjb29yZGluYXRlc0NvbnRhaW5Db29yZGluYXRlcyhvdXRlclJpbmcsIGhvbGUpKSB7XG4gICAgICAgIC8vIHRoZSBob2xlIGlzIGNvbnRhaW5lZCBwdXNoIGl0IGludG8gb3VyIHBvbHlnb25cbiAgICAgICAgb3V0ZXJSaW5nc1t4XS5wdXNoKGhvbGUpO1xuICAgICAgICBjb250YWluZWQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IC8vIHJpbmcgaXMgbm90IGNvbnRhaW5lZCBpbiBhbnkgb3V0ZXIgcmluZ1xuICAgIC8vIHNvbWV0aW1lcyB0aGlzIGhhcHBlbnMgaHR0cHM6Ly9naXRodWIuY29tL0VzcmkvZXNyaS1sZWFmbGV0L2lzc3Vlcy8zMjBcblxuXG4gICAgaWYgKCFjb250YWluZWQpIHtcbiAgICAgIHVuY29udGFpbmVkSG9sZXMucHVzaChob2xlKTtcbiAgICB9XG4gIH0gLy8gaWYgd2UgY291bGRuJ3QgbWF0Y2ggYW55IGhvbGVzIHVzaW5nIGNvbnRhaW5zIHdlIGNhbiB0cnkgaW50ZXJzZWN0cy4uLlxuXG5cbiAgd2hpbGUgKHVuY29udGFpbmVkSG9sZXMubGVuZ3RoKSB7XG4gICAgLy8gcG9wIGEgaG9sZSBvZmYgb3V0IHN0YWNrXG4gICAgaG9sZSA9IHVuY29udGFpbmVkSG9sZXMucG9wKCk7IC8vIGxvb3Agb3ZlciBhbGwgb3V0ZXIgcmluZ3MgYW5kIHNlZSBpZiBhbnkgaW50ZXJzZWN0IG91ciBob2xlLlxuXG4gICAgdmFyIGludGVyc2VjdHMgPSBmYWxzZTtcblxuICAgIGZvciAoeCA9IG91dGVyUmluZ3MubGVuZ3RoIC0gMTsgeCA+PSAwOyB4LS0pIHtcbiAgICAgIG91dGVyUmluZyA9IG91dGVyUmluZ3NbeF1bMF07XG5cbiAgICAgIGlmIChhcnJheUludGVyc2VjdHNBcnJheShvdXRlclJpbmcsIGhvbGUpKSB7XG4gICAgICAgIC8vIHRoZSBob2xlIGlzIGNvbnRhaW5lZCBwdXNoIGl0IGludG8gb3VyIHBvbHlnb25cbiAgICAgICAgb3V0ZXJSaW5nc1t4XS5wdXNoKGhvbGUpO1xuICAgICAgICBpbnRlcnNlY3RzID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFpbnRlcnNlY3RzKSB7XG4gICAgICBvdXRlclJpbmdzLnB1c2goW2hvbGUucmV2ZXJzZSgpXSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG91dGVyUmluZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdQb2x5Z29uJyxcbiAgICAgIGNvb3JkaW5hdGVzOiBvdXRlclJpbmdzWzBdXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ011bHRpUG9seWdvbicsXG4gICAgICBjb29yZGluYXRlczogb3V0ZXJSaW5nc1xuICAgIH07XG4gIH1cbn07XG5cbnZhciBnZXRJZCA9IGZ1bmN0aW9uIGdldElkKGF0dHJpYnV0ZXMsIGlkQXR0cmlidXRlKSB7XG4gIHZhciBrZXlzID0gaWRBdHRyaWJ1dGUgPyBbaWRBdHRyaWJ1dGUsICdPQkpFQ1RJRCcsICdGSUQnXSA6IFsnT0JKRUNUSUQnLCAnRklEJ107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICBpZiAoa2V5IGluIGF0dHJpYnV0ZXMgJiYgKHR5cGVvZiBhdHRyaWJ1dGVzW2tleV0gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBhdHRyaWJ1dGVzW2tleV0gPT09ICdudW1iZXInKSkge1xuICAgICAgcmV0dXJuIGF0dHJpYnV0ZXNba2V5XTtcbiAgICB9XG4gIH1cblxuICB0aHJvdyBFcnJvcignTm8gdmFsaWQgaWQgYXR0cmlidXRlIGZvdW5kJyk7XG59O1xuXG52YXIgYXJjZ2lzVG9HZW9KU09OID0gZnVuY3Rpb24gYXJjZ2lzVG9HZW9KU09OKGFyY2dpcywgaWRBdHRyaWJ1dGUpIHtcbiAgdmFyIGdlb2pzb24gPSB7fTtcblxuICBpZiAoYXJjZ2lzLmZlYXR1cmVzKSB7XG4gICAgZ2VvanNvbi50eXBlID0gJ0ZlYXR1cmVDb2xsZWN0aW9uJztcbiAgICBnZW9qc29uLmZlYXR1cmVzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyY2dpcy5mZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgZ2VvanNvbi5mZWF0dXJlcy5wdXNoKGFyY2dpc1RvR2VvSlNPTihhcmNnaXMuZmVhdHVyZXNbaV0sIGlkQXR0cmlidXRlKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBhcmNnaXMueCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGFyY2dpcy55ID09PSAnbnVtYmVyJykge1xuICAgIGdlb2pzb24udHlwZSA9ICdQb2ludCc7XG4gICAgZ2VvanNvbi5jb29yZGluYXRlcyA9IFthcmNnaXMueCwgYXJjZ2lzLnldO1xuXG4gICAgaWYgKHR5cGVvZiBhcmNnaXMueiA9PT0gJ251bWJlcicpIHtcbiAgICAgIGdlb2pzb24uY29vcmRpbmF0ZXMucHVzaChhcmNnaXMueik7XG4gICAgfVxuICB9XG5cbiAgaWYgKGFyY2dpcy5wb2ludHMpIHtcbiAgICBnZW9qc29uLnR5cGUgPSAnTXVsdGlQb2ludCc7XG4gICAgZ2VvanNvbi5jb29yZGluYXRlcyA9IGFyY2dpcy5wb2ludHMuc2xpY2UoMCk7XG4gIH1cblxuICBpZiAoYXJjZ2lzLnBhdGhzKSB7XG4gICAgaWYgKGFyY2dpcy5wYXRocy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGdlb2pzb24udHlwZSA9ICdMaW5lU3RyaW5nJztcbiAgICAgIGdlb2pzb24uY29vcmRpbmF0ZXMgPSBhcmNnaXMucGF0aHNbMF0uc2xpY2UoMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlb2pzb24udHlwZSA9ICdNdWx0aUxpbmVTdHJpbmcnO1xuICAgICAgZ2VvanNvbi5jb29yZGluYXRlcyA9IGFyY2dpcy5wYXRocy5zbGljZSgwKTtcbiAgICB9XG4gIH1cblxuICBpZiAoYXJjZ2lzLnJpbmdzKSB7XG4gICAgZ2VvanNvbiA9IGNvbnZlcnRSaW5nc1RvR2VvSlNPTihhcmNnaXMucmluZ3Muc2xpY2UoMCkpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBhcmNnaXMueG1pbiA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGFyY2dpcy55bWluID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgYXJjZ2lzLnhtYXggPT09ICdudW1iZXInICYmIHR5cGVvZiBhcmNnaXMueW1heCA9PT0gJ251bWJlcicpIHtcbiAgICBnZW9qc29uLnR5cGUgPSAnUG9seWdvbic7XG4gICAgZ2VvanNvbi5jb29yZGluYXRlcyA9IFtbW2FyY2dpcy54bWF4LCBhcmNnaXMueW1heF0sIFthcmNnaXMueG1pbiwgYXJjZ2lzLnltYXhdLCBbYXJjZ2lzLnhtaW4sIGFyY2dpcy55bWluXSwgW2FyY2dpcy54bWF4LCBhcmNnaXMueW1pbl0sIFthcmNnaXMueG1heCwgYXJjZ2lzLnltYXhdXV07XG4gIH1cblxuICBpZiAoYXJjZ2lzLmdlb21ldHJ5IHx8IGFyY2dpcy5hdHRyaWJ1dGVzKSB7XG4gICAgZ2VvanNvbi50eXBlID0gJ0ZlYXR1cmUnO1xuICAgIGdlb2pzb24uZ2VvbWV0cnkgPSBhcmNnaXMuZ2VvbWV0cnkgPyBhcmNnaXNUb0dlb0pTT04oYXJjZ2lzLmdlb21ldHJ5KSA6IG51bGw7XG4gICAgZ2VvanNvbi5wcm9wZXJ0aWVzID0gYXJjZ2lzLmF0dHJpYnV0ZXMgPyBzaGFsbG93Q2xvbmUoYXJjZ2lzLmF0dHJpYnV0ZXMpIDogbnVsbDtcblxuICAgIGlmIChhcmNnaXMuYXR0cmlidXRlcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZ2VvanNvbi5pZCA9IGdldElkKGFyY2dpcy5hdHRyaWJ1dGVzLCBpZEF0dHJpYnV0ZSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHsvLyBkb24ndCBzZXQgYW4gaWRcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gaWYgbm8gdmFsaWQgZ2VvbWV0cnkgd2FzIGVuY291bnRlcmVkXG5cblxuICBpZiAoSlNPTi5zdHJpbmdpZnkoZ2VvanNvbi5nZW9tZXRyeSkgPT09IEpTT04uc3RyaW5naWZ5KHt9KSkge1xuICAgIGdlb2pzb24uZ2VvbWV0cnkgPSBudWxsO1xuICB9XG5cbiAgaWYgKGFyY2dpcy5zcGF0aWFsUmVmZXJlbmNlICYmIGFyY2dpcy5zcGF0aWFsUmVmZXJlbmNlLndraWQgJiYgYXJjZ2lzLnNwYXRpYWxSZWZlcmVuY2Uud2tpZCAhPT0gNDMyNikge1xuICAgIGNvbnNvbGUud2FybignT2JqZWN0IGNvbnZlcnRlZCBpbiBub24tc3RhbmRhcmQgY3JzIC0gJyArIEpTT04uc3RyaW5naWZ5KGFyY2dpcy5zcGF0aWFsUmVmZXJlbmNlKSk7XG4gIH1cblxuICByZXR1cm4gZ2VvanNvbjtcbn07XG5cbi8qIENvcHlyaWdodCAoYykgMjAxMi0yMDE5IEVudmlyb25tZW50YWwgU3lzdGVtcyBSZXNlYXJjaCBJbnN0aXR1dGUsIEluYy5cbiAqIEFwYWNoZS0yLjAgKi9cbi8vIG91dGVyIHJpbmdzIGFyZSBjbG9ja3dpc2UsIGhvbGVzIGFyZSBjb3VudGVyY2xvY2t3aXNlXG4vLyB1c2VkIGZvciBjb252ZXJ0aW5nIEdlb0pTT04gUG9seWdvbnMgdG8gQXJjR0lTIFBvbHlnb25zXG5cbnZhciBvcmllbnRSaW5ncyA9IGZ1bmN0aW9uIG9yaWVudFJpbmdzKHBvbHkpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICB2YXIgcG9seWdvbiA9IHBvbHkuc2xpY2UoMCk7XG4gIHZhciBvdXRlclJpbmcgPSBjbG9zZVJpbmcocG9seWdvbi5zaGlmdCgpLnNsaWNlKDApKTtcblxuICBpZiAob3V0ZXJSaW5nLmxlbmd0aCA+PSA0KSB7XG4gICAgaWYgKCFyaW5nSXNDbG9ja3dpc2Uob3V0ZXJSaW5nKSkge1xuICAgICAgb3V0ZXJSaW5nLnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICBvdXRwdXQucHVzaChvdXRlclJpbmcpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2x5Z29uLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaG9sZSA9IGNsb3NlUmluZyhwb2x5Z29uW2ldLnNsaWNlKDApKTtcblxuICAgICAgaWYgKGhvbGUubGVuZ3RoID49IDQpIHtcbiAgICAgICAgaWYgKHJpbmdJc0Nsb2Nrd2lzZShob2xlKSkge1xuICAgICAgICAgIGhvbGUucmV2ZXJzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0cHV0LnB1c2goaG9sZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn07IC8vIFRoaXMgZnVuY3Rpb24gZmxhdHRlbnMgaG9sZXMgaW4gbXVsdGlwb2x5Z29ucyB0byBvbmUgYXJyYXkgb2YgcG9seWdvbnNcbi8vIHVzZWQgZm9yIGNvbnZlcnRpbmcgR2VvSlNPTiBQb2x5Z29ucyB0byBBcmNHSVMgUG9seWdvbnNcblxuXG52YXIgZmxhdHRlbk11bHRpUG9seWdvblJpbmdzID0gZnVuY3Rpb24gZmxhdHRlbk11bHRpUG9seWdvblJpbmdzKHJpbmdzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBvbHlnb24gPSBvcmllbnRSaW5ncyhyaW5nc1tpXSk7XG5cbiAgICBmb3IgKHZhciB4ID0gcG9seWdvbi5sZW5ndGggLSAxOyB4ID49IDA7IHgtLSkge1xuICAgICAgdmFyIHJpbmcgPSBwb2x5Z29uW3hdLnNsaWNlKDApO1xuICAgICAgb3V0cHV0LnB1c2gocmluZyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbnZhciBnZW9qc29uVG9BcmNHSVMgPSBmdW5jdGlvbiBnZW9qc29uVG9BcmNHSVMoZ2VvanNvbiwgaWRBdHRyaWJ1dGUpIHtcbiAgaWRBdHRyaWJ1dGUgPSBpZEF0dHJpYnV0ZSB8fCAnT0JKRUNUSUQnO1xuICB2YXIgc3BhdGlhbFJlZmVyZW5jZSA9IHtcbiAgICB3a2lkOiA0MzI2XG4gIH07XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgdmFyIGk7XG5cbiAgc3dpdGNoIChnZW9qc29uLnR5cGUpIHtcbiAgICBjYXNlICdQb2ludCc6XG4gICAgICByZXN1bHQueCA9IGdlb2pzb24uY29vcmRpbmF0ZXNbMF07XG4gICAgICByZXN1bHQueSA9IGdlb2pzb24uY29vcmRpbmF0ZXNbMV07XG5cbiAgICAgIGlmIChnZW9qc29uLmNvb3JkaW5hdGVzWzJdICE9IG51bGwpIHtcbiAgICAgICAgcmVzdWx0LnogPSBnZW9qc29uLmNvb3JkaW5hdGVzWzJdO1xuICAgICAgfVxuXG4gICAgICByZXN1bHQuc3BhdGlhbFJlZmVyZW5jZSA9IHNwYXRpYWxSZWZlcmVuY2U7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ011bHRpUG9pbnQnOlxuICAgICAgcmVzdWx0LnBvaW50cyA9IGdlb2pzb24uY29vcmRpbmF0ZXMuc2xpY2UoMCk7XG5cbiAgICAgIGlmIChnZW9qc29uLmNvb3JkaW5hdGVzWzBdWzJdICE9IG51bGwpIHtcbiAgICAgICAgcmVzdWx0Lmhhc1ogPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXN1bHQuc3BhdGlhbFJlZmVyZW5jZSA9IHNwYXRpYWxSZWZlcmVuY2U7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ0xpbmVTdHJpbmcnOlxuICAgICAgcmVzdWx0LnBhdGhzID0gW2dlb2pzb24uY29vcmRpbmF0ZXMuc2xpY2UoMCldO1xuXG4gICAgICBpZiAoZ2VvanNvbi5jb29yZGluYXRlc1swXVsyXSAhPSBudWxsKSB7XG4gICAgICAgIHJlc3VsdC5oYXNaID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0LnNwYXRpYWxSZWZlcmVuY2UgPSBzcGF0aWFsUmVmZXJlbmNlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdNdWx0aUxpbmVTdHJpbmcnOlxuICAgICAgcmVzdWx0LnBhdGhzID0gZ2VvanNvbi5jb29yZGluYXRlcy5zbGljZSgwKTtcblxuICAgICAgaWYgKGdlb2pzb24uY29vcmRpbmF0ZXNbMF1bMF1bMl0gIT0gbnVsbCkge1xuICAgICAgICByZXN1bHQuaGFzWiA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdC5zcGF0aWFsUmVmZXJlbmNlID0gc3BhdGlhbFJlZmVyZW5jZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnUG9seWdvbic6XG4gICAgICByZXN1bHQucmluZ3MgPSBvcmllbnRSaW5ncyhnZW9qc29uLmNvb3JkaW5hdGVzLnNsaWNlKDApKTtcblxuICAgICAgaWYgKGdlb2pzb24uY29vcmRpbmF0ZXNbMF1bMF1bMl0gIT0gbnVsbCkge1xuICAgICAgICByZXN1bHQuaGFzWiA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdC5zcGF0aWFsUmVmZXJlbmNlID0gc3BhdGlhbFJlZmVyZW5jZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnTXVsdGlQb2x5Z29uJzpcbiAgICAgIHJlc3VsdC5yaW5ncyA9IGZsYXR0ZW5NdWx0aVBvbHlnb25SaW5ncyhnZW9qc29uLmNvb3JkaW5hdGVzLnNsaWNlKDApKTtcblxuICAgICAgaWYgKGdlb2pzb24uY29vcmRpbmF0ZXNbMF1bMF1bMF1bMl0gIT0gbnVsbCkge1xuICAgICAgICByZXN1bHQuaGFzWiA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdC5zcGF0aWFsUmVmZXJlbmNlID0gc3BhdGlhbFJlZmVyZW5jZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnRmVhdHVyZSc6XG4gICAgICBpZiAoZ2VvanNvbi5nZW9tZXRyeSkge1xuICAgICAgICByZXN1bHQuZ2VvbWV0cnkgPSBnZW9qc29uVG9BcmNHSVMoZ2VvanNvbi5nZW9tZXRyeSwgaWRBdHRyaWJ1dGUpO1xuICAgICAgfVxuXG4gICAgICByZXN1bHQuYXR0cmlidXRlcyA9IGdlb2pzb24ucHJvcGVydGllcyA/IHNoYWxsb3dDbG9uZShnZW9qc29uLnByb3BlcnRpZXMpIDoge307XG5cbiAgICAgIGlmIChnZW9qc29uLmlkKSB7XG4gICAgICAgIHJlc3VsdC5hdHRyaWJ1dGVzW2lkQXR0cmlidXRlXSA9IGdlb2pzb24uaWQ7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnRmVhdHVyZUNvbGxlY3Rpb24nOlxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBnZW9qc29uLmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGdlb2pzb25Ub0FyY0dJUyhnZW9qc29uLmZlYXR1cmVzW2ldLCBpZEF0dHJpYnV0ZSkpO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ0dlb21ldHJ5Q29sbGVjdGlvbic6XG4gICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGdlb2pzb24uZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaChnZW9qc29uVG9BcmNHSVMoZ2VvanNvbi5nZW9tZXRyaWVzW2ldLCBpZEF0dHJpYnV0ZSkpO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5leHBvcnQgeyBhcmNnaXNUb0dlb0pTT04sIGdlb2pzb25Ub0FyY0dJUyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@terraformer/arcgis/dist/t-arcgis.esm.js\n");

/***/ }),

/***/ "./resources/assets/core/plugins/custom/leaflet/leaflet.js":
/*!*****************************************************************!*\
  !*** ./resources/assets/core/plugins/custom/leaflet/leaflet.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("// Leaflet - Leaflet is the leading open-source JavaScript library for mobile-friendly interactive maps: https://leafletjs.com/\n\nwindow.L = __webpack_require__(/*! leaflet/dist/leaflet.js */ \"./node_modules/leaflet/dist/leaflet.js\");\n__webpack_require__(/*! esri-leaflet */ \"./node_modules/esri-leaflet/src/EsriLeaflet.js\");\nwindow.L.esri = __webpack_require__(/*! esri-leaflet-geocoder */ \"./node_modules/esri-leaflet-geocoder/dist/esri-leaflet-geocoder-debug.js\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvYXNzZXRzL2NvcmUvcGx1Z2lucy9jdXN0b20vbGVhZmxldC9sZWFmbGV0LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBQSxNQUFNLENBQUNDLENBQUMsR0FBR0MsbUJBQU8sQ0FBQyx1RUFBeUIsQ0FBQztBQUM3Q0EsbUJBQU8sQ0FBQyxvRUFBYyxDQUFDO0FBQ3ZCRixNQUFNLENBQUNDLENBQUMsQ0FBQ0UsSUFBSSxHQUFHRCxtQkFBTyxDQUFDLHVHQUF1QixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy9jb3JlL3BsdWdpbnMvY3VzdG9tL2xlYWZsZXQvbGVhZmxldC5qcz8wMzM2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIExlYWZsZXQgLSBMZWFmbGV0IGlzIHRoZSBsZWFkaW5nIG9wZW4tc291cmNlIEphdmFTY3JpcHQgbGlicmFyeSBmb3IgbW9iaWxlLWZyaWVuZGx5IGludGVyYWN0aXZlIG1hcHM6IGh0dHBzOi8vbGVhZmxldGpzLmNvbS9cclxuXHJcbndpbmRvdy5MID0gcmVxdWlyZSgnbGVhZmxldC9kaXN0L2xlYWZsZXQuanMnKTtcclxucmVxdWlyZSgnZXNyaS1sZWFmbGV0Jyk7XHJcbndpbmRvdy5MLmVzcmkgPSByZXF1aXJlKCdlc3JpLWxlYWZsZXQtZ2VvY29kZXInKTtcclxuIl0sIm5hbWVzIjpbIndpbmRvdyIsIkwiLCJyZXF1aXJlIiwiZXNyaSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/assets/core/plugins/custom/leaflet/leaflet.js\n");

/***/ }),

/***/ "./node_modules/esri-leaflet-geocoder/dist/esri-leaflet-geocoder-debug.js":
/*!********************************************************************************!*\
  !*** ./node_modules/esri-leaflet-geocoder/dist/esri-leaflet-geocoder-debug.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("/* esri-leaflet-geocoder - v3.1.3 - Fri Apr 08 2022 10:06:56 GMT-0500 (Central Daylight Time)\n * Copyright (c) 2022 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n(function (global, factory) {\n   true ? factory(exports, __webpack_require__(/*! leaflet */ \"./node_modules/leaflet/dist/leaflet-src.js\"), __webpack_require__(/*! esri-leaflet */ \"./node_modules/esri-leaflet/src/EsriLeaflet.js\")) :\n  0;\n})(this, (function (exports, leaflet, esriLeaflet) { 'use strict';\n\n  var version = \"3.1.3\";\n\n  var WorldGeocodingServiceUrl = 'https://geocode-api.arcgis.com/arcgis/rest/services/World/GeocodeServer/';\n\n  var Geocode = esriLeaflet.Task.extend({\r\n    path: 'findAddressCandidates',\r\n\r\n    params: {\r\n      outSr: 4326,\r\n      forStorage: false,\r\n      outFields: '*',\r\n      maxLocations: 20\r\n    },\r\n\r\n    setters: {\r\n      address: 'address',\r\n      neighborhood: 'neighborhood',\r\n      city: 'city',\r\n      subregion: 'subregion',\r\n      region: 'region',\r\n      postal: 'postal',\r\n      country: 'country',\r\n      text: 'singleLine',\r\n      category: 'category',\r\n      token: 'token',\r\n      apikey: 'apikey',\r\n      key: 'magicKey',\r\n      fields: 'outFields',\r\n      forStorage: 'forStorage',\r\n      maxLocations: 'maxLocations',\r\n      // World Geocoding Service (only works with singleLine)\r\n      countries: 'sourceCountry'\r\n    },\r\n\r\n    initialize: function (options) {\r\n      options = options || {};\r\n      options.url = options.url || WorldGeocodingServiceUrl;\r\n      esriLeaflet.Task.prototype.initialize.call(this, options);\r\n    },\r\n\r\n    within: function (bounds) {\r\n      bounds = leaflet.latLngBounds(bounds);\r\n      this.params.searchExtent = esriLeaflet.Util.boundsToExtent(bounds);\r\n      return this;\r\n    },\r\n\r\n    nearby: function (coords, radius) {\r\n      var centroid = leaflet.latLng(coords);\r\n      this.params.location = centroid.lng + ',' + centroid.lat;\r\n      if (radius) {\r\n        this.params.distance = Math.min(Math.max(radius, 2000), 50000);\r\n      }\r\n      return this;\r\n    },\r\n\r\n    run: function (callback, context) {\r\n      if (this.options.token) {\r\n        this.params.token = this.options.token;\r\n      }\r\n      if (this.options.apikey) {\r\n        this.params.token = this.options.apikey;\r\n      }\r\n      if (this.options.customParam) {\r\n        this.params[this.options.customParam] = this.params.singleLine;\r\n        delete this.params.singleLine;\r\n      }\r\n\r\n      return this.request(function (error, response) {\r\n        var processor = this._processGeocoderResponse;\r\n        var results = (!error) ? processor(response) : undefined;\r\n        callback.call(context, error, { results: results }, response);\r\n      }, this);\r\n    },\r\n\r\n    _processGeocoderResponse: function (response) {\r\n      var results = [];\r\n\r\n      for (var i = 0; i < response.candidates.length; i++) {\r\n        var candidate = response.candidates[i];\r\n        if (candidate.extent) {\r\n          var bounds = esriLeaflet.Util.extentToBounds(candidate.extent);\r\n        }\r\n\r\n        results.push({\r\n          text: candidate.address,\r\n          bounds: bounds,\r\n          score: candidate.score,\r\n          latlng: leaflet.latLng(candidate.location.y, candidate.location.x),\r\n          properties: candidate.attributes\r\n        });\r\n      }\r\n      return results;\r\n    }\r\n  });\r\n\r\n  function geocode (options) {\r\n    return new Geocode(options);\r\n  }\n\n  var ReverseGeocode = esriLeaflet.Task.extend({\r\n    path: 'reverseGeocode',\r\n\r\n    params: {\r\n      outSR: 4326,\r\n      returnIntersection: false\r\n    },\r\n\r\n    setters: {\r\n      distance: 'distance',\r\n      language: 'langCode',\r\n      intersection: 'returnIntersection',\r\n      apikey: 'apikey'\r\n    },\r\n\r\n    initialize: function (options) {\r\n      options = options || {};\r\n      options.url = options.url || WorldGeocodingServiceUrl;\r\n      esriLeaflet.Task.prototype.initialize.call(this, options);\r\n    },\r\n\r\n    latlng: function (coords) {\r\n      var centroid = leaflet.latLng(coords);\r\n      this.params.location = centroid.lng + ',' + centroid.lat;\r\n      return this;\r\n    },\r\n\r\n    run: function (callback, context) {\r\n      if (this.options.token) {\r\n        this.params.token = this.options.token;\r\n      }\r\n      if (this.options.apikey) {\r\n        this.params.token = this.options.apikey;\r\n      }\r\n      return this.request(function (error, response) {\r\n        var result;\r\n\r\n        if (!error) {\r\n          result = {\r\n            latlng: leaflet.latLng(response.location.y, response.location.x),\r\n            address: response.address\r\n          };\r\n        } else {\r\n          result = undefined;\r\n        }\r\n\r\n        callback.call(context, error, result, response);\r\n      }, this);\r\n    }\r\n  });\r\n\r\n  function reverseGeocode (options) {\r\n    return new ReverseGeocode(options);\r\n  }\n\n  var Suggest = esriLeaflet.Task.extend({\r\n    path: 'suggest',\r\n\r\n    params: {},\r\n\r\n    setters: {\r\n      text: 'text',\r\n      category: 'category',\r\n      countries: 'countryCode',\r\n      maxSuggestions: 'maxSuggestions'\r\n    },\r\n\r\n    initialize: function (options) {\r\n      options = options || {};\r\n      if (!options.url) {\r\n        options.url = WorldGeocodingServiceUrl;\r\n        options.supportsSuggest = true;\r\n      }\r\n      esriLeaflet.Task.prototype.initialize.call(this, options);\r\n    },\r\n\r\n    within: function (bounds) {\r\n      bounds = leaflet.latLngBounds(bounds);\r\n      var center = bounds.getCenter();\r\n      var ne = bounds.getNorthWest();\r\n      this.params.location = center.lng + ',' + center.lat;\r\n      this.params.distance = Math.min(Math.max(center.distanceTo(ne), 2000), 50000);\r\n      this.params.searchExtent = esriLeaflet.Util.boundsToExtent(bounds);\r\n      return this;\r\n    },\r\n\r\n    nearby: function (coords, radius) {\r\n      var centroid = leaflet.latLng(coords);\r\n      this.params.location = centroid.lng + ',' + centroid.lat;\r\n      if (radius) {\r\n        this.params.distance = Math.min(Math.max(radius, 2000), 50000);\r\n      }\r\n      return this;\r\n    },\r\n\r\n    run: function (callback, context) {\r\n      if (this.options.supportsSuggest) {\r\n        return this.request(function (error, response) {\r\n          callback.call(context, error, response, response);\r\n        }, this);\r\n      } else {\r\n        console.warn('this geocoding service does not support asking for suggestions');\r\n      }\r\n    }\r\n\r\n  });\r\n\r\n  function suggest (options) {\r\n    return new Suggest(options);\r\n  }\n\n  var GeocodeService = esriLeaflet.Service.extend({\r\n    initialize: function (options) {\r\n      options = options || {};\r\n      if (options.apikey) {\r\n        options.token = options.apikey;\r\n      }\r\n      if (options.url) {\r\n        esriLeaflet.Service.prototype.initialize.call(this, options);\r\n        this._confirmSuggestSupport();\r\n      } else {\r\n        options.url = WorldGeocodingServiceUrl;\r\n        options.supportsSuggest = true;\r\n        esriLeaflet.Service.prototype.initialize.call(this, options);\r\n      }\r\n    },\r\n\r\n    geocode: function () {\r\n      return geocode(this);\r\n    },\r\n\r\n    reverse: function () {\r\n      return reverseGeocode(this);\r\n    },\r\n\r\n    suggest: function () {\r\n      // requires either the Esri World Geocoding Service or a <10.3 ArcGIS Server Geocoding Service that supports suggest.\r\n      return suggest(this);\r\n    },\r\n\r\n    _confirmSuggestSupport: function () {\r\n      this.metadata(function (error, response) {\r\n        if (error) { return; }\r\n        // pre 10.3 geocoding services dont list capabilities (and dont support maxLocations)\r\n        // only SOME individual services have been configured to support asking for suggestions\r\n        if (!response.capabilities) {\r\n          this.options.supportsSuggest = false;\r\n        } else if (response.capabilities.indexOf('Suggest') > -1) {\r\n          this.options.supportsSuggest = true;\r\n        } else {\r\n          this.options.supportsSuggest = false;\r\n        }\r\n        // whether the service supports suggest or not, utilize the metadata response to determine the appropriate parameter name for single line geocoding requests\r\n        this.options.customParam = response.singleLineAddressField.name;\r\n      }, this);\r\n    }\r\n  });\r\n\r\n  function geocodeService (options) {\r\n    return new GeocodeService(options);\r\n  }\n\n  var GeosearchCore = leaflet.Evented.extend({\r\n\r\n    options: {\r\n      zoomToResult: true,\r\n      useMapBounds: 12,\r\n      searchBounds: null\r\n    },\r\n\r\n    initialize: function (control, options) {\r\n      leaflet.Util.setOptions(this, options);\r\n      this._control = control;\r\n\r\n      if (!options || !options.providers || !options.providers.length) {\r\n        throw new Error('You must specify at least one provider');\r\n      }\r\n\r\n      this._providers = options.providers;\r\n    },\r\n\r\n    _geocode: function (text, key, provider) {\r\n      var activeRequests = 0;\r\n      var allResults = [];\r\n      var bounds;\r\n\r\n      var callback = leaflet.Util.bind(function (error, results) {\r\n        activeRequests--;\r\n        if (error) {\r\n          return;\r\n        }\r\n\r\n        if (results) {\r\n          allResults = allResults.concat(results);\r\n        }\r\n\r\n        if (activeRequests <= 0) {\r\n          bounds = this._boundsFromResults(allResults);\r\n\r\n          this.fire('results', {\r\n            results: allResults,\r\n            bounds: bounds,\r\n            latlng: (bounds) ? bounds.getCenter() : undefined,\r\n            text: text\r\n          }, true);\r\n\r\n          if (this.options.zoomToResult && bounds) {\r\n            this._control._map.fitBounds(bounds);\r\n          }\r\n\r\n          this.fire('load');\r\n        }\r\n      }, this);\r\n\r\n      if (key) {\r\n        activeRequests++;\r\n        provider.results(text, key, this._searchBounds(), callback);\r\n      } else {\r\n        for (var i = 0; i < this._providers.length; i++) {\r\n          activeRequests++;\r\n          this._providers[i].results(text, key, this._searchBounds(), callback);\r\n        }\r\n      }\r\n    },\r\n\r\n    _suggest: function (text) {\r\n      var activeRequests = this._providers.length;\r\n      var suggestionsLength = 0;\r\n\r\n      var createCallback = leaflet.Util.bind(function (text, provider) {\r\n        return leaflet.Util.bind(function (error, suggestions) {\r\n          activeRequests = activeRequests - 1;\r\n          suggestionsLength += suggestions.length;\r\n\r\n          if (error) {\r\n            // an error occurred for one of the providers' suggest requests\r\n            this._control._clearProviderSuggestions(provider);\r\n\r\n            // perform additional cleanup when all requests are finished\r\n            this._control._finalizeSuggestions(activeRequests, suggestionsLength);\r\n\r\n            return;\r\n          }\r\n\r\n          if (suggestions.length) {\r\n            for (var i = 0; i < suggestions.length; i++) {\r\n              suggestions[i].provider = provider;\r\n            }\r\n          } else {\r\n            // we still need to update the UI\r\n            this._control._renderSuggestions(suggestions);\r\n          }\r\n\r\n          if (provider._lastRender !== text) {\r\n            this._control._clearProviderSuggestions(provider);\r\n          }\r\n\r\n          if (suggestions.length && this._control._input.value === text) {\r\n            provider._lastRender = text;\r\n            this._control._renderSuggestions(suggestions);\r\n          }\r\n\r\n          // perform additional cleanup when all requests are finished\r\n          this._control._finalizeSuggestions(activeRequests, suggestionsLength);\r\n        }, this);\r\n      }, this);\r\n\r\n      this._pendingSuggestions = [];\r\n\r\n      for (var i = 0; i < this._providers.length; i++) {\r\n        var provider = this._providers[i];\r\n        var request = provider.suggestions(text, this._searchBounds(), createCallback(text, provider));\r\n        this._pendingSuggestions.push(request);\r\n      }\r\n    },\r\n\r\n    _searchBounds: function () {\r\n      if (this.options.searchBounds !== null) {\r\n        return this.options.searchBounds;\r\n      }\r\n\r\n      if (this.options.useMapBounds === false) {\r\n        return null;\r\n      }\r\n\r\n      if (this.options.useMapBounds === true) {\r\n        return this._control._map.getBounds();\r\n      }\r\n\r\n      if (this.options.useMapBounds <= this._control._map.getZoom()) {\r\n        return this._control._map.getBounds();\r\n      }\r\n\r\n      return null;\r\n    },\r\n\r\n    _boundsFromResults: function (results) {\r\n      if (!results.length) {\r\n        return;\r\n      }\r\n\r\n      var nullIsland = leaflet.latLngBounds([0, 0], [0, 0]);\r\n      var resultBounds = [];\r\n      var resultLatlngs = [];\r\n\r\n      // collect the bounds and center of each result\r\n      for (var i = results.length - 1; i >= 0; i--) {\r\n        var result = results[i];\r\n\r\n        resultLatlngs.push(result.latlng);\r\n\r\n        // make sure bounds are valid and not 0,0. sometimes bounds are incorrect or not present\r\n        if (result.bounds && result.bounds.isValid() && !result.bounds.equals(nullIsland)) {\r\n          resultBounds.push(result.bounds);\r\n        }\r\n      }\r\n\r\n      // form a bounds object containing all center points\r\n      var bounds = leaflet.latLngBounds(resultLatlngs);\r\n\r\n      // and extend it to contain all bounds objects\r\n      for (var j = 0; j < resultBounds.length; j++) {\r\n        bounds.extend(resultBounds[j]);\r\n      }\r\n\r\n      return bounds;\r\n    },\r\n\r\n    _getAttribution: function () {\r\n      var attribs = [];\r\n      var providers = this._providers;\r\n\r\n      for (var i = 0; i < providers.length; i++) {\r\n        if (providers[i].options.attribution) {\r\n          attribs.push(providers[i].options.attribution);\r\n        }\r\n      }\r\n\r\n      return attribs.join(', ');\r\n    }\r\n\r\n  });\r\n\r\n  function geosearchCore (control, options) {\r\n    return new GeosearchCore(control, options);\r\n  }\n\n  var ArcgisOnlineProvider = GeocodeService.extend({\r\n    options: {\r\n      label: 'Places and Addresses',\r\n      maxResults: 5\r\n    },\r\n\r\n    suggestions: function (text, bounds, callback) {\r\n      var request = this.suggest().text(text);\r\n\r\n      if (bounds) {\r\n        request.within(bounds);\r\n      }\r\n\r\n      if (this.options.nearby) {\r\n        // \"distance\"/\"radius\" is not supported by the ArcGIS Online Geocoder,\r\n        // so that is intentionally not passed here:\r\n        request.nearby(this.options.nearby);\r\n      }\r\n\r\n      if (this.options.countries) {\r\n        request.countries(this.options.countries);\r\n      }\r\n\r\n      if (this.options.categories) {\r\n        request.category(this.options.categories);\r\n      }\r\n\r\n      // 15 is the maximum number of suggestions that can be returned\r\n      request.maxSuggestions(this.options.maxResults);\r\n\r\n      return request.run(function (error, results, response) {\r\n        var suggestions = [];\r\n        if (!error) {\r\n          while (response.suggestions.length && suggestions.length <= (this.options.maxResults - 1)) {\r\n            var suggestion = response.suggestions.shift();\r\n            if (!suggestion.isCollection) {\r\n              suggestions.push({\r\n                text: suggestion.text,\r\n                unformattedText: suggestion.text,\r\n                magicKey: suggestion.magicKey\r\n              });\r\n            }\r\n          }\r\n        }\r\n        callback(error, suggestions);\r\n      }, this);\r\n    },\r\n\r\n    results: function (text, key, bounds, callback) {\r\n      var request = this.geocode().text(text);\r\n\r\n      if (key) {\r\n        request.key(key);\r\n      }\r\n      // in the future Address/StreetName geocoding requests that include a magicKey will always only return one match\r\n      request.maxLocations(this.options.maxResults);\r\n\r\n      if (bounds) {\r\n        request.within(bounds);\r\n      }\r\n\r\n      if (this.options.forStorage) {\r\n        request.forStorage(true);\r\n      }\r\n\r\n      if (this.options.nearby) {\r\n        // \"distance\"/\"radius\" is not supported by the ArcGIS Online Geocoder,\r\n        // so that is intentionally not passed here:\r\n        request.nearby(this.options.nearby);\r\n      }\r\n\r\n      if (this.options.countries) {\r\n        request.countries(this.options.countries);\r\n      }\r\n\r\n      if (this.options.categories) {\r\n        request.category(this.options.categories);\r\n      }\r\n\r\n      return request.run(function (error, response) {\r\n        callback(error, response.results);\r\n      }, this);\r\n    }\r\n  });\r\n\r\n  function arcgisOnlineProvider (options) {\r\n    return new ArcgisOnlineProvider(options);\r\n  }\n\n  var Geosearch = leaflet.Control.extend({\r\n    includes: leaflet.Evented.prototype,\r\n\r\n    options: {\r\n      position: 'topleft',\r\n      collapseAfterResult: true,\r\n      expanded: false,\r\n      allowMultipleResults: true,\r\n      placeholder: 'Search for places or addresses',\r\n      title: 'Location Search'\r\n    },\r\n\r\n    initialize: function (options) {\r\n      leaflet.Util.setOptions(this, options);\r\n\r\n      if (!options || !options.providers || !options.providers.length) {\r\n        if (!options) {\r\n          options = {};\r\n        }\r\n        options.providers = [arcgisOnlineProvider()];\r\n      }\r\n\r\n      // instantiate the underlying class and pass along options\r\n      this._geosearchCore = geosearchCore(this, options);\r\n      this._geosearchCore._providers = options.providers;\r\n\r\n      // bubble each providers events to the control\r\n      this._geosearchCore.addEventParent(this);\r\n      for (var i = 0; i < this._geosearchCore._providers.length; i++) {\r\n        this._geosearchCore._providers[i].addEventParent(this);\r\n      }\r\n\r\n      this._geosearchCore._pendingSuggestions = [];\r\n\r\n      leaflet.Control.prototype.initialize.call(this, options);\r\n    },\r\n\r\n    _renderSuggestions: function (suggestions) {\r\n      var currentGroup;\r\n\r\n      if (suggestions.length > 0) {\r\n        this._suggestions.style.display = 'block';\r\n      }\r\n\r\n      var list;\r\n      var header;\r\n      var suggestionTextArray = [];\r\n\r\n      for (var i = 0; i < suggestions.length; i++) {\r\n        var suggestion = suggestions[i];\r\n        if (!header && this._geosearchCore._providers.length > 1 && currentGroup !== suggestion.provider.options.label) {\r\n          header = leaflet.DomUtil.create('div', 'geocoder-control-header', suggestion.provider._contentsElement);\r\n          header.textContent = suggestion.provider.options.label;\r\n          header.innerText = suggestion.provider.options.label;\r\n          currentGroup = suggestion.provider.options.label;\r\n        }\r\n\r\n        if (!list) {\r\n          list = leaflet.DomUtil.create('ul', 'geocoder-control-list', suggestion.provider._contentsElement);\r\n        }\r\n\r\n        if (suggestionTextArray.indexOf(suggestion.text) === -1) {\r\n          var suggestionItem = leaflet.DomUtil.create('li', 'geocoder-control-suggestion', list);\r\n\r\n          suggestionItem.innerHTML = suggestion.text;\r\n          suggestionItem.provider = suggestion.provider;\r\n          suggestionItem['data-magic-key'] = suggestion.magicKey;\r\n          suggestionItem.unformattedText = suggestion.unformattedText;\r\n        } else {\r\n          for (var j = 0; j < list.childNodes.length; j++) {\r\n            // if the same text already appears in the list of suggestions, append an additional ObjectID to its magicKey instead\r\n            if (list.childNodes[j].innerHTML === suggestion.text) {\r\n              list.childNodes[j]['data-magic-key'] += ',' + suggestion.magicKey;\r\n            }\r\n          }\r\n        }\r\n        suggestionTextArray.push(suggestion.text);\r\n      }\r\n\r\n      // when the geocoder position is either \"topleft\" or \"topright\":\r\n      // set the maxHeight of the suggestions box to:\r\n      //  map height\r\n      //  - suggestions offset (distance from top of suggestions to top of control)\r\n      //  - control offset (distance from top of control to top of map)\r\n      //  - 10 (extra padding)\r\n      if (this.getPosition().indexOf('top') > -1) {\r\n        this._suggestions.style.maxHeight = (this._map.getSize().y - this._suggestions.offsetTop - this._wrapper.offsetTop - 10) + 'px';\r\n      }\r\n\r\n      // when the geocoder position is either \"bottomleft\" or \"bottomright\":\r\n      // 1. set the maxHeight of the suggestions box to:\r\n      //  map height\r\n      //  - corner control container offsetHeight (height of container of bottom corner)\r\n      //  - control offsetHeight (height of geocoder control wrapper, the main expandable button)\r\n      // 2. to move it up, set the top of the suggestions box to:\r\n      //  negative offsetHeight of suggestions box (its own negative height now that it has children elements\r\n      //  - control offsetHeight (height of geocoder control wrapper, the main expandable button)\r\n      //  + 20 (extra spacing)\r\n      if (this.getPosition().indexOf('bottom') > -1) {\r\n        this._setSuggestionsBottomPosition();\r\n      }\r\n    },\r\n\r\n    _setSuggestionsBottomPosition: function () {\r\n      this._suggestions.style.maxHeight = (this._map.getSize().y - this._map._controlCorners[this.getPosition()].offsetHeight - this._wrapper.offsetHeight) + 'px';\r\n      this._suggestions.style.top = (-this._suggestions.offsetHeight - this._wrapper.offsetHeight + 20) + 'px';\r\n    },\r\n\r\n    _boundsFromResults: function (results) {\r\n      if (!results.length) {\r\n        return;\r\n      }\r\n\r\n      var nullIsland = leaflet.latLngBounds([0, 0], [0, 0]);\r\n      var resultBounds = [];\r\n      var resultLatlngs = [];\r\n\r\n      // collect the bounds and center of each result\r\n      for (var i = results.length - 1; i >= 0; i--) {\r\n        var result = results[i];\r\n\r\n        resultLatlngs.push(result.latlng);\r\n\r\n        // make sure bounds are valid and not 0,0. sometimes bounds are incorrect or not present\r\n        if (result.bounds && result.bounds.isValid() && !result.bounds.equals(nullIsland)) {\r\n          resultBounds.push(result.bounds);\r\n        }\r\n      }\r\n\r\n      // form a bounds object containing all center points\r\n      var bounds = leaflet.latLngBounds(resultLatlngs);\r\n\r\n      // and extend it to contain all bounds objects\r\n      for (var j = 0; j < resultBounds.length; j++) {\r\n        bounds.extend(resultBounds[j]);\r\n      }\r\n\r\n      return bounds;\r\n    },\r\n\r\n    clear: function () {\r\n      this._clearAllSuggestions();\r\n\r\n      if (this.options.collapseAfterResult) {\r\n        this._input.value = '';\r\n        this._lastValue = '';\r\n        this._input.placeholder = '';\r\n        leaflet.DomUtil.removeClass(this._wrapper, 'geocoder-control-expanded');\r\n      }\r\n\r\n      if (!this._map.scrollWheelZoom.enabled() && this._map.options.scrollWheelZoom) {\r\n        this._map.scrollWheelZoom.enable();\r\n      }\r\n    },\r\n\r\n    _clearAllSuggestions: function () {\r\n      this._suggestions.style.display = 'none';\r\n\r\n      for (var i = 0; i < this.options.providers.length; i++) {\r\n        this._clearProviderSuggestions(this.options.providers[i]);\r\n      }\r\n    },\r\n\r\n    _clearProviderSuggestions: function (provider) {\r\n      provider._contentsElement.innerHTML = '';\r\n    },\r\n\r\n    _finalizeSuggestions: function (activeRequests, suggestionsLength) {\r\n      // check if all requests are finished to remove the loading indicator\r\n      if (!activeRequests) {\r\n        leaflet.DomUtil.removeClass(this._input, 'geocoder-control-loading');\r\n\r\n        // when the geocoder position is either \"bottomleft\" or \"bottomright\",\r\n        // it is necessary in some cases to recalculate the maxHeight and top values of the this._suggestions element,\r\n        // even though this is also being done after each provider returns their own suggestions\r\n        if (this.getPosition().indexOf('bottom') > -1) {\r\n          this._setSuggestionsBottomPosition();\r\n        }\r\n\r\n        // also check if there were 0 total suggest results to clear the parent suggestions element\r\n        // otherwise its display value may be \"block\" instead of \"none\"\r\n        if (!suggestionsLength) {\r\n          this._clearAllSuggestions();\r\n        }\r\n      }\r\n    },\r\n\r\n    _setupClick: function () {\r\n      leaflet.DomUtil.addClass(this._wrapper, 'geocoder-control-expanded');\r\n      this._input.focus();\r\n    },\r\n\r\n    disable: function () {\r\n      this._input.disabled = true;\r\n      leaflet.DomUtil.addClass(this._input, 'geocoder-control-input-disabled');\r\n      leaflet.DomEvent.removeListener(this._wrapper, 'click', this._setupClick, this);\r\n    },\r\n\r\n    enable: function () {\r\n      this._input.disabled = false;\r\n      leaflet.DomUtil.removeClass(this._input, 'geocoder-control-input-disabled');\r\n      leaflet.DomEvent.addListener(this._wrapper, 'click', this._setupClick, this);\r\n    },\r\n\r\n    getAttribution: function () {\r\n      var attribs = [];\r\n\r\n      for (var i = 0; i < this._providers.length; i++) {\r\n        if (this._providers[i].options.attribution) {\r\n          attribs.push(this._providers[i].options.attribution);\r\n        }\r\n      }\r\n\r\n      return attribs.join(', ');\r\n    },\r\n\r\n    geocodeSuggestion: function (e) {\r\n      var suggestionItem = e.target || e.srcElement;\r\n\r\n      if (\r\n        suggestionItem.classList.contains('geocoder-control-suggestions') ||\r\n        suggestionItem.classList.contains('geocoder-control-header')\r\n      ) {\r\n        return;\r\n      }\r\n\r\n      // make sure and point at the actual 'geocoder-control-suggestion'\r\n      if (suggestionItem.classList.length < 1) {\r\n        suggestionItem = suggestionItem.parentNode;\r\n      }\r\n\r\n      this._geosearchCore._geocode(suggestionItem.unformattedText, suggestionItem['data-magic-key'], suggestionItem.provider);\r\n      this.clear();\r\n    },\r\n\r\n    onAdd: function (map) {\r\n      // include 'Powered by Esri' in map attribution\r\n      esriLeaflet.Util.setEsriAttribution(map);\r\n\r\n      this._map = map;\r\n      this._wrapper = leaflet.DomUtil.create('div', 'geocoder-control');\r\n      this._input = leaflet.DomUtil.create('input', 'geocoder-control-input leaflet-bar', this._wrapper);\r\n      this._input.title = this.options.title;\r\n\r\n      if (this.options.expanded) {\r\n        leaflet.DomUtil.addClass(this._wrapper, 'geocoder-control-expanded');\r\n        this._input.placeholder = this.options.placeholder;\r\n      }\r\n\r\n      // create the main suggested results container element\r\n      this._suggestions = leaflet.DomUtil.create('div', 'geocoder-control-suggestions leaflet-bar', this._wrapper);\r\n\r\n      // create a child contents container element for each provider inside of this._suggestions\r\n      // to maintain the configured order of providers for suggested results\r\n      for (var i = 0; i < this.options.providers.length; i++) {\r\n        this.options.providers[i]._contentsElement = leaflet.DomUtil.create('div', null, this._suggestions);\r\n      }\r\n\r\n      var credits = this._geosearchCore._getAttribution();\r\n\r\n      if (map.attributionControl) {\r\n        map.attributionControl.addAttribution(credits);\r\n      }\r\n\r\n      leaflet.DomEvent.addListener(this._input, 'focus', function (e) {\r\n        this._input.placeholder = this.options.placeholder;\r\n        leaflet.DomUtil.addClass(this._wrapper, 'geocoder-control-expanded');\r\n      }, this);\r\n\r\n      leaflet.DomEvent.addListener(this._wrapper, 'click', this._setupClick, this);\r\n\r\n      // make sure both click and touch spawn an address/poi search\r\n      leaflet.DomEvent.addListener(this._suggestions, 'mousedown', this.geocodeSuggestion, this);\r\n\r\n      leaflet.DomEvent.addListener(this._input, 'blur', function (e) {\r\n        // TODO: this is too greedy and should not \"clear\"\r\n        // when trying to use the scrollbar or clicking on a non-suggestion item (such as a provider header)\r\n        this.clear();\r\n      }, this);\r\n\r\n      leaflet.DomEvent.addListener(this._input, 'keydown', function (e) {\r\n        var text = (e.target || e.srcElement).value;\r\n\r\n        leaflet.DomUtil.addClass(this._wrapper, 'geocoder-control-expanded');\r\n\r\n        var list = this._suggestions.querySelectorAll('.' + 'geocoder-control-suggestion');\r\n        var selected = this._suggestions.querySelectorAll('.' + 'geocoder-control-selected')[0];\r\n        var selectedPosition;\r\n\r\n        for (var i = 0; i < list.length; i++) {\r\n          if (list[i] === selected) {\r\n            selectedPosition = i;\r\n            break;\r\n          }\r\n        }\r\n\r\n        switch (e.keyCode) {\r\n          case 13:\r\n            /*\r\n              if an item has been selected, geocode it\r\n              if focus is on the input textbox, geocode only if multiple results are allowed and more than two characters are present, or if a single suggestion is displayed.\r\n              if less than two characters have been typed, abort the geocode\r\n            */\r\n            if (selected) {\r\n              this._input.value = selected.innerText;\r\n              this._geosearchCore._geocode(selected.unformattedText, selected['data-magic-key'], selected.provider);\r\n              this.clear();\r\n            } else if (this.options.allowMultipleResults && text.length >= 2) {\r\n              this._geosearchCore._geocode(this._input.value, undefined);\r\n              this.clear();\r\n            } else {\r\n              if (list.length === 1) {\r\n                leaflet.DomUtil.addClass(list[0], 'geocoder-control-selected');\r\n                this._geosearchCore._geocode(list[0].innerHTML, list[0]['data-magic-key'], list[0].provider);\r\n              } else {\r\n                this.clear();\r\n                this._input.blur();\r\n              }\r\n            }\r\n            leaflet.DomEvent.preventDefault(e);\r\n            break;\r\n          case 38:\r\n            if (selected) {\r\n              leaflet.DomUtil.removeClass(selected, 'geocoder-control-selected');\r\n            }\r\n\r\n            var previousItem = list[selectedPosition - 1];\r\n\r\n            if (selected && previousItem) {\r\n              leaflet.DomUtil.addClass(previousItem, 'geocoder-control-selected');\r\n            } else {\r\n              leaflet.DomUtil.addClass(list[list.length - 1], 'geocoder-control-selected');\r\n            }\r\n            leaflet.DomEvent.preventDefault(e);\r\n            break;\r\n          case 40:\r\n            if (selected) {\r\n              leaflet.DomUtil.removeClass(selected, 'geocoder-control-selected');\r\n            }\r\n\r\n            var nextItem = list[selectedPosition + 1];\r\n\r\n            if (selected && nextItem) {\r\n              leaflet.DomUtil.addClass(nextItem, 'geocoder-control-selected');\r\n            } else {\r\n              leaflet.DomUtil.addClass(list[0], 'geocoder-control-selected');\r\n            }\r\n            leaflet.DomEvent.preventDefault(e);\r\n            break;\r\n          default:\r\n            // when the input changes we should cancel all pending suggestion requests if possible to avoid result collisions\r\n            for (var x = 0; x < this._geosearchCore._pendingSuggestions.length; x++) {\r\n              var request = this._geosearchCore._pendingSuggestions[x];\r\n              if (request && request.abort && !request.id) {\r\n                request.abort();\r\n              }\r\n            }\r\n            break;\r\n        }\r\n      }, this);\r\n\r\n      leaflet.DomEvent.addListener(this._input, 'keyup', leaflet.Util.throttle(function (e) {\r\n        var key = e.which || e.keyCode;\r\n        var text = (e.target || e.srcElement).value;\r\n\r\n        // require at least 2 characters for suggestions\r\n        if (text.length < 2) {\r\n          this._lastValue = this._input.value;\r\n          this._clearAllSuggestions();\r\n          leaflet.DomUtil.removeClass(this._input, 'geocoder-control-loading');\r\n          return;\r\n        }\r\n\r\n        // if this is the escape key it will clear the input so clear suggestions\r\n        if (key === 27) {\r\n          this._clearAllSuggestions();\r\n          return;\r\n        }\r\n\r\n        // if this is NOT the up/down arrows or enter make a suggestion\r\n        if (key !== 13 && key !== 38 && key !== 40) {\r\n          if (this._input.value !== this._lastValue) {\r\n            this._lastValue = this._input.value;\r\n            leaflet.DomUtil.addClass(this._input, 'geocoder-control-loading');\r\n            this._geosearchCore._suggest(text);\r\n          }\r\n        }\r\n      }, 50, this), this);\r\n\r\n      leaflet.DomEvent.disableClickPropagation(this._wrapper);\r\n\r\n      // when mouse moves over suggestions disable scroll wheel zoom if its enabled\r\n      leaflet.DomEvent.addListener(this._suggestions, 'mouseover', function (e) {\r\n        if (map.scrollWheelZoom.enabled() && map.options.scrollWheelZoom) {\r\n          map.scrollWheelZoom.disable();\r\n        }\r\n      });\r\n\r\n      // when mouse moves leaves suggestions enable scroll wheel zoom if its disabled\r\n      leaflet.DomEvent.addListener(this._suggestions, 'mouseout', function (e) {\r\n        if (!map.scrollWheelZoom.enabled() && map.options.scrollWheelZoom) {\r\n          map.scrollWheelZoom.enable();\r\n        }\r\n      });\r\n\r\n      this._geosearchCore.on('load', function (e) {\r\n        leaflet.DomUtil.removeClass(this._input, 'geocoder-control-loading');\r\n        this.clear();\r\n        this._input.blur();\r\n      }, this);\r\n\r\n      return this._wrapper;\r\n    }\r\n  });\r\n\r\n  function geosearch (options) {\r\n    return new Geosearch(options);\r\n  }\n\n  var FeatureLayerProvider = esriLeaflet.FeatureLayerService.extend({\r\n    options: {\r\n      label: 'Feature Layer',\r\n      maxResults: 5,\r\n      bufferRadius: 1000,\r\n      searchMode: 'contain',\r\n      formatSuggestion: function (feature) {\r\n        return feature.properties[this.options.searchFields[0]];\r\n      }\r\n    },\r\n\r\n    initialize: function (options) {\r\n      if (options.apikey) {\r\n        options.token = options.apikey;\r\n      }\r\n      esriLeaflet.FeatureLayerService.prototype.initialize.call(this, options);\r\n      if (typeof this.options.searchFields === 'string') {\r\n        this.options.searchFields = [this.options.searchFields];\r\n      }\r\n      this._suggestionsQuery = this.query();\r\n      this._resultsQuery = this.query();\r\n    },\r\n\r\n    suggestions: function (text, bounds, callback) {\r\n      var query = this._suggestionsQuery.where(this._buildQuery(text))\r\n        .returnGeometry(false);\r\n\r\n      if (bounds) {\r\n        query.intersects(bounds);\r\n      }\r\n\r\n      if (this.options.idField) {\r\n        query.fields([this.options.idField].concat(this.options.searchFields));\r\n      }\r\n\r\n      var request = query.run(function (error, results, raw) {\r\n        if (error) {\r\n          callback(error, []);\r\n        } else {\r\n          this.options.idField = raw.objectIdFieldName;\r\n          var suggestions = [];\r\n          for (var i = results.features.length - 1; i >= 0; i--) {\r\n            var feature = results.features[i];\r\n            suggestions.push({\r\n              text: this.options.formatSuggestion.call(this, feature),\r\n              unformattedText: feature.properties[this.options.searchFields[0]],\r\n              magicKey: feature.id\r\n            });\r\n          }\r\n          callback(error, suggestions.slice(0, this.options.maxResults));\r\n        }\r\n      }, this);\r\n\r\n      return request;\r\n    },\r\n\r\n    results: function (text, key, bounds, callback) {\r\n      var query = this._resultsQuery;\r\n\r\n      if (key) {\r\n        // if there are 1 or more keys available, use query.featureIds()\r\n        delete query.params.where;\r\n        query.featureIds([key]);\r\n      } else {\r\n        // if there are no keys available, use query.where()\r\n        query.where(this._buildQuery(text));\r\n      }\r\n\r\n      if (bounds) {\r\n        query.within(bounds);\r\n      }\r\n\r\n      return query.run(leaflet.Util.bind(function (error, features) {\r\n        var results = [];\r\n        for (var i = 0; i < features.features.length; i++) {\r\n          var feature = features.features[i];\r\n          if (feature) {\r\n            var bounds = this._featureBounds(feature);\r\n\r\n            var result = {\r\n              latlng: bounds.getCenter(),\r\n              bounds: bounds,\r\n              text: this.options.formatSuggestion.call(this, feature),\r\n              properties: feature.properties,\r\n              geojson: feature\r\n            };\r\n\r\n            results.push(result);\r\n\r\n            // clear query parameters for the next search\r\n            delete this._resultsQuery.params['objectIds'];\r\n          }\r\n        }\r\n        callback(error, results);\r\n      }, this));\r\n    },\r\n\r\n    orderBy: function (fieldName, order) {\r\n      this._suggestionsQuery.orderBy(fieldName, order);\r\n    },\r\n\r\n    _buildQuery: function (text) {\r\n      var queryString = [];\r\n\r\n      for (var i = this.options.searchFields.length - 1; i >= 0; i--) {\r\n        var field = 'upper(\"' + this.options.searchFields[i] + '\")';\r\n        if (this.options.searchMode === 'contain') {\r\n          queryString.push(field + \" LIKE upper('%\" + text + \"%')\");\r\n        } else if (this.options.searchMode === 'startWith') {\r\n          queryString.push(field + \" LIKE upper('\" + text + \"%')\");\r\n        } else if (this.options.searchMode === 'endWith') {\r\n          queryString.push(field + \" LIKE upper('%\" + text + \"')\");\r\n        } else if (this.options.searchMode === 'strict') {\r\n          queryString.push(field + \" LIKE upper('\" + text + \"')\");\r\n        } else {\r\n          throw new Error('L.esri.Geocoding.featureLayerProvider: Invalid parameter for \"searchMode\". Use one of \"contain\", \"startWith\", \"endWith\", or \"strict\"');\r\n        }\r\n      }\r\n      if (this.options.where) {\r\n        return this.options.where + ' AND (' + queryString.join(' OR ') + ')';\r\n      } else {\r\n        return queryString.join(' OR ');\r\n      }\r\n    },\r\n\r\n    _featureBounds: function (feature) {\r\n      var geojson = leaflet.geoJson(feature);\r\n      if (feature.geometry.type === 'Point') {\r\n        var center = geojson.getBounds().getCenter();\r\n        var lngRadius = ((this.options.bufferRadius / 40075017) * 360) / Math.cos((180 / Math.PI) * center.lat);\r\n        var latRadius = (this.options.bufferRadius / 40075017) * 360;\r\n        return leaflet.latLngBounds([center.lat - latRadius, center.lng - lngRadius], [center.lat + latRadius, center.lng + lngRadius]);\r\n      } else {\r\n        return geojson.getBounds();\r\n      }\r\n    }\r\n  });\r\n\r\n  function featureLayerProvider (options) {\r\n    return new FeatureLayerProvider(options);\r\n  }\n\n  var MapServiceProvider = esriLeaflet.MapService.extend({\r\n    options: {\r\n      layers: [0],\r\n      label: 'Map Service',\r\n      bufferRadius: 1000,\r\n      maxResults: 5,\r\n      formatSuggestion: function (feature) {\r\n        return feature.properties[feature.displayFieldName] + ' <small>' + feature.layerName + '</small>';\r\n      }\r\n    },\r\n\r\n    initialize: function (options) {\r\n      if (options.apikey) {\r\n        options.token = options.apikey;\r\n      }\r\n      esriLeaflet.MapService.prototype.initialize.call(this, options);\r\n      this._getIdFields();\r\n    },\r\n\r\n    suggestions: function (text, bounds, callback) {\r\n      var request = this.find().text(text).fields(this.options.searchFields).returnGeometry(false).layers(this.options.layers);\r\n\r\n      return request.run(function (error, results, raw) {\r\n        var suggestions = [];\r\n        if (!error) {\r\n          var count = Math.min(this.options.maxResults, results.features.length);\r\n          raw.results = raw.results.reverse();\r\n          for (var i = 0; i < count; i++) {\r\n            var feature = results.features[i];\r\n            var result = raw.results[i];\r\n            var layer = result.layerId;\r\n            var idField = this._idFields[layer];\r\n            feature.layerId = layer;\r\n            feature.layerName = this._layerNames[layer];\r\n            feature.displayFieldName = this._displayFields[layer];\r\n            if (idField) {\r\n              suggestions.push({\r\n                text: this.options.formatSuggestion.call(this, feature),\r\n                unformattedText: feature.properties[feature.displayFieldName],\r\n                magicKey: result.attributes[idField] + ':' + layer\r\n              });\r\n            }\r\n          }\r\n        }\r\n        callback(error, suggestions.reverse());\r\n      }, this);\r\n    },\r\n\r\n    results: function (text, key, bounds, callback) {\r\n      var results = [];\r\n      var request;\r\n\r\n      if (key && !key.includes(',')) {\r\n        // if there is only 1 key available, use query()\r\n        var featureId = key.split(':')[0];\r\n        var layer = key.split(':')[1];\r\n        request = this.query().layer(layer).featureIds(featureId);\r\n      } else {\r\n        // if there are no keys or more than 1 keys available, use find()\r\n        request = this.find().text(text).fields(this.options.searchFields).layers(this.options.layers);\r\n      }\r\n\r\n      return request.run(function (error, features, response) {\r\n        if (!error) {\r\n          if (response.results) {\r\n            response.results = response.results.reverse();\r\n          }\r\n          for (var i = 0; i < features.features.length; i++) {\r\n            var feature = features.features[i];\r\n            layer = layer || response.results[i].layerId;\r\n\r\n            if (feature && layer !== undefined) {\r\n              var bounds = this._featureBounds(feature);\r\n              feature.layerId = layer;\r\n              feature.layerName = this._layerNames[layer];\r\n              feature.displayFieldName = this._displayFields[layer];\r\n\r\n              var result = {\r\n                latlng: bounds.getCenter(),\r\n                bounds: bounds,\r\n                text: this.options.formatSuggestion.call(this, feature),\r\n                properties: feature.properties,\r\n                geojson: feature\r\n              };\r\n\r\n              results.push(result);\r\n            }\r\n          }\r\n        }\r\n        callback(error, results.reverse());\r\n      }, this);\r\n    },\r\n\r\n    _featureBounds: function (feature) {\r\n      var geojson = leaflet.geoJson(feature);\r\n      if (feature.geometry.type === 'Point') {\r\n        var center = geojson.getBounds().getCenter();\r\n        var lngRadius = ((this.options.bufferRadius / 40075017) * 360) / Math.cos((180 / Math.PI) * center.lat);\r\n        var latRadius = (this.options.bufferRadius / 40075017) * 360;\r\n        return leaflet.latLngBounds([center.lat - latRadius, center.lng - lngRadius], [center.lat + latRadius, center.lng + lngRadius]);\r\n      } else {\r\n        return geojson.getBounds();\r\n      }\r\n    },\r\n\r\n    _layerMetadataCallback: function (layerid) {\r\n      return leaflet.Util.bind(function (error, metadata) {\r\n        if (error) { return; }\r\n        this._displayFields[layerid] = metadata.displayField;\r\n        this._layerNames[layerid] = metadata.name;\r\n        for (var i = 0; i < metadata.fields.length; i++) {\r\n          var field = metadata.fields[i];\r\n          if (field.type === 'esriFieldTypeOID') {\r\n            this._idFields[layerid] = field.name;\r\n            break;\r\n          }\r\n        }\r\n      }, this);\r\n    },\r\n\r\n    _getIdFields: function () {\r\n      this._idFields = {};\r\n      this._displayFields = {};\r\n      this._layerNames = {};\r\n      for (var i = 0; i < this.options.layers.length; i++) {\r\n        var layer = this.options.layers[i];\r\n        this.get(layer, {}, this._layerMetadataCallback(layer));\r\n      }\r\n    }\r\n  });\r\n\r\n  function mapServiceProvider (options) {\r\n    return new MapServiceProvider(options);\r\n  }\n\n  var GeocodeServiceProvider = GeocodeService.extend({\r\n    options: {\r\n      label: 'Geocode Server',\r\n      maxResults: 5\r\n    },\r\n\r\n    suggestions: function (text, bounds, callback) {\r\n      if (this.options.supportsSuggest) {\r\n        var request = this.suggest().text(text);\r\n        if (bounds) {\r\n          request.within(bounds);\r\n        }\r\n\r\n        return request.run(function (error, results, response) {\r\n          var suggestions = [];\r\n          if (!error) {\r\n            while (response.suggestions.length && suggestions.length <= (this.options.maxResults - 1)) {\r\n              var suggestion = response.suggestions.shift();\r\n              if (!suggestion.isCollection) {\r\n                suggestions.push({\r\n                  text: suggestion.text,\r\n                  unformattedText: suggestion.text,\r\n                  magicKey: suggestion.magicKey\r\n                });\r\n              }\r\n            }\r\n          }\r\n          callback(error, suggestions);\r\n        }, this);\r\n      } else {\r\n        callback(null, []);\r\n        return false;\r\n      }\r\n    },\r\n\r\n    results: function (text, key, bounds, callback) {\r\n      var request = this.geocode().text(text);\r\n\r\n      if (key) {\r\n        request.key(key);\r\n      }\r\n\r\n      request.maxLocations(this.options.maxResults);\r\n\r\n      if (bounds) {\r\n        request.within(bounds);\r\n      }\r\n\r\n      return request.run(function (error, response) {\r\n        callback(error, response.results);\r\n      }, this);\r\n    }\r\n  });\r\n\r\n  function geocodeServiceProvider (options) {\r\n    return new GeocodeServiceProvider(options);\r\n  }\n\n  exports.ArcgisOnlineProvider = ArcgisOnlineProvider;\n  exports.FeatureLayerProvider = FeatureLayerProvider;\n  exports.Geocode = Geocode;\n  exports.GeocodeService = GeocodeService;\n  exports.GeocodeServiceProvider = GeocodeServiceProvider;\n  exports.Geosearch = Geosearch;\n  exports.GeosearchCore = GeosearchCore;\n  exports.MapServiceProvider = MapServiceProvider;\n  exports.ReverseGeocode = ReverseGeocode;\n  exports.Suggest = Suggest;\n  exports.VERSION = version;\n  exports.WorldGeocodingServiceUrl = WorldGeocodingServiceUrl;\n  exports.arcgisOnlineProvider = arcgisOnlineProvider;\n  exports.featureLayerProvider = featureLayerProvider;\n  exports.geocode = geocode;\n  exports.geocodeService = geocodeService;\n  exports.geocodeServiceProvider = geocodeServiceProvider;\n  exports.geosearch = geosearch;\n  exports.geosearchCore = geosearchCore;\n  exports.mapServiceProvider = mapServiceProvider;\n  exports.reverseGeocode = reverseGeocode;\n  exports.suggest = suggest;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=esri-leaflet-geocoder-debug.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXNyaS1sZWFmbGV0LWdlb2NvZGVyL2Rpc3QvZXNyaS1sZWFmbGV0LWdlb2NvZGVyLWRlYnVnLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxLQUE0RCxvQkFBb0IsbUJBQU8sQ0FBQywyREFBUyxHQUFHLG1CQUFPLENBQUMsb0VBQWM7QUFDNUgsRUFBRSxDQUM0TTtBQUM5TSxDQUFDLG9EQUFvRDs7QUFFckQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxrQkFBa0I7QUFDMUQsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQ0FBZ0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHdCQUF3Qiw0QkFBNEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdCQUF3QjtBQUNwRDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDRCQUE0QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix5QkFBeUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDJDQUEyQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdCQUF3QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViwwQkFBMEIsNEJBQTRCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHlCQUF5QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1DQUFtQztBQUN6RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNEJBQTRCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQ0FBbUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0RBQW9EO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0Esb0RBQW9ELFFBQVE7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhCQUE4QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFFBQVE7QUFDakU7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFdBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsOEJBQThCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSx3QkFBd0IsNEJBQTRCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQ0FBZ0M7QUFDdEQ7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpREFBaUQsYUFBYTs7QUFFOUQsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VzcmktbGVhZmxldC1nZW9jb2Rlci9kaXN0L2VzcmktbGVhZmxldC1nZW9jb2Rlci1kZWJ1Zy5qcz80YWFjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzcmktbGVhZmxldC1nZW9jb2RlciAtIHYzLjEuMyAtIEZyaSBBcHIgMDggMjAyMiAxMDowNjo1NiBHTVQtMDUwMCAoQ2VudHJhbCBEYXlsaWdodCBUaW1lKVxuICogQ29weXJpZ2h0IChjKSAyMDIyIEVudmlyb25tZW50YWwgU3lzdGVtcyBSZXNlYXJjaCBJbnN0aXR1dGUsIEluYy5cbiAqIEFwYWNoZS0yLjAgKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnbGVhZmxldCcpLCByZXF1aXJlKCdlc3JpLWxlYWZsZXQnKSkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ2xlYWZsZXQnLCAnZXNyaS1sZWFmbGV0J10sIGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeSgoZ2xvYmFsLkwgPSBnbG9iYWwuTCB8fCB7fSwgZ2xvYmFsLkwuZXNyaSA9IGdsb2JhbC5MLmVzcmkgfHwge30sIGdsb2JhbC5MLmVzcmkuR2VvY29kaW5nID0ge30pLCBnbG9iYWwuTCwgZ2xvYmFsLkwuZXNyaSkpO1xufSkodGhpcywgKGZ1bmN0aW9uIChleHBvcnRzLCBsZWFmbGV0LCBlc3JpTGVhZmxldCkgeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHZlcnNpb24gPSBcIjMuMS4zXCI7XG5cbiAgdmFyIFdvcmxkR2VvY29kaW5nU2VydmljZVVybCA9ICdodHRwczovL2dlb2NvZGUtYXBpLmFyY2dpcy5jb20vYXJjZ2lzL3Jlc3Qvc2VydmljZXMvV29ybGQvR2VvY29kZVNlcnZlci8nO1xuXG4gIHZhciBHZW9jb2RlID0gZXNyaUxlYWZsZXQuVGFzay5leHRlbmQoe1xyXG4gICAgcGF0aDogJ2ZpbmRBZGRyZXNzQ2FuZGlkYXRlcycsXHJcblxyXG4gICAgcGFyYW1zOiB7XHJcbiAgICAgIG91dFNyOiA0MzI2LFxyXG4gICAgICBmb3JTdG9yYWdlOiBmYWxzZSxcclxuICAgICAgb3V0RmllbGRzOiAnKicsXHJcbiAgICAgIG1heExvY2F0aW9uczogMjBcclxuICAgIH0sXHJcblxyXG4gICAgc2V0dGVyczoge1xyXG4gICAgICBhZGRyZXNzOiAnYWRkcmVzcycsXHJcbiAgICAgIG5laWdoYm9yaG9vZDogJ25laWdoYm9yaG9vZCcsXHJcbiAgICAgIGNpdHk6ICdjaXR5JyxcclxuICAgICAgc3VicmVnaW9uOiAnc3VicmVnaW9uJyxcclxuICAgICAgcmVnaW9uOiAncmVnaW9uJyxcclxuICAgICAgcG9zdGFsOiAncG9zdGFsJyxcclxuICAgICAgY291bnRyeTogJ2NvdW50cnknLFxyXG4gICAgICB0ZXh0OiAnc2luZ2xlTGluZScsXHJcbiAgICAgIGNhdGVnb3J5OiAnY2F0ZWdvcnknLFxyXG4gICAgICB0b2tlbjogJ3Rva2VuJyxcclxuICAgICAgYXBpa2V5OiAnYXBpa2V5JyxcclxuICAgICAga2V5OiAnbWFnaWNLZXknLFxyXG4gICAgICBmaWVsZHM6ICdvdXRGaWVsZHMnLFxyXG4gICAgICBmb3JTdG9yYWdlOiAnZm9yU3RvcmFnZScsXHJcbiAgICAgIG1heExvY2F0aW9uczogJ21heExvY2F0aW9ucycsXHJcbiAgICAgIC8vIFdvcmxkIEdlb2NvZGluZyBTZXJ2aWNlIChvbmx5IHdvcmtzIHdpdGggc2luZ2xlTGluZSlcclxuICAgICAgY291bnRyaWVzOiAnc291cmNlQ291bnRyeSdcclxuICAgIH0sXHJcblxyXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgIG9wdGlvbnMudXJsID0gb3B0aW9ucy51cmwgfHwgV29ybGRHZW9jb2RpbmdTZXJ2aWNlVXJsO1xyXG4gICAgICBlc3JpTGVhZmxldC5UYXNrLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XHJcbiAgICB9LFxyXG5cclxuICAgIHdpdGhpbjogZnVuY3Rpb24gKGJvdW5kcykge1xyXG4gICAgICBib3VuZHMgPSBsZWFmbGV0LmxhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG4gICAgICB0aGlzLnBhcmFtcy5zZWFyY2hFeHRlbnQgPSBlc3JpTGVhZmxldC5VdGlsLmJvdW5kc1RvRXh0ZW50KGJvdW5kcyk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBuZWFyYnk6IGZ1bmN0aW9uIChjb29yZHMsIHJhZGl1cykge1xyXG4gICAgICB2YXIgY2VudHJvaWQgPSBsZWFmbGV0LmxhdExuZyhjb29yZHMpO1xyXG4gICAgICB0aGlzLnBhcmFtcy5sb2NhdGlvbiA9IGNlbnRyb2lkLmxuZyArICcsJyArIGNlbnRyb2lkLmxhdDtcclxuICAgICAgaWYgKHJhZGl1cykge1xyXG4gICAgICAgIHRoaXMucGFyYW1zLmRpc3RhbmNlID0gTWF0aC5taW4oTWF0aC5tYXgocmFkaXVzLCAyMDAwKSwgNTAwMDApO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBydW46IGZ1bmN0aW9uIChjYWxsYmFjaywgY29udGV4dCkge1xyXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnRva2VuKSB7XHJcbiAgICAgICAgdGhpcy5wYXJhbXMudG9rZW4gPSB0aGlzLm9wdGlvbnMudG9rZW47XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hcGlrZXkpIHtcclxuICAgICAgICB0aGlzLnBhcmFtcy50b2tlbiA9IHRoaXMub3B0aW9ucy5hcGlrZXk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jdXN0b21QYXJhbSkge1xyXG4gICAgICAgIHRoaXMucGFyYW1zW3RoaXMub3B0aW9ucy5jdXN0b21QYXJhbV0gPSB0aGlzLnBhcmFtcy5zaW5nbGVMaW5lO1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLnBhcmFtcy5zaW5nbGVMaW5lO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGZ1bmN0aW9uIChlcnJvciwgcmVzcG9uc2UpIHtcclxuICAgICAgICB2YXIgcHJvY2Vzc29yID0gdGhpcy5fcHJvY2Vzc0dlb2NvZGVyUmVzcG9uc2U7XHJcbiAgICAgICAgdmFyIHJlc3VsdHMgPSAoIWVycm9yKSA/IHByb2Nlc3NvcihyZXNwb25zZSkgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgY2FsbGJhY2suY2FsbChjb250ZXh0LCBlcnJvciwgeyByZXN1bHRzOiByZXN1bHRzIH0sIHJlc3BvbnNlKTtcclxuICAgICAgfSwgdGhpcyk7XHJcbiAgICB9LFxyXG5cclxuICAgIF9wcm9jZXNzR2VvY29kZXJSZXNwb25zZTogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XHJcbiAgICAgIHZhciByZXN1bHRzID0gW107XHJcblxyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3BvbnNlLmNhbmRpZGF0ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgY2FuZGlkYXRlID0gcmVzcG9uc2UuY2FuZGlkYXRlc1tpXTtcclxuICAgICAgICBpZiAoY2FuZGlkYXRlLmV4dGVudCkge1xyXG4gICAgICAgICAgdmFyIGJvdW5kcyA9IGVzcmlMZWFmbGV0LlV0aWwuZXh0ZW50VG9Cb3VuZHMoY2FuZGlkYXRlLmV4dGVudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXN1bHRzLnB1c2goe1xyXG4gICAgICAgICAgdGV4dDogY2FuZGlkYXRlLmFkZHJlc3MsXHJcbiAgICAgICAgICBib3VuZHM6IGJvdW5kcyxcclxuICAgICAgICAgIHNjb3JlOiBjYW5kaWRhdGUuc2NvcmUsXHJcbiAgICAgICAgICBsYXRsbmc6IGxlYWZsZXQubGF0TG5nKGNhbmRpZGF0ZS5sb2NhdGlvbi55LCBjYW5kaWRhdGUubG9jYXRpb24ueCksXHJcbiAgICAgICAgICBwcm9wZXJ0aWVzOiBjYW5kaWRhdGUuYXR0cmlidXRlc1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICBmdW5jdGlvbiBnZW9jb2RlIChvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gbmV3IEdlb2NvZGUob3B0aW9ucyk7XHJcbiAgfVxuXG4gIHZhciBSZXZlcnNlR2VvY29kZSA9IGVzcmlMZWFmbGV0LlRhc2suZXh0ZW5kKHtcclxuICAgIHBhdGg6ICdyZXZlcnNlR2VvY29kZScsXHJcblxyXG4gICAgcGFyYW1zOiB7XHJcbiAgICAgIG91dFNSOiA0MzI2LFxyXG4gICAgICByZXR1cm5JbnRlcnNlY3Rpb246IGZhbHNlXHJcbiAgICB9LFxyXG5cclxuICAgIHNldHRlcnM6IHtcclxuICAgICAgZGlzdGFuY2U6ICdkaXN0YW5jZScsXHJcbiAgICAgIGxhbmd1YWdlOiAnbGFuZ0NvZGUnLFxyXG4gICAgICBpbnRlcnNlY3Rpb246ICdyZXR1cm5JbnRlcnNlY3Rpb24nLFxyXG4gICAgICBhcGlrZXk6ICdhcGlrZXknXHJcbiAgICB9LFxyXG5cclxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgICBvcHRpb25zLnVybCA9IG9wdGlvbnMudXJsIHx8IFdvcmxkR2VvY29kaW5nU2VydmljZVVybDtcclxuICAgICAgZXNyaUxlYWZsZXQuVGFzay5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG4gICAgfSxcclxuXHJcbiAgICBsYXRsbmc6IGZ1bmN0aW9uIChjb29yZHMpIHtcclxuICAgICAgdmFyIGNlbnRyb2lkID0gbGVhZmxldC5sYXRMbmcoY29vcmRzKTtcclxuICAgICAgdGhpcy5wYXJhbXMubG9jYXRpb24gPSBjZW50cm9pZC5sbmcgKyAnLCcgKyBjZW50cm9pZC5sYXQ7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBydW46IGZ1bmN0aW9uIChjYWxsYmFjaywgY29udGV4dCkge1xyXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnRva2VuKSB7XHJcbiAgICAgICAgdGhpcy5wYXJhbXMudG9rZW4gPSB0aGlzLm9wdGlvbnMudG9rZW47XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hcGlrZXkpIHtcclxuICAgICAgICB0aGlzLnBhcmFtcy50b2tlbiA9IHRoaXMub3B0aW9ucy5hcGlrZXk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChmdW5jdGlvbiAoZXJyb3IsIHJlc3BvbnNlKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdDtcclxuXHJcbiAgICAgICAgaWYgKCFlcnJvcikge1xyXG4gICAgICAgICAgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICBsYXRsbmc6IGxlYWZsZXQubGF0TG5nKHJlc3BvbnNlLmxvY2F0aW9uLnksIHJlc3BvbnNlLmxvY2F0aW9uLngpLFxyXG4gICAgICAgICAgICBhZGRyZXNzOiByZXNwb25zZS5hZGRyZXNzXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXN1bHQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjYWxsYmFjay5jYWxsKGNvbnRleHQsIGVycm9yLCByZXN1bHQsIHJlc3BvbnNlKTtcclxuICAgICAgfSwgdGhpcyk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIGZ1bmN0aW9uIHJldmVyc2VHZW9jb2RlIChvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gbmV3IFJldmVyc2VHZW9jb2RlKG9wdGlvbnMpO1xyXG4gIH1cblxuICB2YXIgU3VnZ2VzdCA9IGVzcmlMZWFmbGV0LlRhc2suZXh0ZW5kKHtcclxuICAgIHBhdGg6ICdzdWdnZXN0JyxcclxuXHJcbiAgICBwYXJhbXM6IHt9LFxyXG5cclxuICAgIHNldHRlcnM6IHtcclxuICAgICAgdGV4dDogJ3RleHQnLFxyXG4gICAgICBjYXRlZ29yeTogJ2NhdGVnb3J5JyxcclxuICAgICAgY291bnRyaWVzOiAnY291bnRyeUNvZGUnLFxyXG4gICAgICBtYXhTdWdnZXN0aW9uczogJ21heFN1Z2dlc3Rpb25zJ1xyXG4gICAgfSxcclxuXHJcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgICAgaWYgKCFvcHRpb25zLnVybCkge1xyXG4gICAgICAgIG9wdGlvbnMudXJsID0gV29ybGRHZW9jb2RpbmdTZXJ2aWNlVXJsO1xyXG4gICAgICAgIG9wdGlvbnMuc3VwcG9ydHNTdWdnZXN0ID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICBlc3JpTGVhZmxldC5UYXNrLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XHJcbiAgICB9LFxyXG5cclxuICAgIHdpdGhpbjogZnVuY3Rpb24gKGJvdW5kcykge1xyXG4gICAgICBib3VuZHMgPSBsZWFmbGV0LmxhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG4gICAgICB2YXIgY2VudGVyID0gYm91bmRzLmdldENlbnRlcigpO1xyXG4gICAgICB2YXIgbmUgPSBib3VuZHMuZ2V0Tm9ydGhXZXN0KCk7XHJcbiAgICAgIHRoaXMucGFyYW1zLmxvY2F0aW9uID0gY2VudGVyLmxuZyArICcsJyArIGNlbnRlci5sYXQ7XHJcbiAgICAgIHRoaXMucGFyYW1zLmRpc3RhbmNlID0gTWF0aC5taW4oTWF0aC5tYXgoY2VudGVyLmRpc3RhbmNlVG8obmUpLCAyMDAwKSwgNTAwMDApO1xyXG4gICAgICB0aGlzLnBhcmFtcy5zZWFyY2hFeHRlbnQgPSBlc3JpTGVhZmxldC5VdGlsLmJvdW5kc1RvRXh0ZW50KGJvdW5kcyk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBuZWFyYnk6IGZ1bmN0aW9uIChjb29yZHMsIHJhZGl1cykge1xyXG4gICAgICB2YXIgY2VudHJvaWQgPSBsZWFmbGV0LmxhdExuZyhjb29yZHMpO1xyXG4gICAgICB0aGlzLnBhcmFtcy5sb2NhdGlvbiA9IGNlbnRyb2lkLmxuZyArICcsJyArIGNlbnRyb2lkLmxhdDtcclxuICAgICAgaWYgKHJhZGl1cykge1xyXG4gICAgICAgIHRoaXMucGFyYW1zLmRpc3RhbmNlID0gTWF0aC5taW4oTWF0aC5tYXgocmFkaXVzLCAyMDAwKSwgNTAwMDApO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBydW46IGZ1bmN0aW9uIChjYWxsYmFjaywgY29udGV4dCkge1xyXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnN1cHBvcnRzU3VnZ2VzdCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoZnVuY3Rpb24gKGVycm9yLCByZXNwb25zZSkge1xyXG4gICAgICAgICAgY2FsbGJhY2suY2FsbChjb250ZXh0LCBlcnJvciwgcmVzcG9uc2UsIHJlc3BvbnNlKTtcclxuICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ3RoaXMgZ2VvY29kaW5nIHNlcnZpY2UgZG9lcyBub3Qgc3VwcG9ydCBhc2tpbmcgZm9yIHN1Z2dlc3Rpb25zJyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgfSk7XHJcblxyXG4gIGZ1bmN0aW9uIHN1Z2dlc3QgKG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBuZXcgU3VnZ2VzdChvcHRpb25zKTtcclxuICB9XG5cbiAgdmFyIEdlb2NvZGVTZXJ2aWNlID0gZXNyaUxlYWZsZXQuU2VydmljZS5leHRlbmQoe1xyXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgIGlmIChvcHRpb25zLmFwaWtleSkge1xyXG4gICAgICAgIG9wdGlvbnMudG9rZW4gPSBvcHRpb25zLmFwaWtleTtcclxuICAgICAgfVxyXG4gICAgICBpZiAob3B0aW9ucy51cmwpIHtcclxuICAgICAgICBlc3JpTGVhZmxldC5TZXJ2aWNlLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5fY29uZmlybVN1Z2dlc3RTdXBwb3J0KCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgb3B0aW9ucy51cmwgPSBXb3JsZEdlb2NvZGluZ1NlcnZpY2VVcmw7XHJcbiAgICAgICAgb3B0aW9ucy5zdXBwb3J0c1N1Z2dlc3QgPSB0cnVlO1xyXG4gICAgICAgIGVzcmlMZWFmbGV0LlNlcnZpY2UucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBnZW9jb2RlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBnZW9jb2RlKHRoaXMpO1xyXG4gICAgfSxcclxuXHJcbiAgICByZXZlcnNlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiByZXZlcnNlR2VvY29kZSh0aGlzKTtcclxuICAgIH0sXHJcblxyXG4gICAgc3VnZ2VzdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAvLyByZXF1aXJlcyBlaXRoZXIgdGhlIEVzcmkgV29ybGQgR2VvY29kaW5nIFNlcnZpY2Ugb3IgYSA8MTAuMyBBcmNHSVMgU2VydmVyIEdlb2NvZGluZyBTZXJ2aWNlIHRoYXQgc3VwcG9ydHMgc3VnZ2VzdC5cclxuICAgICAgcmV0dXJuIHN1Z2dlc3QodGhpcyk7XHJcbiAgICB9LFxyXG5cclxuICAgIF9jb25maXJtU3VnZ2VzdFN1cHBvcnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5tZXRhZGF0YShmdW5jdGlvbiAoZXJyb3IsIHJlc3BvbnNlKSB7XHJcbiAgICAgICAgaWYgKGVycm9yKSB7IHJldHVybjsgfVxyXG4gICAgICAgIC8vIHByZSAxMC4zIGdlb2NvZGluZyBzZXJ2aWNlcyBkb250IGxpc3QgY2FwYWJpbGl0aWVzIChhbmQgZG9udCBzdXBwb3J0IG1heExvY2F0aW9ucylcclxuICAgICAgICAvLyBvbmx5IFNPTUUgaW5kaXZpZHVhbCBzZXJ2aWNlcyBoYXZlIGJlZW4gY29uZmlndXJlZCB0byBzdXBwb3J0IGFza2luZyBmb3Igc3VnZ2VzdGlvbnNcclxuICAgICAgICBpZiAoIXJlc3BvbnNlLmNhcGFiaWxpdGllcykge1xyXG4gICAgICAgICAgdGhpcy5vcHRpb25zLnN1cHBvcnRzU3VnZ2VzdCA9IGZhbHNlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2UuY2FwYWJpbGl0aWVzLmluZGV4T2YoJ1N1Z2dlc3QnKSA+IC0xKSB7XHJcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuc3VwcG9ydHNTdWdnZXN0ID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5vcHRpb25zLnN1cHBvcnRzU3VnZ2VzdCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB3aGV0aGVyIHRoZSBzZXJ2aWNlIHN1cHBvcnRzIHN1Z2dlc3Qgb3Igbm90LCB1dGlsaXplIHRoZSBtZXRhZGF0YSByZXNwb25zZSB0byBkZXRlcm1pbmUgdGhlIGFwcHJvcHJpYXRlIHBhcmFtZXRlciBuYW1lIGZvciBzaW5nbGUgbGluZSBnZW9jb2RpbmcgcmVxdWVzdHNcclxuICAgICAgICB0aGlzLm9wdGlvbnMuY3VzdG9tUGFyYW0gPSByZXNwb25zZS5zaW5nbGVMaW5lQWRkcmVzc0ZpZWxkLm5hbWU7XHJcbiAgICAgIH0sIHRoaXMpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICBmdW5jdGlvbiBnZW9jb2RlU2VydmljZSAob3B0aW9ucykge1xyXG4gICAgcmV0dXJuIG5ldyBHZW9jb2RlU2VydmljZShvcHRpb25zKTtcclxuICB9XG5cbiAgdmFyIEdlb3NlYXJjaENvcmUgPSBsZWFmbGV0LkV2ZW50ZWQuZXh0ZW5kKHtcclxuXHJcbiAgICBvcHRpb25zOiB7XHJcbiAgICAgIHpvb21Ub1Jlc3VsdDogdHJ1ZSxcclxuICAgICAgdXNlTWFwQm91bmRzOiAxMixcclxuICAgICAgc2VhcmNoQm91bmRzOiBudWxsXHJcbiAgICB9LFxyXG5cclxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIChjb250cm9sLCBvcHRpb25zKSB7XHJcbiAgICAgIGxlYWZsZXQuVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG4gICAgICB0aGlzLl9jb250cm9sID0gY29udHJvbDtcclxuXHJcbiAgICAgIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5wcm92aWRlcnMgfHwgIW9wdGlvbnMucHJvdmlkZXJzLmxlbmd0aCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3Qgc3BlY2lmeSBhdCBsZWFzdCBvbmUgcHJvdmlkZXInKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5fcHJvdmlkZXJzID0gb3B0aW9ucy5wcm92aWRlcnM7XHJcbiAgICB9LFxyXG5cclxuICAgIF9nZW9jb2RlOiBmdW5jdGlvbiAodGV4dCwga2V5LCBwcm92aWRlcikge1xyXG4gICAgICB2YXIgYWN0aXZlUmVxdWVzdHMgPSAwO1xyXG4gICAgICB2YXIgYWxsUmVzdWx0cyA9IFtdO1xyXG4gICAgICB2YXIgYm91bmRzO1xyXG5cclxuICAgICAgdmFyIGNhbGxiYWNrID0gbGVhZmxldC5VdGlsLmJpbmQoZnVuY3Rpb24gKGVycm9yLCByZXN1bHRzKSB7XHJcbiAgICAgICAgYWN0aXZlUmVxdWVzdHMtLTtcclxuICAgICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChyZXN1bHRzKSB7XHJcbiAgICAgICAgICBhbGxSZXN1bHRzID0gYWxsUmVzdWx0cy5jb25jYXQocmVzdWx0cyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYWN0aXZlUmVxdWVzdHMgPD0gMCkge1xyXG4gICAgICAgICAgYm91bmRzID0gdGhpcy5fYm91bmRzRnJvbVJlc3VsdHMoYWxsUmVzdWx0cyk7XHJcblxyXG4gICAgICAgICAgdGhpcy5maXJlKCdyZXN1bHRzJywge1xyXG4gICAgICAgICAgICByZXN1bHRzOiBhbGxSZXN1bHRzLFxyXG4gICAgICAgICAgICBib3VuZHM6IGJvdW5kcyxcclxuICAgICAgICAgICAgbGF0bG5nOiAoYm91bmRzKSA/IGJvdW5kcy5nZXRDZW50ZXIoKSA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgdGV4dDogdGV4dFxyXG4gICAgICAgICAgfSwgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy56b29tVG9SZXN1bHQgJiYgYm91bmRzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbnRyb2wuX21hcC5maXRCb3VuZHMoYm91bmRzKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB0aGlzLmZpcmUoJ2xvYWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sIHRoaXMpO1xyXG5cclxuICAgICAgaWYgKGtleSkge1xyXG4gICAgICAgIGFjdGl2ZVJlcXVlc3RzKys7XHJcbiAgICAgICAgcHJvdmlkZXIucmVzdWx0cyh0ZXh0LCBrZXksIHRoaXMuX3NlYXJjaEJvdW5kcygpLCBjYWxsYmFjayk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9wcm92aWRlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGFjdGl2ZVJlcXVlc3RzKys7XHJcbiAgICAgICAgICB0aGlzLl9wcm92aWRlcnNbaV0ucmVzdWx0cyh0ZXh0LCBrZXksIHRoaXMuX3NlYXJjaEJvdW5kcygpLCBjYWxsYmFjayk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIF9zdWdnZXN0OiBmdW5jdGlvbiAodGV4dCkge1xyXG4gICAgICB2YXIgYWN0aXZlUmVxdWVzdHMgPSB0aGlzLl9wcm92aWRlcnMubGVuZ3RoO1xyXG4gICAgICB2YXIgc3VnZ2VzdGlvbnNMZW5ndGggPSAwO1xyXG5cclxuICAgICAgdmFyIGNyZWF0ZUNhbGxiYWNrID0gbGVhZmxldC5VdGlsLmJpbmQoZnVuY3Rpb24gKHRleHQsIHByb3ZpZGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIGxlYWZsZXQuVXRpbC5iaW5kKGZ1bmN0aW9uIChlcnJvciwgc3VnZ2VzdGlvbnMpIHtcclxuICAgICAgICAgIGFjdGl2ZVJlcXVlc3RzID0gYWN0aXZlUmVxdWVzdHMgLSAxO1xyXG4gICAgICAgICAgc3VnZ2VzdGlvbnNMZW5ndGggKz0gc3VnZ2VzdGlvbnMubGVuZ3RoO1xyXG5cclxuICAgICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgICAvLyBhbiBlcnJvciBvY2N1cnJlZCBmb3Igb25lIG9mIHRoZSBwcm92aWRlcnMnIHN1Z2dlc3QgcmVxdWVzdHNcclxuICAgICAgICAgICAgdGhpcy5fY29udHJvbC5fY2xlYXJQcm92aWRlclN1Z2dlc3Rpb25zKHByb3ZpZGVyKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHBlcmZvcm0gYWRkaXRpb25hbCBjbGVhbnVwIHdoZW4gYWxsIHJlcXVlc3RzIGFyZSBmaW5pc2hlZFxyXG4gICAgICAgICAgICB0aGlzLl9jb250cm9sLl9maW5hbGl6ZVN1Z2dlc3Rpb25zKGFjdGl2ZVJlcXVlc3RzLCBzdWdnZXN0aW9uc0xlbmd0aCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKHN1Z2dlc3Rpb25zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1Z2dlc3Rpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgc3VnZ2VzdGlvbnNbaV0ucHJvdmlkZXIgPSBwcm92aWRlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gd2Ugc3RpbGwgbmVlZCB0byB1cGRhdGUgdGhlIFVJXHJcbiAgICAgICAgICAgIHRoaXMuX2NvbnRyb2wuX3JlbmRlclN1Z2dlc3Rpb25zKHN1Z2dlc3Rpb25zKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAocHJvdmlkZXIuX2xhc3RSZW5kZXIgIT09IHRleHQpIHtcclxuICAgICAgICAgICAgdGhpcy5fY29udHJvbC5fY2xlYXJQcm92aWRlclN1Z2dlc3Rpb25zKHByb3ZpZGVyKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAoc3VnZ2VzdGlvbnMubGVuZ3RoICYmIHRoaXMuX2NvbnRyb2wuX2lucHV0LnZhbHVlID09PSB0ZXh0KSB7XHJcbiAgICAgICAgICAgIHByb3ZpZGVyLl9sYXN0UmVuZGVyID0gdGV4dDtcclxuICAgICAgICAgICAgdGhpcy5fY29udHJvbC5fcmVuZGVyU3VnZ2VzdGlvbnMoc3VnZ2VzdGlvbnMpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIHBlcmZvcm0gYWRkaXRpb25hbCBjbGVhbnVwIHdoZW4gYWxsIHJlcXVlc3RzIGFyZSBmaW5pc2hlZFxyXG4gICAgICAgICAgdGhpcy5fY29udHJvbC5fZmluYWxpemVTdWdnZXN0aW9ucyhhY3RpdmVSZXF1ZXN0cywgc3VnZ2VzdGlvbnNMZW5ndGgpO1xyXG4gICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgIHRoaXMuX3BlbmRpbmdTdWdnZXN0aW9ucyA9IFtdO1xyXG5cclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9wcm92aWRlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0aGlzLl9wcm92aWRlcnNbaV07XHJcbiAgICAgICAgdmFyIHJlcXVlc3QgPSBwcm92aWRlci5zdWdnZXN0aW9ucyh0ZXh0LCB0aGlzLl9zZWFyY2hCb3VuZHMoKSwgY3JlYXRlQ2FsbGJhY2sodGV4dCwgcHJvdmlkZXIpKTtcclxuICAgICAgICB0aGlzLl9wZW5kaW5nU3VnZ2VzdGlvbnMucHVzaChyZXF1ZXN0KTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBfc2VhcmNoQm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2VhcmNoQm91bmRzICE9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zZWFyY2hCb3VuZHM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudXNlTWFwQm91bmRzID09PSBmYWxzZSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnVzZU1hcEJvdW5kcyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jb250cm9sLl9tYXAuZ2V0Qm91bmRzKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudXNlTWFwQm91bmRzIDw9IHRoaXMuX2NvbnRyb2wuX21hcC5nZXRab29tKCkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY29udHJvbC5fbWFwLmdldEJvdW5kcygpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH0sXHJcblxyXG4gICAgX2JvdW5kc0Zyb21SZXN1bHRzOiBmdW5jdGlvbiAocmVzdWx0cykge1xyXG4gICAgICBpZiAoIXJlc3VsdHMubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgbnVsbElzbGFuZCA9IGxlYWZsZXQubGF0TG5nQm91bmRzKFswLCAwXSwgWzAsIDBdKTtcclxuICAgICAgdmFyIHJlc3VsdEJvdW5kcyA9IFtdO1xyXG4gICAgICB2YXIgcmVzdWx0TGF0bG5ncyA9IFtdO1xyXG5cclxuICAgICAgLy8gY29sbGVjdCB0aGUgYm91bmRzIGFuZCBjZW50ZXIgb2YgZWFjaCByZXN1bHRcclxuICAgICAgZm9yICh2YXIgaSA9IHJlc3VsdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gcmVzdWx0c1tpXTtcclxuXHJcbiAgICAgICAgcmVzdWx0TGF0bG5ncy5wdXNoKHJlc3VsdC5sYXRsbmcpO1xyXG5cclxuICAgICAgICAvLyBtYWtlIHN1cmUgYm91bmRzIGFyZSB2YWxpZCBhbmQgbm90IDAsMC4gc29tZXRpbWVzIGJvdW5kcyBhcmUgaW5jb3JyZWN0IG9yIG5vdCBwcmVzZW50XHJcbiAgICAgICAgaWYgKHJlc3VsdC5ib3VuZHMgJiYgcmVzdWx0LmJvdW5kcy5pc1ZhbGlkKCkgJiYgIXJlc3VsdC5ib3VuZHMuZXF1YWxzKG51bGxJc2xhbmQpKSB7XHJcbiAgICAgICAgICByZXN1bHRCb3VuZHMucHVzaChyZXN1bHQuYm91bmRzKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGZvcm0gYSBib3VuZHMgb2JqZWN0IGNvbnRhaW5pbmcgYWxsIGNlbnRlciBwb2ludHNcclxuICAgICAgdmFyIGJvdW5kcyA9IGxlYWZsZXQubGF0TG5nQm91bmRzKHJlc3VsdExhdGxuZ3MpO1xyXG5cclxuICAgICAgLy8gYW5kIGV4dGVuZCBpdCB0byBjb250YWluIGFsbCBib3VuZHMgb2JqZWN0c1xyXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlc3VsdEJvdW5kcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgIGJvdW5kcy5leHRlbmQocmVzdWx0Qm91bmRzW2pdKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGJvdW5kcztcclxuICAgIH0sXHJcblxyXG4gICAgX2dldEF0dHJpYnV0aW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBhdHRyaWJzID0gW107XHJcbiAgICAgIHZhciBwcm92aWRlcnMgPSB0aGlzLl9wcm92aWRlcnM7XHJcblxyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3ZpZGVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChwcm92aWRlcnNbaV0ub3B0aW9ucy5hdHRyaWJ1dGlvbikge1xyXG4gICAgICAgICAgYXR0cmlicy5wdXNoKHByb3ZpZGVyc1tpXS5vcHRpb25zLmF0dHJpYnV0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBhdHRyaWJzLmpvaW4oJywgJyk7XHJcbiAgICB9XHJcblxyXG4gIH0pO1xyXG5cclxuICBmdW5jdGlvbiBnZW9zZWFyY2hDb3JlIChjb250cm9sLCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gbmV3IEdlb3NlYXJjaENvcmUoY29udHJvbCwgb3B0aW9ucyk7XHJcbiAgfVxuXG4gIHZhciBBcmNnaXNPbmxpbmVQcm92aWRlciA9IEdlb2NvZGVTZXJ2aWNlLmV4dGVuZCh7XHJcbiAgICBvcHRpb25zOiB7XHJcbiAgICAgIGxhYmVsOiAnUGxhY2VzIGFuZCBBZGRyZXNzZXMnLFxyXG4gICAgICBtYXhSZXN1bHRzOiA1XHJcbiAgICB9LFxyXG5cclxuICAgIHN1Z2dlc3Rpb25zOiBmdW5jdGlvbiAodGV4dCwgYm91bmRzLCBjYWxsYmFjaykge1xyXG4gICAgICB2YXIgcmVxdWVzdCA9IHRoaXMuc3VnZ2VzdCgpLnRleHQodGV4dCk7XHJcblxyXG4gICAgICBpZiAoYm91bmRzKSB7XHJcbiAgICAgICAgcmVxdWVzdC53aXRoaW4oYm91bmRzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5uZWFyYnkpIHtcclxuICAgICAgICAvLyBcImRpc3RhbmNlXCIvXCJyYWRpdXNcIiBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBBcmNHSVMgT25saW5lIEdlb2NvZGVyLFxyXG4gICAgICAgIC8vIHNvIHRoYXQgaXMgaW50ZW50aW9uYWxseSBub3QgcGFzc2VkIGhlcmU6XHJcbiAgICAgICAgcmVxdWVzdC5uZWFyYnkodGhpcy5vcHRpb25zLm5lYXJieSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY291bnRyaWVzKSB7XHJcbiAgICAgICAgcmVxdWVzdC5jb3VudHJpZXModGhpcy5vcHRpb25zLmNvdW50cmllcyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2F0ZWdvcmllcykge1xyXG4gICAgICAgIHJlcXVlc3QuY2F0ZWdvcnkodGhpcy5vcHRpb25zLmNhdGVnb3JpZXMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyAxNSBpcyB0aGUgbWF4aW11bSBudW1iZXIgb2Ygc3VnZ2VzdGlvbnMgdGhhdCBjYW4gYmUgcmV0dXJuZWRcclxuICAgICAgcmVxdWVzdC5tYXhTdWdnZXN0aW9ucyh0aGlzLm9wdGlvbnMubWF4UmVzdWx0cyk7XHJcblxyXG4gICAgICByZXR1cm4gcmVxdWVzdC5ydW4oZnVuY3Rpb24gKGVycm9yLCByZXN1bHRzLCByZXNwb25zZSkge1xyXG4gICAgICAgIHZhciBzdWdnZXN0aW9ucyA9IFtdO1xyXG4gICAgICAgIGlmICghZXJyb3IpIHtcclxuICAgICAgICAgIHdoaWxlIChyZXNwb25zZS5zdWdnZXN0aW9ucy5sZW5ndGggJiYgc3VnZ2VzdGlvbnMubGVuZ3RoIDw9ICh0aGlzLm9wdGlvbnMubWF4UmVzdWx0cyAtIDEpKSB7XHJcbiAgICAgICAgICAgIHZhciBzdWdnZXN0aW9uID0gcmVzcG9uc2Uuc3VnZ2VzdGlvbnMuc2hpZnQoKTtcclxuICAgICAgICAgICAgaWYgKCFzdWdnZXN0aW9uLmlzQ29sbGVjdGlvbikge1xyXG4gICAgICAgICAgICAgIHN1Z2dlc3Rpb25zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgdGV4dDogc3VnZ2VzdGlvbi50ZXh0LFxyXG4gICAgICAgICAgICAgICAgdW5mb3JtYXR0ZWRUZXh0OiBzdWdnZXN0aW9uLnRleHQsXHJcbiAgICAgICAgICAgICAgICBtYWdpY0tleTogc3VnZ2VzdGlvbi5tYWdpY0tleVxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhbGxiYWNrKGVycm9yLCBzdWdnZXN0aW9ucyk7XHJcbiAgICAgIH0sIHRoaXMpO1xyXG4gICAgfSxcclxuXHJcbiAgICByZXN1bHRzOiBmdW5jdGlvbiAodGV4dCwga2V5LCBib3VuZHMsIGNhbGxiYWNrKSB7XHJcbiAgICAgIHZhciByZXF1ZXN0ID0gdGhpcy5nZW9jb2RlKCkudGV4dCh0ZXh0KTtcclxuXHJcbiAgICAgIGlmIChrZXkpIHtcclxuICAgICAgICByZXF1ZXN0LmtleShrZXkpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIGluIHRoZSBmdXR1cmUgQWRkcmVzcy9TdHJlZXROYW1lIGdlb2NvZGluZyByZXF1ZXN0cyB0aGF0IGluY2x1ZGUgYSBtYWdpY0tleSB3aWxsIGFsd2F5cyBvbmx5IHJldHVybiBvbmUgbWF0Y2hcclxuICAgICAgcmVxdWVzdC5tYXhMb2NhdGlvbnModGhpcy5vcHRpb25zLm1heFJlc3VsdHMpO1xyXG5cclxuICAgICAgaWYgKGJvdW5kcykge1xyXG4gICAgICAgIHJlcXVlc3Qud2l0aGluKGJvdW5kcyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZm9yU3RvcmFnZSkge1xyXG4gICAgICAgIHJlcXVlc3QuZm9yU3RvcmFnZSh0cnVlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5uZWFyYnkpIHtcclxuICAgICAgICAvLyBcImRpc3RhbmNlXCIvXCJyYWRpdXNcIiBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBBcmNHSVMgT25saW5lIEdlb2NvZGVyLFxyXG4gICAgICAgIC8vIHNvIHRoYXQgaXMgaW50ZW50aW9uYWxseSBub3QgcGFzc2VkIGhlcmU6XHJcbiAgICAgICAgcmVxdWVzdC5uZWFyYnkodGhpcy5vcHRpb25zLm5lYXJieSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY291bnRyaWVzKSB7XHJcbiAgICAgICAgcmVxdWVzdC5jb3VudHJpZXModGhpcy5vcHRpb25zLmNvdW50cmllcyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2F0ZWdvcmllcykge1xyXG4gICAgICAgIHJlcXVlc3QuY2F0ZWdvcnkodGhpcy5vcHRpb25zLmNhdGVnb3JpZXMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcmVxdWVzdC5ydW4oZnVuY3Rpb24gKGVycm9yLCByZXNwb25zZSkge1xyXG4gICAgICAgIGNhbGxiYWNrKGVycm9yLCByZXNwb25zZS5yZXN1bHRzKTtcclxuICAgICAgfSwgdGhpcyk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIGZ1bmN0aW9uIGFyY2dpc09ubGluZVByb3ZpZGVyIChvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gbmV3IEFyY2dpc09ubGluZVByb3ZpZGVyKG9wdGlvbnMpO1xyXG4gIH1cblxuICB2YXIgR2Vvc2VhcmNoID0gbGVhZmxldC5Db250cm9sLmV4dGVuZCh7XHJcbiAgICBpbmNsdWRlczogbGVhZmxldC5FdmVudGVkLnByb3RvdHlwZSxcclxuXHJcbiAgICBvcHRpb25zOiB7XHJcbiAgICAgIHBvc2l0aW9uOiAndG9wbGVmdCcsXHJcbiAgICAgIGNvbGxhcHNlQWZ0ZXJSZXN1bHQ6IHRydWUsXHJcbiAgICAgIGV4cGFuZGVkOiBmYWxzZSxcclxuICAgICAgYWxsb3dNdWx0aXBsZVJlc3VsdHM6IHRydWUsXHJcbiAgICAgIHBsYWNlaG9sZGVyOiAnU2VhcmNoIGZvciBwbGFjZXMgb3IgYWRkcmVzc2VzJyxcclxuICAgICAgdGl0bGU6ICdMb2NhdGlvbiBTZWFyY2gnXHJcbiAgICB9LFxyXG5cclxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgIGxlYWZsZXQuVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuICAgICAgaWYgKCFvcHRpb25zIHx8ICFvcHRpb25zLnByb3ZpZGVycyB8fCAhb3B0aW9ucy5wcm92aWRlcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKCFvcHRpb25zKSB7XHJcbiAgICAgICAgICBvcHRpb25zID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9wdGlvbnMucHJvdmlkZXJzID0gW2FyY2dpc09ubGluZVByb3ZpZGVyKCldO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBpbnN0YW50aWF0ZSB0aGUgdW5kZXJseWluZyBjbGFzcyBhbmQgcGFzcyBhbG9uZyBvcHRpb25zXHJcbiAgICAgIHRoaXMuX2dlb3NlYXJjaENvcmUgPSBnZW9zZWFyY2hDb3JlKHRoaXMsIG9wdGlvbnMpO1xyXG4gICAgICB0aGlzLl9nZW9zZWFyY2hDb3JlLl9wcm92aWRlcnMgPSBvcHRpb25zLnByb3ZpZGVycztcclxuXHJcbiAgICAgIC8vIGJ1YmJsZSBlYWNoIHByb3ZpZGVycyBldmVudHMgdG8gdGhlIGNvbnRyb2xcclxuICAgICAgdGhpcy5fZ2Vvc2VhcmNoQ29yZS5hZGRFdmVudFBhcmVudCh0aGlzKTtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9nZW9zZWFyY2hDb3JlLl9wcm92aWRlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB0aGlzLl9nZW9zZWFyY2hDb3JlLl9wcm92aWRlcnNbaV0uYWRkRXZlbnRQYXJlbnQodGhpcyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuX2dlb3NlYXJjaENvcmUuX3BlbmRpbmdTdWdnZXN0aW9ucyA9IFtdO1xyXG5cclxuICAgICAgbGVhZmxldC5Db250cm9sLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XHJcbiAgICB9LFxyXG5cclxuICAgIF9yZW5kZXJTdWdnZXN0aW9uczogZnVuY3Rpb24gKHN1Z2dlc3Rpb25zKSB7XHJcbiAgICAgIHZhciBjdXJyZW50R3JvdXA7XHJcblxyXG4gICAgICBpZiAoc3VnZ2VzdGlvbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHRoaXMuX3N1Z2dlc3Rpb25zLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgbGlzdDtcclxuICAgICAgdmFyIGhlYWRlcjtcclxuICAgICAgdmFyIHN1Z2dlc3Rpb25UZXh0QXJyYXkgPSBbXTtcclxuXHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3VnZ2VzdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgc3VnZ2VzdGlvbiA9IHN1Z2dlc3Rpb25zW2ldO1xyXG4gICAgICAgIGlmICghaGVhZGVyICYmIHRoaXMuX2dlb3NlYXJjaENvcmUuX3Byb3ZpZGVycy5sZW5ndGggPiAxICYmIGN1cnJlbnRHcm91cCAhPT0gc3VnZ2VzdGlvbi5wcm92aWRlci5vcHRpb25zLmxhYmVsKSB7XHJcbiAgICAgICAgICBoZWFkZXIgPSBsZWFmbGV0LkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnZ2VvY29kZXItY29udHJvbC1oZWFkZXInLCBzdWdnZXN0aW9uLnByb3ZpZGVyLl9jb250ZW50c0VsZW1lbnQpO1xyXG4gICAgICAgICAgaGVhZGVyLnRleHRDb250ZW50ID0gc3VnZ2VzdGlvbi5wcm92aWRlci5vcHRpb25zLmxhYmVsO1xyXG4gICAgICAgICAgaGVhZGVyLmlubmVyVGV4dCA9IHN1Z2dlc3Rpb24ucHJvdmlkZXIub3B0aW9ucy5sYWJlbDtcclxuICAgICAgICAgIGN1cnJlbnRHcm91cCA9IHN1Z2dlc3Rpb24ucHJvdmlkZXIub3B0aW9ucy5sYWJlbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghbGlzdCkge1xyXG4gICAgICAgICAgbGlzdCA9IGxlYWZsZXQuRG9tVXRpbC5jcmVhdGUoJ3VsJywgJ2dlb2NvZGVyLWNvbnRyb2wtbGlzdCcsIHN1Z2dlc3Rpb24ucHJvdmlkZXIuX2NvbnRlbnRzRWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoc3VnZ2VzdGlvblRleHRBcnJheS5pbmRleE9mKHN1Z2dlc3Rpb24udGV4dCkgPT09IC0xKSB7XHJcbiAgICAgICAgICB2YXIgc3VnZ2VzdGlvbkl0ZW0gPSBsZWFmbGV0LkRvbVV0aWwuY3JlYXRlKCdsaScsICdnZW9jb2Rlci1jb250cm9sLXN1Z2dlc3Rpb24nLCBsaXN0KTtcclxuXHJcbiAgICAgICAgICBzdWdnZXN0aW9uSXRlbS5pbm5lckhUTUwgPSBzdWdnZXN0aW9uLnRleHQ7XHJcbiAgICAgICAgICBzdWdnZXN0aW9uSXRlbS5wcm92aWRlciA9IHN1Z2dlc3Rpb24ucHJvdmlkZXI7XHJcbiAgICAgICAgICBzdWdnZXN0aW9uSXRlbVsnZGF0YS1tYWdpYy1rZXknXSA9IHN1Z2dlc3Rpb24ubWFnaWNLZXk7XHJcbiAgICAgICAgICBzdWdnZXN0aW9uSXRlbS51bmZvcm1hdHRlZFRleHQgPSBzdWdnZXN0aW9uLnVuZm9ybWF0dGVkVGV4dDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsaXN0LmNoaWxkTm9kZXMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgLy8gaWYgdGhlIHNhbWUgdGV4dCBhbHJlYWR5IGFwcGVhcnMgaW4gdGhlIGxpc3Qgb2Ygc3VnZ2VzdGlvbnMsIGFwcGVuZCBhbiBhZGRpdGlvbmFsIE9iamVjdElEIHRvIGl0cyBtYWdpY0tleSBpbnN0ZWFkXHJcbiAgICAgICAgICAgIGlmIChsaXN0LmNoaWxkTm9kZXNbal0uaW5uZXJIVE1MID09PSBzdWdnZXN0aW9uLnRleHQpIHtcclxuICAgICAgICAgICAgICBsaXN0LmNoaWxkTm9kZXNbal1bJ2RhdGEtbWFnaWMta2V5J10gKz0gJywnICsgc3VnZ2VzdGlvbi5tYWdpY0tleTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzdWdnZXN0aW9uVGV4dEFycmF5LnB1c2goc3VnZ2VzdGlvbi50ZXh0KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gd2hlbiB0aGUgZ2VvY29kZXIgcG9zaXRpb24gaXMgZWl0aGVyIFwidG9wbGVmdFwiIG9yIFwidG9wcmlnaHRcIjpcclxuICAgICAgLy8gc2V0IHRoZSBtYXhIZWlnaHQgb2YgdGhlIHN1Z2dlc3Rpb25zIGJveCB0bzpcclxuICAgICAgLy8gIG1hcCBoZWlnaHRcclxuICAgICAgLy8gIC0gc3VnZ2VzdGlvbnMgb2Zmc2V0IChkaXN0YW5jZSBmcm9tIHRvcCBvZiBzdWdnZXN0aW9ucyB0byB0b3Agb2YgY29udHJvbClcclxuICAgICAgLy8gIC0gY29udHJvbCBvZmZzZXQgKGRpc3RhbmNlIGZyb20gdG9wIG9mIGNvbnRyb2wgdG8gdG9wIG9mIG1hcClcclxuICAgICAgLy8gIC0gMTAgKGV4dHJhIHBhZGRpbmcpXHJcbiAgICAgIGlmICh0aGlzLmdldFBvc2l0aW9uKCkuaW5kZXhPZigndG9wJykgPiAtMSkge1xyXG4gICAgICAgIHRoaXMuX3N1Z2dlc3Rpb25zLnN0eWxlLm1heEhlaWdodCA9ICh0aGlzLl9tYXAuZ2V0U2l6ZSgpLnkgLSB0aGlzLl9zdWdnZXN0aW9ucy5vZmZzZXRUb3AgLSB0aGlzLl93cmFwcGVyLm9mZnNldFRvcCAtIDEwKSArICdweCc7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHdoZW4gdGhlIGdlb2NvZGVyIHBvc2l0aW9uIGlzIGVpdGhlciBcImJvdHRvbWxlZnRcIiBvciBcImJvdHRvbXJpZ2h0XCI6XHJcbiAgICAgIC8vIDEuIHNldCB0aGUgbWF4SGVpZ2h0IG9mIHRoZSBzdWdnZXN0aW9ucyBib3ggdG86XHJcbiAgICAgIC8vICBtYXAgaGVpZ2h0XHJcbiAgICAgIC8vICAtIGNvcm5lciBjb250cm9sIGNvbnRhaW5lciBvZmZzZXRIZWlnaHQgKGhlaWdodCBvZiBjb250YWluZXIgb2YgYm90dG9tIGNvcm5lcilcclxuICAgICAgLy8gIC0gY29udHJvbCBvZmZzZXRIZWlnaHQgKGhlaWdodCBvZiBnZW9jb2RlciBjb250cm9sIHdyYXBwZXIsIHRoZSBtYWluIGV4cGFuZGFibGUgYnV0dG9uKVxyXG4gICAgICAvLyAyLiB0byBtb3ZlIGl0IHVwLCBzZXQgdGhlIHRvcCBvZiB0aGUgc3VnZ2VzdGlvbnMgYm94IHRvOlxyXG4gICAgICAvLyAgbmVnYXRpdmUgb2Zmc2V0SGVpZ2h0IG9mIHN1Z2dlc3Rpb25zIGJveCAoaXRzIG93biBuZWdhdGl2ZSBoZWlnaHQgbm93IHRoYXQgaXQgaGFzIGNoaWxkcmVuIGVsZW1lbnRzXHJcbiAgICAgIC8vICAtIGNvbnRyb2wgb2Zmc2V0SGVpZ2h0IChoZWlnaHQgb2YgZ2VvY29kZXIgY29udHJvbCB3cmFwcGVyLCB0aGUgbWFpbiBleHBhbmRhYmxlIGJ1dHRvbilcclxuICAgICAgLy8gICsgMjAgKGV4dHJhIHNwYWNpbmcpXHJcbiAgICAgIGlmICh0aGlzLmdldFBvc2l0aW9uKCkuaW5kZXhPZignYm90dG9tJykgPiAtMSkge1xyXG4gICAgICAgIHRoaXMuX3NldFN1Z2dlc3Rpb25zQm90dG9tUG9zaXRpb24oKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBfc2V0U3VnZ2VzdGlvbnNCb3R0b21Qb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLl9zdWdnZXN0aW9ucy5zdHlsZS5tYXhIZWlnaHQgPSAodGhpcy5fbWFwLmdldFNpemUoKS55IC0gdGhpcy5fbWFwLl9jb250cm9sQ29ybmVyc1t0aGlzLmdldFBvc2l0aW9uKCldLm9mZnNldEhlaWdodCAtIHRoaXMuX3dyYXBwZXIub2Zmc2V0SGVpZ2h0KSArICdweCc7XHJcbiAgICAgIHRoaXMuX3N1Z2dlc3Rpb25zLnN0eWxlLnRvcCA9ICgtdGhpcy5fc3VnZ2VzdGlvbnMub2Zmc2V0SGVpZ2h0IC0gdGhpcy5fd3JhcHBlci5vZmZzZXRIZWlnaHQgKyAyMCkgKyAncHgnO1xyXG4gICAgfSxcclxuXHJcbiAgICBfYm91bmRzRnJvbVJlc3VsdHM6IGZ1bmN0aW9uIChyZXN1bHRzKSB7XHJcbiAgICAgIGlmICghcmVzdWx0cy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBudWxsSXNsYW5kID0gbGVhZmxldC5sYXRMbmdCb3VuZHMoWzAsIDBdLCBbMCwgMF0pO1xyXG4gICAgICB2YXIgcmVzdWx0Qm91bmRzID0gW107XHJcbiAgICAgIHZhciByZXN1bHRMYXRsbmdzID0gW107XHJcblxyXG4gICAgICAvLyBjb2xsZWN0IHRoZSBib3VuZHMgYW5kIGNlbnRlciBvZiBlYWNoIHJlc3VsdFxyXG4gICAgICBmb3IgKHZhciBpID0gcmVzdWx0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSByZXN1bHRzW2ldO1xyXG5cclxuICAgICAgICByZXN1bHRMYXRsbmdzLnB1c2gocmVzdWx0LmxhdGxuZyk7XHJcblxyXG4gICAgICAgIC8vIG1ha2Ugc3VyZSBib3VuZHMgYXJlIHZhbGlkIGFuZCBub3QgMCwwLiBzb21ldGltZXMgYm91bmRzIGFyZSBpbmNvcnJlY3Qgb3Igbm90IHByZXNlbnRcclxuICAgICAgICBpZiAocmVzdWx0LmJvdW5kcyAmJiByZXN1bHQuYm91bmRzLmlzVmFsaWQoKSAmJiAhcmVzdWx0LmJvdW5kcy5lcXVhbHMobnVsbElzbGFuZCkpIHtcclxuICAgICAgICAgIHJlc3VsdEJvdW5kcy5wdXNoKHJlc3VsdC5ib3VuZHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gZm9ybSBhIGJvdW5kcyBvYmplY3QgY29udGFpbmluZyBhbGwgY2VudGVyIHBvaW50c1xyXG4gICAgICB2YXIgYm91bmRzID0gbGVhZmxldC5sYXRMbmdCb3VuZHMocmVzdWx0TGF0bG5ncyk7XHJcblxyXG4gICAgICAvLyBhbmQgZXh0ZW5kIGl0IHRvIGNvbnRhaW4gYWxsIGJvdW5kcyBvYmplY3RzXHJcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVzdWx0Qm91bmRzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgYm91bmRzLmV4dGVuZChyZXN1bHRCb3VuZHNbal0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gYm91bmRzO1xyXG4gICAgfSxcclxuXHJcbiAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLl9jbGVhckFsbFN1Z2dlc3Rpb25zKCk7XHJcblxyXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmNvbGxhcHNlQWZ0ZXJSZXN1bHQpIHtcclxuICAgICAgICB0aGlzLl9pbnB1dC52YWx1ZSA9ICcnO1xyXG4gICAgICAgIHRoaXMuX2xhc3RWYWx1ZSA9ICcnO1xyXG4gICAgICAgIHRoaXMuX2lucHV0LnBsYWNlaG9sZGVyID0gJyc7XHJcbiAgICAgICAgbGVhZmxldC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX3dyYXBwZXIsICdnZW9jb2Rlci1jb250cm9sLWV4cGFuZGVkJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghdGhpcy5fbWFwLnNjcm9sbFdoZWVsWm9vbS5lbmFibGVkKCkgJiYgdGhpcy5fbWFwLm9wdGlvbnMuc2Nyb2xsV2hlZWxab29tKSB7XHJcbiAgICAgICAgdGhpcy5fbWFwLnNjcm9sbFdoZWVsWm9vbS5lbmFibGUoKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBfY2xlYXJBbGxTdWdnZXN0aW9uczogZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLl9zdWdnZXN0aW9ucy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG5cclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9wdGlvbnMucHJvdmlkZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdGhpcy5fY2xlYXJQcm92aWRlclN1Z2dlc3Rpb25zKHRoaXMub3B0aW9ucy5wcm92aWRlcnNbaV0pO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIF9jbGVhclByb3ZpZGVyU3VnZ2VzdGlvbnM6IGZ1bmN0aW9uIChwcm92aWRlcikge1xyXG4gICAgICBwcm92aWRlci5fY29udGVudHNFbGVtZW50LmlubmVySFRNTCA9ICcnO1xyXG4gICAgfSxcclxuXHJcbiAgICBfZmluYWxpemVTdWdnZXN0aW9uczogZnVuY3Rpb24gKGFjdGl2ZVJlcXVlc3RzLCBzdWdnZXN0aW9uc0xlbmd0aCkge1xyXG4gICAgICAvLyBjaGVjayBpZiBhbGwgcmVxdWVzdHMgYXJlIGZpbmlzaGVkIHRvIHJlbW92ZSB0aGUgbG9hZGluZyBpbmRpY2F0b3JcclxuICAgICAgaWYgKCFhY3RpdmVSZXF1ZXN0cykge1xyXG4gICAgICAgIGxlYWZsZXQuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9pbnB1dCwgJ2dlb2NvZGVyLWNvbnRyb2wtbG9hZGluZycpO1xyXG5cclxuICAgICAgICAvLyB3aGVuIHRoZSBnZW9jb2RlciBwb3NpdGlvbiBpcyBlaXRoZXIgXCJib3R0b21sZWZ0XCIgb3IgXCJib3R0b21yaWdodFwiLFxyXG4gICAgICAgIC8vIGl0IGlzIG5lY2Vzc2FyeSBpbiBzb21lIGNhc2VzIHRvIHJlY2FsY3VsYXRlIHRoZSBtYXhIZWlnaHQgYW5kIHRvcCB2YWx1ZXMgb2YgdGhlIHRoaXMuX3N1Z2dlc3Rpb25zIGVsZW1lbnQsXHJcbiAgICAgICAgLy8gZXZlbiB0aG91Z2ggdGhpcyBpcyBhbHNvIGJlaW5nIGRvbmUgYWZ0ZXIgZWFjaCBwcm92aWRlciByZXR1cm5zIHRoZWlyIG93biBzdWdnZXN0aW9uc1xyXG4gICAgICAgIGlmICh0aGlzLmdldFBvc2l0aW9uKCkuaW5kZXhPZignYm90dG9tJykgPiAtMSkge1xyXG4gICAgICAgICAgdGhpcy5fc2V0U3VnZ2VzdGlvbnNCb3R0b21Qb3NpdGlvbigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gYWxzbyBjaGVjayBpZiB0aGVyZSB3ZXJlIDAgdG90YWwgc3VnZ2VzdCByZXN1bHRzIHRvIGNsZWFyIHRoZSBwYXJlbnQgc3VnZ2VzdGlvbnMgZWxlbWVudFxyXG4gICAgICAgIC8vIG90aGVyd2lzZSBpdHMgZGlzcGxheSB2YWx1ZSBtYXkgYmUgXCJibG9ja1wiIGluc3RlYWQgb2YgXCJub25lXCJcclxuICAgICAgICBpZiAoIXN1Z2dlc3Rpb25zTGVuZ3RoKSB7XHJcbiAgICAgICAgICB0aGlzLl9jbGVhckFsbFN1Z2dlc3Rpb25zKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIF9zZXR1cENsaWNrOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGxlYWZsZXQuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl93cmFwcGVyLCAnZ2VvY29kZXItY29udHJvbC1leHBhbmRlZCcpO1xyXG4gICAgICB0aGlzLl9pbnB1dC5mb2N1cygpO1xyXG4gICAgfSxcclxuXHJcbiAgICBkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMuX2lucHV0LmRpc2FibGVkID0gdHJ1ZTtcclxuICAgICAgbGVhZmxldC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2lucHV0LCAnZ2VvY29kZXItY29udHJvbC1pbnB1dC1kaXNhYmxlZCcpO1xyXG4gICAgICBsZWFmbGV0LkRvbUV2ZW50LnJlbW92ZUxpc3RlbmVyKHRoaXMuX3dyYXBwZXIsICdjbGljaycsIHRoaXMuX3NldHVwQ2xpY2ssIHRoaXMpO1xyXG4gICAgfSxcclxuXHJcbiAgICBlbmFibGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5faW5wdXQuZGlzYWJsZWQgPSBmYWxzZTtcclxuICAgICAgbGVhZmxldC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2lucHV0LCAnZ2VvY29kZXItY29udHJvbC1pbnB1dC1kaXNhYmxlZCcpO1xyXG4gICAgICBsZWFmbGV0LkRvbUV2ZW50LmFkZExpc3RlbmVyKHRoaXMuX3dyYXBwZXIsICdjbGljaycsIHRoaXMuX3NldHVwQ2xpY2ssIHRoaXMpO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRBdHRyaWJ1dGlvbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgYXR0cmlicyA9IFtdO1xyXG5cclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9wcm92aWRlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAodGhpcy5fcHJvdmlkZXJzW2ldLm9wdGlvbnMuYXR0cmlidXRpb24pIHtcclxuICAgICAgICAgIGF0dHJpYnMucHVzaCh0aGlzLl9wcm92aWRlcnNbaV0ub3B0aW9ucy5hdHRyaWJ1dGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gYXR0cmlicy5qb2luKCcsICcpO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZW9jb2RlU3VnZ2VzdGlvbjogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgdmFyIHN1Z2dlc3Rpb25JdGVtID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xyXG5cclxuICAgICAgaWYgKFxyXG4gICAgICAgIHN1Z2dlc3Rpb25JdGVtLmNsYXNzTGlzdC5jb250YWlucygnZ2VvY29kZXItY29udHJvbC1zdWdnZXN0aW9ucycpIHx8XHJcbiAgICAgICAgc3VnZ2VzdGlvbkl0ZW0uY2xhc3NMaXN0LmNvbnRhaW5zKCdnZW9jb2Rlci1jb250cm9sLWhlYWRlcicpXHJcbiAgICAgICkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gbWFrZSBzdXJlIGFuZCBwb2ludCBhdCB0aGUgYWN0dWFsICdnZW9jb2Rlci1jb250cm9sLXN1Z2dlc3Rpb24nXHJcbiAgICAgIGlmIChzdWdnZXN0aW9uSXRlbS5jbGFzc0xpc3QubGVuZ3RoIDwgMSkge1xyXG4gICAgICAgIHN1Z2dlc3Rpb25JdGVtID0gc3VnZ2VzdGlvbkl0ZW0ucGFyZW50Tm9kZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5fZ2Vvc2VhcmNoQ29yZS5fZ2VvY29kZShzdWdnZXN0aW9uSXRlbS51bmZvcm1hdHRlZFRleHQsIHN1Z2dlc3Rpb25JdGVtWydkYXRhLW1hZ2ljLWtleSddLCBzdWdnZXN0aW9uSXRlbS5wcm92aWRlcik7XHJcbiAgICAgIHRoaXMuY2xlYXIoKTtcclxuICAgIH0sXHJcblxyXG4gICAgb25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuICAgICAgLy8gaW5jbHVkZSAnUG93ZXJlZCBieSBFc3JpJyBpbiBtYXAgYXR0cmlidXRpb25cclxuICAgICAgZXNyaUxlYWZsZXQuVXRpbC5zZXRFc3JpQXR0cmlidXRpb24obWFwKTtcclxuXHJcbiAgICAgIHRoaXMuX21hcCA9IG1hcDtcclxuICAgICAgdGhpcy5fd3JhcHBlciA9IGxlYWZsZXQuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdnZW9jb2Rlci1jb250cm9sJyk7XHJcbiAgICAgIHRoaXMuX2lucHV0ID0gbGVhZmxldC5Eb21VdGlsLmNyZWF0ZSgnaW5wdXQnLCAnZ2VvY29kZXItY29udHJvbC1pbnB1dCBsZWFmbGV0LWJhcicsIHRoaXMuX3dyYXBwZXIpO1xyXG4gICAgICB0aGlzLl9pbnB1dC50aXRsZSA9IHRoaXMub3B0aW9ucy50aXRsZTtcclxuXHJcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXhwYW5kZWQpIHtcclxuICAgICAgICBsZWFmbGV0LkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fd3JhcHBlciwgJ2dlb2NvZGVyLWNvbnRyb2wtZXhwYW5kZWQnKTtcclxuICAgICAgICB0aGlzLl9pbnB1dC5wbGFjZWhvbGRlciA9IHRoaXMub3B0aW9ucy5wbGFjZWhvbGRlcjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gY3JlYXRlIHRoZSBtYWluIHN1Z2dlc3RlZCByZXN1bHRzIGNvbnRhaW5lciBlbGVtZW50XHJcbiAgICAgIHRoaXMuX3N1Z2dlc3Rpb25zID0gbGVhZmxldC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2dlb2NvZGVyLWNvbnRyb2wtc3VnZ2VzdGlvbnMgbGVhZmxldC1iYXInLCB0aGlzLl93cmFwcGVyKTtcclxuXHJcbiAgICAgIC8vIGNyZWF0ZSBhIGNoaWxkIGNvbnRlbnRzIGNvbnRhaW5lciBlbGVtZW50IGZvciBlYWNoIHByb3ZpZGVyIGluc2lkZSBvZiB0aGlzLl9zdWdnZXN0aW9uc1xyXG4gICAgICAvLyB0byBtYWludGFpbiB0aGUgY29uZmlndXJlZCBvcmRlciBvZiBwcm92aWRlcnMgZm9yIHN1Z2dlc3RlZCByZXN1bHRzXHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vcHRpb25zLnByb3ZpZGVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHRoaXMub3B0aW9ucy5wcm92aWRlcnNbaV0uX2NvbnRlbnRzRWxlbWVudCA9IGxlYWZsZXQuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIG51bGwsIHRoaXMuX3N1Z2dlc3Rpb25zKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGNyZWRpdHMgPSB0aGlzLl9nZW9zZWFyY2hDb3JlLl9nZXRBdHRyaWJ1dGlvbigpO1xyXG5cclxuICAgICAgaWYgKG1hcC5hdHRyaWJ1dGlvbkNvbnRyb2wpIHtcclxuICAgICAgICBtYXAuYXR0cmlidXRpb25Db250cm9sLmFkZEF0dHJpYnV0aW9uKGNyZWRpdHMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsZWFmbGV0LkRvbUV2ZW50LmFkZExpc3RlbmVyKHRoaXMuX2lucHV0LCAnZm9jdXMnLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIHRoaXMuX2lucHV0LnBsYWNlaG9sZGVyID0gdGhpcy5vcHRpb25zLnBsYWNlaG9sZGVyO1xyXG4gICAgICAgIGxlYWZsZXQuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl93cmFwcGVyLCAnZ2VvY29kZXItY29udHJvbC1leHBhbmRlZCcpO1xyXG4gICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgIGxlYWZsZXQuRG9tRXZlbnQuYWRkTGlzdGVuZXIodGhpcy5fd3JhcHBlciwgJ2NsaWNrJywgdGhpcy5fc2V0dXBDbGljaywgdGhpcyk7XHJcblxyXG4gICAgICAvLyBtYWtlIHN1cmUgYm90aCBjbGljayBhbmQgdG91Y2ggc3Bhd24gYW4gYWRkcmVzcy9wb2kgc2VhcmNoXHJcbiAgICAgIGxlYWZsZXQuRG9tRXZlbnQuYWRkTGlzdGVuZXIodGhpcy5fc3VnZ2VzdGlvbnMsICdtb3VzZWRvd24nLCB0aGlzLmdlb2NvZGVTdWdnZXN0aW9uLCB0aGlzKTtcclxuXHJcbiAgICAgIGxlYWZsZXQuRG9tRXZlbnQuYWRkTGlzdGVuZXIodGhpcy5faW5wdXQsICdibHVyJywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAvLyBUT0RPOiB0aGlzIGlzIHRvbyBncmVlZHkgYW5kIHNob3VsZCBub3QgXCJjbGVhclwiXHJcbiAgICAgICAgLy8gd2hlbiB0cnlpbmcgdG8gdXNlIHRoZSBzY3JvbGxiYXIgb3IgY2xpY2tpbmcgb24gYSBub24tc3VnZ2VzdGlvbiBpdGVtIChzdWNoIGFzIGEgcHJvdmlkZXIgaGVhZGVyKVxyXG4gICAgICAgIHRoaXMuY2xlYXIoKTtcclxuICAgICAgfSwgdGhpcyk7XHJcblxyXG4gICAgICBsZWFmbGV0LkRvbUV2ZW50LmFkZExpc3RlbmVyKHRoaXMuX2lucHV0LCAna2V5ZG93bicsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgdmFyIHRleHQgPSAoZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50KS52YWx1ZTtcclxuXHJcbiAgICAgICAgbGVhZmxldC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX3dyYXBwZXIsICdnZW9jb2Rlci1jb250cm9sLWV4cGFuZGVkJyk7XHJcblxyXG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5fc3VnZ2VzdGlvbnMucXVlcnlTZWxlY3RvckFsbCgnLicgKyAnZ2VvY29kZXItY29udHJvbC1zdWdnZXN0aW9uJyk7XHJcbiAgICAgICAgdmFyIHNlbGVjdGVkID0gdGhpcy5fc3VnZ2VzdGlvbnMucXVlcnlTZWxlY3RvckFsbCgnLicgKyAnZ2VvY29kZXItY29udHJvbC1zZWxlY3RlZCcpWzBdO1xyXG4gICAgICAgIHZhciBzZWxlY3RlZFBvc2l0aW9uO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBzZWxlY3RlZCkge1xyXG4gICAgICAgICAgICBzZWxlY3RlZFBvc2l0aW9uID0gaTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzd2l0Y2ggKGUua2V5Q29kZSkge1xyXG4gICAgICAgICAgY2FzZSAxMzpcclxuICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICBpZiBhbiBpdGVtIGhhcyBiZWVuIHNlbGVjdGVkLCBnZW9jb2RlIGl0XHJcbiAgICAgICAgICAgICAgaWYgZm9jdXMgaXMgb24gdGhlIGlucHV0IHRleHRib3gsIGdlb2NvZGUgb25seSBpZiBtdWx0aXBsZSByZXN1bHRzIGFyZSBhbGxvd2VkIGFuZCBtb3JlIHRoYW4gdHdvIGNoYXJhY3RlcnMgYXJlIHByZXNlbnQsIG9yIGlmIGEgc2luZ2xlIHN1Z2dlc3Rpb24gaXMgZGlzcGxheWVkLlxyXG4gICAgICAgICAgICAgIGlmIGxlc3MgdGhhbiB0d28gY2hhcmFjdGVycyBoYXZlIGJlZW4gdHlwZWQsIGFib3J0IHRoZSBnZW9jb2RlXHJcbiAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZCkge1xyXG4gICAgICAgICAgICAgIHRoaXMuX2lucHV0LnZhbHVlID0gc2VsZWN0ZWQuaW5uZXJUZXh0O1xyXG4gICAgICAgICAgICAgIHRoaXMuX2dlb3NlYXJjaENvcmUuX2dlb2NvZGUoc2VsZWN0ZWQudW5mb3JtYXR0ZWRUZXh0LCBzZWxlY3RlZFsnZGF0YS1tYWdpYy1rZXknXSwgc2VsZWN0ZWQucHJvdmlkZXIpO1xyXG4gICAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuYWxsb3dNdWx0aXBsZVJlc3VsdHMgJiYgdGV4dC5sZW5ndGggPj0gMikge1xyXG4gICAgICAgICAgICAgIHRoaXMuX2dlb3NlYXJjaENvcmUuX2dlb2NvZGUodGhpcy5faW5wdXQudmFsdWUsIHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgbGVhZmxldC5Eb21VdGlsLmFkZENsYXNzKGxpc3RbMF0sICdnZW9jb2Rlci1jb250cm9sLXNlbGVjdGVkJyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9nZW9zZWFyY2hDb3JlLl9nZW9jb2RlKGxpc3RbMF0uaW5uZXJIVE1MLCBsaXN0WzBdWydkYXRhLW1hZ2ljLWtleSddLCBsaXN0WzBdLnByb3ZpZGVyKTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5wdXQuYmx1cigpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZWFmbGV0LkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgMzg6XHJcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZCkge1xyXG4gICAgICAgICAgICAgIGxlYWZsZXQuRG9tVXRpbC5yZW1vdmVDbGFzcyhzZWxlY3RlZCwgJ2dlb2NvZGVyLWNvbnRyb2wtc2VsZWN0ZWQnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHByZXZpb3VzSXRlbSA9IGxpc3Rbc2VsZWN0ZWRQb3NpdGlvbiAtIDFdO1xyXG5cclxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkICYmIHByZXZpb3VzSXRlbSkge1xyXG4gICAgICAgICAgICAgIGxlYWZsZXQuRG9tVXRpbC5hZGRDbGFzcyhwcmV2aW91c0l0ZW0sICdnZW9jb2Rlci1jb250cm9sLXNlbGVjdGVkJyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgbGVhZmxldC5Eb21VdGlsLmFkZENsYXNzKGxpc3RbbGlzdC5sZW5ndGggLSAxXSwgJ2dlb2NvZGVyLWNvbnRyb2wtc2VsZWN0ZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZWFmbGV0LkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgNDA6XHJcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZCkge1xyXG4gICAgICAgICAgICAgIGxlYWZsZXQuRG9tVXRpbC5yZW1vdmVDbGFzcyhzZWxlY3RlZCwgJ2dlb2NvZGVyLWNvbnRyb2wtc2VsZWN0ZWQnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIG5leHRJdGVtID0gbGlzdFtzZWxlY3RlZFBvc2l0aW9uICsgMV07XHJcblxyXG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWQgJiYgbmV4dEl0ZW0pIHtcclxuICAgICAgICAgICAgICBsZWFmbGV0LkRvbVV0aWwuYWRkQ2xhc3MobmV4dEl0ZW0sICdnZW9jb2Rlci1jb250cm9sLXNlbGVjdGVkJyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgbGVhZmxldC5Eb21VdGlsLmFkZENsYXNzKGxpc3RbMF0sICdnZW9jb2Rlci1jb250cm9sLXNlbGVjdGVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGVhZmxldC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAvLyB3aGVuIHRoZSBpbnB1dCBjaGFuZ2VzIHdlIHNob3VsZCBjYW5jZWwgYWxsIHBlbmRpbmcgc3VnZ2VzdGlvbiByZXF1ZXN0cyBpZiBwb3NzaWJsZSB0byBhdm9pZCByZXN1bHQgY29sbGlzaW9uc1xyXG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHRoaXMuX2dlb3NlYXJjaENvcmUuX3BlbmRpbmdTdWdnZXN0aW9ucy5sZW5ndGg7IHgrKykge1xyXG4gICAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gdGhpcy5fZ2Vvc2VhcmNoQ29yZS5fcGVuZGluZ1N1Z2dlc3Rpb25zW3hdO1xyXG4gICAgICAgICAgICAgIGlmIChyZXF1ZXN0ICYmIHJlcXVlc3QuYWJvcnQgJiYgIXJlcXVlc3QuaWQpIHtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3QuYWJvcnQoKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgIGxlYWZsZXQuRG9tRXZlbnQuYWRkTGlzdGVuZXIodGhpcy5faW5wdXQsICdrZXl1cCcsIGxlYWZsZXQuVXRpbC50aHJvdHRsZShmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIHZhciBrZXkgPSBlLndoaWNoIHx8IGUua2V5Q29kZTtcclxuICAgICAgICB2YXIgdGV4dCA9IChlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQpLnZhbHVlO1xyXG5cclxuICAgICAgICAvLyByZXF1aXJlIGF0IGxlYXN0IDIgY2hhcmFjdGVycyBmb3Igc3VnZ2VzdGlvbnNcclxuICAgICAgICBpZiAodGV4dC5sZW5ndGggPCAyKSB7XHJcbiAgICAgICAgICB0aGlzLl9sYXN0VmFsdWUgPSB0aGlzLl9pbnB1dC52YWx1ZTtcclxuICAgICAgICAgIHRoaXMuX2NsZWFyQWxsU3VnZ2VzdGlvbnMoKTtcclxuICAgICAgICAgIGxlYWZsZXQuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9pbnB1dCwgJ2dlb2NvZGVyLWNvbnRyb2wtbG9hZGluZycpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gaWYgdGhpcyBpcyB0aGUgZXNjYXBlIGtleSBpdCB3aWxsIGNsZWFyIHRoZSBpbnB1dCBzbyBjbGVhciBzdWdnZXN0aW9uc1xyXG4gICAgICAgIGlmIChrZXkgPT09IDI3KSB7XHJcbiAgICAgICAgICB0aGlzLl9jbGVhckFsbFN1Z2dlc3Rpb25zKCk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBpZiB0aGlzIGlzIE5PVCB0aGUgdXAvZG93biBhcnJvd3Mgb3IgZW50ZXIgbWFrZSBhIHN1Z2dlc3Rpb25cclxuICAgICAgICBpZiAoa2V5ICE9PSAxMyAmJiBrZXkgIT09IDM4ICYmIGtleSAhPT0gNDApIHtcclxuICAgICAgICAgIGlmICh0aGlzLl9pbnB1dC52YWx1ZSAhPT0gdGhpcy5fbGFzdFZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3RWYWx1ZSA9IHRoaXMuX2lucHV0LnZhbHVlO1xyXG4gICAgICAgICAgICBsZWFmbGV0LkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5faW5wdXQsICdnZW9jb2Rlci1jb250cm9sLWxvYWRpbmcnKTtcclxuICAgICAgICAgICAgdGhpcy5fZ2Vvc2VhcmNoQ29yZS5fc3VnZ2VzdCh0ZXh0KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0sIDUwLCB0aGlzKSwgdGhpcyk7XHJcblxyXG4gICAgICBsZWFmbGV0LkRvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKHRoaXMuX3dyYXBwZXIpO1xyXG5cclxuICAgICAgLy8gd2hlbiBtb3VzZSBtb3ZlcyBvdmVyIHN1Z2dlc3Rpb25zIGRpc2FibGUgc2Nyb2xsIHdoZWVsIHpvb20gaWYgaXRzIGVuYWJsZWRcclxuICAgICAgbGVhZmxldC5Eb21FdmVudC5hZGRMaXN0ZW5lcih0aGlzLl9zdWdnZXN0aW9ucywgJ21vdXNlb3ZlcicsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgaWYgKG1hcC5zY3JvbGxXaGVlbFpvb20uZW5hYmxlZCgpICYmIG1hcC5vcHRpb25zLnNjcm9sbFdoZWVsWm9vbSkge1xyXG4gICAgICAgICAgbWFwLnNjcm9sbFdoZWVsWm9vbS5kaXNhYmxlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIHdoZW4gbW91c2UgbW92ZXMgbGVhdmVzIHN1Z2dlc3Rpb25zIGVuYWJsZSBzY3JvbGwgd2hlZWwgem9vbSBpZiBpdHMgZGlzYWJsZWRcclxuICAgICAgbGVhZmxldC5Eb21FdmVudC5hZGRMaXN0ZW5lcih0aGlzLl9zdWdnZXN0aW9ucywgJ21vdXNlb3V0JywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBpZiAoIW1hcC5zY3JvbGxXaGVlbFpvb20uZW5hYmxlZCgpICYmIG1hcC5vcHRpb25zLnNjcm9sbFdoZWVsWm9vbSkge1xyXG4gICAgICAgICAgbWFwLnNjcm9sbFdoZWVsWm9vbS5lbmFibGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdGhpcy5fZ2Vvc2VhcmNoQ29yZS5vbignbG9hZCcsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgbGVhZmxldC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2lucHV0LCAnZ2VvY29kZXItY29udHJvbC1sb2FkaW5nJyk7XHJcbiAgICAgICAgdGhpcy5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuX2lucHV0LmJsdXIoKTtcclxuICAgICAgfSwgdGhpcyk7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcy5fd3JhcHBlcjtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgZnVuY3Rpb24gZ2Vvc2VhcmNoIChvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gbmV3IEdlb3NlYXJjaChvcHRpb25zKTtcclxuICB9XG5cbiAgdmFyIEZlYXR1cmVMYXllclByb3ZpZGVyID0gZXNyaUxlYWZsZXQuRmVhdHVyZUxheWVyU2VydmljZS5leHRlbmQoe1xyXG4gICAgb3B0aW9uczoge1xyXG4gICAgICBsYWJlbDogJ0ZlYXR1cmUgTGF5ZXInLFxyXG4gICAgICBtYXhSZXN1bHRzOiA1LFxyXG4gICAgICBidWZmZXJSYWRpdXM6IDEwMDAsXHJcbiAgICAgIHNlYXJjaE1vZGU6ICdjb250YWluJyxcclxuICAgICAgZm9ybWF0U3VnZ2VzdGlvbjogZnVuY3Rpb24gKGZlYXR1cmUpIHtcclxuICAgICAgICByZXR1cm4gZmVhdHVyZS5wcm9wZXJ0aWVzW3RoaXMub3B0aW9ucy5zZWFyY2hGaWVsZHNbMF1dO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgIGlmIChvcHRpb25zLmFwaWtleSkge1xyXG4gICAgICAgIG9wdGlvbnMudG9rZW4gPSBvcHRpb25zLmFwaWtleTtcclxuICAgICAgfVxyXG4gICAgICBlc3JpTGVhZmxldC5GZWF0dXJlTGF5ZXJTZXJ2aWNlLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XHJcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnNlYXJjaEZpZWxkcyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICB0aGlzLm9wdGlvbnMuc2VhcmNoRmllbGRzID0gW3RoaXMub3B0aW9ucy5zZWFyY2hGaWVsZHNdO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX3N1Z2dlc3Rpb25zUXVlcnkgPSB0aGlzLnF1ZXJ5KCk7XHJcbiAgICAgIHRoaXMuX3Jlc3VsdHNRdWVyeSA9IHRoaXMucXVlcnkoKTtcclxuICAgIH0sXHJcblxyXG4gICAgc3VnZ2VzdGlvbnM6IGZ1bmN0aW9uICh0ZXh0LCBib3VuZHMsIGNhbGxiYWNrKSB7XHJcbiAgICAgIHZhciBxdWVyeSA9IHRoaXMuX3N1Z2dlc3Rpb25zUXVlcnkud2hlcmUodGhpcy5fYnVpbGRRdWVyeSh0ZXh0KSlcclxuICAgICAgICAucmV0dXJuR2VvbWV0cnkoZmFsc2UpO1xyXG5cclxuICAgICAgaWYgKGJvdW5kcykge1xyXG4gICAgICAgIHF1ZXJ5LmludGVyc2VjdHMoYm91bmRzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5pZEZpZWxkKSB7XHJcbiAgICAgICAgcXVlcnkuZmllbGRzKFt0aGlzLm9wdGlvbnMuaWRGaWVsZF0uY29uY2F0KHRoaXMub3B0aW9ucy5zZWFyY2hGaWVsZHMpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHJlcXVlc3QgPSBxdWVyeS5ydW4oZnVuY3Rpb24gKGVycm9yLCByZXN1bHRzLCByYXcpIHtcclxuICAgICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICAgIGNhbGxiYWNrKGVycm9yLCBbXSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMub3B0aW9ucy5pZEZpZWxkID0gcmF3Lm9iamVjdElkRmllbGROYW1lO1xyXG4gICAgICAgICAgdmFyIHN1Z2dlc3Rpb25zID0gW107XHJcbiAgICAgICAgICBmb3IgKHZhciBpID0gcmVzdWx0cy5mZWF0dXJlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICB2YXIgZmVhdHVyZSA9IHJlc3VsdHMuZmVhdHVyZXNbaV07XHJcbiAgICAgICAgICAgIHN1Z2dlc3Rpb25zLnB1c2goe1xyXG4gICAgICAgICAgICAgIHRleHQ6IHRoaXMub3B0aW9ucy5mb3JtYXRTdWdnZXN0aW9uLmNhbGwodGhpcywgZmVhdHVyZSksXHJcbiAgICAgICAgICAgICAgdW5mb3JtYXR0ZWRUZXh0OiBmZWF0dXJlLnByb3BlcnRpZXNbdGhpcy5vcHRpb25zLnNlYXJjaEZpZWxkc1swXV0sXHJcbiAgICAgICAgICAgICAgbWFnaWNLZXk6IGZlYXR1cmUuaWRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjYWxsYmFjayhlcnJvciwgc3VnZ2VzdGlvbnMuc2xpY2UoMCwgdGhpcy5vcHRpb25zLm1heFJlc3VsdHMpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sIHRoaXMpO1xyXG5cclxuICAgICAgcmV0dXJuIHJlcXVlc3Q7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlc3VsdHM6IGZ1bmN0aW9uICh0ZXh0LCBrZXksIGJvdW5kcywgY2FsbGJhY2spIHtcclxuICAgICAgdmFyIHF1ZXJ5ID0gdGhpcy5fcmVzdWx0c1F1ZXJ5O1xyXG5cclxuICAgICAgaWYgKGtleSkge1xyXG4gICAgICAgIC8vIGlmIHRoZXJlIGFyZSAxIG9yIG1vcmUga2V5cyBhdmFpbGFibGUsIHVzZSBxdWVyeS5mZWF0dXJlSWRzKClcclxuICAgICAgICBkZWxldGUgcXVlcnkucGFyYW1zLndoZXJlO1xyXG4gICAgICAgIHF1ZXJ5LmZlYXR1cmVJZHMoW2tleV0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIGlmIHRoZXJlIGFyZSBubyBrZXlzIGF2YWlsYWJsZSwgdXNlIHF1ZXJ5LndoZXJlKClcclxuICAgICAgICBxdWVyeS53aGVyZSh0aGlzLl9idWlsZFF1ZXJ5KHRleHQpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGJvdW5kcykge1xyXG4gICAgICAgIHF1ZXJ5LndpdGhpbihib3VuZHMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcXVlcnkucnVuKGxlYWZsZXQuVXRpbC5iaW5kKGZ1bmN0aW9uIChlcnJvciwgZmVhdHVyZXMpIHtcclxuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmVhdHVyZXMuZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIHZhciBmZWF0dXJlID0gZmVhdHVyZXMuZmVhdHVyZXNbaV07XHJcbiAgICAgICAgICBpZiAoZmVhdHVyZSkge1xyXG4gICAgICAgICAgICB2YXIgYm91bmRzID0gdGhpcy5fZmVhdHVyZUJvdW5kcyhmZWF0dXJlKTtcclxuXHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7XHJcbiAgICAgICAgICAgICAgbGF0bG5nOiBib3VuZHMuZ2V0Q2VudGVyKCksXHJcbiAgICAgICAgICAgICAgYm91bmRzOiBib3VuZHMsXHJcbiAgICAgICAgICAgICAgdGV4dDogdGhpcy5vcHRpb25zLmZvcm1hdFN1Z2dlc3Rpb24uY2FsbCh0aGlzLCBmZWF0dXJlKSxcclxuICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBmZWF0dXJlLnByb3BlcnRpZXMsXHJcbiAgICAgICAgICAgICAgZ2VvanNvbjogZmVhdHVyZVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XHJcblxyXG4gICAgICAgICAgICAvLyBjbGVhciBxdWVyeSBwYXJhbWV0ZXJzIGZvciB0aGUgbmV4dCBzZWFyY2hcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3Jlc3VsdHNRdWVyeS5wYXJhbXNbJ29iamVjdElkcyddO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYWxsYmFjayhlcnJvciwgcmVzdWx0cyk7XHJcbiAgICAgIH0sIHRoaXMpKTtcclxuICAgIH0sXHJcblxyXG4gICAgb3JkZXJCeTogZnVuY3Rpb24gKGZpZWxkTmFtZSwgb3JkZXIpIHtcclxuICAgICAgdGhpcy5fc3VnZ2VzdGlvbnNRdWVyeS5vcmRlckJ5KGZpZWxkTmFtZSwgb3JkZXIpO1xyXG4gICAgfSxcclxuXHJcbiAgICBfYnVpbGRRdWVyeTogZnVuY3Rpb24gKHRleHQpIHtcclxuICAgICAgdmFyIHF1ZXJ5U3RyaW5nID0gW107XHJcblxyXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5vcHRpb25zLnNlYXJjaEZpZWxkcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgIHZhciBmaWVsZCA9ICd1cHBlcihcIicgKyB0aGlzLm9wdGlvbnMuc2VhcmNoRmllbGRzW2ldICsgJ1wiKSc7XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zZWFyY2hNb2RlID09PSAnY29udGFpbicpIHtcclxuICAgICAgICAgIHF1ZXJ5U3RyaW5nLnB1c2goZmllbGQgKyBcIiBMSUtFIHVwcGVyKCclXCIgKyB0ZXh0ICsgXCIlJylcIik7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuc2VhcmNoTW9kZSA9PT0gJ3N0YXJ0V2l0aCcpIHtcclxuICAgICAgICAgIHF1ZXJ5U3RyaW5nLnB1c2goZmllbGQgKyBcIiBMSUtFIHVwcGVyKCdcIiArIHRleHQgKyBcIiUnKVwiKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5zZWFyY2hNb2RlID09PSAnZW5kV2l0aCcpIHtcclxuICAgICAgICAgIHF1ZXJ5U3RyaW5nLnB1c2goZmllbGQgKyBcIiBMSUtFIHVwcGVyKCclXCIgKyB0ZXh0ICsgXCInKVwiKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5zZWFyY2hNb2RlID09PSAnc3RyaWN0Jykge1xyXG4gICAgICAgICAgcXVlcnlTdHJpbmcucHVzaChmaWVsZCArIFwiIExJS0UgdXBwZXIoJ1wiICsgdGV4dCArIFwiJylcIik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTC5lc3JpLkdlb2NvZGluZy5mZWF0dXJlTGF5ZXJQcm92aWRlcjogSW52YWxpZCBwYXJhbWV0ZXIgZm9yIFwic2VhcmNoTW9kZVwiLiBVc2Ugb25lIG9mIFwiY29udGFpblwiLCBcInN0YXJ0V2l0aFwiLCBcImVuZFdpdGhcIiwgb3IgXCJzdHJpY3RcIicpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5vcHRpb25zLndoZXJlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy53aGVyZSArICcgQU5EICgnICsgcXVlcnlTdHJpbmcuam9pbignIE9SICcpICsgJyknO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBxdWVyeVN0cmluZy5qb2luKCcgT1IgJyk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgX2ZlYXR1cmVCb3VuZHM6IGZ1bmN0aW9uIChmZWF0dXJlKSB7XHJcbiAgICAgIHZhciBnZW9qc29uID0gbGVhZmxldC5nZW9Kc29uKGZlYXR1cmUpO1xyXG4gICAgICBpZiAoZmVhdHVyZS5nZW9tZXRyeS50eXBlID09PSAnUG9pbnQnKSB7XHJcbiAgICAgICAgdmFyIGNlbnRlciA9IGdlb2pzb24uZ2V0Qm91bmRzKCkuZ2V0Q2VudGVyKCk7XHJcbiAgICAgICAgdmFyIGxuZ1JhZGl1cyA9ICgodGhpcy5vcHRpb25zLmJ1ZmZlclJhZGl1cyAvIDQwMDc1MDE3KSAqIDM2MCkgLyBNYXRoLmNvcygoMTgwIC8gTWF0aC5QSSkgKiBjZW50ZXIubGF0KTtcclxuICAgICAgICB2YXIgbGF0UmFkaXVzID0gKHRoaXMub3B0aW9ucy5idWZmZXJSYWRpdXMgLyA0MDA3NTAxNykgKiAzNjA7XHJcbiAgICAgICAgcmV0dXJuIGxlYWZsZXQubGF0TG5nQm91bmRzKFtjZW50ZXIubGF0IC0gbGF0UmFkaXVzLCBjZW50ZXIubG5nIC0gbG5nUmFkaXVzXSwgW2NlbnRlci5sYXQgKyBsYXRSYWRpdXMsIGNlbnRlci5sbmcgKyBsbmdSYWRpdXNdKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZ2VvanNvbi5nZXRCb3VuZHMoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICBmdW5jdGlvbiBmZWF0dXJlTGF5ZXJQcm92aWRlciAob3B0aW9ucykge1xyXG4gICAgcmV0dXJuIG5ldyBGZWF0dXJlTGF5ZXJQcm92aWRlcihvcHRpb25zKTtcclxuICB9XG5cbiAgdmFyIE1hcFNlcnZpY2VQcm92aWRlciA9IGVzcmlMZWFmbGV0Lk1hcFNlcnZpY2UuZXh0ZW5kKHtcclxuICAgIG9wdGlvbnM6IHtcclxuICAgICAgbGF5ZXJzOiBbMF0sXHJcbiAgICAgIGxhYmVsOiAnTWFwIFNlcnZpY2UnLFxyXG4gICAgICBidWZmZXJSYWRpdXM6IDEwMDAsXHJcbiAgICAgIG1heFJlc3VsdHM6IDUsXHJcbiAgICAgIGZvcm1hdFN1Z2dlc3Rpb246IGZ1bmN0aW9uIChmZWF0dXJlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZlYXR1cmUucHJvcGVydGllc1tmZWF0dXJlLmRpc3BsYXlGaWVsZE5hbWVdICsgJyA8c21hbGw+JyArIGZlYXR1cmUubGF5ZXJOYW1lICsgJzwvc21hbGw+JztcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICBpZiAob3B0aW9ucy5hcGlrZXkpIHtcclxuICAgICAgICBvcHRpb25zLnRva2VuID0gb3B0aW9ucy5hcGlrZXk7XHJcbiAgICAgIH1cclxuICAgICAgZXNyaUxlYWZsZXQuTWFwU2VydmljZS5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG4gICAgICB0aGlzLl9nZXRJZEZpZWxkcygpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzdWdnZXN0aW9uczogZnVuY3Rpb24gKHRleHQsIGJvdW5kcywgY2FsbGJhY2spIHtcclxuICAgICAgdmFyIHJlcXVlc3QgPSB0aGlzLmZpbmQoKS50ZXh0KHRleHQpLmZpZWxkcyh0aGlzLm9wdGlvbnMuc2VhcmNoRmllbGRzKS5yZXR1cm5HZW9tZXRyeShmYWxzZSkubGF5ZXJzKHRoaXMub3B0aW9ucy5sYXllcnMpO1xyXG5cclxuICAgICAgcmV0dXJuIHJlcXVlc3QucnVuKGZ1bmN0aW9uIChlcnJvciwgcmVzdWx0cywgcmF3KSB7XHJcbiAgICAgICAgdmFyIHN1Z2dlc3Rpb25zID0gW107XHJcbiAgICAgICAgaWYgKCFlcnJvcikge1xyXG4gICAgICAgICAgdmFyIGNvdW50ID0gTWF0aC5taW4odGhpcy5vcHRpb25zLm1heFJlc3VsdHMsIHJlc3VsdHMuZmVhdHVyZXMubGVuZ3RoKTtcclxuICAgICAgICAgIHJhdy5yZXN1bHRzID0gcmF3LnJlc3VsdHMucmV2ZXJzZSgpO1xyXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBmZWF0dXJlID0gcmVzdWx0cy5mZWF0dXJlc1tpXTtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHJhdy5yZXN1bHRzW2ldO1xyXG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSByZXN1bHQubGF5ZXJJZDtcclxuICAgICAgICAgICAgdmFyIGlkRmllbGQgPSB0aGlzLl9pZEZpZWxkc1tsYXllcl07XHJcbiAgICAgICAgICAgIGZlYXR1cmUubGF5ZXJJZCA9IGxheWVyO1xyXG4gICAgICAgICAgICBmZWF0dXJlLmxheWVyTmFtZSA9IHRoaXMuX2xheWVyTmFtZXNbbGF5ZXJdO1xyXG4gICAgICAgICAgICBmZWF0dXJlLmRpc3BsYXlGaWVsZE5hbWUgPSB0aGlzLl9kaXNwbGF5RmllbGRzW2xheWVyXTtcclxuICAgICAgICAgICAgaWYgKGlkRmllbGQpIHtcclxuICAgICAgICAgICAgICBzdWdnZXN0aW9ucy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHRleHQ6IHRoaXMub3B0aW9ucy5mb3JtYXRTdWdnZXN0aW9uLmNhbGwodGhpcywgZmVhdHVyZSksXHJcbiAgICAgICAgICAgICAgICB1bmZvcm1hdHRlZFRleHQ6IGZlYXR1cmUucHJvcGVydGllc1tmZWF0dXJlLmRpc3BsYXlGaWVsZE5hbWVdLFxyXG4gICAgICAgICAgICAgICAgbWFnaWNLZXk6IHJlc3VsdC5hdHRyaWJ1dGVzW2lkRmllbGRdICsgJzonICsgbGF5ZXJcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYWxsYmFjayhlcnJvciwgc3VnZ2VzdGlvbnMucmV2ZXJzZSgpKTtcclxuICAgICAgfSwgdGhpcyk7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlc3VsdHM6IGZ1bmN0aW9uICh0ZXh0LCBrZXksIGJvdW5kcywgY2FsbGJhY2spIHtcclxuICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcclxuICAgICAgdmFyIHJlcXVlc3Q7XHJcblxyXG4gICAgICBpZiAoa2V5ICYmICFrZXkuaW5jbHVkZXMoJywnKSkge1xyXG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIG9ubHkgMSBrZXkgYXZhaWxhYmxlLCB1c2UgcXVlcnkoKVxyXG4gICAgICAgIHZhciBmZWF0dXJlSWQgPSBrZXkuc3BsaXQoJzonKVswXTtcclxuICAgICAgICB2YXIgbGF5ZXIgPSBrZXkuc3BsaXQoJzonKVsxXTtcclxuICAgICAgICByZXF1ZXN0ID0gdGhpcy5xdWVyeSgpLmxheWVyKGxheWVyKS5mZWF0dXJlSWRzKGZlYXR1cmVJZCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vIGtleXMgb3IgbW9yZSB0aGFuIDEga2V5cyBhdmFpbGFibGUsIHVzZSBmaW5kKClcclxuICAgICAgICByZXF1ZXN0ID0gdGhpcy5maW5kKCkudGV4dCh0ZXh0KS5maWVsZHModGhpcy5vcHRpb25zLnNlYXJjaEZpZWxkcykubGF5ZXJzKHRoaXMub3B0aW9ucy5sYXllcnMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcmVxdWVzdC5ydW4oZnVuY3Rpb24gKGVycm9yLCBmZWF0dXJlcywgcmVzcG9uc2UpIHtcclxuICAgICAgICBpZiAoIWVycm9yKSB7XHJcbiAgICAgICAgICBpZiAocmVzcG9uc2UucmVzdWx0cykge1xyXG4gICAgICAgICAgICByZXNwb25zZS5yZXN1bHRzID0gcmVzcG9uc2UucmVzdWx0cy5yZXZlcnNlKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZlYXR1cmVzLmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBmZWF0dXJlID0gZmVhdHVyZXMuZmVhdHVyZXNbaV07XHJcbiAgICAgICAgICAgIGxheWVyID0gbGF5ZXIgfHwgcmVzcG9uc2UucmVzdWx0c1tpXS5sYXllcklkO1xyXG5cclxuICAgICAgICAgICAgaWYgKGZlYXR1cmUgJiYgbGF5ZXIgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgIHZhciBib3VuZHMgPSB0aGlzLl9mZWF0dXJlQm91bmRzKGZlYXR1cmUpO1xyXG4gICAgICAgICAgICAgIGZlYXR1cmUubGF5ZXJJZCA9IGxheWVyO1xyXG4gICAgICAgICAgICAgIGZlYXR1cmUubGF5ZXJOYW1lID0gdGhpcy5fbGF5ZXJOYW1lc1tsYXllcl07XHJcbiAgICAgICAgICAgICAgZmVhdHVyZS5kaXNwbGF5RmllbGROYW1lID0gdGhpcy5fZGlzcGxheUZpZWxkc1tsYXllcl07XHJcblxyXG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSB7XHJcbiAgICAgICAgICAgICAgICBsYXRsbmc6IGJvdW5kcy5nZXRDZW50ZXIoKSxcclxuICAgICAgICAgICAgICAgIGJvdW5kczogYm91bmRzLFxyXG4gICAgICAgICAgICAgICAgdGV4dDogdGhpcy5vcHRpb25zLmZvcm1hdFN1Z2dlc3Rpb24uY2FsbCh0aGlzLCBmZWF0dXJlKSxcclxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IGZlYXR1cmUucHJvcGVydGllcyxcclxuICAgICAgICAgICAgICAgIGdlb2pzb246IGZlYXR1cmVcclxuICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYWxsYmFjayhlcnJvciwgcmVzdWx0cy5yZXZlcnNlKCkpO1xyXG4gICAgICB9LCB0aGlzKTtcclxuICAgIH0sXHJcblxyXG4gICAgX2ZlYXR1cmVCb3VuZHM6IGZ1bmN0aW9uIChmZWF0dXJlKSB7XHJcbiAgICAgIHZhciBnZW9qc29uID0gbGVhZmxldC5nZW9Kc29uKGZlYXR1cmUpO1xyXG4gICAgICBpZiAoZmVhdHVyZS5nZW9tZXRyeS50eXBlID09PSAnUG9pbnQnKSB7XHJcbiAgICAgICAgdmFyIGNlbnRlciA9IGdlb2pzb24uZ2V0Qm91bmRzKCkuZ2V0Q2VudGVyKCk7XHJcbiAgICAgICAgdmFyIGxuZ1JhZGl1cyA9ICgodGhpcy5vcHRpb25zLmJ1ZmZlclJhZGl1cyAvIDQwMDc1MDE3KSAqIDM2MCkgLyBNYXRoLmNvcygoMTgwIC8gTWF0aC5QSSkgKiBjZW50ZXIubGF0KTtcclxuICAgICAgICB2YXIgbGF0UmFkaXVzID0gKHRoaXMub3B0aW9ucy5idWZmZXJSYWRpdXMgLyA0MDA3NTAxNykgKiAzNjA7XHJcbiAgICAgICAgcmV0dXJuIGxlYWZsZXQubGF0TG5nQm91bmRzKFtjZW50ZXIubGF0IC0gbGF0UmFkaXVzLCBjZW50ZXIubG5nIC0gbG5nUmFkaXVzXSwgW2NlbnRlci5sYXQgKyBsYXRSYWRpdXMsIGNlbnRlci5sbmcgKyBsbmdSYWRpdXNdKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZ2VvanNvbi5nZXRCb3VuZHMoKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBfbGF5ZXJNZXRhZGF0YUNhbGxiYWNrOiBmdW5jdGlvbiAobGF5ZXJpZCkge1xyXG4gICAgICByZXR1cm4gbGVhZmxldC5VdGlsLmJpbmQoZnVuY3Rpb24gKGVycm9yLCBtZXRhZGF0YSkge1xyXG4gICAgICAgIGlmIChlcnJvcikgeyByZXR1cm47IH1cclxuICAgICAgICB0aGlzLl9kaXNwbGF5RmllbGRzW2xheWVyaWRdID0gbWV0YWRhdGEuZGlzcGxheUZpZWxkO1xyXG4gICAgICAgIHRoaXMuX2xheWVyTmFtZXNbbGF5ZXJpZF0gPSBtZXRhZGF0YS5uYW1lO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWV0YWRhdGEuZmllbGRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICB2YXIgZmllbGQgPSBtZXRhZGF0YS5maWVsZHNbaV07XHJcbiAgICAgICAgICBpZiAoZmllbGQudHlwZSA9PT0gJ2VzcmlGaWVsZFR5cGVPSUQnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2lkRmllbGRzW2xheWVyaWRdID0gZmllbGQubmFtZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9LCB0aGlzKTtcclxuICAgIH0sXHJcblxyXG4gICAgX2dldElkRmllbGRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMuX2lkRmllbGRzID0ge307XHJcbiAgICAgIHRoaXMuX2Rpc3BsYXlGaWVsZHMgPSB7fTtcclxuICAgICAgdGhpcy5fbGF5ZXJOYW1lcyA9IHt9O1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3B0aW9ucy5sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLm9wdGlvbnMubGF5ZXJzW2ldO1xyXG4gICAgICAgIHRoaXMuZ2V0KGxheWVyLCB7fSwgdGhpcy5fbGF5ZXJNZXRhZGF0YUNhbGxiYWNrKGxheWVyKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgZnVuY3Rpb24gbWFwU2VydmljZVByb3ZpZGVyIChvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gbmV3IE1hcFNlcnZpY2VQcm92aWRlcihvcHRpb25zKTtcclxuICB9XG5cbiAgdmFyIEdlb2NvZGVTZXJ2aWNlUHJvdmlkZXIgPSBHZW9jb2RlU2VydmljZS5leHRlbmQoe1xyXG4gICAgb3B0aW9uczoge1xyXG4gICAgICBsYWJlbDogJ0dlb2NvZGUgU2VydmVyJyxcclxuICAgICAgbWF4UmVzdWx0czogNVxyXG4gICAgfSxcclxuXHJcbiAgICBzdWdnZXN0aW9uczogZnVuY3Rpb24gKHRleHQsIGJvdW5kcywgY2FsbGJhY2spIHtcclxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdXBwb3J0c1N1Z2dlc3QpIHtcclxuICAgICAgICB2YXIgcmVxdWVzdCA9IHRoaXMuc3VnZ2VzdCgpLnRleHQodGV4dCk7XHJcbiAgICAgICAgaWYgKGJvdW5kcykge1xyXG4gICAgICAgICAgcmVxdWVzdC53aXRoaW4oYm91bmRzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXF1ZXN0LnJ1bihmdW5jdGlvbiAoZXJyb3IsIHJlc3VsdHMsIHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICB2YXIgc3VnZ2VzdGlvbnMgPSBbXTtcclxuICAgICAgICAgIGlmICghZXJyb3IpIHtcclxuICAgICAgICAgICAgd2hpbGUgKHJlc3BvbnNlLnN1Z2dlc3Rpb25zLmxlbmd0aCAmJiBzdWdnZXN0aW9ucy5sZW5ndGggPD0gKHRoaXMub3B0aW9ucy5tYXhSZXN1bHRzIC0gMSkpIHtcclxuICAgICAgICAgICAgICB2YXIgc3VnZ2VzdGlvbiA9IHJlc3BvbnNlLnN1Z2dlc3Rpb25zLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgaWYgKCFzdWdnZXN0aW9uLmlzQ29sbGVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgc3VnZ2VzdGlvbnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgIHRleHQ6IHN1Z2dlc3Rpb24udGV4dCxcclxuICAgICAgICAgICAgICAgICAgdW5mb3JtYXR0ZWRUZXh0OiBzdWdnZXN0aW9uLnRleHQsXHJcbiAgICAgICAgICAgICAgICAgIG1hZ2ljS2V5OiBzdWdnZXN0aW9uLm1hZ2ljS2V5XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGNhbGxiYWNrKGVycm9yLCBzdWdnZXN0aW9ucyk7XHJcbiAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgW10pO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICByZXN1bHRzOiBmdW5jdGlvbiAodGV4dCwga2V5LCBib3VuZHMsIGNhbGxiYWNrKSB7XHJcbiAgICAgIHZhciByZXF1ZXN0ID0gdGhpcy5nZW9jb2RlKCkudGV4dCh0ZXh0KTtcclxuXHJcbiAgICAgIGlmIChrZXkpIHtcclxuICAgICAgICByZXF1ZXN0LmtleShrZXkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXF1ZXN0Lm1heExvY2F0aW9ucyh0aGlzLm9wdGlvbnMubWF4UmVzdWx0cyk7XHJcblxyXG4gICAgICBpZiAoYm91bmRzKSB7XHJcbiAgICAgICAgcmVxdWVzdC53aXRoaW4oYm91bmRzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJlcXVlc3QucnVuKGZ1bmN0aW9uIChlcnJvciwgcmVzcG9uc2UpIHtcclxuICAgICAgICBjYWxsYmFjayhlcnJvciwgcmVzcG9uc2UucmVzdWx0cyk7XHJcbiAgICAgIH0sIHRoaXMpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICBmdW5jdGlvbiBnZW9jb2RlU2VydmljZVByb3ZpZGVyIChvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gbmV3IEdlb2NvZGVTZXJ2aWNlUHJvdmlkZXIob3B0aW9ucyk7XHJcbiAgfVxuXG4gIGV4cG9ydHMuQXJjZ2lzT25saW5lUHJvdmlkZXIgPSBBcmNnaXNPbmxpbmVQcm92aWRlcjtcbiAgZXhwb3J0cy5GZWF0dXJlTGF5ZXJQcm92aWRlciA9IEZlYXR1cmVMYXllclByb3ZpZGVyO1xuICBleHBvcnRzLkdlb2NvZGUgPSBHZW9jb2RlO1xuICBleHBvcnRzLkdlb2NvZGVTZXJ2aWNlID0gR2VvY29kZVNlcnZpY2U7XG4gIGV4cG9ydHMuR2VvY29kZVNlcnZpY2VQcm92aWRlciA9IEdlb2NvZGVTZXJ2aWNlUHJvdmlkZXI7XG4gIGV4cG9ydHMuR2Vvc2VhcmNoID0gR2Vvc2VhcmNoO1xuICBleHBvcnRzLkdlb3NlYXJjaENvcmUgPSBHZW9zZWFyY2hDb3JlO1xuICBleHBvcnRzLk1hcFNlcnZpY2VQcm92aWRlciA9IE1hcFNlcnZpY2VQcm92aWRlcjtcbiAgZXhwb3J0cy5SZXZlcnNlR2VvY29kZSA9IFJldmVyc2VHZW9jb2RlO1xuICBleHBvcnRzLlN1Z2dlc3QgPSBTdWdnZXN0O1xuICBleHBvcnRzLlZFUlNJT04gPSB2ZXJzaW9uO1xuICBleHBvcnRzLldvcmxkR2VvY29kaW5nU2VydmljZVVybCA9IFdvcmxkR2VvY29kaW5nU2VydmljZVVybDtcbiAgZXhwb3J0cy5hcmNnaXNPbmxpbmVQcm92aWRlciA9IGFyY2dpc09ubGluZVByb3ZpZGVyO1xuICBleHBvcnRzLmZlYXR1cmVMYXllclByb3ZpZGVyID0gZmVhdHVyZUxheWVyUHJvdmlkZXI7XG4gIGV4cG9ydHMuZ2VvY29kZSA9IGdlb2NvZGU7XG4gIGV4cG9ydHMuZ2VvY29kZVNlcnZpY2UgPSBnZW9jb2RlU2VydmljZTtcbiAgZXhwb3J0cy5nZW9jb2RlU2VydmljZVByb3ZpZGVyID0gZ2VvY29kZVNlcnZpY2VQcm92aWRlcjtcbiAgZXhwb3J0cy5nZW9zZWFyY2ggPSBnZW9zZWFyY2g7XG4gIGV4cG9ydHMuZ2Vvc2VhcmNoQ29yZSA9IGdlb3NlYXJjaENvcmU7XG4gIGV4cG9ydHMubWFwU2VydmljZVByb3ZpZGVyID0gbWFwU2VydmljZVByb3ZpZGVyO1xuICBleHBvcnRzLnJldmVyc2VHZW9jb2RlID0gcmV2ZXJzZUdlb2NvZGU7XG4gIGV4cG9ydHMuc3VnZ2VzdCA9IHN1Z2dlc3Q7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXNyaS1sZWFmbGV0LWdlb2NvZGVyLWRlYnVnLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/esri-leaflet-geocoder/dist/esri-leaflet-geocoder-debug.js\n");

/***/ }),

/***/ "./node_modules/esri-leaflet/src/EsriLeaflet.js":
/*!******************************************************!*\
  !*** ./node_modules/esri-leaflet/src/EsriLeaflet.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BasemapLayer\": () => (/* reexport safe */ _Layers_BasemapLayer__WEBPACK_IMPORTED_MODULE_15__.BasemapLayer),\n/* harmony export */   \"DynamicMapLayer\": () => (/* reexport safe */ _Layers_DynamicMapLayer__WEBPACK_IMPORTED_MODULE_19__.DynamicMapLayer),\n/* harmony export */   \"FeatureLayer\": () => (/* reexport safe */ _Layers_FeatureLayer_FeatureLayer__WEBPACK_IMPORTED_MODULE_21__.FeatureLayer),\n/* harmony export */   \"FeatureLayerService\": () => (/* reexport safe */ _Services_FeatureLayerService__WEBPACK_IMPORTED_MODULE_14__.FeatureLayerService),\n/* harmony export */   \"FeatureManager\": () => (/* reexport safe */ _Layers_FeatureLayer_FeatureManager__WEBPACK_IMPORTED_MODULE_20__.FeatureManager),\n/* harmony export */   \"Find\": () => (/* reexport safe */ _Tasks_Find__WEBPACK_IMPORTED_MODULE_7__.Find),\n/* harmony export */   \"Identify\": () => (/* reexport safe */ _Tasks_Identify__WEBPACK_IMPORTED_MODULE_8__.Identify),\n/* harmony export */   \"IdentifyFeatures\": () => (/* reexport safe */ _Tasks_IdentifyFeatures__WEBPACK_IMPORTED_MODULE_9__.IdentifyFeatures),\n/* harmony export */   \"IdentifyImage\": () => (/* reexport safe */ _Tasks_IdentifyImage__WEBPACK_IMPORTED_MODULE_10__.IdentifyImage),\n/* harmony export */   \"ImageMapLayer\": () => (/* reexport safe */ _Layers_ImageMapLayer__WEBPACK_IMPORTED_MODULE_18__.ImageMapLayer),\n/* harmony export */   \"ImageService\": () => (/* reexport safe */ _Services_ImageService__WEBPACK_IMPORTED_MODULE_13__.ImageService),\n/* harmony export */   \"MapService\": () => (/* reexport safe */ _Services_MapService__WEBPACK_IMPORTED_MODULE_12__.MapService),\n/* harmony export */   \"Query\": () => (/* reexport safe */ _Tasks_Query__WEBPACK_IMPORTED_MODULE_6__.Query),\n/* harmony export */   \"RasterLayer\": () => (/* reexport safe */ _Layers_RasterLayer__WEBPACK_IMPORTED_MODULE_17__.RasterLayer),\n/* harmony export */   \"Service\": () => (/* reexport safe */ _Services_Service__WEBPACK_IMPORTED_MODULE_11__.Service),\n/* harmony export */   \"Support\": () => (/* reexport safe */ _Support__WEBPACK_IMPORTED_MODULE_1__.Support),\n/* harmony export */   \"Task\": () => (/* reexport safe */ _Tasks_Task__WEBPACK_IMPORTED_MODULE_5__.Task),\n/* harmony export */   \"TiledMapLayer\": () => (/* reexport safe */ _Layers_TiledMapLayer__WEBPACK_IMPORTED_MODULE_16__.TiledMapLayer),\n/* harmony export */   \"Util\": () => (/* reexport safe */ _Util__WEBPACK_IMPORTED_MODULE_3__.EsriUtil),\n/* harmony export */   \"VERSION\": () => (/* binding */ version),\n/* harmony export */   \"basemapLayer\": () => (/* reexport safe */ _Layers_BasemapLayer__WEBPACK_IMPORTED_MODULE_15__.basemapLayer),\n/* harmony export */   \"dynamicMapLayer\": () => (/* reexport safe */ _Layers_DynamicMapLayer__WEBPACK_IMPORTED_MODULE_19__.dynamicMapLayer),\n/* harmony export */   \"featureLayer\": () => (/* reexport safe */ _Layers_FeatureLayer_FeatureLayer__WEBPACK_IMPORTED_MODULE_21__.featureLayer),\n/* harmony export */   \"featureLayerService\": () => (/* reexport safe */ _Services_FeatureLayerService__WEBPACK_IMPORTED_MODULE_14__.featureLayerService),\n/* harmony export */   \"find\": () => (/* reexport safe */ _Tasks_Find__WEBPACK_IMPORTED_MODULE_7__.find),\n/* harmony export */   \"get\": () => (/* reexport safe */ _Request__WEBPACK_IMPORTED_MODULE_4__.get),\n/* harmony export */   \"identify\": () => (/* reexport safe */ _Tasks_Identify__WEBPACK_IMPORTED_MODULE_8__.identify),\n/* harmony export */   \"identifyFeatures\": () => (/* reexport safe */ _Tasks_IdentifyFeatures__WEBPACK_IMPORTED_MODULE_9__.identifyFeatures),\n/* harmony export */   \"identifyImage\": () => (/* reexport safe */ _Tasks_IdentifyImage__WEBPACK_IMPORTED_MODULE_10__.identifyImage),\n/* harmony export */   \"imageMapLayer\": () => (/* reexport safe */ _Layers_ImageMapLayer__WEBPACK_IMPORTED_MODULE_18__.imageMapLayer),\n/* harmony export */   \"imageService\": () => (/* reexport safe */ _Services_ImageService__WEBPACK_IMPORTED_MODULE_13__.imageService),\n/* harmony export */   \"mapService\": () => (/* reexport safe */ _Services_MapService__WEBPACK_IMPORTED_MODULE_12__.mapService),\n/* harmony export */   \"options\": () => (/* reexport safe */ _Options__WEBPACK_IMPORTED_MODULE_2__.options),\n/* harmony export */   \"post\": () => (/* reexport safe */ _Request__WEBPACK_IMPORTED_MODULE_4__.post),\n/* harmony export */   \"query\": () => (/* reexport safe */ _Tasks_Query__WEBPACK_IMPORTED_MODULE_6__.query),\n/* harmony export */   \"request\": () => (/* reexport safe */ _Request__WEBPACK_IMPORTED_MODULE_4__.request),\n/* harmony export */   \"service\": () => (/* reexport safe */ _Services_Service__WEBPACK_IMPORTED_MODULE_11__.service),\n/* harmony export */   \"task\": () => (/* reexport safe */ _Tasks_Task__WEBPACK_IMPORTED_MODULE_5__.task),\n/* harmony export */   \"tiledMapLayer\": () => (/* reexport safe */ _Layers_TiledMapLayer__WEBPACK_IMPORTED_MODULE_16__.tiledMapLayer)\n/* harmony export */ });\n/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../package.json */ \"./node_modules/esri-leaflet/package.json\");\n/* harmony import */ var _Support__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Support */ \"./node_modules/esri-leaflet/src/Support.js\");\n/* harmony import */ var _Options__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Options */ \"./node_modules/esri-leaflet/src/Options.js\");\n/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Util */ \"./node_modules/esri-leaflet/src/Util.js\");\n/* harmony import */ var _Request__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Request */ \"./node_modules/esri-leaflet/src/Request.js\");\n/* harmony import */ var _Tasks_Task__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Tasks/Task */ \"./node_modules/esri-leaflet/src/Tasks/Task.js\");\n/* harmony import */ var _Tasks_Query__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Tasks/Query */ \"./node_modules/esri-leaflet/src/Tasks/Query.js\");\n/* harmony import */ var _Tasks_Find__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Tasks/Find */ \"./node_modules/esri-leaflet/src/Tasks/Find.js\");\n/* harmony import */ var _Tasks_Identify__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Tasks/Identify */ \"./node_modules/esri-leaflet/src/Tasks/Identify.js\");\n/* harmony import */ var _Tasks_IdentifyFeatures__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Tasks/IdentifyFeatures */ \"./node_modules/esri-leaflet/src/Tasks/IdentifyFeatures.js\");\n/* harmony import */ var _Tasks_IdentifyImage__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Tasks/IdentifyImage */ \"./node_modules/esri-leaflet/src/Tasks/IdentifyImage.js\");\n/* harmony import */ var _Services_Service__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Services/Service */ \"./node_modules/esri-leaflet/src/Services/Service.js\");\n/* harmony import */ var _Services_MapService__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Services/MapService */ \"./node_modules/esri-leaflet/src/Services/MapService.js\");\n/* harmony import */ var _Services_ImageService__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Services/ImageService */ \"./node_modules/esri-leaflet/src/Services/ImageService.js\");\n/* harmony import */ var _Services_FeatureLayerService__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Services/FeatureLayerService */ \"./node_modules/esri-leaflet/src/Services/FeatureLayerService.js\");\n/* harmony import */ var _Layers_BasemapLayer__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./Layers/BasemapLayer */ \"./node_modules/esri-leaflet/src/Layers/BasemapLayer.js\");\n/* harmony import */ var _Layers_TiledMapLayer__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./Layers/TiledMapLayer */ \"./node_modules/esri-leaflet/src/Layers/TiledMapLayer.js\");\n/* harmony import */ var _Layers_RasterLayer__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./Layers/RasterLayer */ \"./node_modules/esri-leaflet/src/Layers/RasterLayer.js\");\n/* harmony import */ var _Layers_ImageMapLayer__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./Layers/ImageMapLayer */ \"./node_modules/esri-leaflet/src/Layers/ImageMapLayer.js\");\n/* harmony import */ var _Layers_DynamicMapLayer__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./Layers/DynamicMapLayer */ \"./node_modules/esri-leaflet/src/Layers/DynamicMapLayer.js\");\n/* harmony import */ var _Layers_FeatureLayer_FeatureManager__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./Layers/FeatureLayer/FeatureManager */ \"./node_modules/esri-leaflet/src/Layers/FeatureLayer/FeatureManager.js\");\n/* harmony import */ var _Layers_FeatureLayer_FeatureLayer__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./Layers/FeatureLayer/FeatureLayer */ \"./node_modules/esri-leaflet/src/Layers/FeatureLayer/FeatureLayer.js\");\n// export version\r\n\r\nvar version = _package_json__WEBPACK_IMPORTED_MODULE_0__.version;\r\n\r\n\r\n// import base\r\n\r\n\r\n\r\n\r\n\r\n// export tasks\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// export services\r\n\r\n\r\n\r\n\r\n\r\n// export layers\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXNyaS1sZWFmbGV0L3NyYy9Fc3JpTGVhZmxldC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDMEM7QUFDMUMsY0FBYyxrREFBbUI7QUFDSDtBQUM5QjtBQUNBO0FBQ29DO0FBQ0E7QUFDTTtBQUNLO0FBQy9DO0FBQ0E7QUFDMEM7QUFDRztBQUNIO0FBQ1k7QUFDd0I7QUFDVDtBQUNyRTtBQUNBO0FBQ3NEO0FBQ1M7QUFDTTtBQUNxQjtBQUMxRjtBQUNBO0FBQ21FO0FBQ0c7QUFDbkI7QUFDbUI7QUFDTTtBQUNOO0FBQ1UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXNyaS1sZWFmbGV0L3NyYy9Fc3JpTGVhZmxldC5qcz9jM2MzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4cG9ydCB2ZXJzaW9uXHJcbmltcG9ydCBwYWNrYWdlSW5mbyBmcm9tICcuLi9wYWNrYWdlLmpzb24nO1xyXG52YXIgdmVyc2lvbiA9IHBhY2thZ2VJbmZvLnZlcnNpb247XHJcbmV4cG9ydCB7IHZlcnNpb24gYXMgVkVSU0lPTiB9O1xyXG5cclxuLy8gaW1wb3J0IGJhc2VcclxuZXhwb3J0IHsgU3VwcG9ydCB9IGZyb20gJy4vU3VwcG9ydCc7XHJcbmV4cG9ydCB7IG9wdGlvbnMgfSBmcm9tICcuL09wdGlvbnMnO1xyXG5leHBvcnQgeyBFc3JpVXRpbCBhcyBVdGlsIH0gZnJvbSAnLi9VdGlsJztcclxuZXhwb3J0IHsgZ2V0LCBwb3N0LCByZXF1ZXN0IH0gZnJvbSAnLi9SZXF1ZXN0JztcclxuXHJcbi8vIGV4cG9ydCB0YXNrc1xyXG5leHBvcnQgeyBUYXNrLCB0YXNrIH0gZnJvbSAnLi9UYXNrcy9UYXNrJztcclxuZXhwb3J0IHsgUXVlcnksIHF1ZXJ5IH0gZnJvbSAnLi9UYXNrcy9RdWVyeSc7XHJcbmV4cG9ydCB7IEZpbmQsIGZpbmQgfSBmcm9tICcuL1Rhc2tzL0ZpbmQnO1xyXG5leHBvcnQgeyBJZGVudGlmeSwgaWRlbnRpZnkgfSBmcm9tICcuL1Rhc2tzL0lkZW50aWZ5JztcclxuZXhwb3J0IHsgSWRlbnRpZnlGZWF0dXJlcywgaWRlbnRpZnlGZWF0dXJlcyB9IGZyb20gJy4vVGFza3MvSWRlbnRpZnlGZWF0dXJlcyc7XHJcbmV4cG9ydCB7IElkZW50aWZ5SW1hZ2UsIGlkZW50aWZ5SW1hZ2UgfSBmcm9tICcuL1Rhc2tzL0lkZW50aWZ5SW1hZ2UnO1xyXG5cclxuLy8gZXhwb3J0IHNlcnZpY2VzXHJcbmV4cG9ydCB7IFNlcnZpY2UsIHNlcnZpY2UgfSBmcm9tICcuL1NlcnZpY2VzL1NlcnZpY2UnO1xyXG5leHBvcnQgeyBNYXBTZXJ2aWNlLCBtYXBTZXJ2aWNlIH0gZnJvbSAnLi9TZXJ2aWNlcy9NYXBTZXJ2aWNlJztcclxuZXhwb3J0IHsgSW1hZ2VTZXJ2aWNlLCBpbWFnZVNlcnZpY2UgfSBmcm9tICcuL1NlcnZpY2VzL0ltYWdlU2VydmljZSc7XHJcbmV4cG9ydCB7IEZlYXR1cmVMYXllclNlcnZpY2UsIGZlYXR1cmVMYXllclNlcnZpY2UgfSBmcm9tICcuL1NlcnZpY2VzL0ZlYXR1cmVMYXllclNlcnZpY2UnO1xyXG5cclxuLy8gZXhwb3J0IGxheWVyc1xyXG5leHBvcnQgeyBCYXNlbWFwTGF5ZXIsIGJhc2VtYXBMYXllciB9IGZyb20gJy4vTGF5ZXJzL0Jhc2VtYXBMYXllcic7XHJcbmV4cG9ydCB7IFRpbGVkTWFwTGF5ZXIsIHRpbGVkTWFwTGF5ZXIgfSBmcm9tICcuL0xheWVycy9UaWxlZE1hcExheWVyJztcclxuZXhwb3J0IHsgUmFzdGVyTGF5ZXIgfSBmcm9tICcuL0xheWVycy9SYXN0ZXJMYXllcic7XHJcbmV4cG9ydCB7IEltYWdlTWFwTGF5ZXIsIGltYWdlTWFwTGF5ZXIgfSBmcm9tICcuL0xheWVycy9JbWFnZU1hcExheWVyJztcclxuZXhwb3J0IHsgRHluYW1pY01hcExheWVyLCBkeW5hbWljTWFwTGF5ZXIgfSBmcm9tICcuL0xheWVycy9EeW5hbWljTWFwTGF5ZXInO1xyXG5leHBvcnQgeyBGZWF0dXJlTWFuYWdlciB9IGZyb20gJy4vTGF5ZXJzL0ZlYXR1cmVMYXllci9GZWF0dXJlTWFuYWdlcic7XHJcbmV4cG9ydCB7IEZlYXR1cmVMYXllciwgZmVhdHVyZUxheWVyIH0gZnJvbSAnLi9MYXllcnMvRmVhdHVyZUxheWVyL0ZlYXR1cmVMYXllcic7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/esri-leaflet/src/EsriLeaflet.js\n");

/***/ }),

/***/ "./node_modules/esri-leaflet/src/Layers/BasemapLayer.js":
/*!**************************************************************!*\
  !*** ./node_modules/esri-leaflet/src/Layers/BasemapLayer.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BasemapLayer\": () => (/* binding */ BasemapLayer),\n/* harmony export */   \"basemapLayer\": () => (/* binding */ basemapLayer),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! leaflet */ \"./node_modules/leaflet/dist/leaflet-src.js\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Support__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Support */ \"./node_modules/esri-leaflet/src/Support.js\");\n/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Util */ \"./node_modules/esri-leaflet/src/Util.js\");\n\r\n\r\n\r\n\r\nvar tileProtocol = (window.location.protocol !== 'https:') ? 'http:' : 'https:';\r\n\r\nvar BasemapLayer = leaflet__WEBPACK_IMPORTED_MODULE_0__.TileLayer.extend({\r\n  statics: {\r\n    TILES: {\r\n      Streets: {\r\n        urlTemplate: tileProtocol + '//{s}.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}',\r\n        options: {\r\n          minZoom: 1,\r\n          maxZoom: 19,\r\n          subdomains: ['server', 'services'],\r\n          attribution: 'USGS, NOAA',\r\n          attributionUrl: 'https://static.arcgis.com/attribution/World_Street_Map'\r\n        }\r\n      },\r\n      Topographic: {\r\n        urlTemplate: tileProtocol + '//{s}.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}',\r\n        options: {\r\n          minZoom: 1,\r\n          maxZoom: 19,\r\n          subdomains: ['server', 'services'],\r\n          attribution: 'USGS, NOAA',\r\n          attributionUrl: 'https://static.arcgis.com/attribution/World_Topo_Map'\r\n        }\r\n      },\r\n      Oceans: {\r\n        urlTemplate: tileProtocol + '//{s}.arcgisonline.com/arcgis/rest/services/Ocean/World_Ocean_Base/MapServer/tile/{z}/{y}/{x}',\r\n        options: {\r\n          minZoom: 1,\r\n          maxZoom: 16,\r\n          subdomains: ['server', 'services'],\r\n          attribution: 'USGS, NOAA',\r\n          attributionUrl: 'https://static.arcgis.com/attribution/Ocean_Basemap'\r\n        }\r\n      },\r\n      OceansLabels: {\r\n        urlTemplate: tileProtocol + '//{s}.arcgisonline.com/arcgis/rest/services/Ocean/World_Ocean_Reference/MapServer/tile/{z}/{y}/{x}',\r\n        options: {\r\n          minZoom: 1,\r\n          maxZoom: 16,\r\n          subdomains: ['server', 'services'],\r\n          pane: (_Support__WEBPACK_IMPORTED_MODULE_1__.pointerEvents) ? 'esri-labels' : 'tilePane',\r\n          attribution: ''\r\n        }\r\n      },\r\n      NationalGeographic: {\r\n        urlTemplate: tileProtocol + '//{s}.arcgisonline.com/ArcGIS/rest/services/NatGeo_World_Map/MapServer/tile/{z}/{y}/{x}',\r\n        options: {\r\n          minZoom: 1,\r\n          maxZoom: 16,\r\n          subdomains: ['server', 'services'],\r\n          attribution: 'National Geographic, DeLorme, HERE, UNEP-WCMC, USGS, NASA, ESA, METI, NRCAN, GEBCO, NOAA, increment P Corp.'\r\n        }\r\n      },\r\n      DarkGray: {\r\n        urlTemplate: tileProtocol + '//{s}.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Dark_Gray_Base/MapServer/tile/{z}/{y}/{x}',\r\n        options: {\r\n          minZoom: 1,\r\n          maxZoom: 16,\r\n          subdomains: ['server', 'services'],\r\n          attribution: 'HERE, DeLorme, MapmyIndia, &copy; OpenStreetMap contributors'\r\n        }\r\n      },\r\n      DarkGrayLabels: {\r\n        urlTemplate: tileProtocol + '//{s}.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Dark_Gray_Reference/MapServer/tile/{z}/{y}/{x}',\r\n        options: {\r\n          minZoom: 1,\r\n          maxZoom: 16,\r\n          subdomains: ['server', 'services'],\r\n          pane: (_Support__WEBPACK_IMPORTED_MODULE_1__.pointerEvents) ? 'esri-labels' : 'tilePane',\r\n          attribution: ''\r\n\r\n        }\r\n      },\r\n      Gray: {\r\n        urlTemplate: tileProtocol + '//{s}.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Base/MapServer/tile/{z}/{y}/{x}',\r\n        options: {\r\n          minZoom: 1,\r\n          maxZoom: 16,\r\n          subdomains: ['server', 'services'],\r\n          attribution: 'HERE, DeLorme, MapmyIndia, &copy; OpenStreetMap contributors'\r\n        }\r\n      },\r\n      GrayLabels: {\r\n        urlTemplate: tileProtocol + '//{s}.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Reference/MapServer/tile/{z}/{y}/{x}',\r\n        options: {\r\n          minZoom: 1,\r\n          maxZoom: 16,\r\n          subdomains: ['server', 'services'],\r\n          pane: (_Support__WEBPACK_IMPORTED_MODULE_1__.pointerEvents) ? 'esri-labels' : 'tilePane',\r\n          attribution: ''\r\n        }\r\n      },\r\n      Imagery: {\r\n        urlTemplate: tileProtocol + '//{s}.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',\r\n        options: {\r\n          minZoom: 1,\r\n          maxZoom: 19,\r\n          subdomains: ['server', 'services'],\r\n          attribution: 'DigitalGlobe, GeoEye, i-cubed, USDA, USGS, AEX, Getmapping, Aerogrid, IGN, IGP, swisstopo, and the GIS User Community',\r\n          attributionUrl: 'https://static.arcgis.com/attribution/World_Imagery'\r\n        }\r\n      },\r\n      ImageryLabels: {\r\n        urlTemplate: tileProtocol + '//{s}.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}',\r\n        options: {\r\n          minZoom: 1,\r\n          maxZoom: 19,\r\n          subdomains: ['server', 'services'],\r\n          pane: (_Support__WEBPACK_IMPORTED_MODULE_1__.pointerEvents) ? 'esri-labels' : 'tilePane',\r\n          attribution: ''\r\n        }\r\n      },\r\n      ImageryTransportation: {\r\n        urlTemplate: tileProtocol + '//{s}.arcgisonline.com/ArcGIS/rest/services/Reference/World_Transportation/MapServer/tile/{z}/{y}/{x}',\r\n        options: {\r\n          minZoom: 1,\r\n          maxZoom: 19,\r\n          subdomains: ['server', 'services'],\r\n          pane: (_Support__WEBPACK_IMPORTED_MODULE_1__.pointerEvents) ? 'esri-labels' : 'tilePane',\r\n          attribution: ''\r\n        }\r\n      },\r\n      ShadedRelief: {\r\n        urlTemplate: tileProtocol + '//{s}.arcgisonline.com/ArcGIS/rest/services/World_Shaded_Relief/MapServer/tile/{z}/{y}/{x}',\r\n        options: {\r\n          minZoom: 1,\r\n          maxZoom: 13,\r\n          subdomains: ['server', 'services'],\r\n          attribution: 'USGS'\r\n        }\r\n      },\r\n      ShadedReliefLabels: {\r\n        urlTemplate: tileProtocol + '//{s}.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places_Alternate/MapServer/tile/{z}/{y}/{x}',\r\n        options: {\r\n          minZoom: 1,\r\n          maxZoom: 12,\r\n          subdomains: ['server', 'services'],\r\n          pane: (_Support__WEBPACK_IMPORTED_MODULE_1__.pointerEvents) ? 'esri-labels' : 'tilePane',\r\n          attribution: ''\r\n        }\r\n      },\r\n      Terrain: {\r\n        urlTemplate: tileProtocol + '//{s}.arcgisonline.com/ArcGIS/rest/services/World_Terrain_Base/MapServer/tile/{z}/{y}/{x}',\r\n        options: {\r\n          minZoom: 1,\r\n          maxZoom: 13,\r\n          subdomains: ['server', 'services'],\r\n          attribution: 'USGS, NOAA'\r\n        }\r\n      },\r\n      TerrainLabels: {\r\n        urlTemplate: tileProtocol + '//{s}.arcgisonline.com/ArcGIS/rest/services/Reference/World_Reference_Overlay/MapServer/tile/{z}/{y}/{x}',\r\n        options: {\r\n          minZoom: 1,\r\n          maxZoom: 13,\r\n          subdomains: ['server', 'services'],\r\n          pane: (_Support__WEBPACK_IMPORTED_MODULE_1__.pointerEvents) ? 'esri-labels' : 'tilePane',\r\n          attribution: ''\r\n        }\r\n      },\r\n      USATopo: {\r\n        urlTemplate: tileProtocol + '//{s}.arcgisonline.com/ArcGIS/rest/services/USA_Topo_Maps/MapServer/tile/{z}/{y}/{x}',\r\n        options: {\r\n          minZoom: 1,\r\n          maxZoom: 15,\r\n          subdomains: ['server', 'services'],\r\n          attribution: 'USGS, National Geographic Society, i-cubed'\r\n        }\r\n      },\r\n      ImageryClarity: {\r\n        urlTemplate: tileProtocol + '//clarity.maptiles.arcgis.com/arcgis/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',\r\n        options: {\r\n          minZoom: 1,\r\n          maxZoom: 19,\r\n          attribution: 'Esri, DigitalGlobe, GeoEye, Earthstar Geographics, CNES/Airbus DS, USDA, USGS, AeroGRID, IGN, and the GIS User Community'\r\n        }\r\n      },\r\n      Physical: {\r\n        urlTemplate: tileProtocol + '//{s}.arcgisonline.com/arcgis/rest/services/World_Physical_Map/MapServer/tile/{z}/{y}/{x}',\r\n        options: {\r\n          minZoom: 1,\r\n          maxZoom: 8,\r\n          subdomains: ['server', 'services'],\r\n          attribution: 'U.S. National Park Service'\r\n        }\r\n      },\r\n      ImageryFirefly: {\r\n        urlTemplate: tileProtocol + '//fly.maptiles.arcgis.com/arcgis/rest/services/World_Imagery_Firefly/MapServer/tile/{z}/{y}/{x}',\r\n        options: {\r\n          minZoom: 1,\r\n          maxZoom: 19,\r\n          attribution: 'Esri, DigitalGlobe, GeoEye, Earthstar Geographics, CNES/Airbus DS, USDA, USGS, AeroGRID, IGN, and the GIS User Community',\r\n          attributionUrl: 'https://static.arcgis.com/attribution/World_Imagery'\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  initialize: function (key, options) {\r\n    var config;\r\n\r\n    // set the config variable with the appropriate config object\r\n    if (typeof key === 'object' && key.urlTemplate && key.options) {\r\n      config = key;\r\n    } else if (typeof key === 'string' && BasemapLayer.TILES[key]) {\r\n      config = BasemapLayer.TILES[key];\r\n    } else {\r\n      throw new Error('L.esri.BasemapLayer: Invalid parameter. Use one of \"Streets\", \"Topographic\", \"Oceans\", \"OceansLabels\", \"NationalGeographic\", \"Physical\", \"Gray\", \"GrayLabels\", \"DarkGray\", \"DarkGrayLabels\", \"Imagery\", \"ImageryLabels\", \"ImageryTransportation\", \"ImageryClarity\", \"ImageryFirefly\", ShadedRelief\", \"ShadedReliefLabels\", \"Terrain\", \"TerrainLabels\" or \"USATopo\"');\r\n    }\r\n\r\n    // merge passed options into the config options\r\n    var tileOptions = leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.extend(config.options, options);\r\n\r\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.setOptions(this, tileOptions);\r\n\r\n    // Deprecation notice:\r\n    if (!this.options.ignoreDeprecationWarning) {\r\n      console.warn('WARNING: L.esri.BasemapLayer uses data services that are in mature support and are not being updated. Please use L.esri.Vector.vectorBasemapLayer instead. More info: https://esriurl.com/esri-leaflet-basemap');\r\n    }\r\n\r\n    if (this.options.token && config.urlTemplate.indexOf('token=') === -1) {\r\n      config.urlTemplate += ('?token=' + this.options.token);\r\n    }\r\n    if (this.options.proxy) {\r\n      config.urlTemplate = this.options.proxy + '?' + config.urlTemplate;\r\n    }\r\n\r\n    // call the initialize method on L.TileLayer to set everything up\r\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.TileLayer.prototype.initialize.call(this, config.urlTemplate, tileOptions);\r\n  },\r\n\r\n  onAdd: function (map) {\r\n    // include 'Powered by Esri' in map attribution\r\n    (0,_Util__WEBPACK_IMPORTED_MODULE_2__.setEsriAttribution)(map);\r\n\r\n    if (this.options.pane === 'esri-labels') {\r\n      this._initPane();\r\n    }\r\n    // some basemaps can supply dynamic attribution\r\n    if (this.options.attributionUrl) {\r\n      (0,_Util__WEBPACK_IMPORTED_MODULE_2__._getAttributionData)((this.options.proxy ? this.options.proxy + '?' : '') + this.options.attributionUrl, map);\r\n    }\r\n\r\n    map.on('moveend', _Util__WEBPACK_IMPORTED_MODULE_2__._updateMapAttribution);\r\n\r\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.TileLayer.prototype.onAdd.call(this, map);\r\n  },\r\n\r\n  onRemove: function (map) {\r\n    (0,_Util__WEBPACK_IMPORTED_MODULE_2__.removeEsriAttribution)(map);\r\n\r\n    map.off('moveend', _Util__WEBPACK_IMPORTED_MODULE_2__._updateMapAttribution);\r\n\r\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.TileLayer.prototype.onRemove.call(this, map);\r\n  },\r\n\r\n  _initPane: function () {\r\n    if (!this._map.getPane(this.options.pane)) {\r\n      var pane = this._map.createPane(this.options.pane);\r\n      pane.style.pointerEvents = 'none';\r\n      pane.style.zIndex = 500;\r\n    }\r\n  },\r\n\r\n  getAttribution: function () {\r\n    if (this.options.attribution) {\r\n      var attribution = '<span class=\"esri-dynamic-attribution\">' + this.options.attribution + '</span>';\r\n    }\r\n    return attribution;\r\n  }\r\n});\r\n\r\nfunction basemapLayer (key, options) {\r\n  return new BasemapLayer(key, options);\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (basemapLayer);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXNyaS1sZWFmbGV0L3NyYy9MYXllcnMvQmFzZW1hcExheWVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBMEM7QUFDQztBQU0xQjtBQUNqQjtBQUNBO0FBQ0E7QUFDTyxtQkFBbUIscURBQWdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxFQUFFLHdFQUF3RSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSx3Q0FBd0MsRUFBRSxzRUFBc0UsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esd0NBQXdDLEVBQUUsOEVBQThFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRTtBQUNsSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHdDQUF3QyxFQUFFLG1GQUFtRixFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7QUFDdkk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbURBQWE7QUFDOUI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHdDQUF3QyxFQUFFLHdFQUF3RSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esd0NBQXdDLEVBQUUsbUZBQW1GLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRTtBQUN2STtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBLE9BQU87QUFDUDtBQUNBLHdDQUF3QyxFQUFFLHdGQUF3RixFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7QUFDNUk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbURBQWE7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esd0NBQXdDLEVBQUUsb0ZBQW9GLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRTtBQUN4STtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBLE9BQU87QUFDUDtBQUNBLHdDQUF3QyxFQUFFLHlGQUF5RixFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7QUFDN0k7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbURBQWE7QUFDOUI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHdDQUF3QyxFQUFFLHFFQUFxRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSx3Q0FBd0MsRUFBRSw2RkFBNkYsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFO0FBQ2pKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1EQUFhO0FBQzlCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSx3Q0FBd0MsRUFBRSxzRkFBc0YsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFO0FBQzFJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1EQUFhO0FBQzlCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSx3Q0FBd0MsRUFBRSwyRUFBMkUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHdDQUF3QyxFQUFFLHVHQUF1RyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7QUFDM0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbURBQWE7QUFDOUI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHdDQUF3QyxFQUFFLDBFQUEwRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esd0NBQXdDLEVBQUUseUZBQXlGLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRTtBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtREFBYTtBQUM5QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esd0NBQXdDLEVBQUUscUVBQXFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRTtBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxzSEFBc0gsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSx3Q0FBd0MsRUFBRSwwRUFBMEUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDBIQUEwSCxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7QUFDcEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnREFBVztBQUNqQztBQUNBLElBQUksb0RBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksd0VBQW1DO0FBQ3ZDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFJLHlEQUFrQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDBEQUFtQjtBQUN6QjtBQUNBO0FBQ0Esc0JBQXNCLHdEQUFxQjtBQUMzQztBQUNBLElBQUksbUVBQThCO0FBQ2xDLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSSw0REFBcUI7QUFDekI7QUFDQSx1QkFBdUIsd0RBQXFCO0FBQzVDO0FBQ0EsSUFBSSxzRUFBaUM7QUFDckMsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxZQUFZLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXNyaS1sZWFmbGV0L3NyYy9MYXllcnMvQmFzZW1hcExheWVyLmpzPzE5YmEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVGlsZUxheWVyLCBVdGlsIH0gZnJvbSAnbGVhZmxldCc7XHJcbmltcG9ydCB7IHBvaW50ZXJFdmVudHMgfSBmcm9tICcuLi9TdXBwb3J0JztcclxuaW1wb3J0IHtcclxuICBzZXRFc3JpQXR0cmlidXRpb24sXHJcbiAgcmVtb3ZlRXNyaUF0dHJpYnV0aW9uLFxyXG4gIF9nZXRBdHRyaWJ1dGlvbkRhdGEsXHJcbiAgX3VwZGF0ZU1hcEF0dHJpYnV0aW9uXHJcbn0gZnJvbSAnLi4vVXRpbCc7XHJcblxyXG52YXIgdGlsZVByb3RvY29sID0gKHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCAhPT0gJ2h0dHBzOicpID8gJ2h0dHA6JyA6ICdodHRwczonO1xyXG5cclxuZXhwb3J0IHZhciBCYXNlbWFwTGF5ZXIgPSBUaWxlTGF5ZXIuZXh0ZW5kKHtcclxuICBzdGF0aWNzOiB7XHJcbiAgICBUSUxFUzoge1xyXG4gICAgICBTdHJlZXRzOiB7XHJcbiAgICAgICAgdXJsVGVtcGxhdGU6IHRpbGVQcm90b2NvbCArICcvL3tzfS5hcmNnaXNvbmxpbmUuY29tL0FyY0dJUy9yZXN0L3NlcnZpY2VzL1dvcmxkX1N0cmVldF9NYXAvTWFwU2VydmVyL3RpbGUve3p9L3t5fS97eH0nLFxyXG4gICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgIG1pblpvb206IDEsXHJcbiAgICAgICAgICBtYXhab29tOiAxOSxcclxuICAgICAgICAgIHN1YmRvbWFpbnM6IFsnc2VydmVyJywgJ3NlcnZpY2VzJ10sXHJcbiAgICAgICAgICBhdHRyaWJ1dGlvbjogJ1VTR1MsIE5PQUEnLFxyXG4gICAgICAgICAgYXR0cmlidXRpb25Vcmw6ICdodHRwczovL3N0YXRpYy5hcmNnaXMuY29tL2F0dHJpYnV0aW9uL1dvcmxkX1N0cmVldF9NYXAnXHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBUb3BvZ3JhcGhpYzoge1xyXG4gICAgICAgIHVybFRlbXBsYXRlOiB0aWxlUHJvdG9jb2wgKyAnLy97c30uYXJjZ2lzb25saW5lLmNvbS9BcmNHSVMvcmVzdC9zZXJ2aWNlcy9Xb3JsZF9Ub3BvX01hcC9NYXBTZXJ2ZXIvdGlsZS97en0ve3l9L3t4fScsXHJcbiAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgbWluWm9vbTogMSxcclxuICAgICAgICAgIG1heFpvb206IDE5LFxyXG4gICAgICAgICAgc3ViZG9tYWluczogWydzZXJ2ZXInLCAnc2VydmljZXMnXSxcclxuICAgICAgICAgIGF0dHJpYnV0aW9uOiAnVVNHUywgTk9BQScsXHJcbiAgICAgICAgICBhdHRyaWJ1dGlvblVybDogJ2h0dHBzOi8vc3RhdGljLmFyY2dpcy5jb20vYXR0cmlidXRpb24vV29ybGRfVG9wb19NYXAnXHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBPY2VhbnM6IHtcclxuICAgICAgICB1cmxUZW1wbGF0ZTogdGlsZVByb3RvY29sICsgJy8ve3N9LmFyY2dpc29ubGluZS5jb20vYXJjZ2lzL3Jlc3Qvc2VydmljZXMvT2NlYW4vV29ybGRfT2NlYW5fQmFzZS9NYXBTZXJ2ZXIvdGlsZS97en0ve3l9L3t4fScsXHJcbiAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgbWluWm9vbTogMSxcclxuICAgICAgICAgIG1heFpvb206IDE2LFxyXG4gICAgICAgICAgc3ViZG9tYWluczogWydzZXJ2ZXInLCAnc2VydmljZXMnXSxcclxuICAgICAgICAgIGF0dHJpYnV0aW9uOiAnVVNHUywgTk9BQScsXHJcbiAgICAgICAgICBhdHRyaWJ1dGlvblVybDogJ2h0dHBzOi8vc3RhdGljLmFyY2dpcy5jb20vYXR0cmlidXRpb24vT2NlYW5fQmFzZW1hcCdcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIE9jZWFuc0xhYmVsczoge1xyXG4gICAgICAgIHVybFRlbXBsYXRlOiB0aWxlUHJvdG9jb2wgKyAnLy97c30uYXJjZ2lzb25saW5lLmNvbS9hcmNnaXMvcmVzdC9zZXJ2aWNlcy9PY2Vhbi9Xb3JsZF9PY2Vhbl9SZWZlcmVuY2UvTWFwU2VydmVyL3RpbGUve3p9L3t5fS97eH0nLFxyXG4gICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgIG1pblpvb206IDEsXHJcbiAgICAgICAgICBtYXhab29tOiAxNixcclxuICAgICAgICAgIHN1YmRvbWFpbnM6IFsnc2VydmVyJywgJ3NlcnZpY2VzJ10sXHJcbiAgICAgICAgICBwYW5lOiAocG9pbnRlckV2ZW50cykgPyAnZXNyaS1sYWJlbHMnIDogJ3RpbGVQYW5lJyxcclxuICAgICAgICAgIGF0dHJpYnV0aW9uOiAnJ1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgTmF0aW9uYWxHZW9ncmFwaGljOiB7XHJcbiAgICAgICAgdXJsVGVtcGxhdGU6IHRpbGVQcm90b2NvbCArICcvL3tzfS5hcmNnaXNvbmxpbmUuY29tL0FyY0dJUy9yZXN0L3NlcnZpY2VzL05hdEdlb19Xb3JsZF9NYXAvTWFwU2VydmVyL3RpbGUve3p9L3t5fS97eH0nLFxyXG4gICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgIG1pblpvb206IDEsXHJcbiAgICAgICAgICBtYXhab29tOiAxNixcclxuICAgICAgICAgIHN1YmRvbWFpbnM6IFsnc2VydmVyJywgJ3NlcnZpY2VzJ10sXHJcbiAgICAgICAgICBhdHRyaWJ1dGlvbjogJ05hdGlvbmFsIEdlb2dyYXBoaWMsIERlTG9ybWUsIEhFUkUsIFVORVAtV0NNQywgVVNHUywgTkFTQSwgRVNBLCBNRVRJLCBOUkNBTiwgR0VCQ08sIE5PQUEsIGluY3JlbWVudCBQIENvcnAuJ1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgRGFya0dyYXk6IHtcclxuICAgICAgICB1cmxUZW1wbGF0ZTogdGlsZVByb3RvY29sICsgJy8ve3N9LmFyY2dpc29ubGluZS5jb20vQXJjR0lTL3Jlc3Qvc2VydmljZXMvQ2FudmFzL1dvcmxkX0RhcmtfR3JheV9CYXNlL01hcFNlcnZlci90aWxlL3t6fS97eX0ve3h9JyxcclxuICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICBtaW5ab29tOiAxLFxyXG4gICAgICAgICAgbWF4Wm9vbTogMTYsXHJcbiAgICAgICAgICBzdWJkb21haW5zOiBbJ3NlcnZlcicsICdzZXJ2aWNlcyddLFxyXG4gICAgICAgICAgYXR0cmlidXRpb246ICdIRVJFLCBEZUxvcm1lLCBNYXBteUluZGlhLCAmY29weTsgT3BlblN0cmVldE1hcCBjb250cmlidXRvcnMnXHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBEYXJrR3JheUxhYmVsczoge1xyXG4gICAgICAgIHVybFRlbXBsYXRlOiB0aWxlUHJvdG9jb2wgKyAnLy97c30uYXJjZ2lzb25saW5lLmNvbS9BcmNHSVMvcmVzdC9zZXJ2aWNlcy9DYW52YXMvV29ybGRfRGFya19HcmF5X1JlZmVyZW5jZS9NYXBTZXJ2ZXIvdGlsZS97en0ve3l9L3t4fScsXHJcbiAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgbWluWm9vbTogMSxcclxuICAgICAgICAgIG1heFpvb206IDE2LFxyXG4gICAgICAgICAgc3ViZG9tYWluczogWydzZXJ2ZXInLCAnc2VydmljZXMnXSxcclxuICAgICAgICAgIHBhbmU6IChwb2ludGVyRXZlbnRzKSA/ICdlc3JpLWxhYmVscycgOiAndGlsZVBhbmUnLFxyXG4gICAgICAgICAgYXR0cmlidXRpb246ICcnXHJcblxyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgR3JheToge1xyXG4gICAgICAgIHVybFRlbXBsYXRlOiB0aWxlUHJvdG9jb2wgKyAnLy97c30uYXJjZ2lzb25saW5lLmNvbS9BcmNHSVMvcmVzdC9zZXJ2aWNlcy9DYW52YXMvV29ybGRfTGlnaHRfR3JheV9CYXNlL01hcFNlcnZlci90aWxlL3t6fS97eX0ve3h9JyxcclxuICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICBtaW5ab29tOiAxLFxyXG4gICAgICAgICAgbWF4Wm9vbTogMTYsXHJcbiAgICAgICAgICBzdWJkb21haW5zOiBbJ3NlcnZlcicsICdzZXJ2aWNlcyddLFxyXG4gICAgICAgICAgYXR0cmlidXRpb246ICdIRVJFLCBEZUxvcm1lLCBNYXBteUluZGlhLCAmY29weTsgT3BlblN0cmVldE1hcCBjb250cmlidXRvcnMnXHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBHcmF5TGFiZWxzOiB7XHJcbiAgICAgICAgdXJsVGVtcGxhdGU6IHRpbGVQcm90b2NvbCArICcvL3tzfS5hcmNnaXNvbmxpbmUuY29tL0FyY0dJUy9yZXN0L3NlcnZpY2VzL0NhbnZhcy9Xb3JsZF9MaWdodF9HcmF5X1JlZmVyZW5jZS9NYXBTZXJ2ZXIvdGlsZS97en0ve3l9L3t4fScsXHJcbiAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgbWluWm9vbTogMSxcclxuICAgICAgICAgIG1heFpvb206IDE2LFxyXG4gICAgICAgICAgc3ViZG9tYWluczogWydzZXJ2ZXInLCAnc2VydmljZXMnXSxcclxuICAgICAgICAgIHBhbmU6IChwb2ludGVyRXZlbnRzKSA/ICdlc3JpLWxhYmVscycgOiAndGlsZVBhbmUnLFxyXG4gICAgICAgICAgYXR0cmlidXRpb246ICcnXHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBJbWFnZXJ5OiB7XHJcbiAgICAgICAgdXJsVGVtcGxhdGU6IHRpbGVQcm90b2NvbCArICcvL3tzfS5hcmNnaXNvbmxpbmUuY29tL0FyY0dJUy9yZXN0L3NlcnZpY2VzL1dvcmxkX0ltYWdlcnkvTWFwU2VydmVyL3RpbGUve3p9L3t5fS97eH0nLFxyXG4gICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgIG1pblpvb206IDEsXHJcbiAgICAgICAgICBtYXhab29tOiAxOSxcclxuICAgICAgICAgIHN1YmRvbWFpbnM6IFsnc2VydmVyJywgJ3NlcnZpY2VzJ10sXHJcbiAgICAgICAgICBhdHRyaWJ1dGlvbjogJ0RpZ2l0YWxHbG9iZSwgR2VvRXllLCBpLWN1YmVkLCBVU0RBLCBVU0dTLCBBRVgsIEdldG1hcHBpbmcsIEFlcm9ncmlkLCBJR04sIElHUCwgc3dpc3N0b3BvLCBhbmQgdGhlIEdJUyBVc2VyIENvbW11bml0eScsXHJcbiAgICAgICAgICBhdHRyaWJ1dGlvblVybDogJ2h0dHBzOi8vc3RhdGljLmFyY2dpcy5jb20vYXR0cmlidXRpb24vV29ybGRfSW1hZ2VyeSdcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIEltYWdlcnlMYWJlbHM6IHtcclxuICAgICAgICB1cmxUZW1wbGF0ZTogdGlsZVByb3RvY29sICsgJy8ve3N9LmFyY2dpc29ubGluZS5jb20vQXJjR0lTL3Jlc3Qvc2VydmljZXMvUmVmZXJlbmNlL1dvcmxkX0JvdW5kYXJpZXNfYW5kX1BsYWNlcy9NYXBTZXJ2ZXIvdGlsZS97en0ve3l9L3t4fScsXHJcbiAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgbWluWm9vbTogMSxcclxuICAgICAgICAgIG1heFpvb206IDE5LFxyXG4gICAgICAgICAgc3ViZG9tYWluczogWydzZXJ2ZXInLCAnc2VydmljZXMnXSxcclxuICAgICAgICAgIHBhbmU6IChwb2ludGVyRXZlbnRzKSA/ICdlc3JpLWxhYmVscycgOiAndGlsZVBhbmUnLFxyXG4gICAgICAgICAgYXR0cmlidXRpb246ICcnXHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBJbWFnZXJ5VHJhbnNwb3J0YXRpb246IHtcclxuICAgICAgICB1cmxUZW1wbGF0ZTogdGlsZVByb3RvY29sICsgJy8ve3N9LmFyY2dpc29ubGluZS5jb20vQXJjR0lTL3Jlc3Qvc2VydmljZXMvUmVmZXJlbmNlL1dvcmxkX1RyYW5zcG9ydGF0aW9uL01hcFNlcnZlci90aWxlL3t6fS97eX0ve3h9JyxcclxuICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICBtaW5ab29tOiAxLFxyXG4gICAgICAgICAgbWF4Wm9vbTogMTksXHJcbiAgICAgICAgICBzdWJkb21haW5zOiBbJ3NlcnZlcicsICdzZXJ2aWNlcyddLFxyXG4gICAgICAgICAgcGFuZTogKHBvaW50ZXJFdmVudHMpID8gJ2VzcmktbGFiZWxzJyA6ICd0aWxlUGFuZScsXHJcbiAgICAgICAgICBhdHRyaWJ1dGlvbjogJydcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIFNoYWRlZFJlbGllZjoge1xyXG4gICAgICAgIHVybFRlbXBsYXRlOiB0aWxlUHJvdG9jb2wgKyAnLy97c30uYXJjZ2lzb25saW5lLmNvbS9BcmNHSVMvcmVzdC9zZXJ2aWNlcy9Xb3JsZF9TaGFkZWRfUmVsaWVmL01hcFNlcnZlci90aWxlL3t6fS97eX0ve3h9JyxcclxuICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICBtaW5ab29tOiAxLFxyXG4gICAgICAgICAgbWF4Wm9vbTogMTMsXHJcbiAgICAgICAgICBzdWJkb21haW5zOiBbJ3NlcnZlcicsICdzZXJ2aWNlcyddLFxyXG4gICAgICAgICAgYXR0cmlidXRpb246ICdVU0dTJ1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgU2hhZGVkUmVsaWVmTGFiZWxzOiB7XHJcbiAgICAgICAgdXJsVGVtcGxhdGU6IHRpbGVQcm90b2NvbCArICcvL3tzfS5hcmNnaXNvbmxpbmUuY29tL0FyY0dJUy9yZXN0L3NlcnZpY2VzL1JlZmVyZW5jZS9Xb3JsZF9Cb3VuZGFyaWVzX2FuZF9QbGFjZXNfQWx0ZXJuYXRlL01hcFNlcnZlci90aWxlL3t6fS97eX0ve3h9JyxcclxuICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICBtaW5ab29tOiAxLFxyXG4gICAgICAgICAgbWF4Wm9vbTogMTIsXHJcbiAgICAgICAgICBzdWJkb21haW5zOiBbJ3NlcnZlcicsICdzZXJ2aWNlcyddLFxyXG4gICAgICAgICAgcGFuZTogKHBvaW50ZXJFdmVudHMpID8gJ2VzcmktbGFiZWxzJyA6ICd0aWxlUGFuZScsXHJcbiAgICAgICAgICBhdHRyaWJ1dGlvbjogJydcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIFRlcnJhaW46IHtcclxuICAgICAgICB1cmxUZW1wbGF0ZTogdGlsZVByb3RvY29sICsgJy8ve3N9LmFyY2dpc29ubGluZS5jb20vQXJjR0lTL3Jlc3Qvc2VydmljZXMvV29ybGRfVGVycmFpbl9CYXNlL01hcFNlcnZlci90aWxlL3t6fS97eX0ve3h9JyxcclxuICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICBtaW5ab29tOiAxLFxyXG4gICAgICAgICAgbWF4Wm9vbTogMTMsXHJcbiAgICAgICAgICBzdWJkb21haW5zOiBbJ3NlcnZlcicsICdzZXJ2aWNlcyddLFxyXG4gICAgICAgICAgYXR0cmlidXRpb246ICdVU0dTLCBOT0FBJ1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgVGVycmFpbkxhYmVsczoge1xyXG4gICAgICAgIHVybFRlbXBsYXRlOiB0aWxlUHJvdG9jb2wgKyAnLy97c30uYXJjZ2lzb25saW5lLmNvbS9BcmNHSVMvcmVzdC9zZXJ2aWNlcy9SZWZlcmVuY2UvV29ybGRfUmVmZXJlbmNlX092ZXJsYXkvTWFwU2VydmVyL3RpbGUve3p9L3t5fS97eH0nLFxyXG4gICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgIG1pblpvb206IDEsXHJcbiAgICAgICAgICBtYXhab29tOiAxMyxcclxuICAgICAgICAgIHN1YmRvbWFpbnM6IFsnc2VydmVyJywgJ3NlcnZpY2VzJ10sXHJcbiAgICAgICAgICBwYW5lOiAocG9pbnRlckV2ZW50cykgPyAnZXNyaS1sYWJlbHMnIDogJ3RpbGVQYW5lJyxcclxuICAgICAgICAgIGF0dHJpYnV0aW9uOiAnJ1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgVVNBVG9wbzoge1xyXG4gICAgICAgIHVybFRlbXBsYXRlOiB0aWxlUHJvdG9jb2wgKyAnLy97c30uYXJjZ2lzb25saW5lLmNvbS9BcmNHSVMvcmVzdC9zZXJ2aWNlcy9VU0FfVG9wb19NYXBzL01hcFNlcnZlci90aWxlL3t6fS97eX0ve3h9JyxcclxuICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICBtaW5ab29tOiAxLFxyXG4gICAgICAgICAgbWF4Wm9vbTogMTUsXHJcbiAgICAgICAgICBzdWJkb21haW5zOiBbJ3NlcnZlcicsICdzZXJ2aWNlcyddLFxyXG4gICAgICAgICAgYXR0cmlidXRpb246ICdVU0dTLCBOYXRpb25hbCBHZW9ncmFwaGljIFNvY2lldHksIGktY3ViZWQnXHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBJbWFnZXJ5Q2xhcml0eToge1xyXG4gICAgICAgIHVybFRlbXBsYXRlOiB0aWxlUHJvdG9jb2wgKyAnLy9jbGFyaXR5Lm1hcHRpbGVzLmFyY2dpcy5jb20vYXJjZ2lzL3Jlc3Qvc2VydmljZXMvV29ybGRfSW1hZ2VyeS9NYXBTZXJ2ZXIvdGlsZS97en0ve3l9L3t4fScsXHJcbiAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgbWluWm9vbTogMSxcclxuICAgICAgICAgIG1heFpvb206IDE5LFxyXG4gICAgICAgICAgYXR0cmlidXRpb246ICdFc3JpLCBEaWdpdGFsR2xvYmUsIEdlb0V5ZSwgRWFydGhzdGFyIEdlb2dyYXBoaWNzLCBDTkVTL0FpcmJ1cyBEUywgVVNEQSwgVVNHUywgQWVyb0dSSUQsIElHTiwgYW5kIHRoZSBHSVMgVXNlciBDb21tdW5pdHknXHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBQaHlzaWNhbDoge1xyXG4gICAgICAgIHVybFRlbXBsYXRlOiB0aWxlUHJvdG9jb2wgKyAnLy97c30uYXJjZ2lzb25saW5lLmNvbS9hcmNnaXMvcmVzdC9zZXJ2aWNlcy9Xb3JsZF9QaHlzaWNhbF9NYXAvTWFwU2VydmVyL3RpbGUve3p9L3t5fS97eH0nLFxyXG4gICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgIG1pblpvb206IDEsXHJcbiAgICAgICAgICBtYXhab29tOiA4LFxyXG4gICAgICAgICAgc3ViZG9tYWluczogWydzZXJ2ZXInLCAnc2VydmljZXMnXSxcclxuICAgICAgICAgIGF0dHJpYnV0aW9uOiAnVS5TLiBOYXRpb25hbCBQYXJrIFNlcnZpY2UnXHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBJbWFnZXJ5RmlyZWZseToge1xyXG4gICAgICAgIHVybFRlbXBsYXRlOiB0aWxlUHJvdG9jb2wgKyAnLy9mbHkubWFwdGlsZXMuYXJjZ2lzLmNvbS9hcmNnaXMvcmVzdC9zZXJ2aWNlcy9Xb3JsZF9JbWFnZXJ5X0ZpcmVmbHkvTWFwU2VydmVyL3RpbGUve3p9L3t5fS97eH0nLFxyXG4gICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgIG1pblpvb206IDEsXHJcbiAgICAgICAgICBtYXhab29tOiAxOSxcclxuICAgICAgICAgIGF0dHJpYnV0aW9uOiAnRXNyaSwgRGlnaXRhbEdsb2JlLCBHZW9FeWUsIEVhcnRoc3RhciBHZW9ncmFwaGljcywgQ05FUy9BaXJidXMgRFMsIFVTREEsIFVTR1MsIEFlcm9HUklELCBJR04sIGFuZCB0aGUgR0lTIFVzZXIgQ29tbXVuaXR5JyxcclxuICAgICAgICAgIGF0dHJpYnV0aW9uVXJsOiAnaHR0cHM6Ly9zdGF0aWMuYXJjZ2lzLmNvbS9hdHRyaWJ1dGlvbi9Xb3JsZF9JbWFnZXJ5J1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIChrZXksIG9wdGlvbnMpIHtcclxuICAgIHZhciBjb25maWc7XHJcblxyXG4gICAgLy8gc2V0IHRoZSBjb25maWcgdmFyaWFibGUgd2l0aCB0aGUgYXBwcm9wcmlhdGUgY29uZmlnIG9iamVjdFxyXG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnICYmIGtleS51cmxUZW1wbGF0ZSAmJiBrZXkub3B0aW9ucykge1xyXG4gICAgICBjb25maWcgPSBrZXk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIEJhc2VtYXBMYXllci5USUxFU1trZXldKSB7XHJcbiAgICAgIGNvbmZpZyA9IEJhc2VtYXBMYXllci5USUxFU1trZXldO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdMLmVzcmkuQmFzZW1hcExheWVyOiBJbnZhbGlkIHBhcmFtZXRlci4gVXNlIG9uZSBvZiBcIlN0cmVldHNcIiwgXCJUb3BvZ3JhcGhpY1wiLCBcIk9jZWFuc1wiLCBcIk9jZWFuc0xhYmVsc1wiLCBcIk5hdGlvbmFsR2VvZ3JhcGhpY1wiLCBcIlBoeXNpY2FsXCIsIFwiR3JheVwiLCBcIkdyYXlMYWJlbHNcIiwgXCJEYXJrR3JheVwiLCBcIkRhcmtHcmF5TGFiZWxzXCIsIFwiSW1hZ2VyeVwiLCBcIkltYWdlcnlMYWJlbHNcIiwgXCJJbWFnZXJ5VHJhbnNwb3J0YXRpb25cIiwgXCJJbWFnZXJ5Q2xhcml0eVwiLCBcIkltYWdlcnlGaXJlZmx5XCIsIFNoYWRlZFJlbGllZlwiLCBcIlNoYWRlZFJlbGllZkxhYmVsc1wiLCBcIlRlcnJhaW5cIiwgXCJUZXJyYWluTGFiZWxzXCIgb3IgXCJVU0FUb3BvXCInKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBtZXJnZSBwYXNzZWQgb3B0aW9ucyBpbnRvIHRoZSBjb25maWcgb3B0aW9uc1xyXG4gICAgdmFyIHRpbGVPcHRpb25zID0gVXRpbC5leHRlbmQoY29uZmlnLm9wdGlvbnMsIG9wdGlvbnMpO1xyXG5cclxuICAgIFV0aWwuc2V0T3B0aW9ucyh0aGlzLCB0aWxlT3B0aW9ucyk7XHJcblxyXG4gICAgLy8gRGVwcmVjYXRpb24gbm90aWNlOlxyXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuaWdub3JlRGVwcmVjYXRpb25XYXJuaW5nKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybignV0FSTklORzogTC5lc3JpLkJhc2VtYXBMYXllciB1c2VzIGRhdGEgc2VydmljZXMgdGhhdCBhcmUgaW4gbWF0dXJlIHN1cHBvcnQgYW5kIGFyZSBub3QgYmVpbmcgdXBkYXRlZC4gUGxlYXNlIHVzZSBMLmVzcmkuVmVjdG9yLnZlY3RvckJhc2VtYXBMYXllciBpbnN0ZWFkLiBNb3JlIGluZm86IGh0dHBzOi8vZXNyaXVybC5jb20vZXNyaS1sZWFmbGV0LWJhc2VtYXAnKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5vcHRpb25zLnRva2VuICYmIGNvbmZpZy51cmxUZW1wbGF0ZS5pbmRleE9mKCd0b2tlbj0nKSA9PT0gLTEpIHtcclxuICAgICAgY29uZmlnLnVybFRlbXBsYXRlICs9ICgnP3Rva2VuPScgKyB0aGlzLm9wdGlvbnMudG9rZW4pO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5wcm94eSkge1xyXG4gICAgICBjb25maWcudXJsVGVtcGxhdGUgPSB0aGlzLm9wdGlvbnMucHJveHkgKyAnPycgKyBjb25maWcudXJsVGVtcGxhdGU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY2FsbCB0aGUgaW5pdGlhbGl6ZSBtZXRob2Qgb24gTC5UaWxlTGF5ZXIgdG8gc2V0IGV2ZXJ5dGhpbmcgdXBcclxuICAgIFRpbGVMYXllci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIGNvbmZpZy51cmxUZW1wbGF0ZSwgdGlsZU9wdGlvbnMpO1xyXG4gIH0sXHJcblxyXG4gIG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgICAvLyBpbmNsdWRlICdQb3dlcmVkIGJ5IEVzcmknIGluIG1hcCBhdHRyaWJ1dGlvblxyXG4gICAgc2V0RXNyaUF0dHJpYnV0aW9uKG1hcCk7XHJcblxyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5wYW5lID09PSAnZXNyaS1sYWJlbHMnKSB7XHJcbiAgICAgIHRoaXMuX2luaXRQYW5lKCk7XHJcbiAgICB9XHJcbiAgICAvLyBzb21lIGJhc2VtYXBzIGNhbiBzdXBwbHkgZHluYW1pYyBhdHRyaWJ1dGlvblxyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5hdHRyaWJ1dGlvblVybCkge1xyXG4gICAgICBfZ2V0QXR0cmlidXRpb25EYXRhKCh0aGlzLm9wdGlvbnMucHJveHkgPyB0aGlzLm9wdGlvbnMucHJveHkgKyAnPycgOiAnJykgKyB0aGlzLm9wdGlvbnMuYXR0cmlidXRpb25VcmwsIG1hcCk7XHJcbiAgICB9XHJcblxyXG4gICAgbWFwLm9uKCdtb3ZlZW5kJywgX3VwZGF0ZU1hcEF0dHJpYnV0aW9uKTtcclxuXHJcbiAgICBUaWxlTGF5ZXIucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcclxuICB9LFxyXG5cclxuICBvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG4gICAgcmVtb3ZlRXNyaUF0dHJpYnV0aW9uKG1hcCk7XHJcblxyXG4gICAgbWFwLm9mZignbW92ZWVuZCcsIF91cGRhdGVNYXBBdHRyaWJ1dGlvbik7XHJcblxyXG4gICAgVGlsZUxheWVyLnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsIG1hcCk7XHJcbiAgfSxcclxuXHJcbiAgX2luaXRQYW5lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoIXRoaXMuX21hcC5nZXRQYW5lKHRoaXMub3B0aW9ucy5wYW5lKSkge1xyXG4gICAgICB2YXIgcGFuZSA9IHRoaXMuX21hcC5jcmVhdGVQYW5lKHRoaXMub3B0aW9ucy5wYW5lKTtcclxuICAgICAgcGFuZS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xyXG4gICAgICBwYW5lLnN0eWxlLnpJbmRleCA9IDUwMDtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBnZXRBdHRyaWJ1dGlvbjogZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5hdHRyaWJ1dGlvbikge1xyXG4gICAgICB2YXIgYXR0cmlidXRpb24gPSAnPHNwYW4gY2xhc3M9XCJlc3JpLWR5bmFtaWMtYXR0cmlidXRpb25cIj4nICsgdGhpcy5vcHRpb25zLmF0dHJpYnV0aW9uICsgJzwvc3Bhbj4nO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGF0dHJpYnV0aW9uO1xyXG4gIH1cclxufSk7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYmFzZW1hcExheWVyIChrZXksIG9wdGlvbnMpIHtcclxuICByZXR1cm4gbmV3IEJhc2VtYXBMYXllcihrZXksIG9wdGlvbnMpO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBiYXNlbWFwTGF5ZXI7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/esri-leaflet/src/Layers/BasemapLayer.js\n");

/***/ }),

/***/ "./node_modules/esri-leaflet/src/Layers/DynamicMapLayer.js":
/*!*****************************************************************!*\
  !*** ./node_modules/esri-leaflet/src/Layers/DynamicMapLayer.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DynamicMapLayer\": () => (/* binding */ DynamicMapLayer),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"dynamicMapLayer\": () => (/* binding */ dynamicMapLayer)\n/* harmony export */ });\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! leaflet */ \"./node_modules/leaflet/dist/leaflet-src.js\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _RasterLayer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RasterLayer */ \"./node_modules/esri-leaflet/src/Layers/RasterLayer.js\");\n/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Util */ \"./node_modules/esri-leaflet/src/Util.js\");\n/* harmony import */ var _Services_MapService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Services/MapService */ \"./node_modules/esri-leaflet/src/Services/MapService.js\");\n\r\n\r\n\r\n\r\n\r\nvar DynamicMapLayer = _RasterLayer__WEBPACK_IMPORTED_MODULE_1__.RasterLayer.extend({\r\n\r\n  options: {\r\n    updateInterval: 150,\r\n    layers: false,\r\n    layerDefs: false,\r\n    timeOptions: false,\r\n    format: 'png32',\r\n    transparent: true,\r\n    f: 'json'\r\n  },\r\n\r\n  initialize: function (options) {\r\n    options = (0,_Util__WEBPACK_IMPORTED_MODULE_2__.getUrlParams)(options);\r\n    this.service = (0,_Services_MapService__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(options);\r\n    this.service.addEventParent(this);\r\n\r\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.setOptions(this, options);\r\n  },\r\n\r\n  getDynamicLayers: function () {\r\n    return this.options.dynamicLayers;\r\n  },\r\n\r\n  setDynamicLayers: function (dynamicLayers) {\r\n    this.options.dynamicLayers = dynamicLayers;\r\n    this._update();\r\n    return this;\r\n  },\r\n\r\n  getLayers: function () {\r\n    return this.options.layers;\r\n  },\r\n\r\n  setLayers: function (layers) {\r\n    this.options.layers = layers;\r\n    this._update();\r\n    return this;\r\n  },\r\n\r\n  getLayerDefs: function () {\r\n    return this.options.layerDefs;\r\n  },\r\n\r\n  setLayerDefs: function (layerDefs) {\r\n    this.options.layerDefs = layerDefs;\r\n    this._update();\r\n    return this;\r\n  },\r\n\r\n  getTimeOptions: function () {\r\n    return this.options.timeOptions;\r\n  },\r\n\r\n  setTimeOptions: function (timeOptions) {\r\n    this.options.timeOptions = timeOptions;\r\n    this._update();\r\n    return this;\r\n  },\r\n\r\n  query: function () {\r\n    return this.service.query();\r\n  },\r\n\r\n  identify: function () {\r\n    return this.service.identify();\r\n  },\r\n\r\n  find: function () {\r\n    return this.service.find();\r\n  },\r\n\r\n  _getPopupData: function (e) {\r\n    var callback = leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.bind(function (error, featureCollection, response) {\r\n      if (error) { return; } // we really can't do anything here but authenticate or requesterror will fire\r\n      setTimeout(leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.bind(function () {\r\n        this._renderPopup(e.latlng, error, featureCollection, response);\r\n      }, this), 300);\r\n    }, this);\r\n\r\n    var identifyRequest;\r\n    if (this.options.popup) {\r\n      identifyRequest = this.options.popup.on(this._map).at(e.latlng);\r\n    } else {\r\n      identifyRequest = this.identify().on(this._map).at(e.latlng);\r\n    }\r\n\r\n    // remove extraneous vertices from response features if it has not already been done\r\n    if (!identifyRequest.params.maxAllowableOffset) {\r\n      identifyRequest.simplify(this._map, 0.5);\r\n    }\r\n\r\n    if (!(this.options.popup && this.options.popup.params && this.options.popup.params.layers)) {\r\n      if (this.options.layers) {\r\n        identifyRequest.layers('visible:' + this.options.layers.join(','));\r\n      } else {\r\n        identifyRequest.layers('visible');\r\n      }\r\n    }\r\n\r\n    // if present, pass layer ids and sql filters through to the identify task\r\n    if (this.options.layerDefs && typeof this.options.layerDefs !== 'string' && !identifyRequest.params.layerDefs) {\r\n      for (var id in this.options.layerDefs) {\r\n        if (Object.prototype.hasOwnProperty.call(this.options.layerDefs, id)) {\r\n          identifyRequest.layerDef(id, this.options.layerDefs[id]);\r\n        }\r\n      }\r\n    }\r\n\r\n    identifyRequest.run(callback);\r\n\r\n    // set the flags to show the popup\r\n    this._shouldRenderPopup = true;\r\n    this._lastClick = e.latlng;\r\n  },\r\n\r\n  _buildExportParams: function () {\r\n    var sr = parseInt(this._map.options.crs.code.split(':')[1], 10);\r\n\r\n    var params = {\r\n      bbox: this._calculateBbox(),\r\n      size: this._calculateImageSize(),\r\n      dpi: 96,\r\n      format: this.options.format,\r\n      transparent: this.options.transparent,\r\n      bboxSR: sr,\r\n      imageSR: sr\r\n    };\r\n\r\n    if (this.options.dynamicLayers) {\r\n      params.dynamicLayers = this.options.dynamicLayers;\r\n    }\r\n\r\n    if (this.options.layers) {\r\n      if (this.options.layers.length === 0) {\r\n        return;\r\n      } else {\r\n        params.layers = 'show:' + this.options.layers.join(',');\r\n      }\r\n    }\r\n\r\n    if (this.options.layerDefs) {\r\n      params.layerDefs = typeof this.options.layerDefs === 'string' ? this.options.layerDefs : JSON.stringify(this.options.layerDefs);\r\n    }\r\n\r\n    if (this.options.timeOptions) {\r\n      params.timeOptions = JSON.stringify(this.options.timeOptions);\r\n    }\r\n\r\n    if (this.options.from && this.options.to) {\r\n      params.time = this.options.from.valueOf() + ',' + this.options.to.valueOf();\r\n    }\r\n\r\n    if (this.service.options.token) {\r\n      params.token = this.service.options.token;\r\n    }\r\n\r\n    if (this.options.proxy) {\r\n      params.proxy = this.options.proxy;\r\n    }\r\n\r\n    // use a timestamp to bust server cache\r\n    if (this.options.disableCache) {\r\n      params._ts = Date.now();\r\n    }\r\n\r\n    return params;\r\n  },\r\n\r\n  _requestExport: function (params, bounds) {\r\n    if (this.options.f === 'json') {\r\n      this.service.request('export', params, function (error, response) {\r\n        if (error) { return; } // we really can't do anything here but authenticate or requesterror will fire\r\n\r\n        if (this.options.token && response.href) {\r\n          response.href += ('?token=' + this.options.token);\r\n        }\r\n        if (this.options.proxy && response.href) {\r\n          response.href = this.options.proxy + '?' + response.href;\r\n        }\r\n        if (response.href) {\r\n          this._renderImage(response.href, bounds);\r\n        } else {\r\n          this._renderImage(response.imageData, bounds, response.contentType);\r\n        }\r\n      }, this);\r\n    } else {\r\n      params.f = 'image';\r\n      var fullUrl = this.options.url + 'export' + leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.getParamString(params);\r\n      if (this.options.proxy) {\r\n        fullUrl = this.options.proxy + '?' + fullUrl;\r\n      }\r\n      this._renderImage(fullUrl, bounds);\r\n    }\r\n  }\r\n});\r\n\r\nfunction dynamicMapLayer (url, options) {\r\n  return new DynamicMapLayer(url, options);\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dynamicMapLayer);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXNyaS1sZWFmbGV0L3NyYy9MYXllcnMvRHluYW1pY01hcExheWVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQStCO0FBQ2E7QUFDTDtBQUNTO0FBQ2hEO0FBQ08sc0JBQXNCLDREQUFrQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGNBQWMsbURBQVk7QUFDMUIsbUJBQW1CLGdFQUFVO0FBQzdCO0FBQ0E7QUFDQSxJQUFJLG9EQUFlO0FBQ25CLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsbUJBQW1CLDhDQUFTO0FBQzVCLG1CQUFtQixVQUFVO0FBQzdCLGlCQUFpQiw4Q0FBUztBQUMxQjtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixVQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBLGtEQUFrRCx3REFBbUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxlQUFlLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXNyaS1sZWFmbGV0L3NyYy9MYXllcnMvRHluYW1pY01hcExheWVyLmpzP2ZkMTQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVXRpbCB9IGZyb20gJ2xlYWZsZXQnO1xyXG5pbXBvcnQgeyBSYXN0ZXJMYXllciB9IGZyb20gJy4vUmFzdGVyTGF5ZXInO1xyXG5pbXBvcnQgeyBnZXRVcmxQYXJhbXMgfSBmcm9tICcuLi9VdGlsJztcclxuaW1wb3J0IG1hcFNlcnZpY2UgZnJvbSAnLi4vU2VydmljZXMvTWFwU2VydmljZSc7XHJcblxyXG5leHBvcnQgdmFyIER5bmFtaWNNYXBMYXllciA9IFJhc3RlckxheWVyLmV4dGVuZCh7XHJcblxyXG4gIG9wdGlvbnM6IHtcclxuICAgIHVwZGF0ZUludGVydmFsOiAxNTAsXHJcbiAgICBsYXllcnM6IGZhbHNlLFxyXG4gICAgbGF5ZXJEZWZzOiBmYWxzZSxcclxuICAgIHRpbWVPcHRpb25zOiBmYWxzZSxcclxuICAgIGZvcm1hdDogJ3BuZzMyJyxcclxuICAgIHRyYW5zcGFyZW50OiB0cnVlLFxyXG4gICAgZjogJ2pzb24nXHJcbiAgfSxcclxuXHJcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgIG9wdGlvbnMgPSBnZXRVcmxQYXJhbXMob3B0aW9ucyk7XHJcbiAgICB0aGlzLnNlcnZpY2UgPSBtYXBTZXJ2aWNlKG9wdGlvbnMpO1xyXG4gICAgdGhpcy5zZXJ2aWNlLmFkZEV2ZW50UGFyZW50KHRoaXMpO1xyXG5cclxuICAgIFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuICB9LFxyXG5cclxuICBnZXREeW5hbWljTGF5ZXJzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmR5bmFtaWNMYXllcnM7XHJcbiAgfSxcclxuXHJcbiAgc2V0RHluYW1pY0xheWVyczogZnVuY3Rpb24gKGR5bmFtaWNMYXllcnMpIHtcclxuICAgIHRoaXMub3B0aW9ucy5keW5hbWljTGF5ZXJzID0gZHluYW1pY0xheWVycztcclxuICAgIHRoaXMuX3VwZGF0ZSgpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuXHJcbiAgZ2V0TGF5ZXJzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmxheWVycztcclxuICB9LFxyXG5cclxuICBzZXRMYXllcnM6IGZ1bmN0aW9uIChsYXllcnMpIHtcclxuICAgIHRoaXMub3B0aW9ucy5sYXllcnMgPSBsYXllcnM7XHJcbiAgICB0aGlzLl91cGRhdGUoKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0sXHJcblxyXG4gIGdldExheWVyRGVmczogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5sYXllckRlZnM7XHJcbiAgfSxcclxuXHJcbiAgc2V0TGF5ZXJEZWZzOiBmdW5jdGlvbiAobGF5ZXJEZWZzKSB7XHJcbiAgICB0aGlzLm9wdGlvbnMubGF5ZXJEZWZzID0gbGF5ZXJEZWZzO1xyXG4gICAgdGhpcy5fdXBkYXRlKCk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICBnZXRUaW1lT3B0aW9uczogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy50aW1lT3B0aW9ucztcclxuICB9LFxyXG5cclxuICBzZXRUaW1lT3B0aW9uczogZnVuY3Rpb24gKHRpbWVPcHRpb25zKSB7XHJcbiAgICB0aGlzLm9wdGlvbnMudGltZU9wdGlvbnMgPSB0aW1lT3B0aW9ucztcclxuICAgIHRoaXMuX3VwZGF0ZSgpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuXHJcbiAgcXVlcnk6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLnNlcnZpY2UucXVlcnkoKTtcclxuICB9LFxyXG5cclxuICBpZGVudGlmeTogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc2VydmljZS5pZGVudGlmeSgpO1xyXG4gIH0sXHJcblxyXG4gIGZpbmQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLnNlcnZpY2UuZmluZCgpO1xyXG4gIH0sXHJcblxyXG4gIF9nZXRQb3B1cERhdGE6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICB2YXIgY2FsbGJhY2sgPSBVdGlsLmJpbmQoZnVuY3Rpb24gKGVycm9yLCBmZWF0dXJlQ29sbGVjdGlvbiwgcmVzcG9uc2UpIHtcclxuICAgICAgaWYgKGVycm9yKSB7IHJldHVybjsgfSAvLyB3ZSByZWFsbHkgY2FuJ3QgZG8gYW55dGhpbmcgaGVyZSBidXQgYXV0aGVudGljYXRlIG9yIHJlcXVlc3RlcnJvciB3aWxsIGZpcmVcclxuICAgICAgc2V0VGltZW91dChVdGlsLmJpbmQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX3JlbmRlclBvcHVwKGUubGF0bG5nLCBlcnJvciwgZmVhdHVyZUNvbGxlY3Rpb24sIHJlc3BvbnNlKTtcclxuICAgICAgfSwgdGhpcyksIDMwMCk7XHJcbiAgICB9LCB0aGlzKTtcclxuXHJcbiAgICB2YXIgaWRlbnRpZnlSZXF1ZXN0O1xyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5wb3B1cCkge1xyXG4gICAgICBpZGVudGlmeVJlcXVlc3QgPSB0aGlzLm9wdGlvbnMucG9wdXAub24odGhpcy5fbWFwKS5hdChlLmxhdGxuZyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZGVudGlmeVJlcXVlc3QgPSB0aGlzLmlkZW50aWZ5KCkub24odGhpcy5fbWFwKS5hdChlLmxhdGxuZyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcmVtb3ZlIGV4dHJhbmVvdXMgdmVydGljZXMgZnJvbSByZXNwb25zZSBmZWF0dXJlcyBpZiBpdCBoYXMgbm90IGFscmVhZHkgYmVlbiBkb25lXHJcbiAgICBpZiAoIWlkZW50aWZ5UmVxdWVzdC5wYXJhbXMubWF4QWxsb3dhYmxlT2Zmc2V0KSB7XHJcbiAgICAgIGlkZW50aWZ5UmVxdWVzdC5zaW1wbGlmeSh0aGlzLl9tYXAsIDAuNSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCEodGhpcy5vcHRpb25zLnBvcHVwICYmIHRoaXMub3B0aW9ucy5wb3B1cC5wYXJhbXMgJiYgdGhpcy5vcHRpb25zLnBvcHVwLnBhcmFtcy5sYXllcnMpKSB7XHJcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubGF5ZXJzKSB7XHJcbiAgICAgICAgaWRlbnRpZnlSZXF1ZXN0LmxheWVycygndmlzaWJsZTonICsgdGhpcy5vcHRpb25zLmxheWVycy5qb2luKCcsJykpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlkZW50aWZ5UmVxdWVzdC5sYXllcnMoJ3Zpc2libGUnKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGlmIHByZXNlbnQsIHBhc3MgbGF5ZXIgaWRzIGFuZCBzcWwgZmlsdGVycyB0aHJvdWdoIHRvIHRoZSBpZGVudGlmeSB0YXNrXHJcbiAgICBpZiAodGhpcy5vcHRpb25zLmxheWVyRGVmcyAmJiB0eXBlb2YgdGhpcy5vcHRpb25zLmxheWVyRGVmcyAhPT0gJ3N0cmluZycgJiYgIWlkZW50aWZ5UmVxdWVzdC5wYXJhbXMubGF5ZXJEZWZzKSB7XHJcbiAgICAgIGZvciAodmFyIGlkIGluIHRoaXMub3B0aW9ucy5sYXllckRlZnMpIHtcclxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMub3B0aW9ucy5sYXllckRlZnMsIGlkKSkge1xyXG4gICAgICAgICAgaWRlbnRpZnlSZXF1ZXN0LmxheWVyRGVmKGlkLCB0aGlzLm9wdGlvbnMubGF5ZXJEZWZzW2lkXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWRlbnRpZnlSZXF1ZXN0LnJ1bihjYWxsYmFjayk7XHJcblxyXG4gICAgLy8gc2V0IHRoZSBmbGFncyB0byBzaG93IHRoZSBwb3B1cFxyXG4gICAgdGhpcy5fc2hvdWxkUmVuZGVyUG9wdXAgPSB0cnVlO1xyXG4gICAgdGhpcy5fbGFzdENsaWNrID0gZS5sYXRsbmc7XHJcbiAgfSxcclxuXHJcbiAgX2J1aWxkRXhwb3J0UGFyYW1zOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgc3IgPSBwYXJzZUludCh0aGlzLl9tYXAub3B0aW9ucy5jcnMuY29kZS5zcGxpdCgnOicpWzFdLCAxMCk7XHJcblxyXG4gICAgdmFyIHBhcmFtcyA9IHtcclxuICAgICAgYmJveDogdGhpcy5fY2FsY3VsYXRlQmJveCgpLFxyXG4gICAgICBzaXplOiB0aGlzLl9jYWxjdWxhdGVJbWFnZVNpemUoKSxcclxuICAgICAgZHBpOiA5NixcclxuICAgICAgZm9ybWF0OiB0aGlzLm9wdGlvbnMuZm9ybWF0LFxyXG4gICAgICB0cmFuc3BhcmVudDogdGhpcy5vcHRpb25zLnRyYW5zcGFyZW50LFxyXG4gICAgICBiYm94U1I6IHNyLFxyXG4gICAgICBpbWFnZVNSOiBzclxyXG4gICAgfTtcclxuXHJcbiAgICBpZiAodGhpcy5vcHRpb25zLmR5bmFtaWNMYXllcnMpIHtcclxuICAgICAgcGFyYW1zLmR5bmFtaWNMYXllcnMgPSB0aGlzLm9wdGlvbnMuZHluYW1pY0xheWVycztcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5vcHRpb25zLmxheWVycykge1xyXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxheWVycy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcGFyYW1zLmxheWVycyA9ICdzaG93OicgKyB0aGlzLm9wdGlvbnMubGF5ZXJzLmpvaW4oJywnKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLm9wdGlvbnMubGF5ZXJEZWZzKSB7XHJcbiAgICAgIHBhcmFtcy5sYXllckRlZnMgPSB0eXBlb2YgdGhpcy5vcHRpb25zLmxheWVyRGVmcyA9PT0gJ3N0cmluZycgPyB0aGlzLm9wdGlvbnMubGF5ZXJEZWZzIDogSlNPTi5zdHJpbmdpZnkodGhpcy5vcHRpb25zLmxheWVyRGVmcyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMub3B0aW9ucy50aW1lT3B0aW9ucykge1xyXG4gICAgICBwYXJhbXMudGltZU9wdGlvbnMgPSBKU09OLnN0cmluZ2lmeSh0aGlzLm9wdGlvbnMudGltZU9wdGlvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLm9wdGlvbnMuZnJvbSAmJiB0aGlzLm9wdGlvbnMudG8pIHtcclxuICAgICAgcGFyYW1zLnRpbWUgPSB0aGlzLm9wdGlvbnMuZnJvbS52YWx1ZU9mKCkgKyAnLCcgKyB0aGlzLm9wdGlvbnMudG8udmFsdWVPZigpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLnNlcnZpY2Uub3B0aW9ucy50b2tlbikge1xyXG4gICAgICBwYXJhbXMudG9rZW4gPSB0aGlzLnNlcnZpY2Uub3B0aW9ucy50b2tlbjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5vcHRpb25zLnByb3h5KSB7XHJcbiAgICAgIHBhcmFtcy5wcm94eSA9IHRoaXMub3B0aW9ucy5wcm94eTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB1c2UgYSB0aW1lc3RhbXAgdG8gYnVzdCBzZXJ2ZXIgY2FjaGVcclxuICAgIGlmICh0aGlzLm9wdGlvbnMuZGlzYWJsZUNhY2hlKSB7XHJcbiAgICAgIHBhcmFtcy5fdHMgPSBEYXRlLm5vdygpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwYXJhbXM7XHJcbiAgfSxcclxuXHJcbiAgX3JlcXVlc3RFeHBvcnQ6IGZ1bmN0aW9uIChwYXJhbXMsIGJvdW5kcykge1xyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5mID09PSAnanNvbicpIHtcclxuICAgICAgdGhpcy5zZXJ2aWNlLnJlcXVlc3QoJ2V4cG9ydCcsIHBhcmFtcywgZnVuY3Rpb24gKGVycm9yLCByZXNwb25zZSkge1xyXG4gICAgICAgIGlmIChlcnJvcikgeyByZXR1cm47IH0gLy8gd2UgcmVhbGx5IGNhbid0IGRvIGFueXRoaW5nIGhlcmUgYnV0IGF1dGhlbnRpY2F0ZSBvciByZXF1ZXN0ZXJyb3Igd2lsbCBmaXJlXHJcblxyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudG9rZW4gJiYgcmVzcG9uc2UuaHJlZikge1xyXG4gICAgICAgICAgcmVzcG9uc2UuaHJlZiArPSAoJz90b2tlbj0nICsgdGhpcy5vcHRpb25zLnRva2VuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wcm94eSAmJiByZXNwb25zZS5ocmVmKSB7XHJcbiAgICAgICAgICByZXNwb25zZS5ocmVmID0gdGhpcy5vcHRpb25zLnByb3h5ICsgJz8nICsgcmVzcG9uc2UuaHJlZjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlc3BvbnNlLmhyZWYpIHtcclxuICAgICAgICAgIHRoaXMuX3JlbmRlckltYWdlKHJlc3BvbnNlLmhyZWYsIGJvdW5kcyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuX3JlbmRlckltYWdlKHJlc3BvbnNlLmltYWdlRGF0YSwgYm91bmRzLCByZXNwb25zZS5jb250ZW50VHlwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LCB0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHBhcmFtcy5mID0gJ2ltYWdlJztcclxuICAgICAgdmFyIGZ1bGxVcmwgPSB0aGlzLm9wdGlvbnMudXJsICsgJ2V4cG9ydCcgKyBVdGlsLmdldFBhcmFtU3RyaW5nKHBhcmFtcyk7XHJcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucHJveHkpIHtcclxuICAgICAgICBmdWxsVXJsID0gdGhpcy5vcHRpb25zLnByb3h5ICsgJz8nICsgZnVsbFVybDtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9yZW5kZXJJbWFnZShmdWxsVXJsLCBib3VuZHMpO1xyXG4gICAgfVxyXG4gIH1cclxufSk7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZHluYW1pY01hcExheWVyICh1cmwsIG9wdGlvbnMpIHtcclxuICByZXR1cm4gbmV3IER5bmFtaWNNYXBMYXllcih1cmwsIG9wdGlvbnMpO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBkeW5hbWljTWFwTGF5ZXI7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/esri-leaflet/src/Layers/DynamicMapLayer.js\n");

/***/ }),

/***/ "./node_modules/esri-leaflet/src/Layers/FeatureLayer/FeatureGrid.js":
/*!**************************************************************************!*\
  !*** ./node_modules/esri-leaflet/src/Layers/FeatureLayer/FeatureGrid.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FeatureGrid\": () => (/* binding */ FeatureGrid)\n/* harmony export */ });\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! leaflet */ \"./node_modules/leaflet/dist/leaflet-src.js\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);\n\r\n\r\nvar FeatureGrid = leaflet__WEBPACK_IMPORTED_MODULE_0__.Layer.extend({\r\n  // @section\r\n  // @aka GridLayer options\r\n  options: {\r\n    // @option cellSize: Number|Point = 256\r\n    // Width and height of cells in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.\r\n    cellSize: 512,\r\n\r\n    // @option updateWhenIdle: Boolean = (depends)\r\n    // Load new cells only when panning ends.\r\n    // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.\r\n    // `false` otherwise in order to display new cells _during_ panning, since it is easy to pan outside the\r\n    // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.\r\n    updateWhenIdle: leaflet__WEBPACK_IMPORTED_MODULE_0__.Browser.mobile,\r\n\r\n    // @option updateInterval: Number = 150\r\n    // Cells will not update more than once every `updateInterval` milliseconds when panning.\r\n    updateInterval: 150,\r\n\r\n    // @option noWrap: Boolean = false\r\n    // Whether the layer is wrapped around the antimeridian. If `true`, the\r\n    // GridLayer will only be displayed once at low zoom levels. Has no\r\n    // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used\r\n    // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting\r\n    // cells outside the CRS limits.\r\n    noWrap: false,\r\n\r\n    // @option keepBuffer: Number = 1.5\r\n    // When panning the map, keep this many rows and columns of cells before unloading them.\r\n    keepBuffer: 1.5\r\n  },\r\n\r\n  initialize: function (options) {\r\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.setOptions(this, options);\r\n  },\r\n\r\n  onAdd: function (map) {\r\n    this._cells = {};\r\n    this._activeCells = {};\r\n    this._resetView();\r\n    this._update();\r\n  },\r\n\r\n  onRemove: function (map) {\r\n    this._removeAllCells();\r\n    this._cellZoom = undefined;\r\n  },\r\n\r\n  // @method isLoading: Boolean\r\n  // Returns `true` if any cell in the grid layer has not finished loading.\r\n  isLoading: function () {\r\n    return this._loading;\r\n  },\r\n\r\n  // @method redraw: this\r\n  // Causes the layer to clear all the cells and request them again.\r\n  redraw: function () {\r\n    if (this._map) {\r\n      this._removeAllCells();\r\n      this._update();\r\n    }\r\n    return this;\r\n  },\r\n\r\n  getEvents: function () {\r\n    var events = {\r\n      viewprereset: this._invalidateAll,\r\n      viewreset: this._resetView,\r\n      zoom: this._resetView,\r\n      moveend: this._onMoveEnd\r\n    };\r\n\r\n    if (!this.options.updateWhenIdle) {\r\n      // update cells on move, but not more often than once per given interval\r\n      if (!this._onMove) {\r\n        this._onMove = leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.throttle(\r\n          this._onMoveEnd,\r\n          this.options.updateInterval,\r\n          this\r\n        );\r\n      }\r\n\r\n      events.move = this._onMove;\r\n    }\r\n\r\n    return events;\r\n  },\r\n\r\n  // @section Extension methods\r\n  // Layers extending `GridLayer` shall reimplement the following method.\r\n  // @method createCell(coords: Object, done?: Function): HTMLElement\r\n  // Called only internally, must be overridden by classes extending `GridLayer`.\r\n  // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback\r\n  // is specified, it must be called when the cell has finished loading and drawing.\r\n  createCell: function () {\r\n    return document.createElement('div');\r\n  },\r\n\r\n  removeCell: function () {\r\n\r\n  },\r\n\r\n  reuseCell: function () {\r\n\r\n  },\r\n\r\n  cellLeave: function () {\r\n\r\n  },\r\n\r\n  cellEnter: function () {\r\n\r\n  },\r\n  // @section\r\n  // @method getCellSize: Point\r\n  // Normalizes the [cellSize option](#gridlayer-cellsize) into a point. Used by the `createCell()` method.\r\n  getCellSize: function () {\r\n    var s = this.options.cellSize;\r\n    return s instanceof leaflet__WEBPACK_IMPORTED_MODULE_0__.Point ? s : new leaflet__WEBPACK_IMPORTED_MODULE_0__.Point(s, s);\r\n  },\r\n\r\n  _pruneCells: function () {\r\n    if (!this._map) {\r\n      return;\r\n    }\r\n\r\n    var key, cell;\r\n\r\n    for (key in this._cells) {\r\n      cell = this._cells[key];\r\n      cell.retain = cell.current;\r\n    }\r\n\r\n    for (key in this._cells) {\r\n      cell = this._cells[key];\r\n      if (cell.current && !cell.active) {\r\n        var coords = cell.coords;\r\n        if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {\r\n          this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);\r\n        }\r\n      }\r\n    }\r\n\r\n    for (key in this._cells) {\r\n      if (!this._cells[key].retain) {\r\n        this._removeCell(key);\r\n      }\r\n    }\r\n  },\r\n\r\n  _removeAllCells: function () {\r\n    for (var key in this._cells) {\r\n      this._removeCell(key);\r\n    }\r\n  },\r\n\r\n  _invalidateAll: function () {\r\n    this._removeAllCells();\r\n\r\n    this._cellZoom = undefined;\r\n  },\r\n\r\n  _retainParent: function (x, y, z, minZoom) {\r\n    var x2 = Math.floor(x / 2);\r\n    var y2 = Math.floor(y / 2);\r\n    var z2 = z - 1;\r\n    var coords2 = new leaflet__WEBPACK_IMPORTED_MODULE_0__.Point(+x2, +y2);\r\n    coords2.z = +z2;\r\n\r\n    var key = this._cellCoordsToKey(coords2);\r\n    var cell = this._cells[key];\r\n\r\n    if (cell && cell.active) {\r\n      cell.retain = true;\r\n      return true;\r\n    } else if (cell && cell.loaded) {\r\n      cell.retain = true;\r\n    }\r\n\r\n    if (z2 > minZoom) {\r\n      return this._retainParent(x2, y2, z2, minZoom);\r\n    }\r\n\r\n    return false;\r\n  },\r\n\r\n  _retainChildren: function (x, y, z, maxZoom) {\r\n    for (var i = 2 * x; i < 2 * x + 2; i++) {\r\n      for (var j = 2 * y; j < 2 * y + 2; j++) {\r\n        var coords = new leaflet__WEBPACK_IMPORTED_MODULE_0__.Point(i, j);\r\n        coords.z = z + 1;\r\n\r\n        var key = this._cellCoordsToKey(coords);\r\n        var cell = this._cells[key];\r\n\r\n        if (cell && cell.active) {\r\n          cell.retain = true;\r\n          continue;\r\n        } else if (cell && cell.loaded) {\r\n          cell.retain = true;\r\n        }\r\n\r\n        if (z + 1 < maxZoom) {\r\n          this._retainChildren(i, j, z + 1, maxZoom);\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  _resetView: function (e) {\r\n    var animating = e && (e.pinch || e.flyTo);\r\n\r\n    if (animating) {\r\n      return;\r\n    }\r\n\r\n    this._setView(\r\n      this._map.getCenter(),\r\n      this._map.getZoom(),\r\n      animating,\r\n      animating\r\n    );\r\n  },\r\n\r\n  _setView: function (center, zoom, noPrune, noUpdate) {\r\n    var cellZoom = Math.round(zoom);\r\n\r\n    if (!noUpdate) {\r\n      this._cellZoom = cellZoom;\r\n\r\n      if (this._abortLoading) {\r\n        this._abortLoading();\r\n      }\r\n\r\n      this._resetGrid();\r\n\r\n      if (cellZoom !== undefined) {\r\n        this._update(center);\r\n      }\r\n\r\n      if (!noPrune) {\r\n        this._pruneCells();\r\n      }\r\n\r\n      // Flag to prevent _updateOpacity from pruning cells during\r\n      // a zoom anim or a pinch gesture\r\n      this._noPrune = !!noPrune;\r\n    }\r\n  },\r\n\r\n  _resetGrid: function () {\r\n    var map = this._map;\r\n    var crs = map.options.crs;\r\n    var cellSize = (this._cellSize = this.getCellSize());\r\n    var cellZoom = this._cellZoom;\r\n\r\n    var bounds = this._map.getPixelWorldBounds(this._cellZoom);\r\n    if (bounds) {\r\n      this._globalCellRange = this._pxBoundsToCellRange(bounds);\r\n    }\r\n\r\n    this._wrapX = crs.wrapLng &&\r\n      !this.options.noWrap && [\r\n      Math.floor(map.project([0, crs.wrapLng[0]], cellZoom).x / cellSize.x),\r\n      Math.ceil(map.project([0, crs.wrapLng[1]], cellZoom).x / cellSize.y)\r\n    ];\r\n    this._wrapY = crs.wrapLat &&\r\n      !this.options.noWrap && [\r\n      Math.floor(map.project([crs.wrapLat[0], 0], cellZoom).y / cellSize.x),\r\n      Math.ceil(map.project([crs.wrapLat[1], 0], cellZoom).y / cellSize.y)\r\n    ];\r\n  },\r\n\r\n  _onMoveEnd: function (e) {\r\n    var animating = e && (e.pinch || e.flyTo);\r\n\r\n    if (animating || !this._map || this._map._animatingZoom) {\r\n      return;\r\n    }\r\n\r\n    this._update();\r\n  },\r\n\r\n  _getCelldPixelBounds: function (center) {\r\n    var map = this._map;\r\n    var mapZoom = map._animatingZoom\r\n      ? Math.max(map._animateToZoom, map.getZoom())\r\n      : map.getZoom();\r\n    var scale = map.getZoomScale(mapZoom, this._cellZoom);\r\n    var pixelCenter = map.project(center, this._cellZoom).floor();\r\n    var halfSize = map.getSize().divideBy(scale * 2);\r\n\r\n    return new leaflet__WEBPACK_IMPORTED_MODULE_0__.Bounds(\r\n      pixelCenter.subtract(halfSize),\r\n      pixelCenter.add(halfSize)\r\n    );\r\n  },\r\n\r\n  // Private method to load cells in the grid's active zoom level according to map bounds\r\n  _update: function (center) {\r\n    var map = this._map;\r\n    if (!map) {\r\n      return;\r\n    }\r\n    var zoom = Math.round(map.getZoom());\r\n\r\n    if (center === undefined) {\r\n      center = map.getCenter();\r\n    }\r\n\r\n    var pixelBounds = this._getCelldPixelBounds(center);\r\n    var cellRange = this._pxBoundsToCellRange(pixelBounds);\r\n    var cellCenter = cellRange.getCenter();\r\n    var queue = [];\r\n    var margin = this.options.keepBuffer;\r\n    var noPruneRange = new leaflet__WEBPACK_IMPORTED_MODULE_0__.Bounds(\r\n      cellRange.getBottomLeft().subtract([margin, -margin]),\r\n      cellRange.getTopRight().add([margin, -margin])\r\n    );\r\n\r\n    // Sanity check: panic if the cell range contains Infinity somewhere.\r\n    if (\r\n      !(\r\n        isFinite(cellRange.min.x) &&\r\n        isFinite(cellRange.min.y) &&\r\n        isFinite(cellRange.max.x) &&\r\n        isFinite(cellRange.max.y)\r\n      )\r\n    ) {\r\n      throw new Error('Attempted to load an infinite number of cells');\r\n    }\r\n\r\n    for (var key in this._cells) {\r\n      var c = this._cells[key].coords;\r\n      if (\r\n        c.z !== this._cellZoom ||\r\n        !noPruneRange.contains(new leaflet__WEBPACK_IMPORTED_MODULE_0__.Point(c.x, c.y))\r\n      ) {\r\n        this._cells[key].current = false;\r\n      }\r\n    }\r\n\r\n    // _update just loads more cells. If the cell zoom level differs too much\r\n    // from the map's, let _setView reset levels and prune old cells.\r\n    if (Math.abs(zoom - this._cellZoom) > 1) {\r\n      this._setView(center, zoom);\r\n      return;\r\n    }\r\n\r\n    // create a queue of coordinates to load cells from\r\n    for (var j = cellRange.min.y; j <= cellRange.max.y; j++) {\r\n      for (var i = cellRange.min.x; i <= cellRange.max.x; i++) {\r\n        var coords = new leaflet__WEBPACK_IMPORTED_MODULE_0__.Point(i, j);\r\n        coords.z = this._cellZoom;\r\n\r\n        if (!this._isValidCell(coords)) {\r\n          continue;\r\n        }\r\n\r\n        var cell = this._cells[this._cellCoordsToKey(coords)];\r\n        if (cell) {\r\n          cell.current = true;\r\n        } else {\r\n          queue.push(coords);\r\n        }\r\n      }\r\n    }\r\n\r\n    // sort cell queue to load cells in order of their distance to center\r\n    queue.sort(function (a, b) {\r\n      return a.distanceTo(cellCenter) - b.distanceTo(cellCenter);\r\n    });\r\n\r\n    if (queue.length !== 0) {\r\n      // if it's the first batch of cells to load\r\n      if (!this._loading) {\r\n        this._loading = true;\r\n      }\r\n\r\n      for (i = 0; i < queue.length; i++) {\r\n        var _key = this._cellCoordsToKey(queue[i]);\r\n        var _coords = this._keyToCellCoords(_key);\r\n        if (this._activeCells[_coords]) {\r\n          this._reuseCell(queue[i]);\r\n        } else {\r\n          this._createCell(queue[i]);\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  _isValidCell: function (coords) {\r\n    var crs = this._map.options.crs;\r\n\r\n    if (!crs.infinite) {\r\n      // don't load cell if it's out of bounds and not wrapped\r\n      var bounds = this._globalCellRange;\r\n      if (\r\n        (!crs.wrapLng &&\r\n          (coords.x < bounds.min.x || coords.x > bounds.max.x)) ||\r\n        (!crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y))\r\n      ) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    if (!this.options.bounds) {\r\n      return true;\r\n    }\r\n\r\n    // don't load cell if it doesn't intersect the bounds in options\r\n    var cellBounds = this._cellCoordsToBounds(coords);\r\n    return (0,leaflet__WEBPACK_IMPORTED_MODULE_0__.toLatLngBounds)(this.options.bounds).overlaps(cellBounds);\r\n  },\r\n\r\n  _keyToBounds: function (key) {\r\n    return this._cellCoordsToBounds(this._keyToCellCoords(key));\r\n  },\r\n\r\n  _cellCoordsToNwSe: function (coords) {\r\n    var map = this._map;\r\n    var cellSize = this.getCellSize();\r\n    var nwPoint = coords.scaleBy(cellSize);\r\n    var sePoint = nwPoint.add(cellSize);\r\n    var nw = map.unproject(nwPoint, coords.z);\r\n    var se = map.unproject(sePoint, coords.z);\r\n\r\n    return [nw, se];\r\n  },\r\n\r\n  // converts cell coordinates to its geographical bounds\r\n  _cellCoordsToBounds: function (coords) {\r\n    var bp = this._cellCoordsToNwSe(coords);\r\n    var bounds = new leaflet__WEBPACK_IMPORTED_MODULE_0__.LatLngBounds(bp[0], bp[1]);\r\n\r\n    if (!this.options.noWrap) {\r\n      bounds = this._map.wrapLatLngBounds(bounds);\r\n    }\r\n    return bounds;\r\n  },\r\n  // converts cell coordinates to key for the cell cache\r\n  _cellCoordsToKey: function (coords) {\r\n    return coords.x + ':' + coords.y + ':' + coords.z;\r\n  },\r\n\r\n  // converts cell cache key to coordinates\r\n  _keyToCellCoords: function (key) {\r\n    var k = key.split(':');\r\n    var coords = new leaflet__WEBPACK_IMPORTED_MODULE_0__.Point(+k[0], +k[1]);\r\n\r\n    coords.z = +k[2];\r\n    return coords;\r\n  },\r\n\r\n  _removeCell: function (key) {\r\n    var cell = this._cells[key];\r\n\r\n    if (!cell) {\r\n      return;\r\n    }\r\n\r\n    var coords = this._keyToCellCoords(key);\r\n    var wrappedCoords = this._wrapCoords(coords);\r\n    var cellBounds = this._cellCoordsToBounds(this._wrapCoords(coords));\r\n\r\n    cell.current = false;\r\n\r\n    delete this._cells[key];\r\n    this._activeCells[key] = cell;\r\n\r\n    this.cellLeave(cellBounds, wrappedCoords, key);\r\n\r\n    this.fire('cellleave', {\r\n      key: key,\r\n      coords: wrappedCoords,\r\n      bounds: cellBounds\r\n    });\r\n  },\r\n\r\n  _reuseCell: function (coords) {\r\n    var key = this._cellCoordsToKey(coords);\r\n\r\n    // save cell in cache\r\n    this._cells[key] = this._activeCells[key];\r\n    this._cells[key].current = true;\r\n\r\n    var wrappedCoords = this._wrapCoords(coords);\r\n    var cellBounds = this._cellCoordsToBounds(this._wrapCoords(coords));\r\n\r\n    this.cellEnter(cellBounds, wrappedCoords, key);\r\n\r\n    this.fire('cellenter', {\r\n      key: key,\r\n      coords: wrappedCoords,\r\n      bounds: cellBounds\r\n    });\r\n  },\r\n\r\n  _createCell: function (coords) {\r\n    var key = this._cellCoordsToKey(coords);\r\n\r\n    var wrappedCoords = this._wrapCoords(coords);\r\n    var cellBounds = this._cellCoordsToBounds(this._wrapCoords(coords));\r\n\r\n    this.createCell(cellBounds, wrappedCoords, key);\r\n\r\n    this.fire('cellcreate', {\r\n      key: key,\r\n      coords: wrappedCoords,\r\n      bounds: cellBounds\r\n    });\r\n\r\n    // save cell in cache\r\n    this._cells[key] = {\r\n      coords: coords,\r\n      current: true\r\n    };\r\n\r\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.requestAnimFrame(this._pruneCells, this);\r\n  },\r\n\r\n  _cellReady: function (coords, err, cell) {\r\n    var key = this._cellCoordsToKey(coords);\r\n\r\n    cell = this._cells[key];\r\n\r\n    if (!cell) {\r\n      return;\r\n    }\r\n\r\n    cell.loaded = +new Date();\r\n\r\n    cell.active = true;\r\n  },\r\n\r\n  _getCellPos: function (coords) {\r\n    return coords.scaleBy(this.getCellSize());\r\n  },\r\n\r\n  _wrapCoords: function (coords) {\r\n    var newCoords = new leaflet__WEBPACK_IMPORTED_MODULE_0__.Point(\r\n      this._wrapX ? leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.wrapNum(coords.x, this._wrapX) : coords.x,\r\n      this._wrapY ? leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.wrapNum(coords.y, this._wrapY) : coords.y\r\n    );\r\n    newCoords.z = coords.z;\r\n    return newCoords;\r\n  },\r\n\r\n  _pxBoundsToCellRange: function (bounds) {\r\n    var cellSize = this.getCellSize();\r\n    return new leaflet__WEBPACK_IMPORTED_MODULE_0__.Bounds(\r\n      bounds.min.unscaleBy(cellSize).floor(),\r\n      bounds.max.unscaleBy(cellSize).ceil().subtract([1, 1])\r\n    );\r\n  }\r\n});\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXNyaS1sZWFmbGV0L3NyYy9MYXllcnMvRmVhdHVyZUxheWVyL0ZlYXR1cmVHcmlkLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQVFpQjtBQUNqQjtBQUNPLGtCQUFrQixpREFBWTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbURBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUksb0RBQWU7QUFDbkIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0RBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBDQUFLLFdBQVcsMENBQUs7QUFDN0MsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDBDQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkMsMEJBQTBCLGVBQWU7QUFDekMseUJBQXlCLDBDQUFLO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkNBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwyQ0FBTTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDBDQUFLO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHNCQUFzQjtBQUN4RCxvQ0FBb0Msc0JBQXNCO0FBQzFELHlCQUF5QiwwQ0FBSztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVEQUFZO0FBQ3ZCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaURBQVk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMENBQUs7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwwREFBcUI7QUFDekIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esd0JBQXdCLDBDQUFLO0FBQzdCLG9CQUFvQixpREFBWTtBQUNoQyxvQkFBb0IsaURBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkNBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VzcmktbGVhZmxldC9zcmMvTGF5ZXJzL0ZlYXR1cmVMYXllci9GZWF0dXJlR3JpZC5qcz82NDZjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XHJcbiAgTGF0TG5nQm91bmRzLFxyXG4gIHRvTGF0TG5nQm91bmRzIGFzIGxhdExuZ0JvdW5kcyxcclxuICBMYXllcixcclxuICBCcm93c2VyLFxyXG4gIFV0aWwsXHJcbiAgUG9pbnQsXHJcbiAgQm91bmRzXHJcbn0gZnJvbSAnbGVhZmxldCc7XHJcblxyXG5leHBvcnQgdmFyIEZlYXR1cmVHcmlkID0gTGF5ZXIuZXh0ZW5kKHtcclxuICAvLyBAc2VjdGlvblxyXG4gIC8vIEBha2EgR3JpZExheWVyIG9wdGlvbnNcclxuICBvcHRpb25zOiB7XHJcbiAgICAvLyBAb3B0aW9uIGNlbGxTaXplOiBOdW1iZXJ8UG9pbnQgPSAyNTZcclxuICAgIC8vIFdpZHRoIGFuZCBoZWlnaHQgb2YgY2VsbHMgaW4gdGhlIGdyaWQuIFVzZSBhIG51bWJlciBpZiB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBlcXVhbCwgb3IgYEwucG9pbnQod2lkdGgsIGhlaWdodClgIG90aGVyd2lzZS5cclxuICAgIGNlbGxTaXplOiA1MTIsXHJcblxyXG4gICAgLy8gQG9wdGlvbiB1cGRhdGVXaGVuSWRsZTogQm9vbGVhbiA9IChkZXBlbmRzKVxyXG4gICAgLy8gTG9hZCBuZXcgY2VsbHMgb25seSB3aGVuIHBhbm5pbmcgZW5kcy5cclxuICAgIC8vIGB0cnVlYCBieSBkZWZhdWx0IG9uIG1vYmlsZSBicm93c2VycywgaW4gb3JkZXIgdG8gYXZvaWQgdG9vIG1hbnkgcmVxdWVzdHMgYW5kIGtlZXAgc21vb3RoIG5hdmlnYXRpb24uXHJcbiAgICAvLyBgZmFsc2VgIG90aGVyd2lzZSBpbiBvcmRlciB0byBkaXNwbGF5IG5ldyBjZWxscyBfZHVyaW5nXyBwYW5uaW5nLCBzaW5jZSBpdCBpcyBlYXN5IHRvIHBhbiBvdXRzaWRlIHRoZVxyXG4gICAgLy8gW2BrZWVwQnVmZmVyYF0oI2dyaWRsYXllci1rZWVwYnVmZmVyKSBvcHRpb24gaW4gZGVza3RvcCBicm93c2Vycy5cclxuICAgIHVwZGF0ZVdoZW5JZGxlOiBCcm93c2VyLm1vYmlsZSxcclxuXHJcbiAgICAvLyBAb3B0aW9uIHVwZGF0ZUludGVydmFsOiBOdW1iZXIgPSAxNTBcclxuICAgIC8vIENlbGxzIHdpbGwgbm90IHVwZGF0ZSBtb3JlIHRoYW4gb25jZSBldmVyeSBgdXBkYXRlSW50ZXJ2YWxgIG1pbGxpc2Vjb25kcyB3aGVuIHBhbm5pbmcuXHJcbiAgICB1cGRhdGVJbnRlcnZhbDogMTUwLFxyXG5cclxuICAgIC8vIEBvcHRpb24gbm9XcmFwOiBCb29sZWFuID0gZmFsc2VcclxuICAgIC8vIFdoZXRoZXIgdGhlIGxheWVyIGlzIHdyYXBwZWQgYXJvdW5kIHRoZSBhbnRpbWVyaWRpYW4uIElmIGB0cnVlYCwgdGhlXHJcbiAgICAvLyBHcmlkTGF5ZXIgd2lsbCBvbmx5IGJlIGRpc3BsYXllZCBvbmNlIGF0IGxvdyB6b29tIGxldmVscy4gSGFzIG5vXHJcbiAgICAvLyBlZmZlY3Qgd2hlbiB0aGUgW21hcCBDUlNdKCNtYXAtY3JzKSBkb2Vzbid0IHdyYXAgYXJvdW5kLiBDYW4gYmUgdXNlZFxyXG4gICAgLy8gaW4gY29tYmluYXRpb24gd2l0aCBbYGJvdW5kc2BdKCNncmlkbGF5ZXItYm91bmRzKSB0byBwcmV2ZW50IHJlcXVlc3RpbmdcclxuICAgIC8vIGNlbGxzIG91dHNpZGUgdGhlIENSUyBsaW1pdHMuXHJcbiAgICBub1dyYXA6IGZhbHNlLFxyXG5cclxuICAgIC8vIEBvcHRpb24ga2VlcEJ1ZmZlcjogTnVtYmVyID0gMS41XHJcbiAgICAvLyBXaGVuIHBhbm5pbmcgdGhlIG1hcCwga2VlcCB0aGlzIG1hbnkgcm93cyBhbmQgY29sdW1ucyBvZiBjZWxscyBiZWZvcmUgdW5sb2FkaW5nIHRoZW0uXHJcbiAgICBrZWVwQnVmZmVyOiAxLjVcclxuICB9LFxyXG5cclxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG4gIH0sXHJcblxyXG4gIG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgICB0aGlzLl9jZWxscyA9IHt9O1xyXG4gICAgdGhpcy5fYWN0aXZlQ2VsbHMgPSB7fTtcclxuICAgIHRoaXMuX3Jlc2V0VmlldygpO1xyXG4gICAgdGhpcy5fdXBkYXRlKCk7XHJcbiAgfSxcclxuXHJcbiAgb25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuICAgIHRoaXMuX3JlbW92ZUFsbENlbGxzKCk7XHJcbiAgICB0aGlzLl9jZWxsWm9vbSA9IHVuZGVmaW5lZDtcclxuICB9LFxyXG5cclxuICAvLyBAbWV0aG9kIGlzTG9hZGluZzogQm9vbGVhblxyXG4gIC8vIFJldHVybnMgYHRydWVgIGlmIGFueSBjZWxsIGluIHRoZSBncmlkIGxheWVyIGhhcyBub3QgZmluaXNoZWQgbG9hZGluZy5cclxuICBpc0xvYWRpbmc6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLl9sb2FkaW5nO1xyXG4gIH0sXHJcblxyXG4gIC8vIEBtZXRob2QgcmVkcmF3OiB0aGlzXHJcbiAgLy8gQ2F1c2VzIHRoZSBsYXllciB0byBjbGVhciBhbGwgdGhlIGNlbGxzIGFuZCByZXF1ZXN0IHRoZW0gYWdhaW4uXHJcbiAgcmVkcmF3OiBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodGhpcy5fbWFwKSB7XHJcbiAgICAgIHRoaXMuX3JlbW92ZUFsbENlbGxzKCk7XHJcbiAgICAgIHRoaXMuX3VwZGF0ZSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuXHJcbiAgZ2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXZlbnRzID0ge1xyXG4gICAgICB2aWV3cHJlcmVzZXQ6IHRoaXMuX2ludmFsaWRhdGVBbGwsXHJcbiAgICAgIHZpZXdyZXNldDogdGhpcy5fcmVzZXRWaWV3LFxyXG4gICAgICB6b29tOiB0aGlzLl9yZXNldFZpZXcsXHJcbiAgICAgIG1vdmVlbmQ6IHRoaXMuX29uTW92ZUVuZFxyXG4gICAgfTtcclxuXHJcbiAgICBpZiAoIXRoaXMub3B0aW9ucy51cGRhdGVXaGVuSWRsZSkge1xyXG4gICAgICAvLyB1cGRhdGUgY2VsbHMgb24gbW92ZSwgYnV0IG5vdCBtb3JlIG9mdGVuIHRoYW4gb25jZSBwZXIgZ2l2ZW4gaW50ZXJ2YWxcclxuICAgICAgaWYgKCF0aGlzLl9vbk1vdmUpIHtcclxuICAgICAgICB0aGlzLl9vbk1vdmUgPSBVdGlsLnRocm90dGxlKFxyXG4gICAgICAgICAgdGhpcy5fb25Nb3ZlRW5kLFxyXG4gICAgICAgICAgdGhpcy5vcHRpb25zLnVwZGF0ZUludGVydmFsLFxyXG4gICAgICAgICAgdGhpc1xyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGV2ZW50cy5tb3ZlID0gdGhpcy5fb25Nb3ZlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBldmVudHM7XHJcbiAgfSxcclxuXHJcbiAgLy8gQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcclxuICAvLyBMYXllcnMgZXh0ZW5kaW5nIGBHcmlkTGF5ZXJgIHNoYWxsIHJlaW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgbWV0aG9kLlxyXG4gIC8vIEBtZXRob2QgY3JlYXRlQ2VsbChjb29yZHM6IE9iamVjdCwgZG9uZT86IEZ1bmN0aW9uKTogSFRNTEVsZW1lbnRcclxuICAvLyBDYWxsZWQgb25seSBpbnRlcm5hbGx5LCBtdXN0IGJlIG92ZXJyaWRkZW4gYnkgY2xhc3NlcyBleHRlbmRpbmcgYEdyaWRMYXllcmAuXHJcbiAgLy8gUmV0dXJucyB0aGUgYEhUTUxFbGVtZW50YCBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBgY29vcmRzYC4gSWYgdGhlIGBkb25lYCBjYWxsYmFja1xyXG4gIC8vIGlzIHNwZWNpZmllZCwgaXQgbXVzdCBiZSBjYWxsZWQgd2hlbiB0aGUgY2VsbCBoYXMgZmluaXNoZWQgbG9hZGluZyBhbmQgZHJhd2luZy5cclxuICBjcmVhdGVDZWxsOiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgfSxcclxuXHJcbiAgcmVtb3ZlQ2VsbDogZnVuY3Rpb24gKCkge1xyXG5cclxuICB9LFxyXG5cclxuICByZXVzZUNlbGw6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgfSxcclxuXHJcbiAgY2VsbExlYXZlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gIH0sXHJcblxyXG4gIGNlbGxFbnRlcjogZnVuY3Rpb24gKCkge1xyXG5cclxuICB9LFxyXG4gIC8vIEBzZWN0aW9uXHJcbiAgLy8gQG1ldGhvZCBnZXRDZWxsU2l6ZTogUG9pbnRcclxuICAvLyBOb3JtYWxpemVzIHRoZSBbY2VsbFNpemUgb3B0aW9uXSgjZ3JpZGxheWVyLWNlbGxzaXplKSBpbnRvIGEgcG9pbnQuIFVzZWQgYnkgdGhlIGBjcmVhdGVDZWxsKClgIG1ldGhvZC5cclxuICBnZXRDZWxsU2l6ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHMgPSB0aGlzLm9wdGlvbnMuY2VsbFNpemU7XHJcbiAgICByZXR1cm4gcyBpbnN0YW5jZW9mIFBvaW50ID8gcyA6IG5ldyBQb2ludChzLCBzKTtcclxuICB9LFxyXG5cclxuICBfcHJ1bmVDZWxsczogZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKCF0aGlzLl9tYXApIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBrZXksIGNlbGw7XHJcblxyXG4gICAgZm9yIChrZXkgaW4gdGhpcy5fY2VsbHMpIHtcclxuICAgICAgY2VsbCA9IHRoaXMuX2NlbGxzW2tleV07XHJcbiAgICAgIGNlbGwucmV0YWluID0gY2VsbC5jdXJyZW50O1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAoa2V5IGluIHRoaXMuX2NlbGxzKSB7XHJcbiAgICAgIGNlbGwgPSB0aGlzLl9jZWxsc1trZXldO1xyXG4gICAgICBpZiAoY2VsbC5jdXJyZW50ICYmICFjZWxsLmFjdGl2ZSkge1xyXG4gICAgICAgIHZhciBjb29yZHMgPSBjZWxsLmNvb3JkcztcclxuICAgICAgICBpZiAoIXRoaXMuX3JldGFpblBhcmVudChjb29yZHMueCwgY29vcmRzLnksIGNvb3Jkcy56LCBjb29yZHMueiAtIDUpKSB7XHJcbiAgICAgICAgICB0aGlzLl9yZXRhaW5DaGlsZHJlbihjb29yZHMueCwgY29vcmRzLnksIGNvb3Jkcy56LCBjb29yZHMueiArIDIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZvciAoa2V5IGluIHRoaXMuX2NlbGxzKSB7XHJcbiAgICAgIGlmICghdGhpcy5fY2VsbHNba2V5XS5yZXRhaW4pIHtcclxuICAgICAgICB0aGlzLl9yZW1vdmVDZWxsKGtleSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG5cclxuICBfcmVtb3ZlQWxsQ2VsbHM6IGZ1bmN0aW9uICgpIHtcclxuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl9jZWxscykge1xyXG4gICAgICB0aGlzLl9yZW1vdmVDZWxsKGtleSk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgX2ludmFsaWRhdGVBbGw6IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuX3JlbW92ZUFsbENlbGxzKCk7XHJcblxyXG4gICAgdGhpcy5fY2VsbFpvb20gPSB1bmRlZmluZWQ7XHJcbiAgfSxcclxuXHJcbiAgX3JldGFpblBhcmVudDogZnVuY3Rpb24gKHgsIHksIHosIG1pblpvb20pIHtcclxuICAgIHZhciB4MiA9IE1hdGguZmxvb3IoeCAvIDIpO1xyXG4gICAgdmFyIHkyID0gTWF0aC5mbG9vcih5IC8gMik7XHJcbiAgICB2YXIgejIgPSB6IC0gMTtcclxuICAgIHZhciBjb29yZHMyID0gbmV3IFBvaW50KCt4MiwgK3kyKTtcclxuICAgIGNvb3JkczIueiA9ICt6MjtcclxuXHJcbiAgICB2YXIga2V5ID0gdGhpcy5fY2VsbENvb3Jkc1RvS2V5KGNvb3JkczIpO1xyXG4gICAgdmFyIGNlbGwgPSB0aGlzLl9jZWxsc1trZXldO1xyXG5cclxuICAgIGlmIChjZWxsICYmIGNlbGwuYWN0aXZlKSB7XHJcbiAgICAgIGNlbGwucmV0YWluID0gdHJ1ZTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9IGVsc2UgaWYgKGNlbGwgJiYgY2VsbC5sb2FkZWQpIHtcclxuICAgICAgY2VsbC5yZXRhaW4gPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh6MiA+IG1pblpvb20pIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX3JldGFpblBhcmVudCh4MiwgeTIsIHoyLCBtaW5ab29tKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfSxcclxuXHJcbiAgX3JldGFpbkNoaWxkcmVuOiBmdW5jdGlvbiAoeCwgeSwgeiwgbWF4Wm9vbSkge1xyXG4gICAgZm9yICh2YXIgaSA9IDIgKiB4OyBpIDwgMiAqIHggKyAyOyBpKyspIHtcclxuICAgICAgZm9yICh2YXIgaiA9IDIgKiB5OyBqIDwgMiAqIHkgKyAyOyBqKyspIHtcclxuICAgICAgICB2YXIgY29vcmRzID0gbmV3IFBvaW50KGksIGopO1xyXG4gICAgICAgIGNvb3Jkcy56ID0geiArIDE7XHJcblxyXG4gICAgICAgIHZhciBrZXkgPSB0aGlzLl9jZWxsQ29vcmRzVG9LZXkoY29vcmRzKTtcclxuICAgICAgICB2YXIgY2VsbCA9IHRoaXMuX2NlbGxzW2tleV07XHJcblxyXG4gICAgICAgIGlmIChjZWxsICYmIGNlbGwuYWN0aXZlKSB7XHJcbiAgICAgICAgICBjZWxsLnJldGFpbiA9IHRydWU7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9IGVsc2UgaWYgKGNlbGwgJiYgY2VsbC5sb2FkZWQpIHtcclxuICAgICAgICAgIGNlbGwucmV0YWluID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh6ICsgMSA8IG1heFpvb20pIHtcclxuICAgICAgICAgIHRoaXMuX3JldGFpbkNoaWxkcmVuKGksIGosIHogKyAxLCBtYXhab29tKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG5cclxuICBfcmVzZXRWaWV3OiBmdW5jdGlvbiAoZSkge1xyXG4gICAgdmFyIGFuaW1hdGluZyA9IGUgJiYgKGUucGluY2ggfHwgZS5mbHlUbyk7XHJcblxyXG4gICAgaWYgKGFuaW1hdGluZykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fc2V0VmlldyhcclxuICAgICAgdGhpcy5fbWFwLmdldENlbnRlcigpLFxyXG4gICAgICB0aGlzLl9tYXAuZ2V0Wm9vbSgpLFxyXG4gICAgICBhbmltYXRpbmcsXHJcbiAgICAgIGFuaW1hdGluZ1xyXG4gICAgKTtcclxuICB9LFxyXG5cclxuICBfc2V0VmlldzogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgbm9QcnVuZSwgbm9VcGRhdGUpIHtcclxuICAgIHZhciBjZWxsWm9vbSA9IE1hdGgucm91bmQoem9vbSk7XHJcblxyXG4gICAgaWYgKCFub1VwZGF0ZSkge1xyXG4gICAgICB0aGlzLl9jZWxsWm9vbSA9IGNlbGxab29tO1xyXG5cclxuICAgICAgaWYgKHRoaXMuX2Fib3J0TG9hZGluZykge1xyXG4gICAgICAgIHRoaXMuX2Fib3J0TG9hZGluZygpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLl9yZXNldEdyaWQoKTtcclxuXHJcbiAgICAgIGlmIChjZWxsWm9vbSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlKGNlbnRlcik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghbm9QcnVuZSkge1xyXG4gICAgICAgIHRoaXMuX3BydW5lQ2VsbHMoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRmxhZyB0byBwcmV2ZW50IF91cGRhdGVPcGFjaXR5IGZyb20gcHJ1bmluZyBjZWxscyBkdXJpbmdcclxuICAgICAgLy8gYSB6b29tIGFuaW0gb3IgYSBwaW5jaCBnZXN0dXJlXHJcbiAgICAgIHRoaXMuX25vUHJ1bmUgPSAhIW5vUHJ1bmU7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgX3Jlc2V0R3JpZDogZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIG1hcCA9IHRoaXMuX21hcDtcclxuICAgIHZhciBjcnMgPSBtYXAub3B0aW9ucy5jcnM7XHJcbiAgICB2YXIgY2VsbFNpemUgPSAodGhpcy5fY2VsbFNpemUgPSB0aGlzLmdldENlbGxTaXplKCkpO1xyXG4gICAgdmFyIGNlbGxab29tID0gdGhpcy5fY2VsbFpvb207XHJcblxyXG4gICAgdmFyIGJvdW5kcyA9IHRoaXMuX21hcC5nZXRQaXhlbFdvcmxkQm91bmRzKHRoaXMuX2NlbGxab29tKTtcclxuICAgIGlmIChib3VuZHMpIHtcclxuICAgICAgdGhpcy5fZ2xvYmFsQ2VsbFJhbmdlID0gdGhpcy5fcHhCb3VuZHNUb0NlbGxSYW5nZShib3VuZHMpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX3dyYXBYID0gY3JzLndyYXBMbmcgJiZcclxuICAgICAgIXRoaXMub3B0aW9ucy5ub1dyYXAgJiYgW1xyXG4gICAgICBNYXRoLmZsb29yKG1hcC5wcm9qZWN0KFswLCBjcnMud3JhcExuZ1swXV0sIGNlbGxab29tKS54IC8gY2VsbFNpemUueCksXHJcbiAgICAgIE1hdGguY2VpbChtYXAucHJvamVjdChbMCwgY3JzLndyYXBMbmdbMV1dLCBjZWxsWm9vbSkueCAvIGNlbGxTaXplLnkpXHJcbiAgICBdO1xyXG4gICAgdGhpcy5fd3JhcFkgPSBjcnMud3JhcExhdCAmJlxyXG4gICAgICAhdGhpcy5vcHRpb25zLm5vV3JhcCAmJiBbXHJcbiAgICAgIE1hdGguZmxvb3IobWFwLnByb2plY3QoW2Nycy53cmFwTGF0WzBdLCAwXSwgY2VsbFpvb20pLnkgLyBjZWxsU2l6ZS54KSxcclxuICAgICAgTWF0aC5jZWlsKG1hcC5wcm9qZWN0KFtjcnMud3JhcExhdFsxXSwgMF0sIGNlbGxab29tKS55IC8gY2VsbFNpemUueSlcclxuICAgIF07XHJcbiAgfSxcclxuXHJcbiAgX29uTW92ZUVuZDogZnVuY3Rpb24gKGUpIHtcclxuICAgIHZhciBhbmltYXRpbmcgPSBlICYmIChlLnBpbmNoIHx8IGUuZmx5VG8pO1xyXG5cclxuICAgIGlmIChhbmltYXRpbmcgfHwgIXRoaXMuX21hcCB8fCB0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20pIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX3VwZGF0ZSgpO1xyXG4gIH0sXHJcblxyXG4gIF9nZXRDZWxsZFBpeGVsQm91bmRzOiBmdW5jdGlvbiAoY2VudGVyKSB7XHJcbiAgICB2YXIgbWFwID0gdGhpcy5fbWFwO1xyXG4gICAgdmFyIG1hcFpvb20gPSBtYXAuX2FuaW1hdGluZ1pvb21cclxuICAgICAgPyBNYXRoLm1heChtYXAuX2FuaW1hdGVUb1pvb20sIG1hcC5nZXRab29tKCkpXHJcbiAgICAgIDogbWFwLmdldFpvb20oKTtcclxuICAgIHZhciBzY2FsZSA9IG1hcC5nZXRab29tU2NhbGUobWFwWm9vbSwgdGhpcy5fY2VsbFpvb20pO1xyXG4gICAgdmFyIHBpeGVsQ2VudGVyID0gbWFwLnByb2plY3QoY2VudGVyLCB0aGlzLl9jZWxsWm9vbSkuZmxvb3IoKTtcclxuICAgIHZhciBoYWxmU2l6ZSA9IG1hcC5nZXRTaXplKCkuZGl2aWRlQnkoc2NhbGUgKiAyKTtcclxuXHJcbiAgICByZXR1cm4gbmV3IEJvdW5kcyhcclxuICAgICAgcGl4ZWxDZW50ZXIuc3VidHJhY3QoaGFsZlNpemUpLFxyXG4gICAgICBwaXhlbENlbnRlci5hZGQoaGFsZlNpemUpXHJcbiAgICApO1xyXG4gIH0sXHJcblxyXG4gIC8vIFByaXZhdGUgbWV0aG9kIHRvIGxvYWQgY2VsbHMgaW4gdGhlIGdyaWQncyBhY3RpdmUgem9vbSBsZXZlbCBhY2NvcmRpbmcgdG8gbWFwIGJvdW5kc1xyXG4gIF91cGRhdGU6IGZ1bmN0aW9uIChjZW50ZXIpIHtcclxuICAgIHZhciBtYXAgPSB0aGlzLl9tYXA7XHJcbiAgICBpZiAoIW1hcCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgem9vbSA9IE1hdGgucm91bmQobWFwLmdldFpvb20oKSk7XHJcblxyXG4gICAgaWYgKGNlbnRlciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGNlbnRlciA9IG1hcC5nZXRDZW50ZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcGl4ZWxCb3VuZHMgPSB0aGlzLl9nZXRDZWxsZFBpeGVsQm91bmRzKGNlbnRlcik7XHJcbiAgICB2YXIgY2VsbFJhbmdlID0gdGhpcy5fcHhCb3VuZHNUb0NlbGxSYW5nZShwaXhlbEJvdW5kcyk7XHJcbiAgICB2YXIgY2VsbENlbnRlciA9IGNlbGxSYW5nZS5nZXRDZW50ZXIoKTtcclxuICAgIHZhciBxdWV1ZSA9IFtdO1xyXG4gICAgdmFyIG1hcmdpbiA9IHRoaXMub3B0aW9ucy5rZWVwQnVmZmVyO1xyXG4gICAgdmFyIG5vUHJ1bmVSYW5nZSA9IG5ldyBCb3VuZHMoXHJcbiAgICAgIGNlbGxSYW5nZS5nZXRCb3R0b21MZWZ0KCkuc3VidHJhY3QoW21hcmdpbiwgLW1hcmdpbl0pLFxyXG4gICAgICBjZWxsUmFuZ2UuZ2V0VG9wUmlnaHQoKS5hZGQoW21hcmdpbiwgLW1hcmdpbl0pXHJcbiAgICApO1xyXG5cclxuICAgIC8vIFNhbml0eSBjaGVjazogcGFuaWMgaWYgdGhlIGNlbGwgcmFuZ2UgY29udGFpbnMgSW5maW5pdHkgc29tZXdoZXJlLlxyXG4gICAgaWYgKFxyXG4gICAgICAhKFxyXG4gICAgICAgIGlzRmluaXRlKGNlbGxSYW5nZS5taW4ueCkgJiZcclxuICAgICAgICBpc0Zpbml0ZShjZWxsUmFuZ2UubWluLnkpICYmXHJcbiAgICAgICAgaXNGaW5pdGUoY2VsbFJhbmdlLm1heC54KSAmJlxyXG4gICAgICAgIGlzRmluaXRlKGNlbGxSYW5nZS5tYXgueSlcclxuICAgICAgKVxyXG4gICAgKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHRvIGxvYWQgYW4gaW5maW5pdGUgbnVtYmVyIG9mIGNlbGxzJyk7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuX2NlbGxzKSB7XHJcbiAgICAgIHZhciBjID0gdGhpcy5fY2VsbHNba2V5XS5jb29yZHM7XHJcbiAgICAgIGlmIChcclxuICAgICAgICBjLnogIT09IHRoaXMuX2NlbGxab29tIHx8XHJcbiAgICAgICAgIW5vUHJ1bmVSYW5nZS5jb250YWlucyhuZXcgUG9pbnQoYy54LCBjLnkpKVxyXG4gICAgICApIHtcclxuICAgICAgICB0aGlzLl9jZWxsc1trZXldLmN1cnJlbnQgPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIF91cGRhdGUganVzdCBsb2FkcyBtb3JlIGNlbGxzLiBJZiB0aGUgY2VsbCB6b29tIGxldmVsIGRpZmZlcnMgdG9vIG11Y2hcclxuICAgIC8vIGZyb20gdGhlIG1hcCdzLCBsZXQgX3NldFZpZXcgcmVzZXQgbGV2ZWxzIGFuZCBwcnVuZSBvbGQgY2VsbHMuXHJcbiAgICBpZiAoTWF0aC5hYnMoem9vbSAtIHRoaXMuX2NlbGxab29tKSA+IDEpIHtcclxuICAgICAgdGhpcy5fc2V0VmlldyhjZW50ZXIsIHpvb20pO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY3JlYXRlIGEgcXVldWUgb2YgY29vcmRpbmF0ZXMgdG8gbG9hZCBjZWxscyBmcm9tXHJcbiAgICBmb3IgKHZhciBqID0gY2VsbFJhbmdlLm1pbi55OyBqIDw9IGNlbGxSYW5nZS5tYXgueTsgaisrKSB7XHJcbiAgICAgIGZvciAodmFyIGkgPSBjZWxsUmFuZ2UubWluLng7IGkgPD0gY2VsbFJhbmdlLm1heC54OyBpKyspIHtcclxuICAgICAgICB2YXIgY29vcmRzID0gbmV3IFBvaW50KGksIGopO1xyXG4gICAgICAgIGNvb3Jkcy56ID0gdGhpcy5fY2VsbFpvb207XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5faXNWYWxpZENlbGwoY29vcmRzKSkge1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgY2VsbCA9IHRoaXMuX2NlbGxzW3RoaXMuX2NlbGxDb29yZHNUb0tleShjb29yZHMpXTtcclxuICAgICAgICBpZiAoY2VsbCkge1xyXG4gICAgICAgICAgY2VsbC5jdXJyZW50ID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcXVldWUucHVzaChjb29yZHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHNvcnQgY2VsbCBxdWV1ZSB0byBsb2FkIGNlbGxzIGluIG9yZGVyIG9mIHRoZWlyIGRpc3RhbmNlIHRvIGNlbnRlclxyXG4gICAgcXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICByZXR1cm4gYS5kaXN0YW5jZVRvKGNlbGxDZW50ZXIpIC0gYi5kaXN0YW5jZVRvKGNlbGxDZW50ZXIpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKHF1ZXVlLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAvLyBpZiBpdCdzIHRoZSBmaXJzdCBiYXRjaCBvZiBjZWxscyB0byBsb2FkXHJcbiAgICAgIGlmICghdGhpcy5fbG9hZGluZykge1xyXG4gICAgICAgIHRoaXMuX2xvYWRpbmcgPSB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgX2tleSA9IHRoaXMuX2NlbGxDb29yZHNUb0tleShxdWV1ZVtpXSk7XHJcbiAgICAgICAgdmFyIF9jb29yZHMgPSB0aGlzLl9rZXlUb0NlbGxDb29yZHMoX2tleSk7XHJcbiAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZUNlbGxzW19jb29yZHNdKSB7XHJcbiAgICAgICAgICB0aGlzLl9yZXVzZUNlbGwocXVldWVbaV0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLl9jcmVhdGVDZWxsKHF1ZXVlW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG5cclxuICBfaXNWYWxpZENlbGw6IGZ1bmN0aW9uIChjb29yZHMpIHtcclxuICAgIHZhciBjcnMgPSB0aGlzLl9tYXAub3B0aW9ucy5jcnM7XHJcblxyXG4gICAgaWYgKCFjcnMuaW5maW5pdGUpIHtcclxuICAgICAgLy8gZG9uJ3QgbG9hZCBjZWxsIGlmIGl0J3Mgb3V0IG9mIGJvdW5kcyBhbmQgbm90IHdyYXBwZWRcclxuICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuX2dsb2JhbENlbGxSYW5nZTtcclxuICAgICAgaWYgKFxyXG4gICAgICAgICghY3JzLndyYXBMbmcgJiZcclxuICAgICAgICAgIChjb29yZHMueCA8IGJvdW5kcy5taW4ueCB8fCBjb29yZHMueCA+IGJvdW5kcy5tYXgueCkpIHx8XHJcbiAgICAgICAgKCFjcnMud3JhcExhdCAmJiAoY29vcmRzLnkgPCBib3VuZHMubWluLnkgfHwgY29vcmRzLnkgPiBib3VuZHMubWF4LnkpKVxyXG4gICAgICApIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5ib3VuZHMpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZG9uJ3QgbG9hZCBjZWxsIGlmIGl0IGRvZXNuJ3QgaW50ZXJzZWN0IHRoZSBib3VuZHMgaW4gb3B0aW9uc1xyXG4gICAgdmFyIGNlbGxCb3VuZHMgPSB0aGlzLl9jZWxsQ29vcmRzVG9Cb3VuZHMoY29vcmRzKTtcclxuICAgIHJldHVybiBsYXRMbmdCb3VuZHModGhpcy5vcHRpb25zLmJvdW5kcykub3ZlcmxhcHMoY2VsbEJvdW5kcyk7XHJcbiAgfSxcclxuXHJcbiAgX2tleVRvQm91bmRzOiBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICByZXR1cm4gdGhpcy5fY2VsbENvb3Jkc1RvQm91bmRzKHRoaXMuX2tleVRvQ2VsbENvb3JkcyhrZXkpKTtcclxuICB9LFxyXG5cclxuICBfY2VsbENvb3Jkc1RvTndTZTogZnVuY3Rpb24gKGNvb3Jkcykge1xyXG4gICAgdmFyIG1hcCA9IHRoaXMuX21hcDtcclxuICAgIHZhciBjZWxsU2l6ZSA9IHRoaXMuZ2V0Q2VsbFNpemUoKTtcclxuICAgIHZhciBud1BvaW50ID0gY29vcmRzLnNjYWxlQnkoY2VsbFNpemUpO1xyXG4gICAgdmFyIHNlUG9pbnQgPSBud1BvaW50LmFkZChjZWxsU2l6ZSk7XHJcbiAgICB2YXIgbncgPSBtYXAudW5wcm9qZWN0KG53UG9pbnQsIGNvb3Jkcy56KTtcclxuICAgIHZhciBzZSA9IG1hcC51bnByb2plY3Qoc2VQb2ludCwgY29vcmRzLnopO1xyXG5cclxuICAgIHJldHVybiBbbncsIHNlXTtcclxuICB9LFxyXG5cclxuICAvLyBjb252ZXJ0cyBjZWxsIGNvb3JkaW5hdGVzIHRvIGl0cyBnZW9ncmFwaGljYWwgYm91bmRzXHJcbiAgX2NlbGxDb29yZHNUb0JvdW5kczogZnVuY3Rpb24gKGNvb3Jkcykge1xyXG4gICAgdmFyIGJwID0gdGhpcy5fY2VsbENvb3Jkc1RvTndTZShjb29yZHMpO1xyXG4gICAgdmFyIGJvdW5kcyA9IG5ldyBMYXRMbmdCb3VuZHMoYnBbMF0sIGJwWzFdKTtcclxuXHJcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5ub1dyYXApIHtcclxuICAgICAgYm91bmRzID0gdGhpcy5fbWFwLndyYXBMYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBib3VuZHM7XHJcbiAgfSxcclxuICAvLyBjb252ZXJ0cyBjZWxsIGNvb3JkaW5hdGVzIHRvIGtleSBmb3IgdGhlIGNlbGwgY2FjaGVcclxuICBfY2VsbENvb3Jkc1RvS2V5OiBmdW5jdGlvbiAoY29vcmRzKSB7XHJcbiAgICByZXR1cm4gY29vcmRzLnggKyAnOicgKyBjb29yZHMueSArICc6JyArIGNvb3Jkcy56O1xyXG4gIH0sXHJcblxyXG4gIC8vIGNvbnZlcnRzIGNlbGwgY2FjaGUga2V5IHRvIGNvb3JkaW5hdGVzXHJcbiAgX2tleVRvQ2VsbENvb3JkczogZnVuY3Rpb24gKGtleSkge1xyXG4gICAgdmFyIGsgPSBrZXkuc3BsaXQoJzonKTtcclxuICAgIHZhciBjb29yZHMgPSBuZXcgUG9pbnQoK2tbMF0sICtrWzFdKTtcclxuXHJcbiAgICBjb29yZHMueiA9ICtrWzJdO1xyXG4gICAgcmV0dXJuIGNvb3JkcztcclxuICB9LFxyXG5cclxuICBfcmVtb3ZlQ2VsbDogZnVuY3Rpb24gKGtleSkge1xyXG4gICAgdmFyIGNlbGwgPSB0aGlzLl9jZWxsc1trZXldO1xyXG5cclxuICAgIGlmICghY2VsbCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGNvb3JkcyA9IHRoaXMuX2tleVRvQ2VsbENvb3JkcyhrZXkpO1xyXG4gICAgdmFyIHdyYXBwZWRDb29yZHMgPSB0aGlzLl93cmFwQ29vcmRzKGNvb3Jkcyk7XHJcbiAgICB2YXIgY2VsbEJvdW5kcyA9IHRoaXMuX2NlbGxDb29yZHNUb0JvdW5kcyh0aGlzLl93cmFwQ29vcmRzKGNvb3JkcykpO1xyXG5cclxuICAgIGNlbGwuY3VycmVudCA9IGZhbHNlO1xyXG5cclxuICAgIGRlbGV0ZSB0aGlzLl9jZWxsc1trZXldO1xyXG4gICAgdGhpcy5fYWN0aXZlQ2VsbHNba2V5XSA9IGNlbGw7XHJcblxyXG4gICAgdGhpcy5jZWxsTGVhdmUoY2VsbEJvdW5kcywgd3JhcHBlZENvb3Jkcywga2V5KTtcclxuXHJcbiAgICB0aGlzLmZpcmUoJ2NlbGxsZWF2ZScsIHtcclxuICAgICAga2V5OiBrZXksXHJcbiAgICAgIGNvb3Jkczogd3JhcHBlZENvb3JkcyxcclxuICAgICAgYm91bmRzOiBjZWxsQm91bmRzXHJcbiAgICB9KTtcclxuICB9LFxyXG5cclxuICBfcmV1c2VDZWxsOiBmdW5jdGlvbiAoY29vcmRzKSB7XHJcbiAgICB2YXIga2V5ID0gdGhpcy5fY2VsbENvb3Jkc1RvS2V5KGNvb3Jkcyk7XHJcblxyXG4gICAgLy8gc2F2ZSBjZWxsIGluIGNhY2hlXHJcbiAgICB0aGlzLl9jZWxsc1trZXldID0gdGhpcy5fYWN0aXZlQ2VsbHNba2V5XTtcclxuICAgIHRoaXMuX2NlbGxzW2tleV0uY3VycmVudCA9IHRydWU7XHJcblxyXG4gICAgdmFyIHdyYXBwZWRDb29yZHMgPSB0aGlzLl93cmFwQ29vcmRzKGNvb3Jkcyk7XHJcbiAgICB2YXIgY2VsbEJvdW5kcyA9IHRoaXMuX2NlbGxDb29yZHNUb0JvdW5kcyh0aGlzLl93cmFwQ29vcmRzKGNvb3JkcykpO1xyXG5cclxuICAgIHRoaXMuY2VsbEVudGVyKGNlbGxCb3VuZHMsIHdyYXBwZWRDb29yZHMsIGtleSk7XHJcblxyXG4gICAgdGhpcy5maXJlKCdjZWxsZW50ZXInLCB7XHJcbiAgICAgIGtleToga2V5LFxyXG4gICAgICBjb29yZHM6IHdyYXBwZWRDb29yZHMsXHJcbiAgICAgIGJvdW5kczogY2VsbEJvdW5kc1xyXG4gICAgfSk7XHJcbiAgfSxcclxuXHJcbiAgX2NyZWF0ZUNlbGw6IGZ1bmN0aW9uIChjb29yZHMpIHtcclxuICAgIHZhciBrZXkgPSB0aGlzLl9jZWxsQ29vcmRzVG9LZXkoY29vcmRzKTtcclxuXHJcbiAgICB2YXIgd3JhcHBlZENvb3JkcyA9IHRoaXMuX3dyYXBDb29yZHMoY29vcmRzKTtcclxuICAgIHZhciBjZWxsQm91bmRzID0gdGhpcy5fY2VsbENvb3Jkc1RvQm91bmRzKHRoaXMuX3dyYXBDb29yZHMoY29vcmRzKSk7XHJcblxyXG4gICAgdGhpcy5jcmVhdGVDZWxsKGNlbGxCb3VuZHMsIHdyYXBwZWRDb29yZHMsIGtleSk7XHJcblxyXG4gICAgdGhpcy5maXJlKCdjZWxsY3JlYXRlJywge1xyXG4gICAgICBrZXk6IGtleSxcclxuICAgICAgY29vcmRzOiB3cmFwcGVkQ29vcmRzLFxyXG4gICAgICBib3VuZHM6IGNlbGxCb3VuZHNcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIHNhdmUgY2VsbCBpbiBjYWNoZVxyXG4gICAgdGhpcy5fY2VsbHNba2V5XSA9IHtcclxuICAgICAgY29vcmRzOiBjb29yZHMsXHJcbiAgICAgIGN1cnJlbnQ6IHRydWVcclxuICAgIH07XHJcblxyXG4gICAgVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3BydW5lQ2VsbHMsIHRoaXMpO1xyXG4gIH0sXHJcblxyXG4gIF9jZWxsUmVhZHk6IGZ1bmN0aW9uIChjb29yZHMsIGVyciwgY2VsbCkge1xyXG4gICAgdmFyIGtleSA9IHRoaXMuX2NlbGxDb29yZHNUb0tleShjb29yZHMpO1xyXG5cclxuICAgIGNlbGwgPSB0aGlzLl9jZWxsc1trZXldO1xyXG5cclxuICAgIGlmICghY2VsbCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY2VsbC5sb2FkZWQgPSArbmV3IERhdGUoKTtcclxuXHJcbiAgICBjZWxsLmFjdGl2ZSA9IHRydWU7XHJcbiAgfSxcclxuXHJcbiAgX2dldENlbGxQb3M6IGZ1bmN0aW9uIChjb29yZHMpIHtcclxuICAgIHJldHVybiBjb29yZHMuc2NhbGVCeSh0aGlzLmdldENlbGxTaXplKCkpO1xyXG4gIH0sXHJcblxyXG4gIF93cmFwQ29vcmRzOiBmdW5jdGlvbiAoY29vcmRzKSB7XHJcbiAgICB2YXIgbmV3Q29vcmRzID0gbmV3IFBvaW50KFxyXG4gICAgICB0aGlzLl93cmFwWCA/IFV0aWwud3JhcE51bShjb29yZHMueCwgdGhpcy5fd3JhcFgpIDogY29vcmRzLngsXHJcbiAgICAgIHRoaXMuX3dyYXBZID8gVXRpbC53cmFwTnVtKGNvb3Jkcy55LCB0aGlzLl93cmFwWSkgOiBjb29yZHMueVxyXG4gICAgKTtcclxuICAgIG5ld0Nvb3Jkcy56ID0gY29vcmRzLno7XHJcbiAgICByZXR1cm4gbmV3Q29vcmRzO1xyXG4gIH0sXHJcblxyXG4gIF9weEJvdW5kc1RvQ2VsbFJhbmdlOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcbiAgICB2YXIgY2VsbFNpemUgPSB0aGlzLmdldENlbGxTaXplKCk7XHJcbiAgICByZXR1cm4gbmV3IEJvdW5kcyhcclxuICAgICAgYm91bmRzLm1pbi51bnNjYWxlQnkoY2VsbFNpemUpLmZsb29yKCksXHJcbiAgICAgIGJvdW5kcy5tYXgudW5zY2FsZUJ5KGNlbGxTaXplKS5jZWlsKCkuc3VidHJhY3QoWzEsIDFdKVxyXG4gICAgKTtcclxuICB9XHJcbn0pO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/esri-leaflet/src/Layers/FeatureLayer/FeatureGrid.js\n");

/***/ }),

/***/ "./node_modules/esri-leaflet/src/Layers/FeatureLayer/FeatureLayer.js":
/*!***************************************************************************!*\
  !*** ./node_modules/esri-leaflet/src/Layers/FeatureLayer/FeatureLayer.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FeatureLayer\": () => (/* binding */ FeatureLayer),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"featureLayer\": () => (/* binding */ featureLayer)\n/* harmony export */ });\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! leaflet */ \"./node_modules/leaflet/dist/leaflet-src.js\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _FeatureManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FeatureManager */ \"./node_modules/esri-leaflet/src/Layers/FeatureLayer/FeatureManager.js\");\n/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Util */ \"./node_modules/esri-leaflet/src/Util.js\");\n\r\n\r\n\r\n\r\nvar FeatureLayer = _FeatureManager__WEBPACK_IMPORTED_MODULE_1__.FeatureManager.extend({\r\n  options: {\r\n    cacheLayers: true\r\n  },\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  initialize: function (options) {\r\n    if (options.apikey) {\r\n      options.token = options.apikey;\r\n    }\r\n    _FeatureManager__WEBPACK_IMPORTED_MODULE_1__.FeatureManager.prototype.initialize.call(this, options);\r\n    this._originalStyle = this.options.style;\r\n    this._layers = {};\r\n  },\r\n\r\n  /**\r\n   * Layer Interface\r\n   */\r\n\r\n  onRemove: function (map) {\r\n    for (var i in this._layers) {\r\n      map.removeLayer(this._layers[i]);\r\n      // trigger the event when the entire featureLayer is removed from the map\r\n      this.fire(\r\n        'removefeature',\r\n        {\r\n          feature: this._layers[i].feature,\r\n          permanent: false\r\n        },\r\n        true\r\n      );\r\n    }\r\n\r\n    return _FeatureManager__WEBPACK_IMPORTED_MODULE_1__.FeatureManager.prototype.onRemove.call(this, map);\r\n  },\r\n\r\n  createNewLayer: function (geojson) {\r\n    var layer = leaflet__WEBPACK_IMPORTED_MODULE_0__.GeoJSON.geometryToLayer(geojson, this.options);\r\n    // trap for GeoJSON without geometry\r\n    if (layer) {\r\n      layer.defaultOptions = layer.options;\r\n    }\r\n    return layer;\r\n  },\r\n\r\n  _updateLayer: function (layer, geojson) {\r\n    // convert the geojson coordinates into a Leaflet LatLng array/nested arrays\r\n    // pass it to setLatLngs to update layer geometries\r\n    var latlngs = [];\r\n    var coordsToLatLng = this.options.coordsToLatLng || leaflet__WEBPACK_IMPORTED_MODULE_0__.GeoJSON.coordsToLatLng;\r\n\r\n    // copy new attributes, if present\r\n    if (geojson.properties) {\r\n      layer.feature.properties = geojson.properties;\r\n    }\r\n\r\n    switch (geojson.geometry.type) {\r\n      case 'Point':\r\n        latlngs = leaflet__WEBPACK_IMPORTED_MODULE_0__.GeoJSON.coordsToLatLng(geojson.geometry.coordinates);\r\n        layer.setLatLng(latlngs);\r\n        break;\r\n      case 'LineString':\r\n        latlngs = leaflet__WEBPACK_IMPORTED_MODULE_0__.GeoJSON.coordsToLatLngs(\r\n          geojson.geometry.coordinates,\r\n          0,\r\n          coordsToLatLng\r\n        );\r\n        layer.setLatLngs(latlngs);\r\n        break;\r\n      case 'MultiLineString':\r\n        latlngs = leaflet__WEBPACK_IMPORTED_MODULE_0__.GeoJSON.coordsToLatLngs(\r\n          geojson.geometry.coordinates,\r\n          1,\r\n          coordsToLatLng\r\n        );\r\n        layer.setLatLngs(latlngs);\r\n        break;\r\n      case 'Polygon':\r\n        latlngs = leaflet__WEBPACK_IMPORTED_MODULE_0__.GeoJSON.coordsToLatLngs(\r\n          geojson.geometry.coordinates,\r\n          1,\r\n          coordsToLatLng\r\n        );\r\n        layer.setLatLngs(latlngs);\r\n        break;\r\n      case 'MultiPolygon':\r\n        latlngs = leaflet__WEBPACK_IMPORTED_MODULE_0__.GeoJSON.coordsToLatLngs(\r\n          geojson.geometry.coordinates,\r\n          2,\r\n          coordsToLatLng\r\n        );\r\n        layer.setLatLngs(latlngs);\r\n        break;\r\n    }\r\n\r\n    // update symbol/style\r\n    this.redraw(layer.feature.id);\r\n  },\r\n\r\n  /**\r\n   * Feature Management Methods\r\n   */\r\n\r\n  createLayers: function (features) {\r\n    for (var i = features.length - 1; i >= 0; i--) {\r\n      var geojson = features[i];\r\n\r\n      var layer = this._layers[geojson.id];\r\n      var newLayer;\r\n\r\n      if (\r\n        this._visibleZoom() &&\r\n        layer &&\r\n        !this._map.hasLayer(layer) &&\r\n        (!this.options.timeField || this._featureWithinTimeRange(geojson))\r\n      ) {\r\n        this._map.addLayer(layer);\r\n        this.fire(\r\n          'addfeature',\r\n          {\r\n            feature: layer.feature\r\n          },\r\n          true\r\n        );\r\n      }\r\n\r\n      // update geometry if the layer already existed.\r\n      if (layer && (layer.setLatLngs || layer.setLatLng)) {\r\n        this._updateLayer(layer, geojson);\r\n      }\r\n\r\n      if (!layer) {\r\n        newLayer = this.createNewLayer(geojson);\r\n\r\n        if (!newLayer) {\r\n          (0,_Util__WEBPACK_IMPORTED_MODULE_2__.warn)('invalid GeoJSON encountered');\r\n        } else {\r\n          newLayer.feature = geojson;\r\n\r\n          // bubble events from individual layers to the feature layer\r\n          newLayer.addEventParent(this);\r\n\r\n          if (this.options.onEachFeature) {\r\n            this.options.onEachFeature(newLayer.feature, newLayer);\r\n          }\r\n\r\n          // cache the layer\r\n          this._layers[newLayer.feature.id] = newLayer;\r\n\r\n          // style the layer\r\n          this.setFeatureStyle(newLayer.feature.id, this.options.style);\r\n\r\n          this.fire(\r\n            'createfeature',\r\n            {\r\n              feature: newLayer.feature\r\n            },\r\n            true\r\n          );\r\n\r\n          // add the layer if the current zoom level is inside the range defined for the layer, it is within the current time bounds or our layer is not time enabled\r\n          if (\r\n            this._visibleZoom() &&\r\n            (!this.options.timeField ||\r\n              (this.options.timeField && this._featureWithinTimeRange(geojson)))\r\n          ) {\r\n            this._map.addLayer(newLayer);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  addLayers: function (ids) {\r\n    for (var i = ids.length - 1; i >= 0; i--) {\r\n      var layer = this._layers[ids[i]];\r\n      if (\r\n        layer &&\r\n        (!this.options.timeField || this._featureWithinTimeRange(layer.feature))\r\n      ) {\r\n        this._map.addLayer(layer);\r\n        this.fire(\r\n          'addfeature',\r\n          {\r\n            feature: layer.feature\r\n          },\r\n          true\r\n        );\r\n      }\r\n    }\r\n  },\r\n\r\n  removeLayers: function (ids, permanent) {\r\n    for (var i = ids.length - 1; i >= 0; i--) {\r\n      var id = ids[i];\r\n      var layer = this._layers[id];\r\n      if (layer) {\r\n        this.fire(\r\n          'removefeature',\r\n          {\r\n            feature: layer.feature,\r\n            permanent: permanent\r\n          },\r\n          true\r\n        );\r\n        this._map.removeLayer(layer);\r\n      }\r\n      if (layer && permanent) {\r\n        delete this._layers[id];\r\n      }\r\n    }\r\n  },\r\n\r\n  cellEnter: function (bounds, coords) {\r\n    if (this._visibleZoom() && !this._zooming && this._map) {\r\n      leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.requestAnimFrame(\r\n        leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.bind(function () {\r\n          var cacheKey = this._cacheKey(coords);\r\n          var cellKey = this._cellCoordsToKey(coords);\r\n          var layers = this._cache[cacheKey];\r\n          if (this._activeCells[cellKey] && layers) {\r\n            this.addLayers(layers);\r\n          }\r\n        }, this)\r\n      );\r\n    }\r\n  },\r\n\r\n  cellLeave: function (bounds, coords) {\r\n    if (!this._zooming) {\r\n      leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.requestAnimFrame(\r\n        leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.bind(function () {\r\n          if (this._map) {\r\n            var cacheKey = this._cacheKey(coords);\r\n            var cellKey = this._cellCoordsToKey(coords);\r\n            var layers = this._cache[cacheKey];\r\n            var mapBounds = this._map.getBounds();\r\n            if (!this._activeCells[cellKey] && layers) {\r\n              var removable = true;\r\n\r\n              for (var i = 0; i < layers.length; i++) {\r\n                var layer = this._layers[layers[i]];\r\n                if (\r\n                  layer &&\r\n                  layer.getBounds &&\r\n                  mapBounds.intersects(layer.getBounds())\r\n                ) {\r\n                  removable = false;\r\n                }\r\n              }\r\n\r\n              if (removable) {\r\n                this.removeLayers(layers, !this.options.cacheLayers);\r\n              }\r\n\r\n              if (!this.options.cacheLayers && removable) {\r\n                delete this._cache[cacheKey];\r\n                delete this._cells[cellKey];\r\n                delete this._activeCells[cellKey];\r\n              }\r\n            }\r\n          }\r\n        }, this)\r\n      );\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Styling Methods\r\n   */\r\n\r\n  resetStyle: function () {\r\n    this.options.style = this._originalStyle;\r\n    this.eachFeature(function (layer) {\r\n      this.resetFeatureStyle(layer.feature.id);\r\n    }, this);\r\n    return this;\r\n  },\r\n\r\n  setStyle: function (style) {\r\n    this.options.style = style;\r\n    this.eachFeature(function (layer) {\r\n      this.setFeatureStyle(layer.feature.id, style);\r\n    }, this);\r\n    return this;\r\n  },\r\n\r\n  resetFeatureStyle: function (id) {\r\n    var layer = this._layers[id];\r\n    var style = this._originalStyle || leaflet__WEBPACK_IMPORTED_MODULE_0__.Path.prototype.options;\r\n    if (layer) {\r\n      leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.extend(layer.options, layer.defaultOptions);\r\n      this.setFeatureStyle(id, style);\r\n    }\r\n    return this;\r\n  },\r\n\r\n  setFeatureStyle: function (id, style) {\r\n    var layer = this._layers[id];\r\n    if (typeof style === 'function') {\r\n      style = style(layer.feature);\r\n    }\r\n    if (layer.setStyle) {\r\n      layer.setStyle(style);\r\n    }\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * Utility Methods\r\n   */\r\n\r\n  eachActiveFeature: function (fn, context) {\r\n    // figure out (roughly) which layers are in view\r\n    if (this._map) {\r\n      var activeBounds = this._map.getBounds();\r\n      for (var i in this._layers) {\r\n        if (this._currentSnapshot.indexOf(this._layers[i].feature.id) !== -1) {\r\n          // a simple point in poly test for point geometries\r\n          if (\r\n            typeof this._layers[i].getLatLng === 'function' &&\r\n            activeBounds.contains(this._layers[i].getLatLng())\r\n          ) {\r\n            fn.call(context, this._layers[i]);\r\n          } else if (\r\n            typeof this._layers[i].getBounds === 'function' &&\r\n            activeBounds.intersects(this._layers[i].getBounds())\r\n          ) {\r\n            // intersecting bounds check for polyline and polygon geometries\r\n            fn.call(context, this._layers[i]);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return this;\r\n  },\r\n\r\n  eachFeature: function (fn, context) {\r\n    for (var i in this._layers) {\r\n      fn.call(context, this._layers[i]);\r\n    }\r\n    return this;\r\n  },\r\n\r\n  getFeature: function (id) {\r\n    return this._layers[id];\r\n  },\r\n\r\n  bringToBack: function () {\r\n    this.eachFeature(function (layer) {\r\n      if (layer.bringToBack) {\r\n        layer.bringToBack();\r\n      }\r\n    });\r\n  },\r\n\r\n  bringToFront: function () {\r\n    this.eachFeature(function (layer) {\r\n      if (layer.bringToFront) {\r\n        layer.bringToFront();\r\n      }\r\n    });\r\n  },\r\n\r\n  redraw: function (id) {\r\n    if (id) {\r\n      this._redraw(id);\r\n    }\r\n    return this;\r\n  },\r\n\r\n  _redraw: function (id) {\r\n    var layer = this._layers[id];\r\n    var geojson = layer.feature;\r\n\r\n    // if this looks like a marker\r\n    if (layer && layer.setIcon && this.options.pointToLayer) {\r\n      // update custom symbology, if necessary\r\n      if (this.options.pointToLayer) {\r\n        var getIcon = this.options.pointToLayer(\r\n          geojson,\r\n          (0,leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng)(\r\n            geojson.geometry.coordinates[1],\r\n            geojson.geometry.coordinates[0]\r\n          )\r\n        );\r\n        var updatedIcon = getIcon.options.icon;\r\n        layer.setIcon(updatedIcon);\r\n      }\r\n    }\r\n\r\n    // looks like a vector marker (circleMarker)\r\n    if (layer && layer.setStyle && this.options.pointToLayer) {\r\n      var getStyle = this.options.pointToLayer(\r\n        geojson,\r\n        (0,leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng)(geojson.geometry.coordinates[1], geojson.geometry.coordinates[0])\r\n      );\r\n      var updatedStyle = getStyle.options;\r\n      this.setFeatureStyle(geojson.id, updatedStyle);\r\n    }\r\n\r\n    // looks like a path (polygon/polyline)\r\n    if (layer && layer.setStyle && this.options.style) {\r\n      this.resetFeatureStyle(geojson.id);\r\n    }\r\n  }\r\n});\r\n\r\nfunction featureLayer (options) {\r\n  return new FeatureLayer(options);\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (featureLayer);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXNyaS1sZWFmbGV0L3NyYy9MYXllcnMvRmVhdHVyZUxheWVyL0ZlYXR1cmVMYXllci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXNEO0FBQ0o7QUFDaEI7QUFDbEM7QUFDTyxtQkFBbUIsa0VBQXFCO0FBQy9DO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUkscUZBQXdDO0FBQzVDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUZBQXNDO0FBQ2pELEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0JBQWdCLDREQUF1QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsMkRBQXNCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMkRBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0REFBdUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNERBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDREQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0REFBdUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDJDQUFJO0FBQ2QsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTSwwREFBcUI7QUFDM0IsUUFBUSw4Q0FBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNLDBEQUFxQjtBQUMzQixRQUFRLDhDQUFTO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsbUJBQW1CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywyREFBc0I7QUFDN0Q7QUFDQSxNQUFNLGdEQUFXO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwrQ0FBTTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0NBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsaUVBQWUsWUFBWSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VzcmktbGVhZmxldC9zcmMvTGF5ZXJzL0ZlYXR1cmVMYXllci9GZWF0dXJlTGF5ZXIuanM/ZGZmNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQYXRoLCBVdGlsLCBHZW9KU09OLCBsYXRMbmcgfSBmcm9tICdsZWFmbGV0JztcclxuaW1wb3J0IHsgRmVhdHVyZU1hbmFnZXIgfSBmcm9tICcuL0ZlYXR1cmVNYW5hZ2VyJztcclxuaW1wb3J0IHsgd2FybiB9IGZyb20gJy4uLy4uL1V0aWwnO1xyXG5cclxuZXhwb3J0IHZhciBGZWF0dXJlTGF5ZXIgPSBGZWF0dXJlTWFuYWdlci5leHRlbmQoe1xyXG4gIG9wdGlvbnM6IHtcclxuICAgIGNhY2hlTGF5ZXJzOiB0cnVlXHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQ29uc3RydWN0b3JcclxuICAgKi9cclxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgaWYgKG9wdGlvbnMuYXBpa2V5KSB7XHJcbiAgICAgIG9wdGlvbnMudG9rZW4gPSBvcHRpb25zLmFwaWtleTtcclxuICAgIH1cclxuICAgIEZlYXR1cmVNYW5hZ2VyLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XHJcbiAgICB0aGlzLl9vcmlnaW5hbFN0eWxlID0gdGhpcy5vcHRpb25zLnN0eWxlO1xyXG4gICAgdGhpcy5fbGF5ZXJzID0ge307XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogTGF5ZXIgSW50ZXJmYWNlXHJcbiAgICovXHJcblxyXG4gIG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgICBmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xyXG4gICAgICBtYXAucmVtb3ZlTGF5ZXIodGhpcy5fbGF5ZXJzW2ldKTtcclxuICAgICAgLy8gdHJpZ2dlciB0aGUgZXZlbnQgd2hlbiB0aGUgZW50aXJlIGZlYXR1cmVMYXllciBpcyByZW1vdmVkIGZyb20gdGhlIG1hcFxyXG4gICAgICB0aGlzLmZpcmUoXHJcbiAgICAgICAgJ3JlbW92ZWZlYXR1cmUnLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIGZlYXR1cmU6IHRoaXMuX2xheWVyc1tpXS5mZWF0dXJlLFxyXG4gICAgICAgICAgcGVybWFuZW50OiBmYWxzZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdHJ1ZVxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBGZWF0dXJlTWFuYWdlci5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLCBtYXApO1xyXG4gIH0sXHJcblxyXG4gIGNyZWF0ZU5ld0xheWVyOiBmdW5jdGlvbiAoZ2VvanNvbikge1xyXG4gICAgdmFyIGxheWVyID0gR2VvSlNPTi5nZW9tZXRyeVRvTGF5ZXIoZ2VvanNvbiwgdGhpcy5vcHRpb25zKTtcclxuICAgIC8vIHRyYXAgZm9yIEdlb0pTT04gd2l0aG91dCBnZW9tZXRyeVxyXG4gICAgaWYgKGxheWVyKSB7XHJcbiAgICAgIGxheWVyLmRlZmF1bHRPcHRpb25zID0gbGF5ZXIub3B0aW9ucztcclxuICAgIH1cclxuICAgIHJldHVybiBsYXllcjtcclxuICB9LFxyXG5cclxuICBfdXBkYXRlTGF5ZXI6IGZ1bmN0aW9uIChsYXllciwgZ2VvanNvbikge1xyXG4gICAgLy8gY29udmVydCB0aGUgZ2VvanNvbiBjb29yZGluYXRlcyBpbnRvIGEgTGVhZmxldCBMYXRMbmcgYXJyYXkvbmVzdGVkIGFycmF5c1xyXG4gICAgLy8gcGFzcyBpdCB0byBzZXRMYXRMbmdzIHRvIHVwZGF0ZSBsYXllciBnZW9tZXRyaWVzXHJcbiAgICB2YXIgbGF0bG5ncyA9IFtdO1xyXG4gICAgdmFyIGNvb3Jkc1RvTGF0TG5nID0gdGhpcy5vcHRpb25zLmNvb3Jkc1RvTGF0TG5nIHx8IEdlb0pTT04uY29vcmRzVG9MYXRMbmc7XHJcblxyXG4gICAgLy8gY29weSBuZXcgYXR0cmlidXRlcywgaWYgcHJlc2VudFxyXG4gICAgaWYgKGdlb2pzb24ucHJvcGVydGllcykge1xyXG4gICAgICBsYXllci5mZWF0dXJlLnByb3BlcnRpZXMgPSBnZW9qc29uLnByb3BlcnRpZXM7XHJcbiAgICB9XHJcblxyXG4gICAgc3dpdGNoIChnZW9qc29uLmdlb21ldHJ5LnR5cGUpIHtcclxuICAgICAgY2FzZSAnUG9pbnQnOlxyXG4gICAgICAgIGxhdGxuZ3MgPSBHZW9KU09OLmNvb3Jkc1RvTGF0TG5nKGdlb2pzb24uZ2VvbWV0cnkuY29vcmRpbmF0ZXMpO1xyXG4gICAgICAgIGxheWVyLnNldExhdExuZyhsYXRsbmdzKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnTGluZVN0cmluZyc6XHJcbiAgICAgICAgbGF0bG5ncyA9IEdlb0pTT04uY29vcmRzVG9MYXRMbmdzKFxyXG4gICAgICAgICAgZ2VvanNvbi5nZW9tZXRyeS5jb29yZGluYXRlcyxcclxuICAgICAgICAgIDAsXHJcbiAgICAgICAgICBjb29yZHNUb0xhdExuZ1xyXG4gICAgICAgICk7XHJcbiAgICAgICAgbGF5ZXIuc2V0TGF0TG5ncyhsYXRsbmdzKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcclxuICAgICAgICBsYXRsbmdzID0gR2VvSlNPTi5jb29yZHNUb0xhdExuZ3MoXHJcbiAgICAgICAgICBnZW9qc29uLmdlb21ldHJ5LmNvb3JkaW5hdGVzLFxyXG4gICAgICAgICAgMSxcclxuICAgICAgICAgIGNvb3Jkc1RvTGF0TG5nXHJcbiAgICAgICAgKTtcclxuICAgICAgICBsYXllci5zZXRMYXRMbmdzKGxhdGxuZ3MpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdQb2x5Z29uJzpcclxuICAgICAgICBsYXRsbmdzID0gR2VvSlNPTi5jb29yZHNUb0xhdExuZ3MoXHJcbiAgICAgICAgICBnZW9qc29uLmdlb21ldHJ5LmNvb3JkaW5hdGVzLFxyXG4gICAgICAgICAgMSxcclxuICAgICAgICAgIGNvb3Jkc1RvTGF0TG5nXHJcbiAgICAgICAgKTtcclxuICAgICAgICBsYXllci5zZXRMYXRMbmdzKGxhdGxuZ3MpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdNdWx0aVBvbHlnb24nOlxyXG4gICAgICAgIGxhdGxuZ3MgPSBHZW9KU09OLmNvb3Jkc1RvTGF0TG5ncyhcclxuICAgICAgICAgIGdlb2pzb24uZ2VvbWV0cnkuY29vcmRpbmF0ZXMsXHJcbiAgICAgICAgICAyLFxyXG4gICAgICAgICAgY29vcmRzVG9MYXRMbmdcclxuICAgICAgICApO1xyXG4gICAgICAgIGxheWVyLnNldExhdExuZ3MobGF0bG5ncyk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gdXBkYXRlIHN5bWJvbC9zdHlsZVxyXG4gICAgdGhpcy5yZWRyYXcobGF5ZXIuZmVhdHVyZS5pZCk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogRmVhdHVyZSBNYW5hZ2VtZW50IE1ldGhvZHNcclxuICAgKi9cclxuXHJcbiAgY3JlYXRlTGF5ZXJzOiBmdW5jdGlvbiAoZmVhdHVyZXMpIHtcclxuICAgIGZvciAodmFyIGkgPSBmZWF0dXJlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICB2YXIgZ2VvanNvbiA9IGZlYXR1cmVzW2ldO1xyXG5cclxuICAgICAgdmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW2dlb2pzb24uaWRdO1xyXG4gICAgICB2YXIgbmV3TGF5ZXI7XHJcblxyXG4gICAgICBpZiAoXHJcbiAgICAgICAgdGhpcy5fdmlzaWJsZVpvb20oKSAmJlxyXG4gICAgICAgIGxheWVyICYmXHJcbiAgICAgICAgIXRoaXMuX21hcC5oYXNMYXllcihsYXllcikgJiZcclxuICAgICAgICAoIXRoaXMub3B0aW9ucy50aW1lRmllbGQgfHwgdGhpcy5fZmVhdHVyZVdpdGhpblRpbWVSYW5nZShnZW9qc29uKSlcclxuICAgICAgKSB7XHJcbiAgICAgICAgdGhpcy5fbWFwLmFkZExheWVyKGxheWVyKTtcclxuICAgICAgICB0aGlzLmZpcmUoXHJcbiAgICAgICAgICAnYWRkZmVhdHVyZScsXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIGZlYXR1cmU6IGxheWVyLmZlYXR1cmVcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB0cnVlXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gdXBkYXRlIGdlb21ldHJ5IGlmIHRoZSBsYXllciBhbHJlYWR5IGV4aXN0ZWQuXHJcbiAgICAgIGlmIChsYXllciAmJiAobGF5ZXIuc2V0TGF0TG5ncyB8fCBsYXllci5zZXRMYXRMbmcpKSB7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlTGF5ZXIobGF5ZXIsIGdlb2pzb24pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIWxheWVyKSB7XHJcbiAgICAgICAgbmV3TGF5ZXIgPSB0aGlzLmNyZWF0ZU5ld0xheWVyKGdlb2pzb24pO1xyXG5cclxuICAgICAgICBpZiAoIW5ld0xheWVyKSB7XHJcbiAgICAgICAgICB3YXJuKCdpbnZhbGlkIEdlb0pTT04gZW5jb3VudGVyZWQnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbmV3TGF5ZXIuZmVhdHVyZSA9IGdlb2pzb247XHJcblxyXG4gICAgICAgICAgLy8gYnViYmxlIGV2ZW50cyBmcm9tIGluZGl2aWR1YWwgbGF5ZXJzIHRvIHRoZSBmZWF0dXJlIGxheWVyXHJcbiAgICAgICAgICBuZXdMYXllci5hZGRFdmVudFBhcmVudCh0aGlzKTtcclxuXHJcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLm9uRWFjaEZlYXR1cmUpIHtcclxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9uRWFjaEZlYXR1cmUobmV3TGF5ZXIuZmVhdHVyZSwgbmV3TGF5ZXIpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIGNhY2hlIHRoZSBsYXllclxyXG4gICAgICAgICAgdGhpcy5fbGF5ZXJzW25ld0xheWVyLmZlYXR1cmUuaWRdID0gbmV3TGF5ZXI7XHJcblxyXG4gICAgICAgICAgLy8gc3R5bGUgdGhlIGxheWVyXHJcbiAgICAgICAgICB0aGlzLnNldEZlYXR1cmVTdHlsZShuZXdMYXllci5mZWF0dXJlLmlkLCB0aGlzLm9wdGlvbnMuc3R5bGUpO1xyXG5cclxuICAgICAgICAgIHRoaXMuZmlyZShcclxuICAgICAgICAgICAgJ2NyZWF0ZWZlYXR1cmUnLFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgZmVhdHVyZTogbmV3TGF5ZXIuZmVhdHVyZVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB0cnVlXHJcbiAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgIC8vIGFkZCB0aGUgbGF5ZXIgaWYgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCBpcyBpbnNpZGUgdGhlIHJhbmdlIGRlZmluZWQgZm9yIHRoZSBsYXllciwgaXQgaXMgd2l0aGluIHRoZSBjdXJyZW50IHRpbWUgYm91bmRzIG9yIG91ciBsYXllciBpcyBub3QgdGltZSBlbmFibGVkXHJcbiAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIHRoaXMuX3Zpc2libGVab29tKCkgJiZcclxuICAgICAgICAgICAgKCF0aGlzLm9wdGlvbnMudGltZUZpZWxkIHx8XHJcbiAgICAgICAgICAgICAgKHRoaXMub3B0aW9ucy50aW1lRmllbGQgJiYgdGhpcy5fZmVhdHVyZVdpdGhpblRpbWVSYW5nZShnZW9qc29uKSkpXHJcbiAgICAgICAgICApIHtcclxuICAgICAgICAgICAgdGhpcy5fbWFwLmFkZExheWVyKG5ld0xheWVyKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG5cclxuICBhZGRMYXllcnM6IGZ1bmN0aW9uIChpZHMpIHtcclxuICAgIGZvciAodmFyIGkgPSBpZHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgdmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW2lkc1tpXV07XHJcbiAgICAgIGlmIChcclxuICAgICAgICBsYXllciAmJlxyXG4gICAgICAgICghdGhpcy5vcHRpb25zLnRpbWVGaWVsZCB8fCB0aGlzLl9mZWF0dXJlV2l0aGluVGltZVJhbmdlKGxheWVyLmZlYXR1cmUpKVxyXG4gICAgICApIHtcclxuICAgICAgICB0aGlzLl9tYXAuYWRkTGF5ZXIobGF5ZXIpO1xyXG4gICAgICAgIHRoaXMuZmlyZShcclxuICAgICAgICAgICdhZGRmZWF0dXJlJyxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgZmVhdHVyZTogbGF5ZXIuZmVhdHVyZVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHRydWVcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgcmVtb3ZlTGF5ZXJzOiBmdW5jdGlvbiAoaWRzLCBwZXJtYW5lbnQpIHtcclxuICAgIGZvciAodmFyIGkgPSBpZHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgdmFyIGlkID0gaWRzW2ldO1xyXG4gICAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbaWRdO1xyXG4gICAgICBpZiAobGF5ZXIpIHtcclxuICAgICAgICB0aGlzLmZpcmUoXHJcbiAgICAgICAgICAncmVtb3ZlZmVhdHVyZScsXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIGZlYXR1cmU6IGxheWVyLmZlYXR1cmUsXHJcbiAgICAgICAgICAgIHBlcm1hbmVudDogcGVybWFuZW50XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgdHJ1ZVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdGhpcy5fbWFwLnJlbW92ZUxheWVyKGxheWVyKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAobGF5ZXIgJiYgcGVybWFuZW50KSB7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuX2xheWVyc1tpZF07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG5cclxuICBjZWxsRW50ZXI6IGZ1bmN0aW9uIChib3VuZHMsIGNvb3Jkcykge1xyXG4gICAgaWYgKHRoaXMuX3Zpc2libGVab29tKCkgJiYgIXRoaXMuX3pvb21pbmcgJiYgdGhpcy5fbWFwKSB7XHJcbiAgICAgIFV0aWwucmVxdWVzdEFuaW1GcmFtZShcclxuICAgICAgICBVdGlsLmJpbmQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gdGhpcy5fY2FjaGVLZXkoY29vcmRzKTtcclxuICAgICAgICAgIHZhciBjZWxsS2V5ID0gdGhpcy5fY2VsbENvb3Jkc1RvS2V5KGNvb3Jkcyk7XHJcbiAgICAgICAgICB2YXIgbGF5ZXJzID0gdGhpcy5fY2FjaGVbY2FjaGVLZXldO1xyXG4gICAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZUNlbGxzW2NlbGxLZXldICYmIGxheWVycykge1xyXG4gICAgICAgICAgICB0aGlzLmFkZExheWVycyhsYXllcnMpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sIHRoaXMpXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgY2VsbExlYXZlOiBmdW5jdGlvbiAoYm91bmRzLCBjb29yZHMpIHtcclxuICAgIGlmICghdGhpcy5fem9vbWluZykge1xyXG4gICAgICBVdGlsLnJlcXVlc3RBbmltRnJhbWUoXHJcbiAgICAgICAgVXRpbC5iaW5kKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIGlmICh0aGlzLl9tYXApIHtcclxuICAgICAgICAgICAgdmFyIGNhY2hlS2V5ID0gdGhpcy5fY2FjaGVLZXkoY29vcmRzKTtcclxuICAgICAgICAgICAgdmFyIGNlbGxLZXkgPSB0aGlzLl9jZWxsQ29vcmRzVG9LZXkoY29vcmRzKTtcclxuICAgICAgICAgICAgdmFyIGxheWVycyA9IHRoaXMuX2NhY2hlW2NhY2hlS2V5XTtcclxuICAgICAgICAgICAgdmFyIG1hcEJvdW5kcyA9IHRoaXMuX21hcC5nZXRCb3VuZHMoKTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9hY3RpdmVDZWxsc1tjZWxsS2V5XSAmJiBsYXllcnMpIHtcclxuICAgICAgICAgICAgICB2YXIgcmVtb3ZhYmxlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXMuX2xheWVyc1tsYXllcnNbaV1dO1xyXG4gICAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgICBsYXllciAmJlxyXG4gICAgICAgICAgICAgICAgICBsYXllci5nZXRCb3VuZHMgJiZcclxuICAgICAgICAgICAgICAgICAgbWFwQm91bmRzLmludGVyc2VjdHMobGF5ZXIuZ2V0Qm91bmRzKCkpXHJcbiAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgcmVtb3ZhYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBpZiAocmVtb3ZhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUxheWVycyhsYXllcnMsICF0aGlzLm9wdGlvbnMuY2FjaGVMYXllcnMpO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuY2FjaGVMYXllcnMgJiYgcmVtb3ZhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fY2FjaGVbY2FjaGVLZXldO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2NlbGxzW2NlbGxLZXldO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2FjdGl2ZUNlbGxzW2NlbGxLZXldO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sIHRoaXMpXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogU3R5bGluZyBNZXRob2RzXHJcbiAgICovXHJcblxyXG4gIHJlc2V0U3R5bGU6IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMub3B0aW9ucy5zdHlsZSA9IHRoaXMuX29yaWdpbmFsU3R5bGU7XHJcbiAgICB0aGlzLmVhY2hGZWF0dXJlKGZ1bmN0aW9uIChsYXllcikge1xyXG4gICAgICB0aGlzLnJlc2V0RmVhdHVyZVN0eWxlKGxheWVyLmZlYXR1cmUuaWQpO1xyXG4gICAgfSwgdGhpcyk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICBzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XHJcbiAgICB0aGlzLm9wdGlvbnMuc3R5bGUgPSBzdHlsZTtcclxuICAgIHRoaXMuZWFjaEZlYXR1cmUoZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAgICAgIHRoaXMuc2V0RmVhdHVyZVN0eWxlKGxheWVyLmZlYXR1cmUuaWQsIHN0eWxlKTtcclxuICAgIH0sIHRoaXMpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuXHJcbiAgcmVzZXRGZWF0dXJlU3R5bGU6IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgdmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW2lkXTtcclxuICAgIHZhciBzdHlsZSA9IHRoaXMuX29yaWdpbmFsU3R5bGUgfHwgUGF0aC5wcm90b3R5cGUub3B0aW9ucztcclxuICAgIGlmIChsYXllcikge1xyXG4gICAgICBVdGlsLmV4dGVuZChsYXllci5vcHRpb25zLCBsYXllci5kZWZhdWx0T3B0aW9ucyk7XHJcbiAgICAgIHRoaXMuc2V0RmVhdHVyZVN0eWxlKGlkLCBzdHlsZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICBzZXRGZWF0dXJlU3R5bGU6IGZ1bmN0aW9uIChpZCwgc3R5bGUpIHtcclxuICAgIHZhciBsYXllciA9IHRoaXMuX2xheWVyc1tpZF07XHJcbiAgICBpZiAodHlwZW9mIHN0eWxlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHN0eWxlID0gc3R5bGUobGF5ZXIuZmVhdHVyZSk7XHJcbiAgICB9XHJcbiAgICBpZiAobGF5ZXIuc2V0U3R5bGUpIHtcclxuICAgICAgbGF5ZXIuc2V0U3R5bGUoc3R5bGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogVXRpbGl0eSBNZXRob2RzXHJcbiAgICovXHJcblxyXG4gIGVhY2hBY3RpdmVGZWF0dXJlOiBmdW5jdGlvbiAoZm4sIGNvbnRleHQpIHtcclxuICAgIC8vIGZpZ3VyZSBvdXQgKHJvdWdobHkpIHdoaWNoIGxheWVycyBhcmUgaW4gdmlld1xyXG4gICAgaWYgKHRoaXMuX21hcCkge1xyXG4gICAgICB2YXIgYWN0aXZlQm91bmRzID0gdGhpcy5fbWFwLmdldEJvdW5kcygpO1xyXG4gICAgICBmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xyXG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50U25hcHNob3QuaW5kZXhPZih0aGlzLl9sYXllcnNbaV0uZmVhdHVyZS5pZCkgIT09IC0xKSB7XHJcbiAgICAgICAgICAvLyBhIHNpbXBsZSBwb2ludCBpbiBwb2x5IHRlc3QgZm9yIHBvaW50IGdlb21ldHJpZXNcclxuICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgdHlwZW9mIHRoaXMuX2xheWVyc1tpXS5nZXRMYXRMbmcgPT09ICdmdW5jdGlvbicgJiZcclxuICAgICAgICAgICAgYWN0aXZlQm91bmRzLmNvbnRhaW5zKHRoaXMuX2xheWVyc1tpXS5nZXRMYXRMbmcoKSlcclxuICAgICAgICAgICkge1xyXG4gICAgICAgICAgICBmbi5jYWxsKGNvbnRleHQsIHRoaXMuX2xheWVyc1tpXSk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKFxyXG4gICAgICAgICAgICB0eXBlb2YgdGhpcy5fbGF5ZXJzW2ldLmdldEJvdW5kcyA9PT0gJ2Z1bmN0aW9uJyAmJlxyXG4gICAgICAgICAgICBhY3RpdmVCb3VuZHMuaW50ZXJzZWN0cyh0aGlzLl9sYXllcnNbaV0uZ2V0Qm91bmRzKCkpXHJcbiAgICAgICAgICApIHtcclxuICAgICAgICAgICAgLy8gaW50ZXJzZWN0aW5nIGJvdW5kcyBjaGVjayBmb3IgcG9seWxpbmUgYW5kIHBvbHlnb24gZ2VvbWV0cmllc1xyXG4gICAgICAgICAgICBmbi5jYWxsKGNvbnRleHQsIHRoaXMuX2xheWVyc1tpXSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICBlYWNoRmVhdHVyZTogZnVuY3Rpb24gKGZuLCBjb250ZXh0KSB7XHJcbiAgICBmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xyXG4gICAgICBmbi5jYWxsKGNvbnRleHQsIHRoaXMuX2xheWVyc1tpXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICBnZXRGZWF0dXJlOiBmdW5jdGlvbiAoaWQpIHtcclxuICAgIHJldHVybiB0aGlzLl9sYXllcnNbaWRdO1xyXG4gIH0sXHJcblxyXG4gIGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLmVhY2hGZWF0dXJlKGZ1bmN0aW9uIChsYXllcikge1xyXG4gICAgICBpZiAobGF5ZXIuYnJpbmdUb0JhY2spIHtcclxuICAgICAgICBsYXllci5icmluZ1RvQmFjaygpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9LFxyXG5cclxuICBicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuZWFjaEZlYXR1cmUoZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAgICAgIGlmIChsYXllci5icmluZ1RvRnJvbnQpIHtcclxuICAgICAgICBsYXllci5icmluZ1RvRnJvbnQoKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSxcclxuXHJcbiAgcmVkcmF3OiBmdW5jdGlvbiAoaWQpIHtcclxuICAgIGlmIChpZCkge1xyXG4gICAgICB0aGlzLl9yZWRyYXcoaWQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuXHJcbiAgX3JlZHJhdzogZnVuY3Rpb24gKGlkKSB7XHJcbiAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbaWRdO1xyXG4gICAgdmFyIGdlb2pzb24gPSBsYXllci5mZWF0dXJlO1xyXG5cclxuICAgIC8vIGlmIHRoaXMgbG9va3MgbGlrZSBhIG1hcmtlclxyXG4gICAgaWYgKGxheWVyICYmIGxheWVyLnNldEljb24gJiYgdGhpcy5vcHRpb25zLnBvaW50VG9MYXllcikge1xyXG4gICAgICAvLyB1cGRhdGUgY3VzdG9tIHN5bWJvbG9neSwgaWYgbmVjZXNzYXJ5XHJcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucG9pbnRUb0xheWVyKSB7XHJcbiAgICAgICAgdmFyIGdldEljb24gPSB0aGlzLm9wdGlvbnMucG9pbnRUb0xheWVyKFxyXG4gICAgICAgICAgZ2VvanNvbixcclxuICAgICAgICAgIGxhdExuZyhcclxuICAgICAgICAgICAgZ2VvanNvbi5nZW9tZXRyeS5jb29yZGluYXRlc1sxXSxcclxuICAgICAgICAgICAgZ2VvanNvbi5nZW9tZXRyeS5jb29yZGluYXRlc1swXVxyXG4gICAgICAgICAgKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdmFyIHVwZGF0ZWRJY29uID0gZ2V0SWNvbi5vcHRpb25zLmljb247XHJcbiAgICAgICAgbGF5ZXIuc2V0SWNvbih1cGRhdGVkSWNvbik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBsb29rcyBsaWtlIGEgdmVjdG9yIG1hcmtlciAoY2lyY2xlTWFya2VyKVxyXG4gICAgaWYgKGxheWVyICYmIGxheWVyLnNldFN0eWxlICYmIHRoaXMub3B0aW9ucy5wb2ludFRvTGF5ZXIpIHtcclxuICAgICAgdmFyIGdldFN0eWxlID0gdGhpcy5vcHRpb25zLnBvaW50VG9MYXllcihcclxuICAgICAgICBnZW9qc29uLFxyXG4gICAgICAgIGxhdExuZyhnZW9qc29uLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzFdLCBnZW9qc29uLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdKVxyXG4gICAgICApO1xyXG4gICAgICB2YXIgdXBkYXRlZFN0eWxlID0gZ2V0U3R5bGUub3B0aW9ucztcclxuICAgICAgdGhpcy5zZXRGZWF0dXJlU3R5bGUoZ2VvanNvbi5pZCwgdXBkYXRlZFN0eWxlKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBsb29rcyBsaWtlIGEgcGF0aCAocG9seWdvbi9wb2x5bGluZSlcclxuICAgIGlmIChsYXllciAmJiBsYXllci5zZXRTdHlsZSAmJiB0aGlzLm9wdGlvbnMuc3R5bGUpIHtcclxuICAgICAgdGhpcy5yZXNldEZlYXR1cmVTdHlsZShnZW9qc29uLmlkKTtcclxuICAgIH1cclxuICB9XHJcbn0pO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGZlYXR1cmVMYXllciAob3B0aW9ucykge1xyXG4gIHJldHVybiBuZXcgRmVhdHVyZUxheWVyKG9wdGlvbnMpO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmZWF0dXJlTGF5ZXI7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/esri-leaflet/src/Layers/FeatureLayer/FeatureLayer.js\n");

/***/ }),

/***/ "./node_modules/esri-leaflet/src/Layers/FeatureLayer/FeatureManager.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/esri-leaflet/src/Layers/FeatureLayer/FeatureManager.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FeatureManager\": () => (/* binding */ FeatureManager)\n/* harmony export */ });\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! leaflet */ \"./node_modules/leaflet/dist/leaflet-src.js\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Services_FeatureLayerService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Services/FeatureLayerService */ \"./node_modules/esri-leaflet/src/Services/FeatureLayerService.js\");\n/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Util */ \"./node_modules/esri-leaflet/src/Util.js\");\n/* harmony import */ var _FeatureGrid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./FeatureGrid */ \"./node_modules/esri-leaflet/src/Layers/FeatureLayer/FeatureGrid.js\");\n/* harmony import */ var tiny_binary_search__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tiny-binary-search */ \"./node_modules/tiny-binary-search/index.js\");\n\r\n\r\n\r\n\r\n\r\n\r\nvar FeatureManager = _FeatureGrid__WEBPACK_IMPORTED_MODULE_3__.FeatureGrid.extend({\r\n  /**\r\n   * Options\r\n   */\r\n\r\n  options: {\r\n    attribution: null,\r\n    where: '1=1',\r\n    fields: ['*'],\r\n    from: false,\r\n    to: false,\r\n    timeField: false,\r\n    timeFilterMode: 'server',\r\n    simplifyFactor: 0,\r\n    precision: 6,\r\n    fetchAllFeatures: false\r\n  },\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n\r\n  initialize: function (options) {\r\n    _FeatureGrid__WEBPACK_IMPORTED_MODULE_3__.FeatureGrid.prototype.initialize.call(this, options);\r\n\r\n    options = (0,_Util__WEBPACK_IMPORTED_MODULE_2__.getUrlParams)(options);\r\n    options = leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.setOptions(this, options);\r\n\r\n    this.service = (0,_Services_FeatureLayerService__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(options);\r\n    this.service.addEventParent(this);\r\n\r\n    // use case insensitive regex to look for common fieldnames used for indexing\r\n    if (this.options.fields[0] !== '*') {\r\n      var oidCheck = false;\r\n      for (var i = 0; i < this.options.fields.length; i++) {\r\n        if (this.options.fields[i].match(/^(OBJECTID|FID|OID|ID)$/i)) {\r\n          oidCheck = true;\r\n        }\r\n      }\r\n      if (oidCheck === false) {\r\n        (0,_Util__WEBPACK_IMPORTED_MODULE_2__.warn)(\r\n          'no known esriFieldTypeOID field detected in fields Array.  Please add an attribute field containing unique IDs to ensure the layer can be drawn correctly.'\r\n        );\r\n      }\r\n    }\r\n\r\n    if (this.options.timeField.start && this.options.timeField.end) {\r\n      this._startTimeIndex = new tiny_binary_search__WEBPACK_IMPORTED_MODULE_4__[\"default\"]();\r\n      this._endTimeIndex = new tiny_binary_search__WEBPACK_IMPORTED_MODULE_4__[\"default\"]();\r\n    } else if (this.options.timeField) {\r\n      this._timeIndex = new tiny_binary_search__WEBPACK_IMPORTED_MODULE_4__[\"default\"]();\r\n    }\r\n\r\n    this._cache = {};\r\n    this._currentSnapshot = []; // cache of what layers should be active\r\n    this._activeRequests = 0;\r\n  },\r\n\r\n  /**\r\n   * Layer Interface\r\n   */\r\n\r\n  onAdd: function (map) {\r\n    // include 'Powered by Esri' in map attribution\r\n    (0,_Util__WEBPACK_IMPORTED_MODULE_2__.setEsriAttribution)(map);\r\n\r\n    this.service.metadata(function (err, metadata) {\r\n      if (!err) {\r\n        var supportedFormats = metadata.supportedQueryFormats;\r\n\r\n        // Check if someone has requested that we don't use geoJSON, even if it's available\r\n        var forceJsonFormat = false;\r\n        if (\r\n          this.service.options.isModern === false ||\r\n          this.options.fetchAllFeatures\r\n        ) {\r\n          forceJsonFormat = true;\r\n        }\r\n\r\n        // Unless we've been told otherwise, check to see whether service can emit GeoJSON natively\r\n        if (\r\n          !forceJsonFormat &&\r\n          supportedFormats &&\r\n          supportedFormats.indexOf('geoJSON') !== -1\r\n        ) {\r\n          this.service.options.isModern = true;\r\n        }\r\n\r\n        if (metadata.objectIdField) {\r\n          this.service.options.idAttribute = metadata.objectIdField;\r\n        }\r\n\r\n        // add copyright text listed in service metadata\r\n        if (\r\n          !this.options.attribution &&\r\n          map.attributionControl &&\r\n          metadata.copyrightText\r\n        ) {\r\n          this.options.attribution = metadata.copyrightText;\r\n          map.attributionControl.addAttribution(this.getAttribution());\r\n        }\r\n      }\r\n    }, this);\r\n\r\n    map.on('zoomend', this._handleZoomChange, this);\r\n\r\n    return _FeatureGrid__WEBPACK_IMPORTED_MODULE_3__.FeatureGrid.prototype.onAdd.call(this, map);\r\n  },\r\n\r\n  onRemove: function (map) {\r\n    (0,_Util__WEBPACK_IMPORTED_MODULE_2__.removeEsriAttribution)(map);\r\n    map.off('zoomend', this._handleZoomChange, this);\r\n\r\n    return _FeatureGrid__WEBPACK_IMPORTED_MODULE_3__.FeatureGrid.prototype.onRemove.call(this, map);\r\n  },\r\n\r\n  getAttribution: function () {\r\n    return this.options.attribution;\r\n  },\r\n\r\n  /**\r\n   * Feature Management\r\n   */\r\n\r\n  createCell: function (bounds, coords) {\r\n    // dont fetch features outside the scale range defined for the layer\r\n    if (this._visibleZoom()) {\r\n      this._requestFeatures(bounds, coords);\r\n    }\r\n  },\r\n\r\n  _requestFeatures: function (bounds, coords, callback, offset) {\r\n    this._activeRequests++;\r\n\r\n    // default param\r\n    offset = offset || 0;\r\n\r\n    var originalWhere = this.options.where;\r\n\r\n    // our first active request fires loading\r\n    if (this._activeRequests === 1) {\r\n      this.fire(\r\n        'loading',\r\n        {\r\n          bounds: bounds\r\n        },\r\n        true\r\n      );\r\n    }\r\n\r\n    return this._buildQuery(bounds, offset).run(function (\r\n      error,\r\n      featureCollection,\r\n      response\r\n    ) {\r\n      if (response && response.exceededTransferLimit) {\r\n        this.fire('drawlimitexceeded');\r\n      }\r\n\r\n      // the where changed while this request was being run so don't it.\r\n      if (this.options.where !== originalWhere) {\r\n        return;\r\n      }\r\n\r\n      // no error, features\r\n      if (!error && featureCollection && featureCollection.features.length) {\r\n        // schedule adding features until the next animation frame\r\n        leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.requestAnimFrame(\r\n          leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.bind(function () {\r\n            this._addFeatures(featureCollection.features, coords);\r\n            this._postProcessFeatures(bounds);\r\n          }, this)\r\n        );\r\n      }\r\n\r\n      // no error, no features\r\n      if (!error && featureCollection && !featureCollection.features.length) {\r\n        this._postProcessFeatures(bounds);\r\n      }\r\n\r\n      if (error) {\r\n        this._postProcessFeatures(bounds);\r\n      }\r\n\r\n      if (callback) {\r\n        callback.call(this, error, featureCollection);\r\n      }\r\n      if (\r\n        response &&\r\n        (response.exceededTransferLimit ||\r\n          (response.properties && response.properties.exceededTransferLimit)) &&\r\n        this.options.fetchAllFeatures\r\n      ) {\r\n        this._requestFeatures(\r\n          bounds,\r\n          coords,\r\n          callback,\r\n          offset + featureCollection.features.length\r\n        );\r\n      }\r\n    },\r\n    this);\r\n  },\r\n\r\n  _postProcessFeatures: function (bounds) {\r\n    // deincrement the request counter now that we have processed features\r\n    this._activeRequests--;\r\n\r\n    // if there are no more active requests fire a load event for this view\r\n    if (this._activeRequests <= 0) {\r\n      this.fire('load', {\r\n        bounds: bounds\r\n      });\r\n    }\r\n  },\r\n\r\n  _cacheKey: function (coords) {\r\n    return coords.z + ':' + coords.x + ':' + coords.y;\r\n  },\r\n\r\n  _addFeatures: function (features, coords) {\r\n    // coords is optional - will be false if coming from addFeatures() function\r\n    if (coords) {\r\n      var key = this._cacheKey(coords);\r\n      this._cache[key] = this._cache[key] || [];\r\n    }\r\n\r\n    for (var i = features.length - 1; i >= 0; i--) {\r\n      var id = features[i].id;\r\n\r\n      if (this._currentSnapshot.indexOf(id) === -1) {\r\n        this._currentSnapshot.push(id);\r\n      }\r\n      if (typeof key !== 'undefined' && this._cache[key].indexOf(id) === -1) {\r\n        this._cache[key].push(id);\r\n      }\r\n    }\r\n\r\n    if (this.options.timeField) {\r\n      this._buildTimeIndexes(features);\r\n    }\r\n\r\n    this.createLayers(features);\r\n  },\r\n\r\n  _buildQuery: function (bounds, offset) {\r\n    var query = this.service\r\n      .query()\r\n      .intersects(bounds)\r\n      .where(this.options.where)\r\n      .fields(this.options.fields)\r\n      .precision(this.options.precision);\r\n\r\n    if (this.options.fetchAllFeatures && !isNaN(parseInt(offset))) {\r\n      query = query.offset(offset);\r\n    }\r\n\r\n    query.params['resultType'] = 'tile';\r\n\r\n    if (this.options.requestParams) {\r\n      leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.extend(query.params, this.options.requestParams);\r\n    }\r\n\r\n    if (this.options.simplifyFactor) {\r\n      query.simplify(this._map, this.options.simplifyFactor);\r\n    }\r\n\r\n    if (\r\n      this.options.timeFilterMode === 'server' &&\r\n      this.options.from &&\r\n      this.options.to\r\n    ) {\r\n      query.between(this.options.from, this.options.to);\r\n    }\r\n\r\n    return query;\r\n  },\r\n\r\n  /**\r\n   * Where Methods\r\n   */\r\n\r\n  setWhere: function (where, callback, context) {\r\n    this.options.where = where && where.length ? where : '1=1';\r\n\r\n    var oldSnapshot = [];\r\n    var newSnapshot = [];\r\n    var pendingRequests = 0;\r\n    var requestError = null;\r\n    var requestCallback = leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.bind(function (error, featureCollection) {\r\n      if (error) {\r\n        requestError = error;\r\n      }\r\n\r\n      if (featureCollection) {\r\n        for (var i = featureCollection.features.length - 1; i >= 0; i--) {\r\n          newSnapshot.push(featureCollection.features[i].id);\r\n        }\r\n      }\r\n\r\n      pendingRequests--;\r\n\r\n      if (\r\n        pendingRequests <= 0 &&\r\n        this._visibleZoom() &&\r\n        where === this.options.where // the where is still the same so use this one\r\n      ) {\r\n        this._currentSnapshot = newSnapshot;\r\n        // schedule adding features for the next animation frame\r\n        leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.requestAnimFrame(\r\n          leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.bind(function () {\r\n            this.removeLayers(oldSnapshot);\r\n            this.addLayers(newSnapshot);\r\n            if (callback) {\r\n              callback.call(context, requestError);\r\n            }\r\n          }, this)\r\n        );\r\n      }\r\n    }, this);\r\n\r\n    for (var i = this._currentSnapshot.length - 1; i >= 0; i--) {\r\n      oldSnapshot.push(this._currentSnapshot[i]);\r\n    }\r\n\r\n    this._cache = {};\r\n\r\n    for (var key in this._cells) {\r\n      pendingRequests++;\r\n      var coords = this._keyToCellCoords(key);\r\n      var bounds = this._cellCoordsToBounds(coords);\r\n      this._requestFeatures(bounds, coords, requestCallback);\r\n    }\r\n\r\n    return this;\r\n  },\r\n\r\n  getWhere: function () {\r\n    return this.options.where;\r\n  },\r\n\r\n  /**\r\n   * Time Range Methods\r\n   */\r\n\r\n  getTimeRange: function () {\r\n    return [this.options.from, this.options.to];\r\n  },\r\n\r\n  setTimeRange: function (from, to, callback, context) {\r\n    var oldFrom = this.options.from;\r\n    var oldTo = this.options.to;\r\n    var pendingRequests = 0;\r\n    var requestError = null;\r\n    var requestCallback = leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.bind(function (error) {\r\n      if (error) {\r\n        requestError = error;\r\n      }\r\n      this._filterExistingFeatures(oldFrom, oldTo, from, to);\r\n\r\n      pendingRequests--;\r\n\r\n      if (callback && pendingRequests <= 0) {\r\n        callback.call(context, requestError);\r\n      }\r\n    }, this);\r\n\r\n    this.options.from = from;\r\n    this.options.to = to;\r\n\r\n    this._filterExistingFeatures(oldFrom, oldTo, from, to);\r\n\r\n    if (this.options.timeFilterMode === 'server') {\r\n      for (var key in this._cells) {\r\n        pendingRequests++;\r\n        var coords = this._keyToCellCoords(key);\r\n        var bounds = this._cellCoordsToBounds(coords);\r\n        this._requestFeatures(bounds, coords, requestCallback);\r\n      }\r\n    }\r\n\r\n    return this;\r\n  },\r\n\r\n  refresh: function () {\r\n    this.setWhere(this.options.where);\r\n  },\r\n\r\n  _filterExistingFeatures: function (oldFrom, oldTo, newFrom, newTo) {\r\n    var layersToRemove =\r\n      oldFrom && oldTo\r\n        ? this._getFeaturesInTimeRange(oldFrom, oldTo)\r\n        : this._currentSnapshot;\r\n    var layersToAdd = this._getFeaturesInTimeRange(newFrom, newTo);\r\n\r\n    if (layersToAdd.indexOf) {\r\n      for (var i = 0; i < layersToAdd.length; i++) {\r\n        var shouldRemoveLayer = layersToRemove.indexOf(layersToAdd[i]);\r\n        if (shouldRemoveLayer >= 0) {\r\n          layersToRemove.splice(shouldRemoveLayer, 1);\r\n        }\r\n      }\r\n    }\r\n\r\n    // schedule adding features until the next animation frame\r\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.requestAnimFrame(\r\n      leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.bind(function () {\r\n        this.removeLayers(layersToRemove);\r\n        this.addLayers(layersToAdd);\r\n      }, this)\r\n    );\r\n  },\r\n\r\n  _getFeaturesInTimeRange: function (start, end) {\r\n    var ids = [];\r\n    var search;\r\n\r\n    if (this.options.timeField.start && this.options.timeField.end) {\r\n      var startTimes = this._startTimeIndex.between(start, end);\r\n      var endTimes = this._endTimeIndex.between(start, end);\r\n      search = startTimes.concat(endTimes);\r\n    } else if (this._timeIndex) {\r\n      search = this._timeIndex.between(start, end);\r\n    } else {\r\n      (0,_Util__WEBPACK_IMPORTED_MODULE_2__.warn)(\r\n        'You must set timeField in the layer constructor in order to manipulate the start and end time filter.'\r\n      );\r\n      return [];\r\n    }\r\n\r\n    for (var i = search.length - 1; i >= 0; i--) {\r\n      ids.push(search[i].id);\r\n    }\r\n\r\n    return ids;\r\n  },\r\n\r\n  _buildTimeIndexes: function (geojson) {\r\n    var i;\r\n    var feature;\r\n    if (this.options.timeField.start && this.options.timeField.end) {\r\n      var startTimeEntries = [];\r\n      var endTimeEntries = [];\r\n      for (i = geojson.length - 1; i >= 0; i--) {\r\n        feature = geojson[i];\r\n        startTimeEntries.push({\r\n          id: feature.id,\r\n          value: new Date(feature.properties[this.options.timeField.start])\r\n        });\r\n        endTimeEntries.push({\r\n          id: feature.id,\r\n          value: new Date(feature.properties[this.options.timeField.end])\r\n        });\r\n      }\r\n      this._startTimeIndex.bulkAdd(startTimeEntries);\r\n      this._endTimeIndex.bulkAdd(endTimeEntries);\r\n    } else {\r\n      var timeEntries = [];\r\n      for (i = geojson.length - 1; i >= 0; i--) {\r\n        feature = geojson[i];\r\n        timeEntries.push({\r\n          id: feature.id,\r\n          value: new Date(feature.properties[this.options.timeField])\r\n        });\r\n      }\r\n\r\n      this._timeIndex.bulkAdd(timeEntries);\r\n    }\r\n  },\r\n\r\n  _featureWithinTimeRange: function (feature) {\r\n    if (!this.options.from || !this.options.to) {\r\n      return true;\r\n    }\r\n\r\n    var from = +this.options.from.valueOf();\r\n    var to = +this.options.to.valueOf();\r\n\r\n    if (typeof this.options.timeField === 'string') {\r\n      var date = +feature.properties[this.options.timeField];\r\n      return date >= from && date <= to;\r\n    }\r\n\r\n    if (this.options.timeField.start && this.options.timeField.end) {\r\n      var startDate = +feature.properties[this.options.timeField.start];\r\n      var endDate = +feature.properties[this.options.timeField.end];\r\n      return (\r\n        (startDate >= from && startDate <= to) ||\r\n        (endDate >= from && endDate <= to) ||\r\n        (startDate <= from && endDate >= to)\r\n      );\r\n    }\r\n  },\r\n\r\n  _visibleZoom: function () {\r\n    // check to see whether the current zoom level of the map is within the optional limit defined for the FeatureLayer\r\n    if (!this._map) {\r\n      return false;\r\n    }\r\n    var zoom = this._map.getZoom();\r\n    if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\r\n      return false;\r\n    } else {\r\n      return true;\r\n    }\r\n  },\r\n\r\n  _handleZoomChange: function () {\r\n    if (!this._visibleZoom()) {\r\n      // if we have moved outside the visible zoom range clear the current snapshot, no layers should be active\r\n      this.removeLayers(this._currentSnapshot);\r\n      this._currentSnapshot = [];\r\n    } else {\r\n      /*\r\n      for every cell in this._cells\r\n        1. Get the cache key for the coords of the cell\r\n        2. If this._cache[key] exists it will be an array of feature IDs.\r\n        3. Call this.addLayers(this._cache[key]) to instruct the feature layer to add the layers back.\r\n      */\r\n      for (var i in this._cells) {\r\n        var coords = this._cells[i].coords;\r\n        var key = this._cacheKey(coords);\r\n        if (this._cache[key]) {\r\n          this.addLayers(this._cache[key]);\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Service Methods\r\n   */\r\n\r\n  authenticate: function (token) {\r\n    this.service.authenticate(token);\r\n    return this;\r\n  },\r\n\r\n  metadata: function (callback, context) {\r\n    this.service.metadata(callback, context);\r\n    return this;\r\n  },\r\n\r\n  query: function () {\r\n    return this.service.query();\r\n  },\r\n\r\n  _getMetadata: function (callback) {\r\n    if (this._metadata) {\r\n      var error;\r\n      callback(error, this._metadata);\r\n    } else {\r\n      this.metadata(\r\n        leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.bind(function (error, response) {\r\n          this._metadata = response;\r\n          callback(error, this._metadata);\r\n        }, this)\r\n      );\r\n    }\r\n  },\r\n\r\n  addFeature: function (feature, callback, context) {\r\n    this.addFeatures(feature, callback, context);\r\n  },\r\n\r\n  addFeatures: function (features, callback, context) {\r\n    this._getMetadata(\r\n      leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.bind(function (error, metadata) {\r\n        if (error) {\r\n          if (callback) {\r\n            callback.call(this, error, null);\r\n          }\r\n          return;\r\n        }\r\n        // GeoJSON featureCollection or simple feature\r\n        var featuresArray = features.features ? features.features : [features];\r\n\r\n        this.service.addFeatures(\r\n          features,\r\n          leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.bind(function (error, response) {\r\n            if (!error) {\r\n              for (var i = featuresArray.length - 1; i >= 0; i--) {\r\n                // assign ID from result to appropriate objectid field from service metadata\r\n                featuresArray[i].properties[metadata.objectIdField] =\r\n                  featuresArray.length > 1\r\n                    ? response[i].objectId\r\n                    : response.objectId;\r\n                // we also need to update the geojson id for createLayers() to function\r\n                featuresArray[i].id =\r\n                  featuresArray.length > 1\r\n                    ? response[i].objectId\r\n                    : response.objectId;\r\n              }\r\n              this._addFeatures(featuresArray);\r\n            }\r\n\r\n            if (callback) {\r\n              callback.call(context, error, response);\r\n            }\r\n          }, this)\r\n        );\r\n      }, this)\r\n    );\r\n  },\r\n\r\n  updateFeature: function (feature, callback, context) {\r\n    this.updateFeatures(feature, callback, context);\r\n  },\r\n\r\n  updateFeatures: function (features, callback, context) {\r\n    // GeoJSON featureCollection or simple feature\r\n    var featuresArray = features.features ? features.features : [features];\r\n    this.service.updateFeatures(\r\n      features,\r\n      function (error, response) {\r\n        if (!error) {\r\n          for (var i = featuresArray.length - 1; i >= 0; i--) {\r\n            this.removeLayers([featuresArray[i].id], true);\r\n          }\r\n          this._addFeatures(featuresArray);\r\n        }\r\n\r\n        if (callback) {\r\n          callback.call(context, error, response);\r\n        }\r\n      },\r\n      this\r\n    );\r\n  },\r\n\r\n  deleteFeature: function (id, callback, context) {\r\n    this.deleteFeatures(id, callback, context);\r\n  },\r\n\r\n  deleteFeatures: function (ids, callback, context) {\r\n    return this.service.deleteFeatures(\r\n      ids,\r\n      function (error, response) {\r\n        var responseArray = response.length ? response : [response];\r\n        if (!error && responseArray.length > 0) {\r\n          for (var i = responseArray.length - 1; i >= 0; i--) {\r\n            this.removeLayers([responseArray[i].objectId], true);\r\n          }\r\n        }\r\n        if (callback) {\r\n          callback.call(context, error, response);\r\n        }\r\n      },\r\n      this\r\n    );\r\n  }\r\n});\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXNyaS1sZWFmbGV0L3NyYy9MYXllcnMvRmVhdHVyZUxheWVyL0ZlYXR1cmVNYW5hZ2VyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBK0I7QUFDc0M7QUFNakQ7QUFDd0I7QUFDTztBQUNuRDtBQUNPLHFCQUFxQiw0REFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksK0VBQXFDO0FBQ3pDO0FBQ0EsY0FBYyxtREFBWTtBQUMxQixjQUFjLG9EQUFlO0FBQzdCO0FBQ0EsbUJBQW1CLHlFQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdDQUFnQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyQ0FBSTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywwREFBaUI7QUFDbEQsK0JBQStCLDBEQUFpQjtBQUNoRCxNQUFNO0FBQ04sNEJBQTRCLDBEQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHlEQUFrQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxXQUFXLDBFQUFnQztBQUMzQyxHQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUksNERBQXFCO0FBQ3pCO0FBQ0E7QUFDQSxXQUFXLDZFQUFtQztBQUM5QyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDBEQUFxQjtBQUM3QixVQUFVLDhDQUFTO0FBQ25CO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxnREFBVztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDhDQUFTO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsUUFBUTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMERBQXFCO0FBQzdCLFVBQVUsOENBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbURBQW1ELFFBQVE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw4Q0FBUztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdCQUF3QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwwREFBcUI7QUFDekIsTUFBTSw4Q0FBUztBQUNmO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOLE1BQU0sMkNBQUk7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsUUFBUSw4Q0FBUztBQUNqQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU0sOENBQVM7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4Q0FBUztBQUNuQjtBQUNBLHFEQUFxRCxRQUFRO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsUUFBUTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFFBQVE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXNyaS1sZWFmbGV0L3NyYy9MYXllcnMvRmVhdHVyZUxheWVyL0ZlYXR1cmVNYW5hZ2VyLmpzPzc5NTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVXRpbCB9IGZyb20gJ2xlYWZsZXQnO1xyXG5pbXBvcnQgZmVhdHVyZUxheWVyU2VydmljZSBmcm9tICcuLi8uLi9TZXJ2aWNlcy9GZWF0dXJlTGF5ZXJTZXJ2aWNlJztcclxuaW1wb3J0IHtcclxuICBnZXRVcmxQYXJhbXMsXHJcbiAgd2FybixcclxuICBzZXRFc3JpQXR0cmlidXRpb24sXHJcbiAgcmVtb3ZlRXNyaUF0dHJpYnV0aW9uXHJcbn0gZnJvbSAnLi4vLi4vVXRpbCc7XHJcbmltcG9ydCB7IEZlYXR1cmVHcmlkIH0gZnJvbSAnLi9GZWF0dXJlR3JpZCc7XHJcbmltcG9ydCBCaW5hcnlTZWFyY2hJbmRleCBmcm9tICd0aW55LWJpbmFyeS1zZWFyY2gnO1xyXG5cclxuZXhwb3J0IHZhciBGZWF0dXJlTWFuYWdlciA9IEZlYXR1cmVHcmlkLmV4dGVuZCh7XHJcbiAgLyoqXHJcbiAgICogT3B0aW9uc1xyXG4gICAqL1xyXG5cclxuICBvcHRpb25zOiB7XHJcbiAgICBhdHRyaWJ1dGlvbjogbnVsbCxcclxuICAgIHdoZXJlOiAnMT0xJyxcclxuICAgIGZpZWxkczogWycqJ10sXHJcbiAgICBmcm9tOiBmYWxzZSxcclxuICAgIHRvOiBmYWxzZSxcclxuICAgIHRpbWVGaWVsZDogZmFsc2UsXHJcbiAgICB0aW1lRmlsdGVyTW9kZTogJ3NlcnZlcicsXHJcbiAgICBzaW1wbGlmeUZhY3RvcjogMCxcclxuICAgIHByZWNpc2lvbjogNixcclxuICAgIGZldGNoQWxsRmVhdHVyZXM6IGZhbHNlXHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQ29uc3RydWN0b3JcclxuICAgKi9cclxuXHJcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgIEZlYXR1cmVHcmlkLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XHJcblxyXG4gICAgb3B0aW9ucyA9IGdldFVybFBhcmFtcyhvcHRpb25zKTtcclxuICAgIG9wdGlvbnMgPSBVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG4gICAgdGhpcy5zZXJ2aWNlID0gZmVhdHVyZUxheWVyU2VydmljZShvcHRpb25zKTtcclxuICAgIHRoaXMuc2VydmljZS5hZGRFdmVudFBhcmVudCh0aGlzKTtcclxuXHJcbiAgICAvLyB1c2UgY2FzZSBpbnNlbnNpdGl2ZSByZWdleCB0byBsb29rIGZvciBjb21tb24gZmllbGRuYW1lcyB1c2VkIGZvciBpbmRleGluZ1xyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5maWVsZHNbMF0gIT09ICcqJykge1xyXG4gICAgICB2YXIgb2lkQ2hlY2sgPSBmYWxzZTtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9wdGlvbnMuZmllbGRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5maWVsZHNbaV0ubWF0Y2goL14oT0JKRUNUSUR8RklEfE9JRHxJRCkkL2kpKSB7XHJcbiAgICAgICAgICBvaWRDaGVjayA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChvaWRDaGVjayA9PT0gZmFsc2UpIHtcclxuICAgICAgICB3YXJuKFxyXG4gICAgICAgICAgJ25vIGtub3duIGVzcmlGaWVsZFR5cGVPSUQgZmllbGQgZGV0ZWN0ZWQgaW4gZmllbGRzIEFycmF5LiAgUGxlYXNlIGFkZCBhbiBhdHRyaWJ1dGUgZmllbGQgY29udGFpbmluZyB1bmlxdWUgSURzIHRvIGVuc3VyZSB0aGUgbGF5ZXIgY2FuIGJlIGRyYXduIGNvcnJlY3RseS4nXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLm9wdGlvbnMudGltZUZpZWxkLnN0YXJ0ICYmIHRoaXMub3B0aW9ucy50aW1lRmllbGQuZW5kKSB7XHJcbiAgICAgIHRoaXMuX3N0YXJ0VGltZUluZGV4ID0gbmV3IEJpbmFyeVNlYXJjaEluZGV4KCk7XHJcbiAgICAgIHRoaXMuX2VuZFRpbWVJbmRleCA9IG5ldyBCaW5hcnlTZWFyY2hJbmRleCgpO1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMudGltZUZpZWxkKSB7XHJcbiAgICAgIHRoaXMuX3RpbWVJbmRleCA9IG5ldyBCaW5hcnlTZWFyY2hJbmRleCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX2NhY2hlID0ge307XHJcbiAgICB0aGlzLl9jdXJyZW50U25hcHNob3QgPSBbXTsgLy8gY2FjaGUgb2Ygd2hhdCBsYXllcnMgc2hvdWxkIGJlIGFjdGl2ZVxyXG4gICAgdGhpcy5fYWN0aXZlUmVxdWVzdHMgPSAwO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIExheWVyIEludGVyZmFjZVxyXG4gICAqL1xyXG5cclxuICBvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG4gICAgLy8gaW5jbHVkZSAnUG93ZXJlZCBieSBFc3JpJyBpbiBtYXAgYXR0cmlidXRpb25cclxuICAgIHNldEVzcmlBdHRyaWJ1dGlvbihtYXApO1xyXG5cclxuICAgIHRoaXMuc2VydmljZS5tZXRhZGF0YShmdW5jdGlvbiAoZXJyLCBtZXRhZGF0YSkge1xyXG4gICAgICBpZiAoIWVycikge1xyXG4gICAgICAgIHZhciBzdXBwb3J0ZWRGb3JtYXRzID0gbWV0YWRhdGEuc3VwcG9ydGVkUXVlcnlGb3JtYXRzO1xyXG5cclxuICAgICAgICAvLyBDaGVjayBpZiBzb21lb25lIGhhcyByZXF1ZXN0ZWQgdGhhdCB3ZSBkb24ndCB1c2UgZ2VvSlNPTiwgZXZlbiBpZiBpdCdzIGF2YWlsYWJsZVxyXG4gICAgICAgIHZhciBmb3JjZUpzb25Gb3JtYXQgPSBmYWxzZTtcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICB0aGlzLnNlcnZpY2Uub3B0aW9ucy5pc01vZGVybiA9PT0gZmFsc2UgfHxcclxuICAgICAgICAgIHRoaXMub3B0aW9ucy5mZXRjaEFsbEZlYXR1cmVzXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICBmb3JjZUpzb25Gb3JtYXQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVW5sZXNzIHdlJ3ZlIGJlZW4gdG9sZCBvdGhlcndpc2UsIGNoZWNrIHRvIHNlZSB3aGV0aGVyIHNlcnZpY2UgY2FuIGVtaXQgR2VvSlNPTiBuYXRpdmVseVxyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgICFmb3JjZUpzb25Gb3JtYXQgJiZcclxuICAgICAgICAgIHN1cHBvcnRlZEZvcm1hdHMgJiZcclxuICAgICAgICAgIHN1cHBvcnRlZEZvcm1hdHMuaW5kZXhPZignZ2VvSlNPTicpICE9PSAtMVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgdGhpcy5zZXJ2aWNlLm9wdGlvbnMuaXNNb2Rlcm4gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG1ldGFkYXRhLm9iamVjdElkRmllbGQpIHtcclxuICAgICAgICAgIHRoaXMuc2VydmljZS5vcHRpb25zLmlkQXR0cmlidXRlID0gbWV0YWRhdGEub2JqZWN0SWRGaWVsZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGFkZCBjb3B5cmlnaHQgdGV4dCBsaXN0ZWQgaW4gc2VydmljZSBtZXRhZGF0YVxyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgICF0aGlzLm9wdGlvbnMuYXR0cmlidXRpb24gJiZcclxuICAgICAgICAgIG1hcC5hdHRyaWJ1dGlvbkNvbnRyb2wgJiZcclxuICAgICAgICAgIG1ldGFkYXRhLmNvcHlyaWdodFRleHRcclxuICAgICAgICApIHtcclxuICAgICAgICAgIHRoaXMub3B0aW9ucy5hdHRyaWJ1dGlvbiA9IG1ldGFkYXRhLmNvcHlyaWdodFRleHQ7XHJcbiAgICAgICAgICBtYXAuYXR0cmlidXRpb25Db250cm9sLmFkZEF0dHJpYnV0aW9uKHRoaXMuZ2V0QXR0cmlidXRpb24oKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9LCB0aGlzKTtcclxuXHJcbiAgICBtYXAub24oJ3pvb21lbmQnLCB0aGlzLl9oYW5kbGVab29tQ2hhbmdlLCB0aGlzKTtcclxuXHJcbiAgICByZXR1cm4gRmVhdHVyZUdyaWQucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcclxuICB9LFxyXG5cclxuICBvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG4gICAgcmVtb3ZlRXNyaUF0dHJpYnV0aW9uKG1hcCk7XHJcbiAgICBtYXAub2ZmKCd6b29tZW5kJywgdGhpcy5faGFuZGxlWm9vbUNoYW5nZSwgdGhpcyk7XHJcblxyXG4gICAgcmV0dXJuIEZlYXR1cmVHcmlkLnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsIG1hcCk7XHJcbiAgfSxcclxuXHJcbiAgZ2V0QXR0cmlidXRpb246IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYXR0cmlidXRpb247XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogRmVhdHVyZSBNYW5hZ2VtZW50XHJcbiAgICovXHJcblxyXG4gIGNyZWF0ZUNlbGw6IGZ1bmN0aW9uIChib3VuZHMsIGNvb3Jkcykge1xyXG4gICAgLy8gZG9udCBmZXRjaCBmZWF0dXJlcyBvdXRzaWRlIHRoZSBzY2FsZSByYW5nZSBkZWZpbmVkIGZvciB0aGUgbGF5ZXJcclxuICAgIGlmICh0aGlzLl92aXNpYmxlWm9vbSgpKSB7XHJcbiAgICAgIHRoaXMuX3JlcXVlc3RGZWF0dXJlcyhib3VuZHMsIGNvb3Jkcyk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgX3JlcXVlc3RGZWF0dXJlczogZnVuY3Rpb24gKGJvdW5kcywgY29vcmRzLCBjYWxsYmFjaywgb2Zmc2V0KSB7XHJcbiAgICB0aGlzLl9hY3RpdmVSZXF1ZXN0cysrO1xyXG5cclxuICAgIC8vIGRlZmF1bHQgcGFyYW1cclxuICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xyXG5cclxuICAgIHZhciBvcmlnaW5hbFdoZXJlID0gdGhpcy5vcHRpb25zLndoZXJlO1xyXG5cclxuICAgIC8vIG91ciBmaXJzdCBhY3RpdmUgcmVxdWVzdCBmaXJlcyBsb2FkaW5nXHJcbiAgICBpZiAodGhpcy5fYWN0aXZlUmVxdWVzdHMgPT09IDEpIHtcclxuICAgICAgdGhpcy5maXJlKFxyXG4gICAgICAgICdsb2FkaW5nJyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBib3VuZHM6IGJvdW5kc1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdHJ1ZVxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLl9idWlsZFF1ZXJ5KGJvdW5kcywgb2Zmc2V0KS5ydW4oZnVuY3Rpb24gKFxyXG4gICAgICBlcnJvcixcclxuICAgICAgZmVhdHVyZUNvbGxlY3Rpb24sXHJcbiAgICAgIHJlc3BvbnNlXHJcbiAgICApIHtcclxuICAgICAgaWYgKHJlc3BvbnNlICYmIHJlc3BvbnNlLmV4Y2VlZGVkVHJhbnNmZXJMaW1pdCkge1xyXG4gICAgICAgIHRoaXMuZmlyZSgnZHJhd2xpbWl0ZXhjZWVkZWQnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gdGhlIHdoZXJlIGNoYW5nZWQgd2hpbGUgdGhpcyByZXF1ZXN0IHdhcyBiZWluZyBydW4gc28gZG9uJ3QgaXQuXHJcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMud2hlcmUgIT09IG9yaWdpbmFsV2hlcmUpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIG5vIGVycm9yLCBmZWF0dXJlc1xyXG4gICAgICBpZiAoIWVycm9yICYmIGZlYXR1cmVDb2xsZWN0aW9uICYmIGZlYXR1cmVDb2xsZWN0aW9uLmZlYXR1cmVzLmxlbmd0aCkge1xyXG4gICAgICAgIC8vIHNjaGVkdWxlIGFkZGluZyBmZWF0dXJlcyB1bnRpbCB0aGUgbmV4dCBhbmltYXRpb24gZnJhbWVcclxuICAgICAgICBVdGlsLnJlcXVlc3RBbmltRnJhbWUoXHJcbiAgICAgICAgICBVdGlsLmJpbmQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9hZGRGZWF0dXJlcyhmZWF0dXJlQ29sbGVjdGlvbi5mZWF0dXJlcywgY29vcmRzKTtcclxuICAgICAgICAgICAgdGhpcy5fcG9zdFByb2Nlc3NGZWF0dXJlcyhib3VuZHMpO1xyXG4gICAgICAgICAgfSwgdGhpcylcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBubyBlcnJvciwgbm8gZmVhdHVyZXNcclxuICAgICAgaWYgKCFlcnJvciAmJiBmZWF0dXJlQ29sbGVjdGlvbiAmJiAhZmVhdHVyZUNvbGxlY3Rpb24uZmVhdHVyZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgdGhpcy5fcG9zdFByb2Nlc3NGZWF0dXJlcyhib3VuZHMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICB0aGlzLl9wb3N0UHJvY2Vzc0ZlYXR1cmVzKGJvdW5kcyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChjYWxsYmFjaykge1xyXG4gICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgZXJyb3IsIGZlYXR1cmVDb2xsZWN0aW9uKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoXHJcbiAgICAgICAgcmVzcG9uc2UgJiZcclxuICAgICAgICAocmVzcG9uc2UuZXhjZWVkZWRUcmFuc2ZlckxpbWl0IHx8XHJcbiAgICAgICAgICAocmVzcG9uc2UucHJvcGVydGllcyAmJiByZXNwb25zZS5wcm9wZXJ0aWVzLmV4Y2VlZGVkVHJhbnNmZXJMaW1pdCkpICYmXHJcbiAgICAgICAgdGhpcy5vcHRpb25zLmZldGNoQWxsRmVhdHVyZXNcclxuICAgICAgKSB7XHJcbiAgICAgICAgdGhpcy5fcmVxdWVzdEZlYXR1cmVzKFxyXG4gICAgICAgICAgYm91bmRzLFxyXG4gICAgICAgICAgY29vcmRzLFxyXG4gICAgICAgICAgY2FsbGJhY2ssXHJcbiAgICAgICAgICBvZmZzZXQgKyBmZWF0dXJlQ29sbGVjdGlvbi5mZWF0dXJlcy5sZW5ndGhcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgdGhpcyk7XHJcbiAgfSxcclxuXHJcbiAgX3Bvc3RQcm9jZXNzRmVhdHVyZXM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuICAgIC8vIGRlaW5jcmVtZW50IHRoZSByZXF1ZXN0IGNvdW50ZXIgbm93IHRoYXQgd2UgaGF2ZSBwcm9jZXNzZWQgZmVhdHVyZXNcclxuICAgIHRoaXMuX2FjdGl2ZVJlcXVlc3RzLS07XHJcblxyXG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIG1vcmUgYWN0aXZlIHJlcXVlc3RzIGZpcmUgYSBsb2FkIGV2ZW50IGZvciB0aGlzIHZpZXdcclxuICAgIGlmICh0aGlzLl9hY3RpdmVSZXF1ZXN0cyA8PSAwKSB7XHJcbiAgICAgIHRoaXMuZmlyZSgnbG9hZCcsIHtcclxuICAgICAgICBib3VuZHM6IGJvdW5kc1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBfY2FjaGVLZXk6IGZ1bmN0aW9uIChjb29yZHMpIHtcclxuICAgIHJldHVybiBjb29yZHMueiArICc6JyArIGNvb3Jkcy54ICsgJzonICsgY29vcmRzLnk7XHJcbiAgfSxcclxuXHJcbiAgX2FkZEZlYXR1cmVzOiBmdW5jdGlvbiAoZmVhdHVyZXMsIGNvb3Jkcykge1xyXG4gICAgLy8gY29vcmRzIGlzIG9wdGlvbmFsIC0gd2lsbCBiZSBmYWxzZSBpZiBjb21pbmcgZnJvbSBhZGRGZWF0dXJlcygpIGZ1bmN0aW9uXHJcbiAgICBpZiAoY29vcmRzKSB7XHJcbiAgICAgIHZhciBrZXkgPSB0aGlzLl9jYWNoZUtleShjb29yZHMpO1xyXG4gICAgICB0aGlzLl9jYWNoZVtrZXldID0gdGhpcy5fY2FjaGVba2V5XSB8fCBbXTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKHZhciBpID0gZmVhdHVyZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgdmFyIGlkID0gZmVhdHVyZXNbaV0uaWQ7XHJcblxyXG4gICAgICBpZiAodGhpcy5fY3VycmVudFNuYXBzaG90LmluZGV4T2YoaWQpID09PSAtMSkge1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRTbmFwc2hvdC5wdXNoKGlkKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy5fY2FjaGVba2V5XS5pbmRleE9mKGlkKSA9PT0gLTEpIHtcclxuICAgICAgICB0aGlzLl9jYWNoZVtrZXldLnB1c2goaWQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMub3B0aW9ucy50aW1lRmllbGQpIHtcclxuICAgICAgdGhpcy5fYnVpbGRUaW1lSW5kZXhlcyhmZWF0dXJlcyk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jcmVhdGVMYXllcnMoZmVhdHVyZXMpO1xyXG4gIH0sXHJcblxyXG4gIF9idWlsZFF1ZXJ5OiBmdW5jdGlvbiAoYm91bmRzLCBvZmZzZXQpIHtcclxuICAgIHZhciBxdWVyeSA9IHRoaXMuc2VydmljZVxyXG4gICAgICAucXVlcnkoKVxyXG4gICAgICAuaW50ZXJzZWN0cyhib3VuZHMpXHJcbiAgICAgIC53aGVyZSh0aGlzLm9wdGlvbnMud2hlcmUpXHJcbiAgICAgIC5maWVsZHModGhpcy5vcHRpb25zLmZpZWxkcylcclxuICAgICAgLnByZWNpc2lvbih0aGlzLm9wdGlvbnMucHJlY2lzaW9uKTtcclxuXHJcbiAgICBpZiAodGhpcy5vcHRpb25zLmZldGNoQWxsRmVhdHVyZXMgJiYgIWlzTmFOKHBhcnNlSW50KG9mZnNldCkpKSB7XHJcbiAgICAgIHF1ZXJ5ID0gcXVlcnkub2Zmc2V0KG9mZnNldCk7XHJcbiAgICB9XHJcblxyXG4gICAgcXVlcnkucGFyYW1zWydyZXN1bHRUeXBlJ10gPSAndGlsZSc7XHJcblxyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXF1ZXN0UGFyYW1zKSB7XHJcbiAgICAgIFV0aWwuZXh0ZW5kKHF1ZXJ5LnBhcmFtcywgdGhpcy5vcHRpb25zLnJlcXVlc3RQYXJhbXMpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLm9wdGlvbnMuc2ltcGxpZnlGYWN0b3IpIHtcclxuICAgICAgcXVlcnkuc2ltcGxpZnkodGhpcy5fbWFwLCB0aGlzLm9wdGlvbnMuc2ltcGxpZnlGYWN0b3IpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChcclxuICAgICAgdGhpcy5vcHRpb25zLnRpbWVGaWx0ZXJNb2RlID09PSAnc2VydmVyJyAmJlxyXG4gICAgICB0aGlzLm9wdGlvbnMuZnJvbSAmJlxyXG4gICAgICB0aGlzLm9wdGlvbnMudG9cclxuICAgICkge1xyXG4gICAgICBxdWVyeS5iZXR3ZWVuKHRoaXMub3B0aW9ucy5mcm9tLCB0aGlzLm9wdGlvbnMudG8pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBxdWVyeTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBXaGVyZSBNZXRob2RzXHJcbiAgICovXHJcblxyXG4gIHNldFdoZXJlOiBmdW5jdGlvbiAod2hlcmUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XHJcbiAgICB0aGlzLm9wdGlvbnMud2hlcmUgPSB3aGVyZSAmJiB3aGVyZS5sZW5ndGggPyB3aGVyZSA6ICcxPTEnO1xyXG5cclxuICAgIHZhciBvbGRTbmFwc2hvdCA9IFtdO1xyXG4gICAgdmFyIG5ld1NuYXBzaG90ID0gW107XHJcbiAgICB2YXIgcGVuZGluZ1JlcXVlc3RzID0gMDtcclxuICAgIHZhciByZXF1ZXN0RXJyb3IgPSBudWxsO1xyXG4gICAgdmFyIHJlcXVlc3RDYWxsYmFjayA9IFV0aWwuYmluZChmdW5jdGlvbiAoZXJyb3IsIGZlYXR1cmVDb2xsZWN0aW9uKSB7XHJcbiAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgIHJlcXVlc3RFcnJvciA9IGVycm9yO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoZmVhdHVyZUNvbGxlY3Rpb24pIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gZmVhdHVyZUNvbGxlY3Rpb24uZmVhdHVyZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgIG5ld1NuYXBzaG90LnB1c2goZmVhdHVyZUNvbGxlY3Rpb24uZmVhdHVyZXNbaV0uaWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcGVuZGluZ1JlcXVlc3RzLS07XHJcblxyXG4gICAgICBpZiAoXHJcbiAgICAgICAgcGVuZGluZ1JlcXVlc3RzIDw9IDAgJiZcclxuICAgICAgICB0aGlzLl92aXNpYmxlWm9vbSgpICYmXHJcbiAgICAgICAgd2hlcmUgPT09IHRoaXMub3B0aW9ucy53aGVyZSAvLyB0aGUgd2hlcmUgaXMgc3RpbGwgdGhlIHNhbWUgc28gdXNlIHRoaXMgb25lXHJcbiAgICAgICkge1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRTbmFwc2hvdCA9IG5ld1NuYXBzaG90O1xyXG4gICAgICAgIC8vIHNjaGVkdWxlIGFkZGluZyBmZWF0dXJlcyBmb3IgdGhlIG5leHQgYW5pbWF0aW9uIGZyYW1lXHJcbiAgICAgICAgVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKFxyXG4gICAgICAgICAgVXRpbC5iaW5kKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVMYXllcnMob2xkU25hcHNob3QpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZExheWVycyhuZXdTbmFwc2hvdCk7XHJcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoY29udGV4dCwgcmVxdWVzdEVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSwgdGhpcylcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9LCB0aGlzKTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gdGhpcy5fY3VycmVudFNuYXBzaG90Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgIG9sZFNuYXBzaG90LnB1c2godGhpcy5fY3VycmVudFNuYXBzaG90W2ldKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9jYWNoZSA9IHt9O1xyXG5cclxuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl9jZWxscykge1xyXG4gICAgICBwZW5kaW5nUmVxdWVzdHMrKztcclxuICAgICAgdmFyIGNvb3JkcyA9IHRoaXMuX2tleVRvQ2VsbENvb3JkcyhrZXkpO1xyXG4gICAgICB2YXIgYm91bmRzID0gdGhpcy5fY2VsbENvb3Jkc1RvQm91bmRzKGNvb3Jkcyk7XHJcbiAgICAgIHRoaXMuX3JlcXVlc3RGZWF0dXJlcyhib3VuZHMsIGNvb3JkcywgcmVxdWVzdENhbGxiYWNrKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICBnZXRXaGVyZTogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy53aGVyZTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBUaW1lIFJhbmdlIE1ldGhvZHNcclxuICAgKi9cclxuXHJcbiAgZ2V0VGltZVJhbmdlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gW3RoaXMub3B0aW9ucy5mcm9tLCB0aGlzLm9wdGlvbnMudG9dO1xyXG4gIH0sXHJcblxyXG4gIHNldFRpbWVSYW5nZTogZnVuY3Rpb24gKGZyb20sIHRvLCBjYWxsYmFjaywgY29udGV4dCkge1xyXG4gICAgdmFyIG9sZEZyb20gPSB0aGlzLm9wdGlvbnMuZnJvbTtcclxuICAgIHZhciBvbGRUbyA9IHRoaXMub3B0aW9ucy50bztcclxuICAgIHZhciBwZW5kaW5nUmVxdWVzdHMgPSAwO1xyXG4gICAgdmFyIHJlcXVlc3RFcnJvciA9IG51bGw7XHJcbiAgICB2YXIgcmVxdWVzdENhbGxiYWNrID0gVXRpbC5iaW5kKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICByZXF1ZXN0RXJyb3IgPSBlcnJvcjtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9maWx0ZXJFeGlzdGluZ0ZlYXR1cmVzKG9sZEZyb20sIG9sZFRvLCBmcm9tLCB0byk7XHJcblxyXG4gICAgICBwZW5kaW5nUmVxdWVzdHMtLTtcclxuXHJcbiAgICAgIGlmIChjYWxsYmFjayAmJiBwZW5kaW5nUmVxdWVzdHMgPD0gMCkge1xyXG4gICAgICAgIGNhbGxiYWNrLmNhbGwoY29udGV4dCwgcmVxdWVzdEVycm9yKTtcclxuICAgICAgfVxyXG4gICAgfSwgdGhpcyk7XHJcblxyXG4gICAgdGhpcy5vcHRpb25zLmZyb20gPSBmcm9tO1xyXG4gICAgdGhpcy5vcHRpb25zLnRvID0gdG87XHJcblxyXG4gICAgdGhpcy5fZmlsdGVyRXhpc3RpbmdGZWF0dXJlcyhvbGRGcm9tLCBvbGRUbywgZnJvbSwgdG8pO1xyXG5cclxuICAgIGlmICh0aGlzLm9wdGlvbnMudGltZUZpbHRlck1vZGUgPT09ICdzZXJ2ZXInKSB7XHJcbiAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl9jZWxscykge1xyXG4gICAgICAgIHBlbmRpbmdSZXF1ZXN0cysrO1xyXG4gICAgICAgIHZhciBjb29yZHMgPSB0aGlzLl9rZXlUb0NlbGxDb29yZHMoa2V5KTtcclxuICAgICAgICB2YXIgYm91bmRzID0gdGhpcy5fY2VsbENvb3Jkc1RvQm91bmRzKGNvb3Jkcyk7XHJcbiAgICAgICAgdGhpcy5fcmVxdWVzdEZlYXR1cmVzKGJvdW5kcywgY29vcmRzLCByZXF1ZXN0Q2FsbGJhY2spO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuXHJcbiAgcmVmcmVzaDogZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5zZXRXaGVyZSh0aGlzLm9wdGlvbnMud2hlcmUpO1xyXG4gIH0sXHJcblxyXG4gIF9maWx0ZXJFeGlzdGluZ0ZlYXR1cmVzOiBmdW5jdGlvbiAob2xkRnJvbSwgb2xkVG8sIG5ld0Zyb20sIG5ld1RvKSB7XHJcbiAgICB2YXIgbGF5ZXJzVG9SZW1vdmUgPVxyXG4gICAgICBvbGRGcm9tICYmIG9sZFRvXHJcbiAgICAgICAgPyB0aGlzLl9nZXRGZWF0dXJlc0luVGltZVJhbmdlKG9sZEZyb20sIG9sZFRvKVxyXG4gICAgICAgIDogdGhpcy5fY3VycmVudFNuYXBzaG90O1xyXG4gICAgdmFyIGxheWVyc1RvQWRkID0gdGhpcy5fZ2V0RmVhdHVyZXNJblRpbWVSYW5nZShuZXdGcm9tLCBuZXdUbyk7XHJcblxyXG4gICAgaWYgKGxheWVyc1RvQWRkLmluZGV4T2YpIHtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXllcnNUb0FkZC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBzaG91bGRSZW1vdmVMYXllciA9IGxheWVyc1RvUmVtb3ZlLmluZGV4T2YobGF5ZXJzVG9BZGRbaV0pO1xyXG4gICAgICAgIGlmIChzaG91bGRSZW1vdmVMYXllciA+PSAwKSB7XHJcbiAgICAgICAgICBsYXllcnNUb1JlbW92ZS5zcGxpY2Uoc2hvdWxkUmVtb3ZlTGF5ZXIsIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHNjaGVkdWxlIGFkZGluZyBmZWF0dXJlcyB1bnRpbCB0aGUgbmV4dCBhbmltYXRpb24gZnJhbWVcclxuICAgIFV0aWwucmVxdWVzdEFuaW1GcmFtZShcclxuICAgICAgVXRpbC5iaW5kKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnJlbW92ZUxheWVycyhsYXllcnNUb1JlbW92ZSk7XHJcbiAgICAgICAgdGhpcy5hZGRMYXllcnMobGF5ZXJzVG9BZGQpO1xyXG4gICAgICB9LCB0aGlzKVxyXG4gICAgKTtcclxuICB9LFxyXG5cclxuICBfZ2V0RmVhdHVyZXNJblRpbWVSYW5nZTogZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcclxuICAgIHZhciBpZHMgPSBbXTtcclxuICAgIHZhciBzZWFyY2g7XHJcblxyXG4gICAgaWYgKHRoaXMub3B0aW9ucy50aW1lRmllbGQuc3RhcnQgJiYgdGhpcy5vcHRpb25zLnRpbWVGaWVsZC5lbmQpIHtcclxuICAgICAgdmFyIHN0YXJ0VGltZXMgPSB0aGlzLl9zdGFydFRpbWVJbmRleC5iZXR3ZWVuKHN0YXJ0LCBlbmQpO1xyXG4gICAgICB2YXIgZW5kVGltZXMgPSB0aGlzLl9lbmRUaW1lSW5kZXguYmV0d2VlbihzdGFydCwgZW5kKTtcclxuICAgICAgc2VhcmNoID0gc3RhcnRUaW1lcy5jb25jYXQoZW5kVGltZXMpO1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLl90aW1lSW5kZXgpIHtcclxuICAgICAgc2VhcmNoID0gdGhpcy5fdGltZUluZGV4LmJldHdlZW4oc3RhcnQsIGVuZCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB3YXJuKFxyXG4gICAgICAgICdZb3UgbXVzdCBzZXQgdGltZUZpZWxkIGluIHRoZSBsYXllciBjb25zdHJ1Y3RvciBpbiBvcmRlciB0byBtYW5pcHVsYXRlIHRoZSBzdGFydCBhbmQgZW5kIHRpbWUgZmlsdGVyLidcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAodmFyIGkgPSBzZWFyY2gubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgaWRzLnB1c2goc2VhcmNoW2ldLmlkKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaWRzO1xyXG4gIH0sXHJcblxyXG4gIF9idWlsZFRpbWVJbmRleGVzOiBmdW5jdGlvbiAoZ2VvanNvbikge1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgZmVhdHVyZTtcclxuICAgIGlmICh0aGlzLm9wdGlvbnMudGltZUZpZWxkLnN0YXJ0ICYmIHRoaXMub3B0aW9ucy50aW1lRmllbGQuZW5kKSB7XHJcbiAgICAgIHZhciBzdGFydFRpbWVFbnRyaWVzID0gW107XHJcbiAgICAgIHZhciBlbmRUaW1lRW50cmllcyA9IFtdO1xyXG4gICAgICBmb3IgKGkgPSBnZW9qc29uLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgZmVhdHVyZSA9IGdlb2pzb25baV07XHJcbiAgICAgICAgc3RhcnRUaW1lRW50cmllcy5wdXNoKHtcclxuICAgICAgICAgIGlkOiBmZWF0dXJlLmlkLFxyXG4gICAgICAgICAgdmFsdWU6IG5ldyBEYXRlKGZlYXR1cmUucHJvcGVydGllc1t0aGlzLm9wdGlvbnMudGltZUZpZWxkLnN0YXJ0XSlcclxuICAgICAgICB9KTtcclxuICAgICAgICBlbmRUaW1lRW50cmllcy5wdXNoKHtcclxuICAgICAgICAgIGlkOiBmZWF0dXJlLmlkLFxyXG4gICAgICAgICAgdmFsdWU6IG5ldyBEYXRlKGZlYXR1cmUucHJvcGVydGllc1t0aGlzLm9wdGlvbnMudGltZUZpZWxkLmVuZF0pXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fc3RhcnRUaW1lSW5kZXguYnVsa0FkZChzdGFydFRpbWVFbnRyaWVzKTtcclxuICAgICAgdGhpcy5fZW5kVGltZUluZGV4LmJ1bGtBZGQoZW5kVGltZUVudHJpZXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFyIHRpbWVFbnRyaWVzID0gW107XHJcbiAgICAgIGZvciAoaSA9IGdlb2pzb24ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICBmZWF0dXJlID0gZ2VvanNvbltpXTtcclxuICAgICAgICB0aW1lRW50cmllcy5wdXNoKHtcclxuICAgICAgICAgIGlkOiBmZWF0dXJlLmlkLFxyXG4gICAgICAgICAgdmFsdWU6IG5ldyBEYXRlKGZlYXR1cmUucHJvcGVydGllc1t0aGlzLm9wdGlvbnMudGltZUZpZWxkXSlcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5fdGltZUluZGV4LmJ1bGtBZGQodGltZUVudHJpZXMpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIF9mZWF0dXJlV2l0aGluVGltZVJhbmdlOiBmdW5jdGlvbiAoZmVhdHVyZSkge1xyXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuZnJvbSB8fCAhdGhpcy5vcHRpb25zLnRvKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBmcm9tID0gK3RoaXMub3B0aW9ucy5mcm9tLnZhbHVlT2YoKTtcclxuICAgIHZhciB0byA9ICt0aGlzLm9wdGlvbnMudG8udmFsdWVPZigpO1xyXG5cclxuICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnRpbWVGaWVsZCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgdmFyIGRhdGUgPSArZmVhdHVyZS5wcm9wZXJ0aWVzW3RoaXMub3B0aW9ucy50aW1lRmllbGRdO1xyXG4gICAgICByZXR1cm4gZGF0ZSA+PSBmcm9tICYmIGRhdGUgPD0gdG87XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMub3B0aW9ucy50aW1lRmllbGQuc3RhcnQgJiYgdGhpcy5vcHRpb25zLnRpbWVGaWVsZC5lbmQpIHtcclxuICAgICAgdmFyIHN0YXJ0RGF0ZSA9ICtmZWF0dXJlLnByb3BlcnRpZXNbdGhpcy5vcHRpb25zLnRpbWVGaWVsZC5zdGFydF07XHJcbiAgICAgIHZhciBlbmREYXRlID0gK2ZlYXR1cmUucHJvcGVydGllc1t0aGlzLm9wdGlvbnMudGltZUZpZWxkLmVuZF07XHJcbiAgICAgIHJldHVybiAoXHJcbiAgICAgICAgKHN0YXJ0RGF0ZSA+PSBmcm9tICYmIHN0YXJ0RGF0ZSA8PSB0bykgfHxcclxuICAgICAgICAoZW5kRGF0ZSA+PSBmcm9tICYmIGVuZERhdGUgPD0gdG8pIHx8XHJcbiAgICAgICAgKHN0YXJ0RGF0ZSA8PSBmcm9tICYmIGVuZERhdGUgPj0gdG8pXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgX3Zpc2libGVab29tOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAvLyBjaGVjayB0byBzZWUgd2hldGhlciB0aGUgY3VycmVudCB6b29tIGxldmVsIG9mIHRoZSBtYXAgaXMgd2l0aGluIHRoZSBvcHRpb25hbCBsaW1pdCBkZWZpbmVkIGZvciB0aGUgRmVhdHVyZUxheWVyXHJcbiAgICBpZiAoIXRoaXMuX21hcCkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB2YXIgem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XHJcbiAgICBpZiAoem9vbSA+IHRoaXMub3B0aW9ucy5tYXhab29tIHx8IHpvb20gPCB0aGlzLm9wdGlvbnMubWluWm9vbSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBfaGFuZGxlWm9vbUNoYW5nZTogZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKCF0aGlzLl92aXNpYmxlWm9vbSgpKSB7XHJcbiAgICAgIC8vIGlmIHdlIGhhdmUgbW92ZWQgb3V0c2lkZSB0aGUgdmlzaWJsZSB6b29tIHJhbmdlIGNsZWFyIHRoZSBjdXJyZW50IHNuYXBzaG90LCBubyBsYXllcnMgc2hvdWxkIGJlIGFjdGl2ZVxyXG4gICAgICB0aGlzLnJlbW92ZUxheWVycyh0aGlzLl9jdXJyZW50U25hcHNob3QpO1xyXG4gICAgICB0aGlzLl9jdXJyZW50U25hcHNob3QgPSBbXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8qXHJcbiAgICAgIGZvciBldmVyeSBjZWxsIGluIHRoaXMuX2NlbGxzXHJcbiAgICAgICAgMS4gR2V0IHRoZSBjYWNoZSBrZXkgZm9yIHRoZSBjb29yZHMgb2YgdGhlIGNlbGxcclxuICAgICAgICAyLiBJZiB0aGlzLl9jYWNoZVtrZXldIGV4aXN0cyBpdCB3aWxsIGJlIGFuIGFycmF5IG9mIGZlYXR1cmUgSURzLlxyXG4gICAgICAgIDMuIENhbGwgdGhpcy5hZGRMYXllcnModGhpcy5fY2FjaGVba2V5XSkgdG8gaW5zdHJ1Y3QgdGhlIGZlYXR1cmUgbGF5ZXIgdG8gYWRkIHRoZSBsYXllcnMgYmFjay5cclxuICAgICAgKi9cclxuICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLl9jZWxscykge1xyXG4gICAgICAgIHZhciBjb29yZHMgPSB0aGlzLl9jZWxsc1tpXS5jb29yZHM7XHJcbiAgICAgICAgdmFyIGtleSA9IHRoaXMuX2NhY2hlS2V5KGNvb3Jkcyk7XHJcbiAgICAgICAgaWYgKHRoaXMuX2NhY2hlW2tleV0pIHtcclxuICAgICAgICAgIHRoaXMuYWRkTGF5ZXJzKHRoaXMuX2NhY2hlW2tleV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFNlcnZpY2UgTWV0aG9kc1xyXG4gICAqL1xyXG5cclxuICBhdXRoZW50aWNhdGU6IGZ1bmN0aW9uICh0b2tlbikge1xyXG4gICAgdGhpcy5zZXJ2aWNlLmF1dGhlbnRpY2F0ZSh0b2tlbik7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICBtZXRhZGF0YTogZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XHJcbiAgICB0aGlzLnNlcnZpY2UubWV0YWRhdGEoY2FsbGJhY2ssIGNvbnRleHQpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuXHJcbiAgcXVlcnk6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLnNlcnZpY2UucXVlcnkoKTtcclxuICB9LFxyXG5cclxuICBfZ2V0TWV0YWRhdGE6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgaWYgKHRoaXMuX21ldGFkYXRhKSB7XHJcbiAgICAgIHZhciBlcnJvcjtcclxuICAgICAgY2FsbGJhY2soZXJyb3IsIHRoaXMuX21ldGFkYXRhKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMubWV0YWRhdGEoXHJcbiAgICAgICAgVXRpbC5iaW5kKGZ1bmN0aW9uIChlcnJvciwgcmVzcG9uc2UpIHtcclxuICAgICAgICAgIHRoaXMuX21ldGFkYXRhID0gcmVzcG9uc2U7XHJcbiAgICAgICAgICBjYWxsYmFjayhlcnJvciwgdGhpcy5fbWV0YWRhdGEpO1xyXG4gICAgICAgIH0sIHRoaXMpXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgYWRkRmVhdHVyZTogZnVuY3Rpb24gKGZlYXR1cmUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XHJcbiAgICB0aGlzLmFkZEZlYXR1cmVzKGZlYXR1cmUsIGNhbGxiYWNrLCBjb250ZXh0KTtcclxuICB9LFxyXG5cclxuICBhZGRGZWF0dXJlczogZnVuY3Rpb24gKGZlYXR1cmVzLCBjYWxsYmFjaywgY29udGV4dCkge1xyXG4gICAgdGhpcy5fZ2V0TWV0YWRhdGEoXHJcbiAgICAgIFV0aWwuYmluZChmdW5jdGlvbiAoZXJyb3IsIG1ldGFkYXRhKSB7XHJcbiAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBlcnJvciwgbnVsbCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEdlb0pTT04gZmVhdHVyZUNvbGxlY3Rpb24gb3Igc2ltcGxlIGZlYXR1cmVcclxuICAgICAgICB2YXIgZmVhdHVyZXNBcnJheSA9IGZlYXR1cmVzLmZlYXR1cmVzID8gZmVhdHVyZXMuZmVhdHVyZXMgOiBbZmVhdHVyZXNdO1xyXG5cclxuICAgICAgICB0aGlzLnNlcnZpY2UuYWRkRmVhdHVyZXMoXHJcbiAgICAgICAgICBmZWF0dXJlcyxcclxuICAgICAgICAgIFV0aWwuYmluZChmdW5jdGlvbiAoZXJyb3IsIHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcclxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gZmVhdHVyZXNBcnJheS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgLy8gYXNzaWduIElEIGZyb20gcmVzdWx0IHRvIGFwcHJvcHJpYXRlIG9iamVjdGlkIGZpZWxkIGZyb20gc2VydmljZSBtZXRhZGF0YVxyXG4gICAgICAgICAgICAgICAgZmVhdHVyZXNBcnJheVtpXS5wcm9wZXJ0aWVzW21ldGFkYXRhLm9iamVjdElkRmllbGRdID1cclxuICAgICAgICAgICAgICAgICAgZmVhdHVyZXNBcnJheS5sZW5ndGggPiAxXHJcbiAgICAgICAgICAgICAgICAgICAgPyByZXNwb25zZVtpXS5vYmplY3RJZFxyXG4gICAgICAgICAgICAgICAgICAgIDogcmVzcG9uc2Uub2JqZWN0SWQ7XHJcbiAgICAgICAgICAgICAgICAvLyB3ZSBhbHNvIG5lZWQgdG8gdXBkYXRlIHRoZSBnZW9qc29uIGlkIGZvciBjcmVhdGVMYXllcnMoKSB0byBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgZmVhdHVyZXNBcnJheVtpXS5pZCA9XHJcbiAgICAgICAgICAgICAgICAgIGZlYXR1cmVzQXJyYXkubGVuZ3RoID4gMVxyXG4gICAgICAgICAgICAgICAgICAgID8gcmVzcG9uc2VbaV0ub2JqZWN0SWRcclxuICAgICAgICAgICAgICAgICAgICA6IHJlc3BvbnNlLm9iamVjdElkO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB0aGlzLl9hZGRGZWF0dXJlcyhmZWF0dXJlc0FycmF5KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChjb250ZXh0LCBlcnJvciwgcmVzcG9uc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9LCB0aGlzKVxyXG4gICAgICAgICk7XHJcbiAgICAgIH0sIHRoaXMpXHJcbiAgICApO1xyXG4gIH0sXHJcblxyXG4gIHVwZGF0ZUZlYXR1cmU6IGZ1bmN0aW9uIChmZWF0dXJlLCBjYWxsYmFjaywgY29udGV4dCkge1xyXG4gICAgdGhpcy51cGRhdGVGZWF0dXJlcyhmZWF0dXJlLCBjYWxsYmFjaywgY29udGV4dCk7XHJcbiAgfSxcclxuXHJcbiAgdXBkYXRlRmVhdHVyZXM6IGZ1bmN0aW9uIChmZWF0dXJlcywgY2FsbGJhY2ssIGNvbnRleHQpIHtcclxuICAgIC8vIEdlb0pTT04gZmVhdHVyZUNvbGxlY3Rpb24gb3Igc2ltcGxlIGZlYXR1cmVcclxuICAgIHZhciBmZWF0dXJlc0FycmF5ID0gZmVhdHVyZXMuZmVhdHVyZXMgPyBmZWF0dXJlcy5mZWF0dXJlcyA6IFtmZWF0dXJlc107XHJcbiAgICB0aGlzLnNlcnZpY2UudXBkYXRlRmVhdHVyZXMoXHJcbiAgICAgIGZlYXR1cmVzLFxyXG4gICAgICBmdW5jdGlvbiAoZXJyb3IsIHJlc3BvbnNlKSB7XHJcbiAgICAgICAgaWYgKCFlcnJvcikge1xyXG4gICAgICAgICAgZm9yICh2YXIgaSA9IGZlYXR1cmVzQXJyYXkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVMYXllcnMoW2ZlYXR1cmVzQXJyYXlbaV0uaWRdLCB0cnVlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRoaXMuX2FkZEZlYXR1cmVzKGZlYXR1cmVzQXJyYXkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICBjYWxsYmFjay5jYWxsKGNvbnRleHQsIGVycm9yLCByZXNwb25zZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICB0aGlzXHJcbiAgICApO1xyXG4gIH0sXHJcblxyXG4gIGRlbGV0ZUZlYXR1cmU6IGZ1bmN0aW9uIChpZCwgY2FsbGJhY2ssIGNvbnRleHQpIHtcclxuICAgIHRoaXMuZGVsZXRlRmVhdHVyZXMoaWQsIGNhbGxiYWNrLCBjb250ZXh0KTtcclxuICB9LFxyXG5cclxuICBkZWxldGVGZWF0dXJlczogZnVuY3Rpb24gKGlkcywgY2FsbGJhY2ssIGNvbnRleHQpIHtcclxuICAgIHJldHVybiB0aGlzLnNlcnZpY2UuZGVsZXRlRmVhdHVyZXMoXHJcbiAgICAgIGlkcyxcclxuICAgICAgZnVuY3Rpb24gKGVycm9yLCByZXNwb25zZSkge1xyXG4gICAgICAgIHZhciByZXNwb25zZUFycmF5ID0gcmVzcG9uc2UubGVuZ3RoID8gcmVzcG9uc2UgOiBbcmVzcG9uc2VdO1xyXG4gICAgICAgIGlmICghZXJyb3IgJiYgcmVzcG9uc2VBcnJheS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICBmb3IgKHZhciBpID0gcmVzcG9uc2VBcnJheS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUxheWVycyhbcmVzcG9uc2VBcnJheVtpXS5vYmplY3RJZF0sIHRydWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgICAgIGNhbGxiYWNrLmNhbGwoY29udGV4dCwgZXJyb3IsIHJlc3BvbnNlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIHRoaXNcclxuICAgICk7XHJcbiAgfVxyXG59KTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/esri-leaflet/src/Layers/FeatureLayer/FeatureManager.js\n");

/***/ }),

/***/ "./node_modules/esri-leaflet/src/Layers/ImageMapLayer.js":
/*!***************************************************************!*\
  !*** ./node_modules/esri-leaflet/src/Layers/ImageMapLayer.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ImageMapLayer\": () => (/* binding */ ImageMapLayer),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"imageMapLayer\": () => (/* binding */ imageMapLayer)\n/* harmony export */ });\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! leaflet */ \"./node_modules/leaflet/dist/leaflet-src.js\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _RasterLayer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RasterLayer */ \"./node_modules/esri-leaflet/src/Layers/RasterLayer.js\");\n/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Util */ \"./node_modules/esri-leaflet/src/Util.js\");\n/* harmony import */ var _Services_ImageService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Services/ImageService */ \"./node_modules/esri-leaflet/src/Services/ImageService.js\");\n\r\n\r\n\r\n\r\n\r\nvar ImageMapLayer = _RasterLayer__WEBPACK_IMPORTED_MODULE_1__.RasterLayer.extend({\r\n\r\n  options: {\r\n    updateInterval: 150,\r\n    format: 'jpgpng',\r\n    transparent: true,\r\n    f: 'image'\r\n  },\r\n\r\n  query: function () {\r\n    return this.service.query();\r\n  },\r\n\r\n  identify: function () {\r\n    return this.service.identify();\r\n  },\r\n\r\n  initialize: function (options) {\r\n    options = (0,_Util__WEBPACK_IMPORTED_MODULE_2__.getUrlParams)(options);\r\n    this.service = (0,_Services_ImageService__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(options);\r\n    this.service.addEventParent(this);\r\n\r\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.setOptions(this, options);\r\n  },\r\n\r\n  setPixelType: function (pixelType) {\r\n    this.options.pixelType = pixelType;\r\n    this._update();\r\n    return this;\r\n  },\r\n\r\n  getPixelType: function () {\r\n    return this.options.pixelType;\r\n  },\r\n\r\n  setBandIds: function (bandIds) {\r\n    if (leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.isArray(bandIds)) {\r\n      this.options.bandIds = bandIds.join(',');\r\n    } else {\r\n      this.options.bandIds = bandIds.toString();\r\n    }\r\n    this._update();\r\n    return this;\r\n  },\r\n\r\n  getBandIds: function () {\r\n    return this.options.bandIds;\r\n  },\r\n\r\n  setNoData: function (noData, noDataInterpretation) {\r\n    if (leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.isArray(noData)) {\r\n      this.options.noData = noData.join(',');\r\n    } else {\r\n      this.options.noData = noData.toString();\r\n    }\r\n    if (noDataInterpretation) {\r\n      this.options.noDataInterpretation = noDataInterpretation;\r\n    }\r\n    this._update();\r\n    return this;\r\n  },\r\n\r\n  getNoData: function () {\r\n    return this.options.noData;\r\n  },\r\n\r\n  getNoDataInterpretation: function () {\r\n    return this.options.noDataInterpretation;\r\n  },\r\n\r\n  setRenderingRule: function (renderingRule) {\r\n    this.options.renderingRule = renderingRule;\r\n    this._update();\r\n  },\r\n\r\n  getRenderingRule: function () {\r\n    return this.options.renderingRule;\r\n  },\r\n\r\n  setMosaicRule: function (mosaicRule) {\r\n    this.options.mosaicRule = mosaicRule;\r\n    this._update();\r\n  },\r\n\r\n  getMosaicRule: function () {\r\n    return this.options.mosaicRule;\r\n  },\r\n\r\n  _getPopupData: function (e) {\r\n    var callback = leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.bind(function (error, results, response) {\r\n      if (error) { return; } // we really can't do anything here but authenticate or requesterror will fire\r\n      setTimeout(leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.bind(function () {\r\n        this._renderPopup(e.latlng, error, results, response);\r\n      }, this), 300);\r\n    }, this);\r\n\r\n    var identifyRequest = this.identify().at(e.latlng);\r\n\r\n    // set mosaic rule for identify task if it is set for layer\r\n    if (this.options.mosaicRule) {\r\n      identifyRequest.setMosaicRule(this.options.mosaicRule);\r\n      // @TODO: force return catalog items too?\r\n    }\r\n\r\n    // @TODO: set rendering rule? Not sure,\r\n    // sometimes you want raw pixel values\r\n    // if (this.options.renderingRule) {\r\n    //   identifyRequest.setRenderingRule(this.options.renderingRule);\r\n    // }\r\n\r\n    identifyRequest.run(callback);\r\n\r\n    // set the flags to show the popup\r\n    this._shouldRenderPopup = true;\r\n    this._lastClick = e.latlng;\r\n  },\r\n\r\n  _buildExportParams: function () {\r\n    var sr = parseInt(this._map.options.crs.code.split(':')[1], 10);\r\n\r\n    var params = {\r\n      bbox: this._calculateBbox(),\r\n      size: this._calculateImageSize(),\r\n      format: this.options.format,\r\n      transparent: this.options.transparent,\r\n      bboxSR: sr,\r\n      imageSR: sr\r\n    };\r\n\r\n    if (this.options.from && this.options.to) {\r\n      params.time = this.options.from.valueOf() + ',' + this.options.to.valueOf();\r\n    }\r\n\r\n    if (this.options.pixelType) {\r\n      params.pixelType = this.options.pixelType;\r\n    }\r\n\r\n    if (this.options.interpolation) {\r\n      params.interpolation = this.options.interpolation;\r\n    }\r\n\r\n    if (this.options.compressionQuality) {\r\n      params.compressionQuality = this.options.compressionQuality;\r\n    }\r\n\r\n    if (this.options.bandIds) {\r\n      params.bandIds = this.options.bandIds;\r\n    }\r\n\r\n    // 0 is falsy *and* a valid input parameter\r\n    if (this.options.noData === 0 || this.options.noData) {\r\n      params.noData = this.options.noData;\r\n    }\r\n\r\n    if (this.options.noDataInterpretation) {\r\n      params.noDataInterpretation = this.options.noDataInterpretation;\r\n    }\r\n\r\n    if (this.service.options.token) {\r\n      params.token = this.service.options.token;\r\n    }\r\n\r\n    if (this.options.renderingRule) {\r\n      params.renderingRule = JSON.stringify(this.options.renderingRule);\r\n    }\r\n\r\n    if (this.options.mosaicRule) {\r\n      params.mosaicRule = JSON.stringify(this.options.mosaicRule);\r\n    }\r\n\r\n    return params;\r\n  },\r\n\r\n  _requestExport: function (params, bounds) {\r\n    if (this.options.f === 'json') {\r\n      this.service.request('exportImage', params, function (error, response) {\r\n        if (error) { return; } // we really can't do anything here but authenticate or requesterror will fire\r\n        if (this.options.token) {\r\n          response.href += ('?token=' + this.options.token);\r\n        }\r\n        if (this.options.proxy) {\r\n          response.href = this.options.proxy + '?' + response.href;\r\n        }\r\n        this._renderImage(response.href, bounds);\r\n      }, this);\r\n    } else {\r\n      params.f = 'image';\r\n      var fullUrl = this.options.url + 'exportImage' + leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.getParamString(params);\r\n      if (this.options.proxy) {\r\n        fullUrl = this.options.proxy + '?' + fullUrl;\r\n      }\r\n      this._renderImage(fullUrl, bounds);\r\n    }\r\n  }\r\n});\r\n\r\nfunction imageMapLayer (url, options) {\r\n  return new ImageMapLayer(url, options);\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (imageMapLayer);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXNyaS1sZWFmbGV0L3NyYy9MYXllcnMvSW1hZ2VNYXBMYXllci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUErQjtBQUNhO0FBQ0w7QUFDYTtBQUNwRDtBQUNPLG9CQUFvQiw0REFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGNBQWMsbURBQVk7QUFDMUIsbUJBQW1CLGtFQUFZO0FBQy9CO0FBQ0E7QUFDQSxJQUFJLG9EQUFlO0FBQ25CLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsUUFBUSxpREFBWTtBQUNwQjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFFBQVEsaURBQVk7QUFDcEI7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQkFBbUIsOENBQVM7QUFDNUIsbUJBQW1CLFVBQVU7QUFDN0IsaUJBQWlCLDhDQUFTO0FBQzFCO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFVBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0EsdURBQXVELHdEQUFtQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGlFQUFlLGFBQWEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lc3JpLWxlYWZsZXQvc3JjL0xheWVycy9JbWFnZU1hcExheWVyLmpzPzQwNDUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVXRpbCB9IGZyb20gJ2xlYWZsZXQnO1xyXG5pbXBvcnQgeyBSYXN0ZXJMYXllciB9IGZyb20gJy4vUmFzdGVyTGF5ZXInO1xyXG5pbXBvcnQgeyBnZXRVcmxQYXJhbXMgfSBmcm9tICcuLi9VdGlsJztcclxuaW1wb3J0IGltYWdlU2VydmljZSBmcm9tICcuLi9TZXJ2aWNlcy9JbWFnZVNlcnZpY2UnO1xyXG5cclxuZXhwb3J0IHZhciBJbWFnZU1hcExheWVyID0gUmFzdGVyTGF5ZXIuZXh0ZW5kKHtcclxuXHJcbiAgb3B0aW9uczoge1xyXG4gICAgdXBkYXRlSW50ZXJ2YWw6IDE1MCxcclxuICAgIGZvcm1hdDogJ2pwZ3BuZycsXHJcbiAgICB0cmFuc3BhcmVudDogdHJ1ZSxcclxuICAgIGY6ICdpbWFnZSdcclxuICB9LFxyXG5cclxuICBxdWVyeTogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc2VydmljZS5xdWVyeSgpO1xyXG4gIH0sXHJcblxyXG4gIGlkZW50aWZ5OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zZXJ2aWNlLmlkZW50aWZ5KCk7XHJcbiAgfSxcclxuXHJcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgIG9wdGlvbnMgPSBnZXRVcmxQYXJhbXMob3B0aW9ucyk7XHJcbiAgICB0aGlzLnNlcnZpY2UgPSBpbWFnZVNlcnZpY2Uob3B0aW9ucyk7XHJcbiAgICB0aGlzLnNlcnZpY2UuYWRkRXZlbnRQYXJlbnQodGhpcyk7XHJcblxyXG4gICAgVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG4gIH0sXHJcblxyXG4gIHNldFBpeGVsVHlwZTogZnVuY3Rpb24gKHBpeGVsVHlwZSkge1xyXG4gICAgdGhpcy5vcHRpb25zLnBpeGVsVHlwZSA9IHBpeGVsVHlwZTtcclxuICAgIHRoaXMuX3VwZGF0ZSgpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuXHJcbiAgZ2V0UGl4ZWxUeXBlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnBpeGVsVHlwZTtcclxuICB9LFxyXG5cclxuICBzZXRCYW5kSWRzOiBmdW5jdGlvbiAoYmFuZElkcykge1xyXG4gICAgaWYgKFV0aWwuaXNBcnJheShiYW5kSWRzKSkge1xyXG4gICAgICB0aGlzLm9wdGlvbnMuYmFuZElkcyA9IGJhbmRJZHMuam9pbignLCcpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5vcHRpb25zLmJhbmRJZHMgPSBiYW5kSWRzLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLl91cGRhdGUoKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0sXHJcblxyXG4gIGdldEJhbmRJZHM6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYmFuZElkcztcclxuICB9LFxyXG5cclxuICBzZXROb0RhdGE6IGZ1bmN0aW9uIChub0RhdGEsIG5vRGF0YUludGVycHJldGF0aW9uKSB7XHJcbiAgICBpZiAoVXRpbC5pc0FycmF5KG5vRGF0YSkpIHtcclxuICAgICAgdGhpcy5vcHRpb25zLm5vRGF0YSA9IG5vRGF0YS5qb2luKCcsJyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLm9wdGlvbnMubm9EYXRhID0gbm9EYXRhLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICBpZiAobm9EYXRhSW50ZXJwcmV0YXRpb24pIHtcclxuICAgICAgdGhpcy5vcHRpb25zLm5vRGF0YUludGVycHJldGF0aW9uID0gbm9EYXRhSW50ZXJwcmV0YXRpb247XHJcbiAgICB9XHJcbiAgICB0aGlzLl91cGRhdGUoKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0sXHJcblxyXG4gIGdldE5vRGF0YTogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5ub0RhdGE7XHJcbiAgfSxcclxuXHJcbiAgZ2V0Tm9EYXRhSW50ZXJwcmV0YXRpb246IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLm9wdGlvbnMubm9EYXRhSW50ZXJwcmV0YXRpb247XHJcbiAgfSxcclxuXHJcbiAgc2V0UmVuZGVyaW5nUnVsZTogZnVuY3Rpb24gKHJlbmRlcmluZ1J1bGUpIHtcclxuICAgIHRoaXMub3B0aW9ucy5yZW5kZXJpbmdSdWxlID0gcmVuZGVyaW5nUnVsZTtcclxuICAgIHRoaXMuX3VwZGF0ZSgpO1xyXG4gIH0sXHJcblxyXG4gIGdldFJlbmRlcmluZ1J1bGU6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLm9wdGlvbnMucmVuZGVyaW5nUnVsZTtcclxuICB9LFxyXG5cclxuICBzZXRNb3NhaWNSdWxlOiBmdW5jdGlvbiAobW9zYWljUnVsZSkge1xyXG4gICAgdGhpcy5vcHRpb25zLm1vc2FpY1J1bGUgPSBtb3NhaWNSdWxlO1xyXG4gICAgdGhpcy5fdXBkYXRlKCk7XHJcbiAgfSxcclxuXHJcbiAgZ2V0TW9zYWljUnVsZTogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5tb3NhaWNSdWxlO1xyXG4gIH0sXHJcblxyXG4gIF9nZXRQb3B1cERhdGE6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICB2YXIgY2FsbGJhY2sgPSBVdGlsLmJpbmQoZnVuY3Rpb24gKGVycm9yLCByZXN1bHRzLCByZXNwb25zZSkge1xyXG4gICAgICBpZiAoZXJyb3IpIHsgcmV0dXJuOyB9IC8vIHdlIHJlYWxseSBjYW4ndCBkbyBhbnl0aGluZyBoZXJlIGJ1dCBhdXRoZW50aWNhdGUgb3IgcmVxdWVzdGVycm9yIHdpbGwgZmlyZVxyXG4gICAgICBzZXRUaW1lb3V0KFV0aWwuYmluZChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyUG9wdXAoZS5sYXRsbmcsIGVycm9yLCByZXN1bHRzLCByZXNwb25zZSk7XHJcbiAgICAgIH0sIHRoaXMpLCAzMDApO1xyXG4gICAgfSwgdGhpcyk7XHJcblxyXG4gICAgdmFyIGlkZW50aWZ5UmVxdWVzdCA9IHRoaXMuaWRlbnRpZnkoKS5hdChlLmxhdGxuZyk7XHJcblxyXG4gICAgLy8gc2V0IG1vc2FpYyBydWxlIGZvciBpZGVudGlmeSB0YXNrIGlmIGl0IGlzIHNldCBmb3IgbGF5ZXJcclxuICAgIGlmICh0aGlzLm9wdGlvbnMubW9zYWljUnVsZSkge1xyXG4gICAgICBpZGVudGlmeVJlcXVlc3Quc2V0TW9zYWljUnVsZSh0aGlzLm9wdGlvbnMubW9zYWljUnVsZSk7XHJcbiAgICAgIC8vIEBUT0RPOiBmb3JjZSByZXR1cm4gY2F0YWxvZyBpdGVtcyB0b28/XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQFRPRE86IHNldCByZW5kZXJpbmcgcnVsZT8gTm90IHN1cmUsXHJcbiAgICAvLyBzb21ldGltZXMgeW91IHdhbnQgcmF3IHBpeGVsIHZhbHVlc1xyXG4gICAgLy8gaWYgKHRoaXMub3B0aW9ucy5yZW5kZXJpbmdSdWxlKSB7XHJcbiAgICAvLyAgIGlkZW50aWZ5UmVxdWVzdC5zZXRSZW5kZXJpbmdSdWxlKHRoaXMub3B0aW9ucy5yZW5kZXJpbmdSdWxlKTtcclxuICAgIC8vIH1cclxuXHJcbiAgICBpZGVudGlmeVJlcXVlc3QucnVuKGNhbGxiYWNrKTtcclxuXHJcbiAgICAvLyBzZXQgdGhlIGZsYWdzIHRvIHNob3cgdGhlIHBvcHVwXHJcbiAgICB0aGlzLl9zaG91bGRSZW5kZXJQb3B1cCA9IHRydWU7XHJcbiAgICB0aGlzLl9sYXN0Q2xpY2sgPSBlLmxhdGxuZztcclxuICB9LFxyXG5cclxuICBfYnVpbGRFeHBvcnRQYXJhbXM6IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBzciA9IHBhcnNlSW50KHRoaXMuX21hcC5vcHRpb25zLmNycy5jb2RlLnNwbGl0KCc6JylbMV0sIDEwKTtcclxuXHJcbiAgICB2YXIgcGFyYW1zID0ge1xyXG4gICAgICBiYm94OiB0aGlzLl9jYWxjdWxhdGVCYm94KCksXHJcbiAgICAgIHNpemU6IHRoaXMuX2NhbGN1bGF0ZUltYWdlU2l6ZSgpLFxyXG4gICAgICBmb3JtYXQ6IHRoaXMub3B0aW9ucy5mb3JtYXQsXHJcbiAgICAgIHRyYW5zcGFyZW50OiB0aGlzLm9wdGlvbnMudHJhbnNwYXJlbnQsXHJcbiAgICAgIGJib3hTUjogc3IsXHJcbiAgICAgIGltYWdlU1I6IHNyXHJcbiAgICB9O1xyXG5cclxuICAgIGlmICh0aGlzLm9wdGlvbnMuZnJvbSAmJiB0aGlzLm9wdGlvbnMudG8pIHtcclxuICAgICAgcGFyYW1zLnRpbWUgPSB0aGlzLm9wdGlvbnMuZnJvbS52YWx1ZU9mKCkgKyAnLCcgKyB0aGlzLm9wdGlvbnMudG8udmFsdWVPZigpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLm9wdGlvbnMucGl4ZWxUeXBlKSB7XHJcbiAgICAgIHBhcmFtcy5waXhlbFR5cGUgPSB0aGlzLm9wdGlvbnMucGl4ZWxUeXBlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbikge1xyXG4gICAgICBwYXJhbXMuaW50ZXJwb2xhdGlvbiA9IHRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLm9wdGlvbnMuY29tcHJlc3Npb25RdWFsaXR5KSB7XHJcbiAgICAgIHBhcmFtcy5jb21wcmVzc2lvblF1YWxpdHkgPSB0aGlzLm9wdGlvbnMuY29tcHJlc3Npb25RdWFsaXR5O1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLm9wdGlvbnMuYmFuZElkcykge1xyXG4gICAgICBwYXJhbXMuYmFuZElkcyA9IHRoaXMub3B0aW9ucy5iYW5kSWRzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIDAgaXMgZmFsc3kgKmFuZCogYSB2YWxpZCBpbnB1dCBwYXJhbWV0ZXJcclxuICAgIGlmICh0aGlzLm9wdGlvbnMubm9EYXRhID09PSAwIHx8IHRoaXMub3B0aW9ucy5ub0RhdGEpIHtcclxuICAgICAgcGFyYW1zLm5vRGF0YSA9IHRoaXMub3B0aW9ucy5ub0RhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5ub0RhdGFJbnRlcnByZXRhdGlvbikge1xyXG4gICAgICBwYXJhbXMubm9EYXRhSW50ZXJwcmV0YXRpb24gPSB0aGlzLm9wdGlvbnMubm9EYXRhSW50ZXJwcmV0YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuc2VydmljZS5vcHRpb25zLnRva2VuKSB7XHJcbiAgICAgIHBhcmFtcy50b2tlbiA9IHRoaXMuc2VydmljZS5vcHRpb25zLnRva2VuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLm9wdGlvbnMucmVuZGVyaW5nUnVsZSkge1xyXG4gICAgICBwYXJhbXMucmVuZGVyaW5nUnVsZSA9IEpTT04uc3RyaW5naWZ5KHRoaXMub3B0aW9ucy5yZW5kZXJpbmdSdWxlKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5vcHRpb25zLm1vc2FpY1J1bGUpIHtcclxuICAgICAgcGFyYW1zLm1vc2FpY1J1bGUgPSBKU09OLnN0cmluZ2lmeSh0aGlzLm9wdGlvbnMubW9zYWljUnVsZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHBhcmFtcztcclxuICB9LFxyXG5cclxuICBfcmVxdWVzdEV4cG9ydDogZnVuY3Rpb24gKHBhcmFtcywgYm91bmRzKSB7XHJcbiAgICBpZiAodGhpcy5vcHRpb25zLmYgPT09ICdqc29uJykge1xyXG4gICAgICB0aGlzLnNlcnZpY2UucmVxdWVzdCgnZXhwb3J0SW1hZ2UnLCBwYXJhbXMsIGZ1bmN0aW9uIChlcnJvciwgcmVzcG9uc2UpIHtcclxuICAgICAgICBpZiAoZXJyb3IpIHsgcmV0dXJuOyB9IC8vIHdlIHJlYWxseSBjYW4ndCBkbyBhbnl0aGluZyBoZXJlIGJ1dCBhdXRoZW50aWNhdGUgb3IgcmVxdWVzdGVycm9yIHdpbGwgZmlyZVxyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudG9rZW4pIHtcclxuICAgICAgICAgIHJlc3BvbnNlLmhyZWYgKz0gKCc/dG9rZW49JyArIHRoaXMub3B0aW9ucy50b2tlbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucHJveHkpIHtcclxuICAgICAgICAgIHJlc3BvbnNlLmhyZWYgPSB0aGlzLm9wdGlvbnMucHJveHkgKyAnPycgKyByZXNwb25zZS5ocmVmO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9yZW5kZXJJbWFnZShyZXNwb25zZS5ocmVmLCBib3VuZHMpO1xyXG4gICAgICB9LCB0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHBhcmFtcy5mID0gJ2ltYWdlJztcclxuICAgICAgdmFyIGZ1bGxVcmwgPSB0aGlzLm9wdGlvbnMudXJsICsgJ2V4cG9ydEltYWdlJyArIFV0aWwuZ2V0UGFyYW1TdHJpbmcocGFyYW1zKTtcclxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5wcm94eSkge1xyXG4gICAgICAgIGZ1bGxVcmwgPSB0aGlzLm9wdGlvbnMucHJveHkgKyAnPycgKyBmdWxsVXJsO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX3JlbmRlckltYWdlKGZ1bGxVcmwsIGJvdW5kcyk7XHJcbiAgICB9XHJcbiAgfVxyXG59KTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpbWFnZU1hcExheWVyICh1cmwsIG9wdGlvbnMpIHtcclxuICByZXR1cm4gbmV3IEltYWdlTWFwTGF5ZXIodXJsLCBvcHRpb25zKTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgaW1hZ2VNYXBMYXllcjtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/esri-leaflet/src/Layers/ImageMapLayer.js\n");

/***/ }),

/***/ "./node_modules/esri-leaflet/src/Layers/RasterLayer.js":
/*!*************************************************************!*\
  !*** ./node_modules/esri-leaflet/src/Layers/RasterLayer.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RasterLayer\": () => (/* binding */ RasterLayer)\n/* harmony export */ });\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! leaflet */ \"./node_modules/leaflet/dist/leaflet-src.js\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Support__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Support */ \"./node_modules/esri-leaflet/src/Support.js\");\n/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Util */ \"./node_modules/esri-leaflet/src/Util.js\");\n\r\n\r\n\r\n\r\nvar Overlay = leaflet__WEBPACK_IMPORTED_MODULE_0__.ImageOverlay.extend({\r\n  onAdd: function (map) {\r\n    this._topLeft = map.getPixelBounds().min;\r\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.ImageOverlay.prototype.onAdd.call(this, map);\r\n  },\r\n  _reset: function () {\r\n    if (this._map.options.crs === leaflet__WEBPACK_IMPORTED_MODULE_0__.CRS.EPSG3857) {\r\n      leaflet__WEBPACK_IMPORTED_MODULE_0__.ImageOverlay.prototype._reset.call(this);\r\n    } else {\r\n      leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.setPosition(this._image, this._topLeft.subtract(this._map.getPixelOrigin()));\r\n    }\r\n  }\r\n});\r\n\r\nvar RasterLayer = leaflet__WEBPACK_IMPORTED_MODULE_0__.Layer.extend({\r\n  options: {\r\n    opacity: 1,\r\n    position: 'front',\r\n    f: 'image',\r\n    useCors: _Support__WEBPACK_IMPORTED_MODULE_1__.cors,\r\n    attribution: null,\r\n    interactive: false,\r\n    alt: ''\r\n  },\r\n\r\n  onAdd: function (map) {\r\n    // include 'Powered by Esri' in map attribution\r\n    (0,_Util__WEBPACK_IMPORTED_MODULE_2__.setEsriAttribution)(map);\r\n\r\n    if (this.options.zIndex) {\r\n      this.options.position = null;\r\n    }\r\n\r\n    this._update = leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.throttle(this._update, this.options.updateInterval, this);\r\n\r\n    map.on('moveend', this._update, this);\r\n\r\n    // if we had an image loaded and it matches the\r\n    // current bounds show the image otherwise remove it\r\n    if (this._currentImage && this._currentImage._bounds.equals(this._map.getBounds())) {\r\n      map.addLayer(this._currentImage);\r\n    } else if (this._currentImage) {\r\n      this._map.removeLayer(this._currentImage);\r\n      this._currentImage = null;\r\n    }\r\n\r\n    this._update();\r\n\r\n    if (this._popup) {\r\n      this._map.on('click', this._getPopupData, this);\r\n      this._map.on('dblclick', this._resetPopupState, this);\r\n    }\r\n\r\n    // add copyright text listed in service metadata\r\n    this.metadata(function (err, metadata) {\r\n      if (!err && !this.options.attribution && map.attributionControl && metadata.copyrightText) {\r\n        this.options.attribution = metadata.copyrightText;\r\n        map.attributionControl.addAttribution(this.getAttribution());\r\n      }\r\n    }, this);\r\n  },\r\n\r\n  onRemove: function (map) {\r\n    (0,_Util__WEBPACK_IMPORTED_MODULE_2__.removeEsriAttribution)(map);\r\n\r\n    if (this._currentImage) {\r\n      this._map.removeLayer(this._currentImage);\r\n    }\r\n\r\n    if (this._popup) {\r\n      this._map.off('click', this._getPopupData, this);\r\n      this._map.off('dblclick', this._resetPopupState, this);\r\n    }\r\n\r\n    this._map.off('moveend', this._update, this);\r\n  },\r\n\r\n  bindPopup: function (fn, popupOptions) {\r\n    this._shouldRenderPopup = false;\r\n    this._lastClick = false;\r\n    this._popup = (0,leaflet__WEBPACK_IMPORTED_MODULE_0__.popup)(popupOptions);\r\n    this._popupFunction = fn;\r\n    if (this._map) {\r\n      this._map.on('click', this._getPopupData, this);\r\n      this._map.on('dblclick', this._resetPopupState, this);\r\n    }\r\n    return this;\r\n  },\r\n\r\n  unbindPopup: function () {\r\n    if (this._map) {\r\n      this._map.closePopup(this._popup);\r\n      this._map.off('click', this._getPopupData, this);\r\n      this._map.off('dblclick', this._resetPopupState, this);\r\n    }\r\n    this._popup = false;\r\n    return this;\r\n  },\r\n\r\n  bringToFront: function () {\r\n    this.options.position = 'front';\r\n    if (this._currentImage) {\r\n      this._currentImage.bringToFront();\r\n      this._setAutoZIndex(Math.max);\r\n    }\r\n    return this;\r\n  },\r\n\r\n  bringToBack: function () {\r\n    this.options.position = 'back';\r\n    if (this._currentImage) {\r\n      this._currentImage.bringToBack();\r\n      this._setAutoZIndex(Math.min);\r\n    }\r\n    return this;\r\n  },\r\n\r\n  setZIndex: function (value) {\r\n    this.options.zIndex = value;\r\n    if (this._currentImage) {\r\n      this._currentImage.setZIndex(value);\r\n    }\r\n    return this;\r\n  },\r\n\r\n  _setAutoZIndex: function (compare) {\r\n    // go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)\r\n    if (!this._currentImage) {\r\n      return;\r\n    }\r\n    var layers = this._currentImage.getPane().children;\r\n    var edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min\r\n    for (var i = 0, len = layers.length, zIndex; i < len; i++) {\r\n      zIndex = layers[i].style.zIndex;\r\n      if (layers[i] !== this._currentImage._image && zIndex) {\r\n        edgeZIndex = compare(edgeZIndex, +zIndex);\r\n      }\r\n    }\r\n\r\n    if (isFinite(edgeZIndex)) {\r\n      this.options.zIndex = edgeZIndex + compare(-1, 1);\r\n      this.setZIndex(this.options.zIndex);\r\n    }\r\n  },\r\n\r\n  getAttribution: function () {\r\n    return this.options.attribution;\r\n  },\r\n\r\n  getOpacity: function () {\r\n    return this.options.opacity;\r\n  },\r\n\r\n  setOpacity: function (opacity) {\r\n    this.options.opacity = opacity;\r\n    if (this._currentImage) {\r\n      this._currentImage.setOpacity(opacity);\r\n    }\r\n    return this;\r\n  },\r\n\r\n  getTimeRange: function () {\r\n    return [this.options.from, this.options.to];\r\n  },\r\n\r\n  setTimeRange: function (from, to) {\r\n    this.options.from = from;\r\n    this.options.to = to;\r\n    this._update();\r\n    return this;\r\n  },\r\n\r\n  metadata: function (callback, context) {\r\n    this.service.metadata(callback, context);\r\n    return this;\r\n  },\r\n\r\n  authenticate: function (token) {\r\n    this.service.authenticate(token);\r\n    return this;\r\n  },\r\n\r\n  redraw: function () {\r\n    this._update();\r\n  },\r\n\r\n  _renderImage: function (url, bounds, contentType) {\r\n    if (this._map) {\r\n      // if no output directory has been specified for a service, MIME data will be returned\r\n      if (contentType) {\r\n        url = 'data:' + contentType + ';base64,' + url;\r\n      }\r\n\r\n      // if server returns an inappropriate response, abort.\r\n      if (!url) return;\r\n\r\n      // create a new image overlay and add it to the map\r\n      // to start loading the image\r\n      // opacity is 0 while the image is loading\r\n      var image = new Overlay(url, bounds, {\r\n        opacity: 0,\r\n        crossOrigin: this.options.withCredentials ? 'use-credentials' : this.options.useCors,\r\n        alt: this.options.alt,\r\n        pane: this.options.pane || this.getPane(),\r\n        interactive: this.options.interactive\r\n      }).addTo(this._map);\r\n\r\n      var onOverlayError = function () {\r\n        this._map.removeLayer(image);\r\n        this.fire('error');\r\n        image.off('load', onOverlayLoad, this);\r\n      };\r\n\r\n      var onOverlayLoad = function (e) {\r\n        image.off('error', onOverlayError, this);\r\n        if (this._map) {\r\n          var newImage = e.target;\r\n          var oldImage = this._currentImage;\r\n\r\n          // if the bounds of this image matches the bounds that\r\n          // _renderImage was called with and we have a map with the same bounds\r\n          // hide the old image if there is one and set the opacity\r\n          // of the new image otherwise remove the new image\r\n          if (newImage._bounds.equals(bounds) && newImage._bounds.equals(this._map.getBounds())) {\r\n            this._currentImage = newImage;\r\n\r\n            if (this.options.position === 'front') {\r\n              this.bringToFront();\r\n            } else if (this.options.position === 'back') {\r\n              this.bringToBack();\r\n            }\r\n\r\n            if (this.options.zIndex) {\r\n              this.setZIndex(this.options.zIndex);\r\n            }\r\n\r\n            if (this._map && this._currentImage._map) {\r\n              this._currentImage.setOpacity(this.options.opacity);\r\n            } else {\r\n              this._currentImage._map.removeLayer(this._currentImage);\r\n            }\r\n\r\n            if (oldImage && this._map) {\r\n              this._map.removeLayer(oldImage);\r\n            }\r\n\r\n            if (oldImage && oldImage._map) {\r\n              oldImage._map.removeLayer(oldImage);\r\n            }\r\n          } else {\r\n            this._map.removeLayer(newImage);\r\n          }\r\n        }\r\n\r\n        this.fire('load', {\r\n          bounds: bounds\r\n        });\r\n      };\r\n\r\n      // If loading the image fails\r\n      image.once('error', onOverlayError, this);\r\n\r\n      // once the image loads\r\n      image.once('load', onOverlayLoad, this);\r\n    }\r\n  },\r\n\r\n  _update: function () {\r\n    if (!this._map) {\r\n      return;\r\n    }\r\n\r\n    var zoom = this._map.getZoom();\r\n    var bounds = this._map.getBounds();\r\n\r\n    if (this._animatingZoom) {\r\n      return;\r\n    }\r\n\r\n    if (this._map._panTransition && this._map._panTransition._inProgress) {\r\n      return;\r\n    }\r\n\r\n    if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\r\n      if (this._currentImage) {\r\n        this._currentImage._map.removeLayer(this._currentImage);\r\n        this._currentImage = null;\r\n      }\r\n      return;\r\n    }\r\n\r\n    var params = this._buildExportParams();\r\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.extend(params, this.options.requestParams);\r\n\r\n    if (params) {\r\n      this._requestExport(params, bounds);\r\n\r\n      this.fire('loading', {\r\n        bounds: bounds\r\n      });\r\n    } else if (this._currentImage) {\r\n      this._currentImage._map.removeLayer(this._currentImage);\r\n      this._currentImage = null;\r\n    }\r\n  },\r\n\r\n  _renderPopup: function (latlng, error, results, response) {\r\n    latlng = (0,leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng)(latlng);\r\n    if (this._shouldRenderPopup && this._lastClick.equals(latlng)) {\r\n      // add the popup to the map where the mouse was clicked at\r\n      var content = this._popupFunction(error, results, response);\r\n      if (content) {\r\n        this._popup.setLatLng(latlng).setContent(content).openOn(this._map);\r\n      }\r\n    }\r\n  },\r\n\r\n  _resetPopupState: function (e) {\r\n    this._shouldRenderPopup = false;\r\n    this._lastClick = e.latlng;\r\n  },\r\n\r\n  _calculateBbox: function () {\r\n    var pixelBounds = this._map.getPixelBounds();\r\n\r\n    var sw = this._map.unproject(pixelBounds.getBottomLeft());\r\n    var ne = this._map.unproject(pixelBounds.getTopRight());\r\n\r\n    var neProjected = this._map.options.crs.project(ne);\r\n    var swProjected = this._map.options.crs.project(sw);\r\n\r\n    // this ensures ne/sw are switched in polar maps where north/top bottom/south is inverted\r\n    var boundsProjected = (0,leaflet__WEBPACK_IMPORTED_MODULE_0__.bounds)(neProjected, swProjected);\r\n\r\n    return [boundsProjected.getBottomLeft().x, boundsProjected.getBottomLeft().y, boundsProjected.getTopRight().x, boundsProjected.getTopRight().y].join(',');\r\n  },\r\n\r\n  _calculateImageSize: function () {\r\n    // ensure that we don't ask ArcGIS Server for a taller image than we have actual map displaying within the div\r\n    var bounds = this._map.getPixelBounds();\r\n    var size = this._map.getSize();\r\n\r\n    var sw = this._map.unproject(bounds.getBottomLeft());\r\n    var ne = this._map.unproject(bounds.getTopRight());\r\n\r\n    var top = this._map.latLngToLayerPoint(ne).y;\r\n    var bottom = this._map.latLngToLayerPoint(sw).y;\r\n\r\n    if (top > 0 || bottom < size.y) {\r\n      size.y = bottom - top;\r\n    }\r\n\r\n    return size.x + ',' + size.y;\r\n  }\r\n});\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXNyaS1sZWFmbGV0L3NyYy9MYXllcnMvUmFzdGVyTGF5ZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBeUY7QUFDdkQ7QUFDa0M7QUFDcEU7QUFDQSxjQUFjLHdEQUFtQjtBQUNqQztBQUNBO0FBQ0EsSUFBSSxzRUFBaUM7QUFDckMsR0FBRztBQUNIO0FBQ0Esa0NBQWtDLGlEQUFZO0FBQzlDLE1BQU0sdUVBQWtDO0FBQ3hDLE1BQU07QUFDTixNQUFNLHdEQUFtQjtBQUN6QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ08sa0JBQWtCLGlEQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwwQ0FBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBSSx5REFBa0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrREFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSSw0REFBcUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw4Q0FBSztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRCxpREFBaUQsU0FBUztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0RBQVc7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsYUFBYSwrQ0FBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLCtDQUFNO0FBQ2hDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lc3JpLWxlYWZsZXQvc3JjL0xheWVycy9SYXN0ZXJMYXllci5qcz8yZWU2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEltYWdlT3ZlcmxheSwgQ1JTLCBEb21VdGlsLCBVdGlsLCBMYXllciwgcG9wdXAsIGxhdExuZywgYm91bmRzIH0gZnJvbSAnbGVhZmxldCc7XHJcbmltcG9ydCB7IGNvcnMgfSBmcm9tICcuLi9TdXBwb3J0JztcclxuaW1wb3J0IHsgc2V0RXNyaUF0dHJpYnV0aW9uLCByZW1vdmVFc3JpQXR0cmlidXRpb24gfSBmcm9tICcuLi9VdGlsJztcclxuXHJcbnZhciBPdmVybGF5ID0gSW1hZ2VPdmVybGF5LmV4dGVuZCh7XHJcbiAgb25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuICAgIHRoaXMuX3RvcExlZnQgPSBtYXAuZ2V0UGl4ZWxCb3VuZHMoKS5taW47XHJcbiAgICBJbWFnZU92ZXJsYXkucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcclxuICB9LFxyXG4gIF9yZXNldDogZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHRoaXMuX21hcC5vcHRpb25zLmNycyA9PT0gQ1JTLkVQU0czODU3KSB7XHJcbiAgICAgIEltYWdlT3ZlcmxheS5wcm90b3R5cGUuX3Jlc2V0LmNhbGwodGhpcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBEb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2ltYWdlLCB0aGlzLl90b3BMZWZ0LnN1YnRyYWN0KHRoaXMuX21hcC5nZXRQaXhlbE9yaWdpbigpKSk7XHJcbiAgICB9XHJcbiAgfVxyXG59KTtcclxuXHJcbmV4cG9ydCB2YXIgUmFzdGVyTGF5ZXIgPSBMYXllci5leHRlbmQoe1xyXG4gIG9wdGlvbnM6IHtcclxuICAgIG9wYWNpdHk6IDEsXHJcbiAgICBwb3NpdGlvbjogJ2Zyb250JyxcclxuICAgIGY6ICdpbWFnZScsXHJcbiAgICB1c2VDb3JzOiBjb3JzLFxyXG4gICAgYXR0cmlidXRpb246IG51bGwsXHJcbiAgICBpbnRlcmFjdGl2ZTogZmFsc2UsXHJcbiAgICBhbHQ6ICcnXHJcbiAgfSxcclxuXHJcbiAgb25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuICAgIC8vIGluY2x1ZGUgJ1Bvd2VyZWQgYnkgRXNyaScgaW4gbWFwIGF0dHJpYnV0aW9uXHJcbiAgICBzZXRFc3JpQXR0cmlidXRpb24obWFwKTtcclxuXHJcbiAgICBpZiAodGhpcy5vcHRpb25zLnpJbmRleCkge1xyXG4gICAgICB0aGlzLm9wdGlvbnMucG9zaXRpb24gPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX3VwZGF0ZSA9IFV0aWwudGhyb3R0bGUodGhpcy5fdXBkYXRlLCB0aGlzLm9wdGlvbnMudXBkYXRlSW50ZXJ2YWwsIHRoaXMpO1xyXG5cclxuICAgIG1hcC5vbignbW92ZWVuZCcsIHRoaXMuX3VwZGF0ZSwgdGhpcyk7XHJcblxyXG4gICAgLy8gaWYgd2UgaGFkIGFuIGltYWdlIGxvYWRlZCBhbmQgaXQgbWF0Y2hlcyB0aGVcclxuICAgIC8vIGN1cnJlbnQgYm91bmRzIHNob3cgdGhlIGltYWdlIG90aGVyd2lzZSByZW1vdmUgaXRcclxuICAgIGlmICh0aGlzLl9jdXJyZW50SW1hZ2UgJiYgdGhpcy5fY3VycmVudEltYWdlLl9ib3VuZHMuZXF1YWxzKHRoaXMuX21hcC5nZXRCb3VuZHMoKSkpIHtcclxuICAgICAgbWFwLmFkZExheWVyKHRoaXMuX2N1cnJlbnRJbWFnZSk7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2N1cnJlbnRJbWFnZSkge1xyXG4gICAgICB0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fY3VycmVudEltYWdlKTtcclxuICAgICAgdGhpcy5fY3VycmVudEltYWdlID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl91cGRhdGUoKTtcclxuXHJcbiAgICBpZiAodGhpcy5fcG9wdXApIHtcclxuICAgICAgdGhpcy5fbWFwLm9uKCdjbGljaycsIHRoaXMuX2dldFBvcHVwRGF0YSwgdGhpcyk7XHJcbiAgICAgIHRoaXMuX21hcC5vbignZGJsY2xpY2snLCB0aGlzLl9yZXNldFBvcHVwU3RhdGUsIHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGFkZCBjb3B5cmlnaHQgdGV4dCBsaXN0ZWQgaW4gc2VydmljZSBtZXRhZGF0YVxyXG4gICAgdGhpcy5tZXRhZGF0YShmdW5jdGlvbiAoZXJyLCBtZXRhZGF0YSkge1xyXG4gICAgICBpZiAoIWVyciAmJiAhdGhpcy5vcHRpb25zLmF0dHJpYnV0aW9uICYmIG1hcC5hdHRyaWJ1dGlvbkNvbnRyb2wgJiYgbWV0YWRhdGEuY29weXJpZ2h0VGV4dCkge1xyXG4gICAgICAgIHRoaXMub3B0aW9ucy5hdHRyaWJ1dGlvbiA9IG1ldGFkYXRhLmNvcHlyaWdodFRleHQ7XHJcbiAgICAgICAgbWFwLmF0dHJpYnV0aW9uQ29udHJvbC5hZGRBdHRyaWJ1dGlvbih0aGlzLmdldEF0dHJpYnV0aW9uKCkpO1xyXG4gICAgICB9XHJcbiAgICB9LCB0aGlzKTtcclxuICB9LFxyXG5cclxuICBvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG4gICAgcmVtb3ZlRXNyaUF0dHJpYnV0aW9uKG1hcCk7XHJcblxyXG4gICAgaWYgKHRoaXMuX2N1cnJlbnRJbWFnZSkge1xyXG4gICAgICB0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fY3VycmVudEltYWdlKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fcG9wdXApIHtcclxuICAgICAgdGhpcy5fbWFwLm9mZignY2xpY2snLCB0aGlzLl9nZXRQb3B1cERhdGEsIHRoaXMpO1xyXG4gICAgICB0aGlzLl9tYXAub2ZmKCdkYmxjbGljaycsIHRoaXMuX3Jlc2V0UG9wdXBTdGF0ZSwgdGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fbWFwLm9mZignbW92ZWVuZCcsIHRoaXMuX3VwZGF0ZSwgdGhpcyk7XHJcbiAgfSxcclxuXHJcbiAgYmluZFBvcHVwOiBmdW5jdGlvbiAoZm4sIHBvcHVwT3B0aW9ucykge1xyXG4gICAgdGhpcy5fc2hvdWxkUmVuZGVyUG9wdXAgPSBmYWxzZTtcclxuICAgIHRoaXMuX2xhc3RDbGljayA9IGZhbHNlO1xyXG4gICAgdGhpcy5fcG9wdXAgPSBwb3B1cChwb3B1cE9wdGlvbnMpO1xyXG4gICAgdGhpcy5fcG9wdXBGdW5jdGlvbiA9IGZuO1xyXG4gICAgaWYgKHRoaXMuX21hcCkge1xyXG4gICAgICB0aGlzLl9tYXAub24oJ2NsaWNrJywgdGhpcy5fZ2V0UG9wdXBEYXRhLCB0aGlzKTtcclxuICAgICAgdGhpcy5fbWFwLm9uKCdkYmxjbGljaycsIHRoaXMuX3Jlc2V0UG9wdXBTdGF0ZSwgdGhpcyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICB1bmJpbmRQb3B1cDogZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHRoaXMuX21hcCkge1xyXG4gICAgICB0aGlzLl9tYXAuY2xvc2VQb3B1cCh0aGlzLl9wb3B1cCk7XHJcbiAgICAgIHRoaXMuX21hcC5vZmYoJ2NsaWNrJywgdGhpcy5fZ2V0UG9wdXBEYXRhLCB0aGlzKTtcclxuICAgICAgdGhpcy5fbWFwLm9mZignZGJsY2xpY2snLCB0aGlzLl9yZXNldFBvcHVwU3RhdGUsIHRoaXMpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fcG9wdXAgPSBmYWxzZTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0sXHJcblxyXG4gIGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5vcHRpb25zLnBvc2l0aW9uID0gJ2Zyb250JztcclxuICAgIGlmICh0aGlzLl9jdXJyZW50SW1hZ2UpIHtcclxuICAgICAgdGhpcy5fY3VycmVudEltYWdlLmJyaW5nVG9Gcm9udCgpO1xyXG4gICAgICB0aGlzLl9zZXRBdXRvWkluZGV4KE1hdGgubWF4KTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0sXHJcblxyXG4gIGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLm9wdGlvbnMucG9zaXRpb24gPSAnYmFjayc7XHJcbiAgICBpZiAodGhpcy5fY3VycmVudEltYWdlKSB7XHJcbiAgICAgIHRoaXMuX2N1cnJlbnRJbWFnZS5icmluZ1RvQmFjaygpO1xyXG4gICAgICB0aGlzLl9zZXRBdXRvWkluZGV4KE1hdGgubWluKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0sXHJcblxyXG4gIHNldFpJbmRleDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICB0aGlzLm9wdGlvbnMuekluZGV4ID0gdmFsdWU7XHJcbiAgICBpZiAodGhpcy5fY3VycmVudEltYWdlKSB7XHJcbiAgICAgIHRoaXMuX2N1cnJlbnRJbWFnZS5zZXRaSW5kZXgodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuXHJcbiAgX3NldEF1dG9aSW5kZXg6IGZ1bmN0aW9uIChjb21wYXJlKSB7XHJcbiAgICAvLyBnbyB0aHJvdWdoIGFsbCBvdGhlciBsYXllcnMgb2YgdGhlIHNhbWUgcGFuZSwgc2V0IHpJbmRleCB0byBtYXggKyAxIChmcm9udCkgb3IgbWluIC0gMSAoYmFjaylcclxuICAgIGlmICghdGhpcy5fY3VycmVudEltYWdlKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciBsYXllcnMgPSB0aGlzLl9jdXJyZW50SW1hZ2UuZ2V0UGFuZSgpLmNoaWxkcmVuO1xyXG4gICAgdmFyIGVkZ2VaSW5kZXggPSAtY29tcGFyZSgtSW5maW5pdHksIEluZmluaXR5KTsgLy8gLUluZmluaXR5IGZvciBtYXgsIEluZmluaXR5IGZvciBtaW5cclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXllcnMubGVuZ3RoLCB6SW5kZXg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICB6SW5kZXggPSBsYXllcnNbaV0uc3R5bGUuekluZGV4O1xyXG4gICAgICBpZiAobGF5ZXJzW2ldICE9PSB0aGlzLl9jdXJyZW50SW1hZ2UuX2ltYWdlICYmIHpJbmRleCkge1xyXG4gICAgICAgIGVkZ2VaSW5kZXggPSBjb21wYXJlKGVkZ2VaSW5kZXgsICt6SW5kZXgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzRmluaXRlKGVkZ2VaSW5kZXgpKSB7XHJcbiAgICAgIHRoaXMub3B0aW9ucy56SW5kZXggPSBlZGdlWkluZGV4ICsgY29tcGFyZSgtMSwgMSk7XHJcbiAgICAgIHRoaXMuc2V0WkluZGV4KHRoaXMub3B0aW9ucy56SW5kZXgpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGdldEF0dHJpYnV0aW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmF0dHJpYnV0aW9uO1xyXG4gIH0sXHJcblxyXG4gIGdldE9wYWNpdHk6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLm9wdGlvbnMub3BhY2l0eTtcclxuICB9LFxyXG5cclxuICBzZXRPcGFjaXR5OiBmdW5jdGlvbiAob3BhY2l0eSkge1xyXG4gICAgdGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xyXG4gICAgaWYgKHRoaXMuX2N1cnJlbnRJbWFnZSkge1xyXG4gICAgICB0aGlzLl9jdXJyZW50SW1hZ2Uuc2V0T3BhY2l0eShvcGFjaXR5KTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0sXHJcblxyXG4gIGdldFRpbWVSYW5nZTogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIFt0aGlzLm9wdGlvbnMuZnJvbSwgdGhpcy5vcHRpb25zLnRvXTtcclxuICB9LFxyXG5cclxuICBzZXRUaW1lUmFuZ2U6IGZ1bmN0aW9uIChmcm9tLCB0bykge1xyXG4gICAgdGhpcy5vcHRpb25zLmZyb20gPSBmcm9tO1xyXG4gICAgdGhpcy5vcHRpb25zLnRvID0gdG87XHJcbiAgICB0aGlzLl91cGRhdGUoKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0sXHJcblxyXG4gIG1ldGFkYXRhOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGNvbnRleHQpIHtcclxuICAgIHRoaXMuc2VydmljZS5tZXRhZGF0YShjYWxsYmFjaywgY29udGV4dCk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICBhdXRoZW50aWNhdGU6IGZ1bmN0aW9uICh0b2tlbikge1xyXG4gICAgdGhpcy5zZXJ2aWNlLmF1dGhlbnRpY2F0ZSh0b2tlbik7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICByZWRyYXc6IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuX3VwZGF0ZSgpO1xyXG4gIH0sXHJcblxyXG4gIF9yZW5kZXJJbWFnZTogZnVuY3Rpb24gKHVybCwgYm91bmRzLCBjb250ZW50VHlwZSkge1xyXG4gICAgaWYgKHRoaXMuX21hcCkge1xyXG4gICAgICAvLyBpZiBubyBvdXRwdXQgZGlyZWN0b3J5IGhhcyBiZWVuIHNwZWNpZmllZCBmb3IgYSBzZXJ2aWNlLCBNSU1FIGRhdGEgd2lsbCBiZSByZXR1cm5lZFxyXG4gICAgICBpZiAoY29udGVudFR5cGUpIHtcclxuICAgICAgICB1cmwgPSAnZGF0YTonICsgY29udGVudFR5cGUgKyAnO2Jhc2U2NCwnICsgdXJsO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBpZiBzZXJ2ZXIgcmV0dXJucyBhbiBpbmFwcHJvcHJpYXRlIHJlc3BvbnNlLCBhYm9ydC5cclxuICAgICAgaWYgKCF1cmwpIHJldHVybjtcclxuXHJcbiAgICAgIC8vIGNyZWF0ZSBhIG5ldyBpbWFnZSBvdmVybGF5IGFuZCBhZGQgaXQgdG8gdGhlIG1hcFxyXG4gICAgICAvLyB0byBzdGFydCBsb2FkaW5nIHRoZSBpbWFnZVxyXG4gICAgICAvLyBvcGFjaXR5IGlzIDAgd2hpbGUgdGhlIGltYWdlIGlzIGxvYWRpbmdcclxuICAgICAgdmFyIGltYWdlID0gbmV3IE92ZXJsYXkodXJsLCBib3VuZHMsIHtcclxuICAgICAgICBvcGFjaXR5OiAwLFxyXG4gICAgICAgIGNyb3NzT3JpZ2luOiB0aGlzLm9wdGlvbnMud2l0aENyZWRlbnRpYWxzID8gJ3VzZS1jcmVkZW50aWFscycgOiB0aGlzLm9wdGlvbnMudXNlQ29ycyxcclxuICAgICAgICBhbHQ6IHRoaXMub3B0aW9ucy5hbHQsXHJcbiAgICAgICAgcGFuZTogdGhpcy5vcHRpb25zLnBhbmUgfHwgdGhpcy5nZXRQYW5lKCksXHJcbiAgICAgICAgaW50ZXJhY3RpdmU6IHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZVxyXG4gICAgICB9KS5hZGRUbyh0aGlzLl9tYXApO1xyXG5cclxuICAgICAgdmFyIG9uT3ZlcmxheUVycm9yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX21hcC5yZW1vdmVMYXllcihpbWFnZSk7XHJcbiAgICAgICAgdGhpcy5maXJlKCdlcnJvcicpO1xyXG4gICAgICAgIGltYWdlLm9mZignbG9hZCcsIG9uT3ZlcmxheUxvYWQsIHRoaXMpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgdmFyIG9uT3ZlcmxheUxvYWQgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGltYWdlLm9mZignZXJyb3InLCBvbk92ZXJsYXlFcnJvciwgdGhpcyk7XHJcbiAgICAgICAgaWYgKHRoaXMuX21hcCkge1xyXG4gICAgICAgICAgdmFyIG5ld0ltYWdlID0gZS50YXJnZXQ7XHJcbiAgICAgICAgICB2YXIgb2xkSW1hZ2UgPSB0aGlzLl9jdXJyZW50SW1hZ2U7XHJcblxyXG4gICAgICAgICAgLy8gaWYgdGhlIGJvdW5kcyBvZiB0aGlzIGltYWdlIG1hdGNoZXMgdGhlIGJvdW5kcyB0aGF0XHJcbiAgICAgICAgICAvLyBfcmVuZGVySW1hZ2Ugd2FzIGNhbGxlZCB3aXRoIGFuZCB3ZSBoYXZlIGEgbWFwIHdpdGggdGhlIHNhbWUgYm91bmRzXHJcbiAgICAgICAgICAvLyBoaWRlIHRoZSBvbGQgaW1hZ2UgaWYgdGhlcmUgaXMgb25lIGFuZCBzZXQgdGhlIG9wYWNpdHlcclxuICAgICAgICAgIC8vIG9mIHRoZSBuZXcgaW1hZ2Ugb3RoZXJ3aXNlIHJlbW92ZSB0aGUgbmV3IGltYWdlXHJcbiAgICAgICAgICBpZiAobmV3SW1hZ2UuX2JvdW5kcy5lcXVhbHMoYm91bmRzKSAmJiBuZXdJbWFnZS5fYm91bmRzLmVxdWFscyh0aGlzLl9tYXAuZ2V0Qm91bmRzKCkpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRJbWFnZSA9IG5ld0ltYWdlO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9PT0gJ2Zyb250Jykge1xyXG4gICAgICAgICAgICAgIHRoaXMuYnJpbmdUb0Zyb250KCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSAnYmFjaycpIHtcclxuICAgICAgICAgICAgICB0aGlzLmJyaW5nVG9CYWNrKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuekluZGV4KSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5zZXRaSW5kZXgodGhpcy5vcHRpb25zLnpJbmRleCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9tYXAgJiYgdGhpcy5fY3VycmVudEltYWdlLl9tYXApIHtcclxuICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50SW1hZ2Uuc2V0T3BhY2l0eSh0aGlzLm9wdGlvbnMub3BhY2l0eSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5fY3VycmVudEltYWdlLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fY3VycmVudEltYWdlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG9sZEltYWdlICYmIHRoaXMuX21hcCkge1xyXG4gICAgICAgICAgICAgIHRoaXMuX21hcC5yZW1vdmVMYXllcihvbGRJbWFnZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChvbGRJbWFnZSAmJiBvbGRJbWFnZS5fbWFwKSB7XHJcbiAgICAgICAgICAgICAgb2xkSW1hZ2UuX21hcC5yZW1vdmVMYXllcihvbGRJbWFnZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21hcC5yZW1vdmVMYXllcihuZXdJbWFnZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmZpcmUoJ2xvYWQnLCB7XHJcbiAgICAgICAgICBib3VuZHM6IGJvdW5kc1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gSWYgbG9hZGluZyB0aGUgaW1hZ2UgZmFpbHNcclxuICAgICAgaW1hZ2Uub25jZSgnZXJyb3InLCBvbk92ZXJsYXlFcnJvciwgdGhpcyk7XHJcblxyXG4gICAgICAvLyBvbmNlIHRoZSBpbWFnZSBsb2Fkc1xyXG4gICAgICBpbWFnZS5vbmNlKCdsb2FkJywgb25PdmVybGF5TG9hZCwgdGhpcyk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgX3VwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKCF0aGlzLl9tYXApIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcclxuICAgIHZhciBib3VuZHMgPSB0aGlzLl9tYXAuZ2V0Qm91bmRzKCk7XHJcblxyXG4gICAgaWYgKHRoaXMuX2FuaW1hdGluZ1pvb20pIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9tYXAuX3BhblRyYW5zaXRpb24gJiYgdGhpcy5fbWFwLl9wYW5UcmFuc2l0aW9uLl9pblByb2dyZXNzKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoem9vbSA+IHRoaXMub3B0aW9ucy5tYXhab29tIHx8IHpvb20gPCB0aGlzLm9wdGlvbnMubWluWm9vbSkge1xyXG4gICAgICBpZiAodGhpcy5fY3VycmVudEltYWdlKSB7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudEltYWdlLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fY3VycmVudEltYWdlKTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50SW1hZ2UgPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcGFyYW1zID0gdGhpcy5fYnVpbGRFeHBvcnRQYXJhbXMoKTtcclxuICAgIFV0aWwuZXh0ZW5kKHBhcmFtcywgdGhpcy5vcHRpb25zLnJlcXVlc3RQYXJhbXMpO1xyXG5cclxuICAgIGlmIChwYXJhbXMpIHtcclxuICAgICAgdGhpcy5fcmVxdWVzdEV4cG9ydChwYXJhbXMsIGJvdW5kcyk7XHJcblxyXG4gICAgICB0aGlzLmZpcmUoJ2xvYWRpbmcnLCB7XHJcbiAgICAgICAgYm91bmRzOiBib3VuZHNcclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2N1cnJlbnRJbWFnZSkge1xyXG4gICAgICB0aGlzLl9jdXJyZW50SW1hZ2UuX21hcC5yZW1vdmVMYXllcih0aGlzLl9jdXJyZW50SW1hZ2UpO1xyXG4gICAgICB0aGlzLl9jdXJyZW50SW1hZ2UgPSBudWxsO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIF9yZW5kZXJQb3B1cDogZnVuY3Rpb24gKGxhdGxuZywgZXJyb3IsIHJlc3VsdHMsIHJlc3BvbnNlKSB7XHJcbiAgICBsYXRsbmcgPSBsYXRMbmcobGF0bG5nKTtcclxuICAgIGlmICh0aGlzLl9zaG91bGRSZW5kZXJQb3B1cCAmJiB0aGlzLl9sYXN0Q2xpY2suZXF1YWxzKGxhdGxuZykpIHtcclxuICAgICAgLy8gYWRkIHRoZSBwb3B1cCB0byB0aGUgbWFwIHdoZXJlIHRoZSBtb3VzZSB3YXMgY2xpY2tlZCBhdFxyXG4gICAgICB2YXIgY29udGVudCA9IHRoaXMuX3BvcHVwRnVuY3Rpb24oZXJyb3IsIHJlc3VsdHMsIHJlc3BvbnNlKTtcclxuICAgICAgaWYgKGNvbnRlbnQpIHtcclxuICAgICAgICB0aGlzLl9wb3B1cC5zZXRMYXRMbmcobGF0bG5nKS5zZXRDb250ZW50KGNvbnRlbnQpLm9wZW5Pbih0aGlzLl9tYXApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgX3Jlc2V0UG9wdXBTdGF0ZTogZnVuY3Rpb24gKGUpIHtcclxuICAgIHRoaXMuX3Nob3VsZFJlbmRlclBvcHVwID0gZmFsc2U7XHJcbiAgICB0aGlzLl9sYXN0Q2xpY2sgPSBlLmxhdGxuZztcclxuICB9LFxyXG5cclxuICBfY2FsY3VsYXRlQmJveDogZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHBpeGVsQm91bmRzID0gdGhpcy5fbWFwLmdldFBpeGVsQm91bmRzKCk7XHJcblxyXG4gICAgdmFyIHN3ID0gdGhpcy5fbWFwLnVucHJvamVjdChwaXhlbEJvdW5kcy5nZXRCb3R0b21MZWZ0KCkpO1xyXG4gICAgdmFyIG5lID0gdGhpcy5fbWFwLnVucHJvamVjdChwaXhlbEJvdW5kcy5nZXRUb3BSaWdodCgpKTtcclxuXHJcbiAgICB2YXIgbmVQcm9qZWN0ZWQgPSB0aGlzLl9tYXAub3B0aW9ucy5jcnMucHJvamVjdChuZSk7XHJcbiAgICB2YXIgc3dQcm9qZWN0ZWQgPSB0aGlzLl9tYXAub3B0aW9ucy5jcnMucHJvamVjdChzdyk7XHJcblxyXG4gICAgLy8gdGhpcyBlbnN1cmVzIG5lL3N3IGFyZSBzd2l0Y2hlZCBpbiBwb2xhciBtYXBzIHdoZXJlIG5vcnRoL3RvcCBib3R0b20vc291dGggaXMgaW52ZXJ0ZWRcclxuICAgIHZhciBib3VuZHNQcm9qZWN0ZWQgPSBib3VuZHMobmVQcm9qZWN0ZWQsIHN3UHJvamVjdGVkKTtcclxuXHJcbiAgICByZXR1cm4gW2JvdW5kc1Byb2plY3RlZC5nZXRCb3R0b21MZWZ0KCkueCwgYm91bmRzUHJvamVjdGVkLmdldEJvdHRvbUxlZnQoKS55LCBib3VuZHNQcm9qZWN0ZWQuZ2V0VG9wUmlnaHQoKS54LCBib3VuZHNQcm9qZWN0ZWQuZ2V0VG9wUmlnaHQoKS55XS5qb2luKCcsJyk7XHJcbiAgfSxcclxuXHJcbiAgX2NhbGN1bGF0ZUltYWdlU2l6ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gZW5zdXJlIHRoYXQgd2UgZG9uJ3QgYXNrIEFyY0dJUyBTZXJ2ZXIgZm9yIGEgdGFsbGVyIGltYWdlIHRoYW4gd2UgaGF2ZSBhY3R1YWwgbWFwIGRpc3BsYXlpbmcgd2l0aGluIHRoZSBkaXZcclxuICAgIHZhciBib3VuZHMgPSB0aGlzLl9tYXAuZ2V0UGl4ZWxCb3VuZHMoKTtcclxuICAgIHZhciBzaXplID0gdGhpcy5fbWFwLmdldFNpemUoKTtcclxuXHJcbiAgICB2YXIgc3cgPSB0aGlzLl9tYXAudW5wcm9qZWN0KGJvdW5kcy5nZXRCb3R0b21MZWZ0KCkpO1xyXG4gICAgdmFyIG5lID0gdGhpcy5fbWFwLnVucHJvamVjdChib3VuZHMuZ2V0VG9wUmlnaHQoKSk7XHJcblxyXG4gICAgdmFyIHRvcCA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQobmUpLnk7XHJcbiAgICB2YXIgYm90dG9tID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChzdykueTtcclxuXHJcbiAgICBpZiAodG9wID4gMCB8fCBib3R0b20gPCBzaXplLnkpIHtcclxuICAgICAgc2l6ZS55ID0gYm90dG9tIC0gdG9wO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzaXplLnggKyAnLCcgKyBzaXplLnk7XHJcbiAgfVxyXG59KTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/esri-leaflet/src/Layers/RasterLayer.js\n");

/***/ }),

/***/ "./node_modules/esri-leaflet/src/Layers/TiledMapLayer.js":
/*!***************************************************************!*\
  !*** ./node_modules/esri-leaflet/src/Layers/TiledMapLayer.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TiledMapLayer\": () => (/* binding */ TiledMapLayer),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"tiledMapLayer\": () => (/* binding */ tiledMapLayer)\n/* harmony export */ });\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! leaflet */ \"./node_modules/leaflet/dist/leaflet-src.js\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Util */ \"./node_modules/esri-leaflet/src/Util.js\");\n/* harmony import */ var _Services_MapService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Services/MapService */ \"./node_modules/esri-leaflet/src/Services/MapService.js\");\n\r\n\r\n\r\n\r\nvar TiledMapLayer = leaflet__WEBPACK_IMPORTED_MODULE_0__.TileLayer.extend({\r\n  options: {\r\n    zoomOffsetAllowance: 0.1,\r\n    errorTileUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEABAMAAACuXLVVAAAAA1BMVEUzNDVszlHHAAAAAXRSTlMAQObYZgAAAAlwSFlzAAAAAAAAAAAB6mUWpAAAADZJREFUeJztwQEBAAAAgiD/r25IQAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA7waBAAABw08RwAAAAABJRU5ErkJggg=='\r\n  },\r\n\r\n  statics: {\r\n    MercatorZoomLevels: {\r\n      0: 156543.03392799999,\r\n      1: 78271.516963999893,\r\n      2: 39135.758482000099,\r\n      3: 19567.879240999901,\r\n      4: 9783.9396204999593,\r\n      5: 4891.9698102499797,\r\n      6: 2445.9849051249898,\r\n      7: 1222.9924525624899,\r\n      8: 611.49622628138002,\r\n      9: 305.74811314055802,\r\n      10: 152.874056570411,\r\n      11: 76.437028285073197,\r\n      12: 38.218514142536598,\r\n      13: 19.109257071268299,\r\n      14: 9.5546285356341496,\r\n      15: 4.7773142679493699,\r\n      16: 2.38865713397468,\r\n      17: 1.1943285668550501,\r\n      18: 0.59716428355981699,\r\n      19: 0.29858214164761698,\r\n      20: 0.14929107082381,\r\n      21: 0.07464553541191,\r\n      22: 0.0373227677059525,\r\n      23: 0.0186613838529763\r\n    }\r\n  },\r\n\r\n  initialize: function (options) {\r\n    options = leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.setOptions(this, options);\r\n\r\n    // set the urls\r\n    options = (0,_Util__WEBPACK_IMPORTED_MODULE_1__.getUrlParams)(options);\r\n    this.tileUrl = (options.proxy ? options.proxy + '?' : '') + options.url + 'tile/{z}/{y}/{x}' + (options.requestParams && Object.keys(options.requestParams).length > 0 ? leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.getParamString(options.requestParams) : '');\r\n    // Remove subdomain in url\r\n    // https://github.com/Esri/esri-leaflet/issues/991\r\n    if (options.url.indexOf('{s}') !== -1 && options.subdomains) {\r\n      options.url = options.url.replace('{s}', options.subdomains[0]);\r\n    }\r\n    this.service = (0,_Services_MapService__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(options);\r\n    this.service.addEventParent(this);\r\n\r\n    var arcgisonline = new RegExp(/tiles.arcgis(online)?\\.com/g);\r\n    if (arcgisonline.test(options.url)) {\r\n      this.tileUrl = this.tileUrl.replace('://tiles', '://tiles{s}');\r\n      options.subdomains = ['1', '2', '3', '4'];\r\n    }\r\n\r\n    if (this.options.token) {\r\n      this.tileUrl += ('?token=' + this.options.token);\r\n    }\r\n\r\n    // init layer by calling TileLayers initialize method\r\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.TileLayer.prototype.initialize.call(this, this.tileUrl, options);\r\n  },\r\n\r\n  getTileUrl: function (tilePoint) {\r\n    var zoom = this._getZoomForUrl();\r\n\r\n    return leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.template(this.tileUrl, leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.extend({\r\n      s: this._getSubdomain(tilePoint),\r\n      x: tilePoint.x,\r\n      y: tilePoint.y,\r\n      // try lod map first, then just default to zoom level\r\n      z: (this._lodMap && this._lodMap[zoom]) ? this._lodMap[zoom] : zoom\r\n    }, this.options));\r\n  },\r\n\r\n  createTile: function (coords, done) {\r\n    var tile = document.createElement('img');\r\n\r\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.DomEvent.on(tile, 'load', leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.bind(this._tileOnLoad, this, done, tile));\r\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.DomEvent.on(tile, 'error', leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.bind(this._tileOnError, this, done, tile));\r\n\r\n    if (this.options.crossOrigin) {\r\n      tile.crossOrigin = '';\r\n    }\r\n\r\n    /*\r\n     Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons\r\n     http://www.w3.org/TR/WCAG20-TECHS/H67\r\n    */\r\n    tile.alt = '';\r\n\r\n    // if there is no lod map or an lod map with a proper zoom load the tile\r\n    // otherwise wait for the lod map to become available\r\n    if (!this._lodMap || (this._lodMap && this._lodMap[this._getZoomForUrl()])) {\r\n      tile.src = this.getTileUrl(coords);\r\n    } else {\r\n      this.once('lodmap', function () {\r\n        tile.src = this.getTileUrl(coords);\r\n      }, this);\r\n    }\r\n\r\n    return tile;\r\n  },\r\n\r\n  onAdd: function (map) {\r\n    // include 'Powered by Esri' in map attribution\r\n    (0,_Util__WEBPACK_IMPORTED_MODULE_1__.setEsriAttribution)(map);\r\n\r\n    if (!this._lodMap) {\r\n      this.metadata(function (error, metadata) {\r\n        if (!error && metadata.spatialReference) {\r\n          var sr = metadata.spatialReference.latestWkid || metadata.spatialReference.wkid;\r\n          // display the copyright text from the service using leaflet's attribution control\r\n          if (!this.options.attribution && map.attributionControl && metadata.copyrightText) {\r\n            this.options.attribution = metadata.copyrightText;\r\n            map.attributionControl.addAttribution(this.getAttribution());\r\n          }\r\n\r\n          // if the service tiles were published in web mercator using conventional LODs but missing levels, we can try and remap them\r\n          if (map.options.crs === leaflet__WEBPACK_IMPORTED_MODULE_0__.CRS.EPSG3857 && (sr === 102100 || sr === 3857)) {\r\n            this._lodMap = {};\r\n            // create the zoom level data\r\n            var arcgisLODs = metadata.tileInfo.lods;\r\n            var correctResolutions = TiledMapLayer.MercatorZoomLevels;\r\n\r\n            for (var i = 0; i < arcgisLODs.length; i++) {\r\n              var arcgisLOD = arcgisLODs[i];\r\n              for (var ci in correctResolutions) {\r\n                var correctRes = correctResolutions[ci];\r\n\r\n                if (this._withinPercentage(arcgisLOD.resolution, correctRes, this.options.zoomOffsetAllowance)) {\r\n                  this._lodMap[ci] = arcgisLOD.level;\r\n                  break;\r\n                }\r\n              }\r\n            }\r\n\r\n            this.fire('lodmap');\r\n          } else if (map.options.crs && map.options.crs.code && (map.options.crs.code.indexOf(sr) > -1)) {\r\n            // if the projection is WGS84, or the developer is using Proj4 to define a custom CRS, no action is required\r\n          } else {\r\n            // if the service was cached in a custom projection and an appropriate LOD hasn't been defined in the map, guide the developer to our Proj4 sample\r\n            (0,_Util__WEBPACK_IMPORTED_MODULE_1__.warn)('L.esri.TiledMapLayer is using a non-mercator spatial reference. Support may be available through Proj4Leaflet https://developers.arcgis.com/esri-leaflet/samples/non-mercator-projection/');\r\n          }\r\n        }\r\n      }, this);\r\n    }\r\n\r\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.TileLayer.prototype.onAdd.call(this, map);\r\n  },\r\n\r\n  onRemove: function (map) {\r\n    (0,_Util__WEBPACK_IMPORTED_MODULE_1__.removeEsriAttribution)(map);\r\n\r\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.TileLayer.prototype.onRemove.call(this, map);\r\n  },\r\n\r\n  metadata: function (callback, context) {\r\n    this.service.metadata(callback, context);\r\n    return this;\r\n  },\r\n\r\n  identify: function () {\r\n    return this.service.identify();\r\n  },\r\n\r\n  find: function () {\r\n    return this.service.find();\r\n  },\r\n\r\n  query: function () {\r\n    return this.service.query();\r\n  },\r\n\r\n  authenticate: function (token) {\r\n    var tokenQs = '?token=' + token;\r\n    this.tileUrl = (this.options.token) ? this.tileUrl.replace(/\\?token=(.+)/g, tokenQs) : this.tileUrl + tokenQs;\r\n    this.options.token = token;\r\n    this.service.authenticate(token);\r\n    return this;\r\n  },\r\n\r\n  _withinPercentage: function (a, b, percentage) {\r\n    var diff = Math.abs((a / b) - 1);\r\n    return diff < percentage;\r\n  }\r\n});\r\n\r\nfunction tiledMapLayer (url, options) {\r\n  return new TiledMapLayer(url, options);\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (tiledMapLayer);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXNyaS1sZWFmbGV0L3NyYy9MYXllcnMvVGlsZWRNYXBMYXllci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXlEO0FBQytCO0FBQ3hDO0FBQ2hEO0FBQ08sb0JBQW9CLHFEQUFnQjtBQUMzQztBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsY0FBYyxvREFBZTtBQUM3QjtBQUNBO0FBQ0EsY0FBYyxtREFBWTtBQUMxQixxRkFBcUYsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLDhFQUE4RSx3REFBbUI7QUFDaE07QUFDQTtBQUNBLDhCQUE4QixFQUFFO0FBQ2hDLDBDQUEwQyxFQUFFO0FBQzVDO0FBQ0EsbUJBQW1CLGdFQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLEVBQUU7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksd0VBQW1DO0FBQ3ZDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0RBQWEsZUFBZSxnREFBVztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0RBQVcsZUFBZSw4Q0FBUztBQUN2QyxJQUFJLGdEQUFXLGdCQUFnQiw4Q0FBUztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBSSx5REFBa0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGlEQUFZO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUJBQXVCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVksMkNBQUk7QUFDaEI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsSUFBSSxtRUFBOEI7QUFDbEMsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJLDREQUFxQjtBQUN6QjtBQUNBLElBQUksc0VBQWlDO0FBQ3JDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxhQUFhLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXNyaS1sZWFmbGV0L3NyYy9MYXllcnMvVGlsZWRNYXBMYXllci5qcz80Y2ZmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENSUywgRG9tRXZlbnQsIFRpbGVMYXllciwgVXRpbCB9IGZyb20gJ2xlYWZsZXQnO1xyXG5pbXBvcnQgeyB3YXJuLCBnZXRVcmxQYXJhbXMsIHNldEVzcmlBdHRyaWJ1dGlvbiwgcmVtb3ZlRXNyaUF0dHJpYnV0aW9uIH0gZnJvbSAnLi4vVXRpbCc7XHJcbmltcG9ydCBtYXBTZXJ2aWNlIGZyb20gJy4uL1NlcnZpY2VzL01hcFNlcnZpY2UnO1xyXG5cclxuZXhwb3J0IHZhciBUaWxlZE1hcExheWVyID0gVGlsZUxheWVyLmV4dGVuZCh7XHJcbiAgb3B0aW9uczoge1xyXG4gICAgem9vbU9mZnNldEFsbG93YW5jZTogMC4xLFxyXG4gICAgZXJyb3JUaWxlVXJsOiAnZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFRQUFBQUVBQkFNQUFBQ3VYTFZWQUFBQUExQk1WRVV6TkRWc3psSEhBQUFBQVhSU1RsTUFRT2JZWmdBQUFBbHdTRmx6QUFBQUFBQUFBQUFCNm1VV3BBQUFBRFpKUkVGVWVKenR3UUVCQUFBQWdpRC9yMjVJUUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUE3d2FCQUFBQncwOFJ3QUFBQUFCSlJVNUVya0pnZ2c9PSdcclxuICB9LFxyXG5cclxuICBzdGF0aWNzOiB7XHJcbiAgICBNZXJjYXRvclpvb21MZXZlbHM6IHtcclxuICAgICAgMDogMTU2NTQzLjAzMzkyNzk5OTk5LFxyXG4gICAgICAxOiA3ODI3MS41MTY5NjM5OTk4OTMsXHJcbiAgICAgIDI6IDM5MTM1Ljc1ODQ4MjAwMDA5OSxcclxuICAgICAgMzogMTk1NjcuODc5MjQwOTk5OTAxLFxyXG4gICAgICA0OiA5NzgzLjkzOTYyMDQ5OTk1OTMsXHJcbiAgICAgIDU6IDQ4OTEuOTY5ODEwMjQ5OTc5NyxcclxuICAgICAgNjogMjQ0NS45ODQ5MDUxMjQ5ODk4LFxyXG4gICAgICA3OiAxMjIyLjk5MjQ1MjU2MjQ4OTksXHJcbiAgICAgIDg6IDYxMS40OTYyMjYyODEzODAwMixcclxuICAgICAgOTogMzA1Ljc0ODExMzE0MDU1ODAyLFxyXG4gICAgICAxMDogMTUyLjg3NDA1NjU3MDQxMSxcclxuICAgICAgMTE6IDc2LjQzNzAyODI4NTA3MzE5NyxcclxuICAgICAgMTI6IDM4LjIxODUxNDE0MjUzNjU5OCxcclxuICAgICAgMTM6IDE5LjEwOTI1NzA3MTI2ODI5OSxcclxuICAgICAgMTQ6IDkuNTU0NjI4NTM1NjM0MTQ5NixcclxuICAgICAgMTU6IDQuNzc3MzE0MjY3OTQ5MzY5OSxcclxuICAgICAgMTY6IDIuMzg4NjU3MTMzOTc0NjgsXHJcbiAgICAgIDE3OiAxLjE5NDMyODU2Njg1NTA1MDEsXHJcbiAgICAgIDE4OiAwLjU5NzE2NDI4MzU1OTgxNjk5LFxyXG4gICAgICAxOTogMC4yOTg1ODIxNDE2NDc2MTY5OCxcclxuICAgICAgMjA6IDAuMTQ5MjkxMDcwODIzODEsXHJcbiAgICAgIDIxOiAwLjA3NDY0NTUzNTQxMTkxLFxyXG4gICAgICAyMjogMC4wMzczMjI3Njc3MDU5NTI1LFxyXG4gICAgICAyMzogMC4wMTg2NjEzODM4NTI5NzYzXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgIG9wdGlvbnMgPSBVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG4gICAgLy8gc2V0IHRoZSB1cmxzXHJcbiAgICBvcHRpb25zID0gZ2V0VXJsUGFyYW1zKG9wdGlvbnMpO1xyXG4gICAgdGhpcy50aWxlVXJsID0gKG9wdGlvbnMucHJveHkgPyBvcHRpb25zLnByb3h5ICsgJz8nIDogJycpICsgb3B0aW9ucy51cmwgKyAndGlsZS97en0ve3l9L3t4fScgKyAob3B0aW9ucy5yZXF1ZXN0UGFyYW1zICYmIE9iamVjdC5rZXlzKG9wdGlvbnMucmVxdWVzdFBhcmFtcykubGVuZ3RoID4gMCA/IFV0aWwuZ2V0UGFyYW1TdHJpbmcob3B0aW9ucy5yZXF1ZXN0UGFyYW1zKSA6ICcnKTtcclxuICAgIC8vIFJlbW92ZSBzdWJkb21haW4gaW4gdXJsXHJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vRXNyaS9lc3JpLWxlYWZsZXQvaXNzdWVzLzk5MVxyXG4gICAgaWYgKG9wdGlvbnMudXJsLmluZGV4T2YoJ3tzfScpICE9PSAtMSAmJiBvcHRpb25zLnN1YmRvbWFpbnMpIHtcclxuICAgICAgb3B0aW9ucy51cmwgPSBvcHRpb25zLnVybC5yZXBsYWNlKCd7c30nLCBvcHRpb25zLnN1YmRvbWFpbnNbMF0pO1xyXG4gICAgfVxyXG4gICAgdGhpcy5zZXJ2aWNlID0gbWFwU2VydmljZShvcHRpb25zKTtcclxuICAgIHRoaXMuc2VydmljZS5hZGRFdmVudFBhcmVudCh0aGlzKTtcclxuXHJcbiAgICB2YXIgYXJjZ2lzb25saW5lID0gbmV3IFJlZ0V4cCgvdGlsZXMuYXJjZ2lzKG9ubGluZSk/XFwuY29tL2cpO1xyXG4gICAgaWYgKGFyY2dpc29ubGluZS50ZXN0KG9wdGlvbnMudXJsKSkge1xyXG4gICAgICB0aGlzLnRpbGVVcmwgPSB0aGlzLnRpbGVVcmwucmVwbGFjZSgnOi8vdGlsZXMnLCAnOi8vdGlsZXN7c30nKTtcclxuICAgICAgb3B0aW9ucy5zdWJkb21haW5zID0gWycxJywgJzInLCAnMycsICc0J107XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMub3B0aW9ucy50b2tlbikge1xyXG4gICAgICB0aGlzLnRpbGVVcmwgKz0gKCc/dG9rZW49JyArIHRoaXMub3B0aW9ucy50b2tlbik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaW5pdCBsYXllciBieSBjYWxsaW5nIFRpbGVMYXllcnMgaW5pdGlhbGl6ZSBtZXRob2RcclxuICAgIFRpbGVMYXllci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIHRoaXMudGlsZVVybCwgb3B0aW9ucyk7XHJcbiAgfSxcclxuXHJcbiAgZ2V0VGlsZVVybDogZnVuY3Rpb24gKHRpbGVQb2ludCkge1xyXG4gICAgdmFyIHpvb20gPSB0aGlzLl9nZXRab29tRm9yVXJsKCk7XHJcblxyXG4gICAgcmV0dXJuIFV0aWwudGVtcGxhdGUodGhpcy50aWxlVXJsLCBVdGlsLmV4dGVuZCh7XHJcbiAgICAgIHM6IHRoaXMuX2dldFN1YmRvbWFpbih0aWxlUG9pbnQpLFxyXG4gICAgICB4OiB0aWxlUG9pbnQueCxcclxuICAgICAgeTogdGlsZVBvaW50LnksXHJcbiAgICAgIC8vIHRyeSBsb2QgbWFwIGZpcnN0LCB0aGVuIGp1c3QgZGVmYXVsdCB0byB6b29tIGxldmVsXHJcbiAgICAgIHo6ICh0aGlzLl9sb2RNYXAgJiYgdGhpcy5fbG9kTWFwW3pvb21dKSA/IHRoaXMuX2xvZE1hcFt6b29tXSA6IHpvb21cclxuICAgIH0sIHRoaXMub3B0aW9ucykpO1xyXG4gIH0sXHJcblxyXG4gIGNyZWF0ZVRpbGU6IGZ1bmN0aW9uIChjb29yZHMsIGRvbmUpIHtcclxuICAgIHZhciB0aWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XHJcblxyXG4gICAgRG9tRXZlbnQub24odGlsZSwgJ2xvYWQnLCBVdGlsLmJpbmQodGhpcy5fdGlsZU9uTG9hZCwgdGhpcywgZG9uZSwgdGlsZSkpO1xyXG4gICAgRG9tRXZlbnQub24odGlsZSwgJ2Vycm9yJywgVXRpbC5iaW5kKHRoaXMuX3RpbGVPbkVycm9yLCB0aGlzLCBkb25lLCB0aWxlKSk7XHJcblxyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbikge1xyXG4gICAgICB0aWxlLmNyb3NzT3JpZ2luID0gJyc7XHJcbiAgICB9XHJcblxyXG4gICAgLypcclxuICAgICBBbHQgdGFnIGlzIHNldCB0byBlbXB0eSBzdHJpbmcgdG8ga2VlcCBzY3JlZW4gcmVhZGVycyBmcm9tIHJlYWRpbmcgVVJMIGFuZCBmb3IgY29tcGxpYW5jZSByZWFzb25zXHJcbiAgICAgaHR0cDovL3d3dy53My5vcmcvVFIvV0NBRzIwLVRFQ0hTL0g2N1xyXG4gICAgKi9cclxuICAgIHRpbGUuYWx0ID0gJyc7XHJcblxyXG4gICAgLy8gaWYgdGhlcmUgaXMgbm8gbG9kIG1hcCBvciBhbiBsb2QgbWFwIHdpdGggYSBwcm9wZXIgem9vbSBsb2FkIHRoZSB0aWxlXHJcbiAgICAvLyBvdGhlcndpc2Ugd2FpdCBmb3IgdGhlIGxvZCBtYXAgdG8gYmVjb21lIGF2YWlsYWJsZVxyXG4gICAgaWYgKCF0aGlzLl9sb2RNYXAgfHwgKHRoaXMuX2xvZE1hcCAmJiB0aGlzLl9sb2RNYXBbdGhpcy5fZ2V0Wm9vbUZvclVybCgpXSkpIHtcclxuICAgICAgdGlsZS5zcmMgPSB0aGlzLmdldFRpbGVVcmwoY29vcmRzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMub25jZSgnbG9kbWFwJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRpbGUuc3JjID0gdGhpcy5nZXRUaWxlVXJsKGNvb3Jkcyk7XHJcbiAgICAgIH0sIHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aWxlO1xyXG4gIH0sXHJcblxyXG4gIG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgICAvLyBpbmNsdWRlICdQb3dlcmVkIGJ5IEVzcmknIGluIG1hcCBhdHRyaWJ1dGlvblxyXG4gICAgc2V0RXNyaUF0dHJpYnV0aW9uKG1hcCk7XHJcblxyXG4gICAgaWYgKCF0aGlzLl9sb2RNYXApIHtcclxuICAgICAgdGhpcy5tZXRhZGF0YShmdW5jdGlvbiAoZXJyb3IsIG1ldGFkYXRhKSB7XHJcbiAgICAgICAgaWYgKCFlcnJvciAmJiBtZXRhZGF0YS5zcGF0aWFsUmVmZXJlbmNlKSB7XHJcbiAgICAgICAgICB2YXIgc3IgPSBtZXRhZGF0YS5zcGF0aWFsUmVmZXJlbmNlLmxhdGVzdFdraWQgfHwgbWV0YWRhdGEuc3BhdGlhbFJlZmVyZW5jZS53a2lkO1xyXG4gICAgICAgICAgLy8gZGlzcGxheSB0aGUgY29weXJpZ2h0IHRleHQgZnJvbSB0aGUgc2VydmljZSB1c2luZyBsZWFmbGV0J3MgYXR0cmlidXRpb24gY29udHJvbFxyXG4gICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYXR0cmlidXRpb24gJiYgbWFwLmF0dHJpYnV0aW9uQ29udHJvbCAmJiBtZXRhZGF0YS5jb3B5cmlnaHRUZXh0KSB7XHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5hdHRyaWJ1dGlvbiA9IG1ldGFkYXRhLmNvcHlyaWdodFRleHQ7XHJcbiAgICAgICAgICAgIG1hcC5hdHRyaWJ1dGlvbkNvbnRyb2wuYWRkQXR0cmlidXRpb24odGhpcy5nZXRBdHRyaWJ1dGlvbigpKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBpZiB0aGUgc2VydmljZSB0aWxlcyB3ZXJlIHB1Ymxpc2hlZCBpbiB3ZWIgbWVyY2F0b3IgdXNpbmcgY29udmVudGlvbmFsIExPRHMgYnV0IG1pc3NpbmcgbGV2ZWxzLCB3ZSBjYW4gdHJ5IGFuZCByZW1hcCB0aGVtXHJcbiAgICAgICAgICBpZiAobWFwLm9wdGlvbnMuY3JzID09PSBDUlMuRVBTRzM4NTcgJiYgKHNyID09PSAxMDIxMDAgfHwgc3IgPT09IDM4NTcpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZE1hcCA9IHt9O1xyXG4gICAgICAgICAgICAvLyBjcmVhdGUgdGhlIHpvb20gbGV2ZWwgZGF0YVxyXG4gICAgICAgICAgICB2YXIgYXJjZ2lzTE9EcyA9IG1ldGFkYXRhLnRpbGVJbmZvLmxvZHM7XHJcbiAgICAgICAgICAgIHZhciBjb3JyZWN0UmVzb2x1dGlvbnMgPSBUaWxlZE1hcExheWVyLk1lcmNhdG9yWm9vbUxldmVscztcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJjZ2lzTE9Ecy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgIHZhciBhcmNnaXNMT0QgPSBhcmNnaXNMT0RzW2ldO1xyXG4gICAgICAgICAgICAgIGZvciAodmFyIGNpIGluIGNvcnJlY3RSZXNvbHV0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvcnJlY3RSZXMgPSBjb3JyZWN0UmVzb2x1dGlvbnNbY2ldO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl93aXRoaW5QZXJjZW50YWdlKGFyY2dpc0xPRC5yZXNvbHV0aW9uLCBjb3JyZWN0UmVzLCB0aGlzLm9wdGlvbnMuem9vbU9mZnNldEFsbG93YW5jZSkpIHtcclxuICAgICAgICAgICAgICAgICAgdGhpcy5fbG9kTWFwW2NpXSA9IGFyY2dpc0xPRC5sZXZlbDtcclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLmZpcmUoJ2xvZG1hcCcpO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChtYXAub3B0aW9ucy5jcnMgJiYgbWFwLm9wdGlvbnMuY3JzLmNvZGUgJiYgKG1hcC5vcHRpb25zLmNycy5jb2RlLmluZGV4T2Yoc3IpID4gLTEpKSB7XHJcbiAgICAgICAgICAgIC8vIGlmIHRoZSBwcm9qZWN0aW9uIGlzIFdHUzg0LCBvciB0aGUgZGV2ZWxvcGVyIGlzIHVzaW5nIFByb2o0IHRvIGRlZmluZSBhIGN1c3RvbSBDUlMsIG5vIGFjdGlvbiBpcyByZXF1aXJlZFxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gaWYgdGhlIHNlcnZpY2Ugd2FzIGNhY2hlZCBpbiBhIGN1c3RvbSBwcm9qZWN0aW9uIGFuZCBhbiBhcHByb3ByaWF0ZSBMT0QgaGFzbid0IGJlZW4gZGVmaW5lZCBpbiB0aGUgbWFwLCBndWlkZSB0aGUgZGV2ZWxvcGVyIHRvIG91ciBQcm9qNCBzYW1wbGVcclxuICAgICAgICAgICAgd2FybignTC5lc3JpLlRpbGVkTWFwTGF5ZXIgaXMgdXNpbmcgYSBub24tbWVyY2F0b3Igc3BhdGlhbCByZWZlcmVuY2UuIFN1cHBvcnQgbWF5IGJlIGF2YWlsYWJsZSB0aHJvdWdoIFByb2o0TGVhZmxldCBodHRwczovL2RldmVsb3BlcnMuYXJjZ2lzLmNvbS9lc3JpLWxlYWZsZXQvc2FtcGxlcy9ub24tbWVyY2F0b3ItcHJvamVjdGlvbi8nKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0sIHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIFRpbGVMYXllci5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xyXG4gIH0sXHJcblxyXG4gIG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgICByZW1vdmVFc3JpQXR0cmlidXRpb24obWFwKTtcclxuXHJcbiAgICBUaWxlTGF5ZXIucHJvdG90eXBlLm9uUmVtb3ZlLmNhbGwodGhpcywgbWFwKTtcclxuICB9LFxyXG5cclxuICBtZXRhZGF0YTogZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XHJcbiAgICB0aGlzLnNlcnZpY2UubWV0YWRhdGEoY2FsbGJhY2ssIGNvbnRleHQpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuXHJcbiAgaWRlbnRpZnk6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLnNlcnZpY2UuaWRlbnRpZnkoKTtcclxuICB9LFxyXG5cclxuICBmaW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zZXJ2aWNlLmZpbmQoKTtcclxuICB9LFxyXG5cclxuICBxdWVyeTogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc2VydmljZS5xdWVyeSgpO1xyXG4gIH0sXHJcblxyXG4gIGF1dGhlbnRpY2F0ZTogZnVuY3Rpb24gKHRva2VuKSB7XHJcbiAgICB2YXIgdG9rZW5RcyA9ICc/dG9rZW49JyArIHRva2VuO1xyXG4gICAgdGhpcy50aWxlVXJsID0gKHRoaXMub3B0aW9ucy50b2tlbikgPyB0aGlzLnRpbGVVcmwucmVwbGFjZSgvXFw/dG9rZW49KC4rKS9nLCB0b2tlblFzKSA6IHRoaXMudGlsZVVybCArIHRva2VuUXM7XHJcbiAgICB0aGlzLm9wdGlvbnMudG9rZW4gPSB0b2tlbjtcclxuICAgIHRoaXMuc2VydmljZS5hdXRoZW50aWNhdGUodG9rZW4pO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuXHJcbiAgX3dpdGhpblBlcmNlbnRhZ2U6IGZ1bmN0aW9uIChhLCBiLCBwZXJjZW50YWdlKSB7XHJcbiAgICB2YXIgZGlmZiA9IE1hdGguYWJzKChhIC8gYikgLSAxKTtcclxuICAgIHJldHVybiBkaWZmIDwgcGVyY2VudGFnZTtcclxuICB9XHJcbn0pO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRpbGVkTWFwTGF5ZXIgKHVybCwgb3B0aW9ucykge1xyXG4gIHJldHVybiBuZXcgVGlsZWRNYXBMYXllcih1cmwsIG9wdGlvbnMpO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCB0aWxlZE1hcExheWVyO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/esri-leaflet/src/Layers/TiledMapLayer.js\n");

/***/ }),

/***/ "./node_modules/esri-leaflet/src/Options.js":
/*!**************************************************!*\
  !*** ./node_modules/esri-leaflet/src/Options.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"options\": () => (/* binding */ options)\n/* harmony export */ });\nvar options = {\r\n  attributionWidthOffset: 55\r\n};\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (options);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXNyaS1sZWFmbGV0L3NyYy9PcHRpb25zLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxPQUFPLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXNyaS1sZWFmbGV0L3NyYy9PcHRpb25zLmpzP2ZiMjAiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHZhciBvcHRpb25zID0ge1xyXG4gIGF0dHJpYnV0aW9uV2lkdGhPZmZzZXQ6IDU1XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBvcHRpb25zO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/esri-leaflet/src/Options.js\n");

/***/ }),

/***/ "./node_modules/esri-leaflet/src/Request.js":
/*!**************************************************!*\
  !*** ./node_modules/esri-leaflet/src/Request.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Request\": () => (/* binding */ Request),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"get\": () => (/* binding */ get),\n/* harmony export */   \"jsonp\": () => (/* binding */ jsonp),\n/* harmony export */   \"post\": () => (/* binding */ xmlHttpPost),\n/* harmony export */   \"request\": () => (/* binding */ request),\n/* harmony export */   \"warn\": () => (/* binding */ warn)\n/* harmony export */ });\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! leaflet */ \"./node_modules/leaflet/dist/leaflet-src.js\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Support__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Support */ \"./node_modules/esri-leaflet/src/Support.js\");\n\r\n\r\n\r\nvar callbacks = 0;\r\n\r\nfunction serialize (params) {\r\n  var data = '';\r\n\r\n  params.f = params.f || 'json';\r\n\r\n  for (var key in params) {\r\n    if (Object.prototype.hasOwnProperty.call(params, key)) {\r\n      var param = params[key];\r\n      var type = Object.prototype.toString.call(param);\r\n      var value;\r\n\r\n      if (data.length) {\r\n        data += '&';\r\n      }\r\n\r\n      if (type === '[object Array]') {\r\n        value = (Object.prototype.toString.call(param[0]) === '[object Object]') ? JSON.stringify(param) : param.join(',');\r\n      } else if (type === '[object Object]') {\r\n        value = JSON.stringify(param);\r\n      } else if (type === '[object Date]') {\r\n        value = param.valueOf();\r\n      } else {\r\n        value = param;\r\n      }\r\n\r\n      data += encodeURIComponent(key) + '=' + encodeURIComponent(value);\r\n    }\r\n  }\r\n\r\n  return data;\r\n}\r\n\r\nfunction createRequest (callback, context) {\r\n  var httpRequest = new window.XMLHttpRequest();\r\n\r\n  httpRequest.onerror = function (e) {\r\n    httpRequest.onreadystatechange = leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.falseFn;\r\n\r\n    callback.call(context, {\r\n      error: {\r\n        code: 500,\r\n        message: 'XMLHttpRequest error'\r\n      }\r\n    }, null);\r\n  };\r\n\r\n  httpRequest.onreadystatechange = function () {\r\n    var response;\r\n    var error;\r\n\r\n    if (httpRequest.readyState === 4) {\r\n      try {\r\n        response = JSON.parse(httpRequest.responseText);\r\n      } catch (e) {\r\n        response = null;\r\n        error = {\r\n          code: 500,\r\n          message: 'Could not parse response as JSON. This could also be caused by a CORS or XMLHttpRequest error.'\r\n        };\r\n      }\r\n\r\n      if (!error && response.error) {\r\n        error = response.error;\r\n        response = null;\r\n      }\r\n\r\n      httpRequest.onerror = leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.falseFn;\r\n\r\n      callback.call(context, error, response);\r\n    }\r\n  };\r\n\r\n  httpRequest.ontimeout = function () {\r\n    this.onerror();\r\n  };\r\n\r\n  return httpRequest;\r\n}\r\n\r\nfunction xmlHttpPost (url, params, callback, context) {\r\n  var httpRequest = createRequest(callback, context);\r\n  httpRequest.open('POST', url);\r\n\r\n  if (typeof context !== 'undefined' && context !== null) {\r\n    if (typeof context.options !== 'undefined') {\r\n      httpRequest.timeout = context.options.timeout;\r\n    }\r\n  }\r\n  httpRequest.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8');\r\n  httpRequest.send(serialize(params));\r\n\r\n  return httpRequest;\r\n}\r\n\r\nfunction xmlHttpGet (url, params, callback, context) {\r\n  var httpRequest = createRequest(callback, context);\r\n  httpRequest.open('GET', url + '?' + serialize(params), true);\r\n\r\n  if (typeof context !== 'undefined' && context !== null) {\r\n    if (typeof context.options !== 'undefined') {\r\n      httpRequest.timeout = context.options.timeout;\r\n      if (context.options.withCredentials) {\r\n        httpRequest.withCredentials = true;\r\n      }\r\n    }\r\n  }\r\n  httpRequest.send(null);\r\n\r\n  return httpRequest;\r\n}\r\n\r\n// AJAX handlers for CORS (modern browsers) or JSONP (older browsers)\r\nfunction request (url, params, callback, context) {\r\n  var paramString = serialize(params);\r\n  var httpRequest = createRequest(callback, context);\r\n  var requestLength = (url + '?' + paramString).length;\r\n\r\n  // ie10/11 require the request be opened before a timeout is applied\r\n  if (requestLength <= 2000 && _Support__WEBPACK_IMPORTED_MODULE_1__.Support.cors) {\r\n    httpRequest.open('GET', url + '?' + paramString);\r\n  } else if (requestLength > 2000 && _Support__WEBPACK_IMPORTED_MODULE_1__.Support.cors) {\r\n    httpRequest.open('POST', url);\r\n    httpRequest.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8');\r\n  }\r\n\r\n  if (typeof context !== 'undefined' && context !== null) {\r\n    if (typeof context.options !== 'undefined') {\r\n      httpRequest.timeout = context.options.timeout;\r\n      if (context.options.withCredentials) {\r\n        httpRequest.withCredentials = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  // request is less than 2000 characters and the browser supports CORS, make GET request with XMLHttpRequest\r\n  if (requestLength <= 2000 && _Support__WEBPACK_IMPORTED_MODULE_1__.Support.cors) {\r\n    httpRequest.send(null);\r\n\r\n  // request is more than 2000 characters and the browser supports CORS, make POST request with XMLHttpRequest\r\n  } else if (requestLength > 2000 && _Support__WEBPACK_IMPORTED_MODULE_1__.Support.cors) {\r\n    httpRequest.send(paramString);\r\n\r\n  // request is less  than 2000 characters and the browser does not support CORS, make a JSONP request\r\n  } else if (requestLength <= 2000 && !_Support__WEBPACK_IMPORTED_MODULE_1__.Support.cors) {\r\n    return jsonp(url, params, callback, context);\r\n\r\n  // request is longer then 2000 characters and the browser does not support CORS, log a warning\r\n  } else {\r\n    warn('a request to ' + url + ' was longer then 2000 characters and this browser cannot make a cross-domain post request. Please use a proxy https://developers.arcgis.com/esri-leaflet/api-reference/request/');\r\n    return;\r\n  }\r\n\r\n  return httpRequest;\r\n}\r\n\r\nfunction jsonp (url, params, callback, context) {\r\n  window._EsriLeafletCallbacks = window._EsriLeafletCallbacks || {};\r\n  var callbackId = 'c' + callbacks;\r\n  params.callback = 'window._EsriLeafletCallbacks.' + callbackId;\r\n\r\n  window._EsriLeafletCallbacks[callbackId] = function (response) {\r\n    if (window._EsriLeafletCallbacks[callbackId] !== true) {\r\n      var error;\r\n      var responseType = Object.prototype.toString.call(response);\r\n\r\n      if (!(responseType === '[object Object]' || responseType === '[object Array]')) {\r\n        error = {\r\n          error: {\r\n            code: 500,\r\n            message: 'Expected array or object as JSONP response'\r\n          }\r\n        };\r\n        response = null;\r\n      }\r\n\r\n      if (!error && response.error) {\r\n        error = response;\r\n        response = null;\r\n      }\r\n\r\n      callback.call(context, error, response);\r\n      window._EsriLeafletCallbacks[callbackId] = true;\r\n    }\r\n  };\r\n\r\n  var script = leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.create('script', null, document.body);\r\n  script.type = 'text/javascript';\r\n  script.src = url + '?' + serialize(params);\r\n  script.id = callbackId;\r\n  script.onerror = function (error) {\r\n    if (error && window._EsriLeafletCallbacks[callbackId] !== true) {\r\n      // Can't get true error code: it can be 404, or 401, or 500\r\n      var err = {\r\n        error: {\r\n          code: 500,\r\n          message: 'An unknown error occurred'\r\n        }\r\n      };\r\n\r\n      callback.call(context, err);\r\n      window._EsriLeafletCallbacks[callbackId] = true;\r\n    }\r\n  };\r\n  leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.addClass(script, 'esri-leaflet-jsonp');\r\n\r\n  callbacks++;\r\n\r\n  return {\r\n    id: callbackId,\r\n    url: script.src,\r\n    abort: function () {\r\n      window._EsriLeafletCallbacks._callback[callbackId]({\r\n        code: 0,\r\n        message: 'Request aborted.'\r\n      });\r\n    }\r\n  };\r\n}\r\n\r\nvar get = ((_Support__WEBPACK_IMPORTED_MODULE_1__.Support.cors) ? xmlHttpGet : jsonp);\r\nget.CORS = xmlHttpGet;\r\nget.JSONP = jsonp;\r\n\r\nfunction warn () {\r\n  if (console && console.warn) {\r\n    console.warn.apply(console, arguments);\r\n  }\r\n}\r\n\r\n// choose the correct AJAX handler depending on CORS support\r\n\r\n\r\n// always use XMLHttpRequest for posts\r\n\r\n\r\n// export the Request object to call the different handlers for debugging\r\nvar Request = {\r\n  request: request,\r\n  get: get,\r\n  post: xmlHttpPost\r\n};\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Request);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXNyaS1sZWFmbGV0L3NyYy9SZXF1ZXN0LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBd0M7QUFDSjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsaURBQVk7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaURBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isa0RBQVk7QUFDM0M7QUFDQSxJQUFJLGlDQUFpQyxrREFBWTtBQUNqRDtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isa0RBQVk7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsSUFBSSxpQ0FBaUMsa0RBQVk7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsSUFBSSxtQ0FBbUMsa0RBQVk7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtREFBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxxREFBZ0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtEQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQytCO0FBQy9CO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxPQUFPLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXNyaS1sZWFmbGV0L3NyYy9SZXF1ZXN0LmpzP2M5YmUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVXRpbCwgRG9tVXRpbCB9IGZyb20gJ2xlYWZsZXQnO1xyXG5pbXBvcnQgeyBTdXBwb3J0IH0gZnJvbSAnLi9TdXBwb3J0JztcclxuXHJcbnZhciBjYWxsYmFja3MgPSAwO1xyXG5cclxuZnVuY3Rpb24gc2VyaWFsaXplIChwYXJhbXMpIHtcclxuICB2YXIgZGF0YSA9ICcnO1xyXG5cclxuICBwYXJhbXMuZiA9IHBhcmFtcy5mIHx8ICdqc29uJztcclxuXHJcbiAgZm9yICh2YXIga2V5IGluIHBhcmFtcykge1xyXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwYXJhbXMsIGtleSkpIHtcclxuICAgICAgdmFyIHBhcmFtID0gcGFyYW1zW2tleV07XHJcbiAgICAgIHZhciB0eXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHBhcmFtKTtcclxuICAgICAgdmFyIHZhbHVlO1xyXG5cclxuICAgICAgaWYgKGRhdGEubGVuZ3RoKSB7XHJcbiAgICAgICAgZGF0YSArPSAnJic7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0eXBlID09PSAnW29iamVjdCBBcnJheV0nKSB7XHJcbiAgICAgICAgdmFsdWUgPSAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHBhcmFtWzBdKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpID8gSlNPTi5zdHJpbmdpZnkocGFyYW0pIDogcGFyYW0uam9pbignLCcpO1xyXG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XHJcbiAgICAgICAgdmFsdWUgPSBKU09OLnN0cmluZ2lmeShwYXJhbSk7XHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1tvYmplY3QgRGF0ZV0nKSB7XHJcbiAgICAgICAgdmFsdWUgPSBwYXJhbS52YWx1ZU9mKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFsdWUgPSBwYXJhbTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZGF0YSArPSBlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZGF0YTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlUmVxdWVzdCAoY2FsbGJhY2ssIGNvbnRleHQpIHtcclxuICB2YXIgaHR0cFJlcXVlc3QgPSBuZXcgd2luZG93LlhNTEh0dHBSZXF1ZXN0KCk7XHJcblxyXG4gIGh0dHBSZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgaHR0cFJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gVXRpbC5mYWxzZUZuO1xyXG5cclxuICAgIGNhbGxiYWNrLmNhbGwoY29udGV4dCwge1xyXG4gICAgICBlcnJvcjoge1xyXG4gICAgICAgIGNvZGU6IDUwMCxcclxuICAgICAgICBtZXNzYWdlOiAnWE1MSHR0cFJlcXVlc3QgZXJyb3InXHJcbiAgICAgIH1cclxuICAgIH0sIG51bGwpO1xyXG4gIH07XHJcblxyXG4gIGh0dHBSZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciByZXNwb25zZTtcclxuICAgIHZhciBlcnJvcjtcclxuXHJcbiAgICBpZiAoaHR0cFJlcXVlc3QucmVhZHlTdGF0ZSA9PT0gNCkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHJlc3BvbnNlID0gSlNPTi5wYXJzZShodHRwUmVxdWVzdC5yZXNwb25zZVRleHQpO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgcmVzcG9uc2UgPSBudWxsO1xyXG4gICAgICAgIGVycm9yID0ge1xyXG4gICAgICAgICAgY29kZTogNTAwLFxyXG4gICAgICAgICAgbWVzc2FnZTogJ0NvdWxkIG5vdCBwYXJzZSByZXNwb25zZSBhcyBKU09OLiBUaGlzIGNvdWxkIGFsc28gYmUgY2F1c2VkIGJ5IGEgQ09SUyBvciBYTUxIdHRwUmVxdWVzdCBlcnJvci4nXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFlcnJvciAmJiByZXNwb25zZS5lcnJvcikge1xyXG4gICAgICAgIGVycm9yID0gcmVzcG9uc2UuZXJyb3I7XHJcbiAgICAgICAgcmVzcG9uc2UgPSBudWxsO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBodHRwUmVxdWVzdC5vbmVycm9yID0gVXRpbC5mYWxzZUZuO1xyXG5cclxuICAgICAgY2FsbGJhY2suY2FsbChjb250ZXh0LCBlcnJvciwgcmVzcG9uc2UpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGh0dHBSZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMub25lcnJvcigpO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBodHRwUmVxdWVzdDtcclxufVxyXG5cclxuZnVuY3Rpb24geG1sSHR0cFBvc3QgKHVybCwgcGFyYW1zLCBjYWxsYmFjaywgY29udGV4dCkge1xyXG4gIHZhciBodHRwUmVxdWVzdCA9IGNyZWF0ZVJlcXVlc3QoY2FsbGJhY2ssIGNvbnRleHQpO1xyXG4gIGh0dHBSZXF1ZXN0Lm9wZW4oJ1BPU1QnLCB1cmwpO1xyXG5cclxuICBpZiAodHlwZW9mIGNvbnRleHQgIT09ICd1bmRlZmluZWQnICYmIGNvbnRleHQgIT09IG51bGwpIHtcclxuICAgIGlmICh0eXBlb2YgY29udGV4dC5vcHRpb25zICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICBodHRwUmVxdWVzdC50aW1lb3V0ID0gY29udGV4dC5vcHRpb25zLnRpbWVvdXQ7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGh0dHBSZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLTgnKTtcclxuICBodHRwUmVxdWVzdC5zZW5kKHNlcmlhbGl6ZShwYXJhbXMpKTtcclxuXHJcbiAgcmV0dXJuIGh0dHBSZXF1ZXN0O1xyXG59XHJcblxyXG5mdW5jdGlvbiB4bWxIdHRwR2V0ICh1cmwsIHBhcmFtcywgY2FsbGJhY2ssIGNvbnRleHQpIHtcclxuICB2YXIgaHR0cFJlcXVlc3QgPSBjcmVhdGVSZXF1ZXN0KGNhbGxiYWNrLCBjb250ZXh0KTtcclxuICBodHRwUmVxdWVzdC5vcGVuKCdHRVQnLCB1cmwgKyAnPycgKyBzZXJpYWxpemUocGFyYW1zKSwgdHJ1ZSk7XHJcblxyXG4gIGlmICh0eXBlb2YgY29udGV4dCAhPT0gJ3VuZGVmaW5lZCcgJiYgY29udGV4dCAhPT0gbnVsbCkge1xyXG4gICAgaWYgKHR5cGVvZiBjb250ZXh0Lm9wdGlvbnMgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIGh0dHBSZXF1ZXN0LnRpbWVvdXQgPSBjb250ZXh0Lm9wdGlvbnMudGltZW91dDtcclxuICAgICAgaWYgKGNvbnRleHQub3B0aW9ucy53aXRoQ3JlZGVudGlhbHMpIHtcclxuICAgICAgICBodHRwUmVxdWVzdC53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIGh0dHBSZXF1ZXN0LnNlbmQobnVsbCk7XHJcblxyXG4gIHJldHVybiBodHRwUmVxdWVzdDtcclxufVxyXG5cclxuLy8gQUpBWCBoYW5kbGVycyBmb3IgQ09SUyAobW9kZXJuIGJyb3dzZXJzKSBvciBKU09OUCAob2xkZXIgYnJvd3NlcnMpXHJcbmV4cG9ydCBmdW5jdGlvbiByZXF1ZXN0ICh1cmwsIHBhcmFtcywgY2FsbGJhY2ssIGNvbnRleHQpIHtcclxuICB2YXIgcGFyYW1TdHJpbmcgPSBzZXJpYWxpemUocGFyYW1zKTtcclxuICB2YXIgaHR0cFJlcXVlc3QgPSBjcmVhdGVSZXF1ZXN0KGNhbGxiYWNrLCBjb250ZXh0KTtcclxuICB2YXIgcmVxdWVzdExlbmd0aCA9ICh1cmwgKyAnPycgKyBwYXJhbVN0cmluZykubGVuZ3RoO1xyXG5cclxuICAvLyBpZTEwLzExIHJlcXVpcmUgdGhlIHJlcXVlc3QgYmUgb3BlbmVkIGJlZm9yZSBhIHRpbWVvdXQgaXMgYXBwbGllZFxyXG4gIGlmIChyZXF1ZXN0TGVuZ3RoIDw9IDIwMDAgJiYgU3VwcG9ydC5jb3JzKSB7XHJcbiAgICBodHRwUmVxdWVzdC5vcGVuKCdHRVQnLCB1cmwgKyAnPycgKyBwYXJhbVN0cmluZyk7XHJcbiAgfSBlbHNlIGlmIChyZXF1ZXN0TGVuZ3RoID4gMjAwMCAmJiBTdXBwb3J0LmNvcnMpIHtcclxuICAgIGh0dHBSZXF1ZXN0Lm9wZW4oJ1BPU1QnLCB1cmwpO1xyXG4gICAgaHR0cFJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOCcpO1xyXG4gIH1cclxuXHJcbiAgaWYgKHR5cGVvZiBjb250ZXh0ICE9PSAndW5kZWZpbmVkJyAmJiBjb250ZXh0ICE9PSBudWxsKSB7XHJcbiAgICBpZiAodHlwZW9mIGNvbnRleHQub3B0aW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgaHR0cFJlcXVlc3QudGltZW91dCA9IGNvbnRleHQub3B0aW9ucy50aW1lb3V0O1xyXG4gICAgICBpZiAoY29udGV4dC5vcHRpb25zLndpdGhDcmVkZW50aWFscykge1xyXG4gICAgICAgIGh0dHBSZXF1ZXN0LndpdGhDcmVkZW50aWFscyA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIHJlcXVlc3QgaXMgbGVzcyB0aGFuIDIwMDAgY2hhcmFjdGVycyBhbmQgdGhlIGJyb3dzZXIgc3VwcG9ydHMgQ09SUywgbWFrZSBHRVQgcmVxdWVzdCB3aXRoIFhNTEh0dHBSZXF1ZXN0XHJcbiAgaWYgKHJlcXVlc3RMZW5ndGggPD0gMjAwMCAmJiBTdXBwb3J0LmNvcnMpIHtcclxuICAgIGh0dHBSZXF1ZXN0LnNlbmQobnVsbCk7XHJcblxyXG4gIC8vIHJlcXVlc3QgaXMgbW9yZSB0aGFuIDIwMDAgY2hhcmFjdGVycyBhbmQgdGhlIGJyb3dzZXIgc3VwcG9ydHMgQ09SUywgbWFrZSBQT1NUIHJlcXVlc3Qgd2l0aCBYTUxIdHRwUmVxdWVzdFxyXG4gIH0gZWxzZSBpZiAocmVxdWVzdExlbmd0aCA+IDIwMDAgJiYgU3VwcG9ydC5jb3JzKSB7XHJcbiAgICBodHRwUmVxdWVzdC5zZW5kKHBhcmFtU3RyaW5nKTtcclxuXHJcbiAgLy8gcmVxdWVzdCBpcyBsZXNzICB0aGFuIDIwMDAgY2hhcmFjdGVycyBhbmQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBDT1JTLCBtYWtlIGEgSlNPTlAgcmVxdWVzdFxyXG4gIH0gZWxzZSBpZiAocmVxdWVzdExlbmd0aCA8PSAyMDAwICYmICFTdXBwb3J0LmNvcnMpIHtcclxuICAgIHJldHVybiBqc29ucCh1cmwsIHBhcmFtcywgY2FsbGJhY2ssIGNvbnRleHQpO1xyXG5cclxuICAvLyByZXF1ZXN0IGlzIGxvbmdlciB0aGVuIDIwMDAgY2hhcmFjdGVycyBhbmQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBDT1JTLCBsb2cgYSB3YXJuaW5nXHJcbiAgfSBlbHNlIHtcclxuICAgIHdhcm4oJ2EgcmVxdWVzdCB0byAnICsgdXJsICsgJyB3YXMgbG9uZ2VyIHRoZW4gMjAwMCBjaGFyYWN0ZXJzIGFuZCB0aGlzIGJyb3dzZXIgY2Fubm90IG1ha2UgYSBjcm9zcy1kb21haW4gcG9zdCByZXF1ZXN0LiBQbGVhc2UgdXNlIGEgcHJveHkgaHR0cHM6Ly9kZXZlbG9wZXJzLmFyY2dpcy5jb20vZXNyaS1sZWFmbGV0L2FwaS1yZWZlcmVuY2UvcmVxdWVzdC8nKTtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIHJldHVybiBodHRwUmVxdWVzdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGpzb25wICh1cmwsIHBhcmFtcywgY2FsbGJhY2ssIGNvbnRleHQpIHtcclxuICB3aW5kb3cuX0VzcmlMZWFmbGV0Q2FsbGJhY2tzID0gd2luZG93Ll9Fc3JpTGVhZmxldENhbGxiYWNrcyB8fCB7fTtcclxuICB2YXIgY2FsbGJhY2tJZCA9ICdjJyArIGNhbGxiYWNrcztcclxuICBwYXJhbXMuY2FsbGJhY2sgPSAnd2luZG93Ll9Fc3JpTGVhZmxldENhbGxiYWNrcy4nICsgY2FsbGJhY2tJZDtcclxuXHJcbiAgd2luZG93Ll9Fc3JpTGVhZmxldENhbGxiYWNrc1tjYWxsYmFja0lkXSA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xyXG4gICAgaWYgKHdpbmRvdy5fRXNyaUxlYWZsZXRDYWxsYmFja3NbY2FsbGJhY2tJZF0gIT09IHRydWUpIHtcclxuICAgICAgdmFyIGVycm9yO1xyXG4gICAgICB2YXIgcmVzcG9uc2VUeXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHJlc3BvbnNlKTtcclxuXHJcbiAgICAgIGlmICghKHJlc3BvbnNlVHlwZSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgfHwgcmVzcG9uc2VUeXBlID09PSAnW29iamVjdCBBcnJheV0nKSkge1xyXG4gICAgICAgIGVycm9yID0ge1xyXG4gICAgICAgICAgZXJyb3I6IHtcclxuICAgICAgICAgICAgY29kZTogNTAwLFxyXG4gICAgICAgICAgICBtZXNzYWdlOiAnRXhwZWN0ZWQgYXJyYXkgb3Igb2JqZWN0IGFzIEpTT05QIHJlc3BvbnNlJ1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmVzcG9uc2UgPSBudWxsO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIWVycm9yICYmIHJlc3BvbnNlLmVycm9yKSB7XHJcbiAgICAgICAgZXJyb3IgPSByZXNwb25zZTtcclxuICAgICAgICByZXNwb25zZSA9IG51bGw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNhbGxiYWNrLmNhbGwoY29udGV4dCwgZXJyb3IsIHJlc3BvbnNlKTtcclxuICAgICAgd2luZG93Ll9Fc3JpTGVhZmxldENhbGxiYWNrc1tjYWxsYmFja0lkXSA9IHRydWU7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgdmFyIHNjcmlwdCA9IERvbVV0aWwuY3JlYXRlKCdzY3JpcHQnLCBudWxsLCBkb2N1bWVudC5ib2R5KTtcclxuICBzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xyXG4gIHNjcmlwdC5zcmMgPSB1cmwgKyAnPycgKyBzZXJpYWxpemUocGFyYW1zKTtcclxuICBzY3JpcHQuaWQgPSBjYWxsYmFja0lkO1xyXG4gIHNjcmlwdC5vbmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICBpZiAoZXJyb3IgJiYgd2luZG93Ll9Fc3JpTGVhZmxldENhbGxiYWNrc1tjYWxsYmFja0lkXSAhPT0gdHJ1ZSkge1xyXG4gICAgICAvLyBDYW4ndCBnZXQgdHJ1ZSBlcnJvciBjb2RlOiBpdCBjYW4gYmUgNDA0LCBvciA0MDEsIG9yIDUwMFxyXG4gICAgICB2YXIgZXJyID0ge1xyXG4gICAgICAgIGVycm9yOiB7XHJcbiAgICAgICAgICBjb2RlOiA1MDAsXHJcbiAgICAgICAgICBtZXNzYWdlOiAnQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZCdcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBjYWxsYmFjay5jYWxsKGNvbnRleHQsIGVycik7XHJcbiAgICAgIHdpbmRvdy5fRXNyaUxlYWZsZXRDYWxsYmFja3NbY2FsbGJhY2tJZF0gPSB0cnVlO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgRG9tVXRpbC5hZGRDbGFzcyhzY3JpcHQsICdlc3JpLWxlYWZsZXQtanNvbnAnKTtcclxuXHJcbiAgY2FsbGJhY2tzKys7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBpZDogY2FsbGJhY2tJZCxcclxuICAgIHVybDogc2NyaXB0LnNyYyxcclxuICAgIGFib3J0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHdpbmRvdy5fRXNyaUxlYWZsZXRDYWxsYmFja3MuX2NhbGxiYWNrW2NhbGxiYWNrSWRdKHtcclxuICAgICAgICBjb2RlOiAwLFxyXG4gICAgICAgIG1lc3NhZ2U6ICdSZXF1ZXN0IGFib3J0ZWQuJ1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9O1xyXG59XHJcblxyXG52YXIgZ2V0ID0gKChTdXBwb3J0LmNvcnMpID8geG1sSHR0cEdldCA6IGpzb25wKTtcclxuZ2V0LkNPUlMgPSB4bWxIdHRwR2V0O1xyXG5nZXQuSlNPTlAgPSBqc29ucDtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB3YXJuICgpIHtcclxuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIHtcclxuICAgIGNvbnNvbGUud2Fybi5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xyXG4gIH1cclxufVxyXG5cclxuLy8gY2hvb3NlIHRoZSBjb3JyZWN0IEFKQVggaGFuZGxlciBkZXBlbmRpbmcgb24gQ09SUyBzdXBwb3J0XHJcbmV4cG9ydCB7IGdldCB9O1xyXG5cclxuLy8gYWx3YXlzIHVzZSBYTUxIdHRwUmVxdWVzdCBmb3IgcG9zdHNcclxuZXhwb3J0IHsgeG1sSHR0cFBvc3QgYXMgcG9zdCB9O1xyXG5cclxuLy8gZXhwb3J0IHRoZSBSZXF1ZXN0IG9iamVjdCB0byBjYWxsIHRoZSBkaWZmZXJlbnQgaGFuZGxlcnMgZm9yIGRlYnVnZ2luZ1xyXG5leHBvcnQgdmFyIFJlcXVlc3QgPSB7XHJcbiAgcmVxdWVzdDogcmVxdWVzdCxcclxuICBnZXQ6IGdldCxcclxuICBwb3N0OiB4bWxIdHRwUG9zdFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgUmVxdWVzdDtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/esri-leaflet/src/Request.js\n");

/***/ }),

/***/ "./node_modules/esri-leaflet/src/Services/FeatureLayerService.js":
/*!***********************************************************************!*\
  !*** ./node_modules/esri-leaflet/src/Services/FeatureLayerService.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FeatureLayerService\": () => (/* binding */ FeatureLayerService),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"featureLayerService\": () => (/* binding */ featureLayerService)\n/* harmony export */ });\n/* harmony import */ var _Service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Service */ \"./node_modules/esri-leaflet/src/Services/Service.js\");\n/* harmony import */ var _Tasks_Query__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Tasks/Query */ \"./node_modules/esri-leaflet/src/Tasks/Query.js\");\n/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Util */ \"./node_modules/esri-leaflet/src/Util.js\");\n\r\n\r\n\r\n\r\nvar FeatureLayerService = _Service__WEBPACK_IMPORTED_MODULE_0__.Service.extend({\r\n\r\n  options: {\r\n    idAttribute: 'OBJECTID'\r\n  },\r\n\r\n  query: function () {\r\n    return (0,_Tasks_Query__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this);\r\n  },\r\n\r\n  addFeature: function (feature, callback, context) {\r\n    this.addFeatures(feature, callback, context);\r\n  },\r\n\r\n  addFeatures: function (features, callback, context) {\r\n    var featuresArray = features.features ? features.features : [features];\r\n    for (var i = featuresArray.length - 1; i >= 0; i--) {\r\n      delete featuresArray[i].id;\r\n    }\r\n    features = (0,_Util__WEBPACK_IMPORTED_MODULE_2__.geojsonToArcGIS)(features);\r\n    features = featuresArray.length > 1 ? features : [features];\r\n    return this.post('addFeatures', {\r\n      features: features\r\n    }, function (error, response) {\r\n      // For compatibility reason with former addFeature function,\r\n      // we return the object in the array and not the array itself\r\n      var result = (response && response.addResults) ? response.addResults.length > 1 ? response.addResults : response.addResults[0] : undefined;\r\n      if (callback) {\r\n        callback.call(context, error || response.addResults[0].error, result);\r\n      }\r\n    }, context);\r\n  },\r\n\r\n  updateFeature: function (feature, callback, context) {\r\n    this.updateFeatures(feature, callback, context);\r\n  },\r\n\r\n  updateFeatures: function (features, callback, context) {\r\n    var featuresArray = features.features ? features.features : [features];\r\n    features = (0,_Util__WEBPACK_IMPORTED_MODULE_2__.geojsonToArcGIS)(features, this.options.idAttribute);\r\n    features = featuresArray.length > 1 ? features : [features];\r\n\r\n    return this.post('updateFeatures', {\r\n      features: features\r\n    }, function (error, response) {\r\n      // For compatibility reason with former updateFeature function,\r\n      // we return the object in the array and not the array itself\r\n      var result = (response && response.updateResults) ? response.updateResults.length > 1 ? response.updateResults : response.updateResults[0] : undefined;\r\n      if (callback) {\r\n        callback.call(context, error || response.updateResults[0].error, result);\r\n      }\r\n    }, context);\r\n  },\r\n\r\n  deleteFeature: function (id, callback, context) {\r\n    this.deleteFeatures(id, callback, context);\r\n  },\r\n\r\n  deleteFeatures: function (ids, callback, context) {\r\n    return this.post('deleteFeatures', {\r\n      objectIds: ids\r\n    }, function (error, response) {\r\n      // For compatibility reason with former deleteFeature function,\r\n      // we return the object in the array and not the array itself\r\n      var result = (response && response.deleteResults) ? response.deleteResults.length > 1 ? response.deleteResults : response.deleteResults[0] : undefined;\r\n      if (callback) {\r\n        callback.call(context, error || response.deleteResults[0].error, result);\r\n      }\r\n    }, context);\r\n  }\r\n});\r\n\r\nfunction featureLayerService (options) {\r\n  return new FeatureLayerService(options);\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (featureLayerService);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXNyaS1sZWFmbGV0L3NyYy9TZXJ2aWNlcy9GZWF0dXJlTGF5ZXJTZXJ2aWNlLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFvQztBQUNEO0FBQ087QUFDMUM7QUFDTywwQkFBMEIsb0RBQWM7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxXQUFXLHdEQUFLO0FBQ2hCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBLGVBQWUsc0RBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0RBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxtQkFBbUIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lc3JpLWxlYWZsZXQvc3JjL1NlcnZpY2VzL0ZlYXR1cmVMYXllclNlcnZpY2UuanM/ZjUzMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTZXJ2aWNlIH0gZnJvbSAnLi9TZXJ2aWNlJztcclxuaW1wb3J0IHF1ZXJ5IGZyb20gJy4uL1Rhc2tzL1F1ZXJ5JztcclxuaW1wb3J0IHsgZ2VvanNvblRvQXJjR0lTIH0gZnJvbSAnLi4vVXRpbCc7XHJcblxyXG5leHBvcnQgdmFyIEZlYXR1cmVMYXllclNlcnZpY2UgPSBTZXJ2aWNlLmV4dGVuZCh7XHJcblxyXG4gIG9wdGlvbnM6IHtcclxuICAgIGlkQXR0cmlidXRlOiAnT0JKRUNUSUQnXHJcbiAgfSxcclxuXHJcbiAgcXVlcnk6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBxdWVyeSh0aGlzKTtcclxuICB9LFxyXG5cclxuICBhZGRGZWF0dXJlOiBmdW5jdGlvbiAoZmVhdHVyZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcclxuICAgIHRoaXMuYWRkRmVhdHVyZXMoZmVhdHVyZSwgY2FsbGJhY2ssIGNvbnRleHQpO1xyXG4gIH0sXHJcblxyXG4gIGFkZEZlYXR1cmVzOiBmdW5jdGlvbiAoZmVhdHVyZXMsIGNhbGxiYWNrLCBjb250ZXh0KSB7XHJcbiAgICB2YXIgZmVhdHVyZXNBcnJheSA9IGZlYXR1cmVzLmZlYXR1cmVzID8gZmVhdHVyZXMuZmVhdHVyZXMgOiBbZmVhdHVyZXNdO1xyXG4gICAgZm9yICh2YXIgaSA9IGZlYXR1cmVzQXJyYXkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgZGVsZXRlIGZlYXR1cmVzQXJyYXlbaV0uaWQ7XHJcbiAgICB9XHJcbiAgICBmZWF0dXJlcyA9IGdlb2pzb25Ub0FyY0dJUyhmZWF0dXJlcyk7XHJcbiAgICBmZWF0dXJlcyA9IGZlYXR1cmVzQXJyYXkubGVuZ3RoID4gMSA/IGZlYXR1cmVzIDogW2ZlYXR1cmVzXTtcclxuICAgIHJldHVybiB0aGlzLnBvc3QoJ2FkZEZlYXR1cmVzJywge1xyXG4gICAgICBmZWF0dXJlczogZmVhdHVyZXNcclxuICAgIH0sIGZ1bmN0aW9uIChlcnJvciwgcmVzcG9uc2UpIHtcclxuICAgICAgLy8gRm9yIGNvbXBhdGliaWxpdHkgcmVhc29uIHdpdGggZm9ybWVyIGFkZEZlYXR1cmUgZnVuY3Rpb24sXHJcbiAgICAgIC8vIHdlIHJldHVybiB0aGUgb2JqZWN0IGluIHRoZSBhcnJheSBhbmQgbm90IHRoZSBhcnJheSBpdHNlbGZcclxuICAgICAgdmFyIHJlc3VsdCA9IChyZXNwb25zZSAmJiByZXNwb25zZS5hZGRSZXN1bHRzKSA/IHJlc3BvbnNlLmFkZFJlc3VsdHMubGVuZ3RoID4gMSA/IHJlc3BvbnNlLmFkZFJlc3VsdHMgOiByZXNwb25zZS5hZGRSZXN1bHRzWzBdIDogdW5kZWZpbmVkO1xyXG4gICAgICBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgICBjYWxsYmFjay5jYWxsKGNvbnRleHQsIGVycm9yIHx8IHJlc3BvbnNlLmFkZFJlc3VsdHNbMF0uZXJyb3IsIHJlc3VsdCk7XHJcbiAgICAgIH1cclxuICAgIH0sIGNvbnRleHQpO1xyXG4gIH0sXHJcblxyXG4gIHVwZGF0ZUZlYXR1cmU6IGZ1bmN0aW9uIChmZWF0dXJlLCBjYWxsYmFjaywgY29udGV4dCkge1xyXG4gICAgdGhpcy51cGRhdGVGZWF0dXJlcyhmZWF0dXJlLCBjYWxsYmFjaywgY29udGV4dCk7XHJcbiAgfSxcclxuXHJcbiAgdXBkYXRlRmVhdHVyZXM6IGZ1bmN0aW9uIChmZWF0dXJlcywgY2FsbGJhY2ssIGNvbnRleHQpIHtcclxuICAgIHZhciBmZWF0dXJlc0FycmF5ID0gZmVhdHVyZXMuZmVhdHVyZXMgPyBmZWF0dXJlcy5mZWF0dXJlcyA6IFtmZWF0dXJlc107XHJcbiAgICBmZWF0dXJlcyA9IGdlb2pzb25Ub0FyY0dJUyhmZWF0dXJlcywgdGhpcy5vcHRpb25zLmlkQXR0cmlidXRlKTtcclxuICAgIGZlYXR1cmVzID0gZmVhdHVyZXNBcnJheS5sZW5ndGggPiAxID8gZmVhdHVyZXMgOiBbZmVhdHVyZXNdO1xyXG5cclxuICAgIHJldHVybiB0aGlzLnBvc3QoJ3VwZGF0ZUZlYXR1cmVzJywge1xyXG4gICAgICBmZWF0dXJlczogZmVhdHVyZXNcclxuICAgIH0sIGZ1bmN0aW9uIChlcnJvciwgcmVzcG9uc2UpIHtcclxuICAgICAgLy8gRm9yIGNvbXBhdGliaWxpdHkgcmVhc29uIHdpdGggZm9ybWVyIHVwZGF0ZUZlYXR1cmUgZnVuY3Rpb24sXHJcbiAgICAgIC8vIHdlIHJldHVybiB0aGUgb2JqZWN0IGluIHRoZSBhcnJheSBhbmQgbm90IHRoZSBhcnJheSBpdHNlbGZcclxuICAgICAgdmFyIHJlc3VsdCA9IChyZXNwb25zZSAmJiByZXNwb25zZS51cGRhdGVSZXN1bHRzKSA/IHJlc3BvbnNlLnVwZGF0ZVJlc3VsdHMubGVuZ3RoID4gMSA/IHJlc3BvbnNlLnVwZGF0ZVJlc3VsdHMgOiByZXNwb25zZS51cGRhdGVSZXN1bHRzWzBdIDogdW5kZWZpbmVkO1xyXG4gICAgICBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgICBjYWxsYmFjay5jYWxsKGNvbnRleHQsIGVycm9yIHx8IHJlc3BvbnNlLnVwZGF0ZVJlc3VsdHNbMF0uZXJyb3IsIHJlc3VsdCk7XHJcbiAgICAgIH1cclxuICAgIH0sIGNvbnRleHQpO1xyXG4gIH0sXHJcblxyXG4gIGRlbGV0ZUZlYXR1cmU6IGZ1bmN0aW9uIChpZCwgY2FsbGJhY2ssIGNvbnRleHQpIHtcclxuICAgIHRoaXMuZGVsZXRlRmVhdHVyZXMoaWQsIGNhbGxiYWNrLCBjb250ZXh0KTtcclxuICB9LFxyXG5cclxuICBkZWxldGVGZWF0dXJlczogZnVuY3Rpb24gKGlkcywgY2FsbGJhY2ssIGNvbnRleHQpIHtcclxuICAgIHJldHVybiB0aGlzLnBvc3QoJ2RlbGV0ZUZlYXR1cmVzJywge1xyXG4gICAgICBvYmplY3RJZHM6IGlkc1xyXG4gICAgfSwgZnVuY3Rpb24gKGVycm9yLCByZXNwb25zZSkge1xyXG4gICAgICAvLyBGb3IgY29tcGF0aWJpbGl0eSByZWFzb24gd2l0aCBmb3JtZXIgZGVsZXRlRmVhdHVyZSBmdW5jdGlvbixcclxuICAgICAgLy8gd2UgcmV0dXJuIHRoZSBvYmplY3QgaW4gdGhlIGFycmF5IGFuZCBub3QgdGhlIGFycmF5IGl0c2VsZlxyXG4gICAgICB2YXIgcmVzdWx0ID0gKHJlc3BvbnNlICYmIHJlc3BvbnNlLmRlbGV0ZVJlc3VsdHMpID8gcmVzcG9uc2UuZGVsZXRlUmVzdWx0cy5sZW5ndGggPiAxID8gcmVzcG9uc2UuZGVsZXRlUmVzdWx0cyA6IHJlc3BvbnNlLmRlbGV0ZVJlc3VsdHNbMF0gOiB1bmRlZmluZWQ7XHJcbiAgICAgIGlmIChjYWxsYmFjaykge1xyXG4gICAgICAgIGNhbGxiYWNrLmNhbGwoY29udGV4dCwgZXJyb3IgfHwgcmVzcG9uc2UuZGVsZXRlUmVzdWx0c1swXS5lcnJvciwgcmVzdWx0KTtcclxuICAgICAgfVxyXG4gICAgfSwgY29udGV4dCk7XHJcbiAgfVxyXG59KTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBmZWF0dXJlTGF5ZXJTZXJ2aWNlIChvcHRpb25zKSB7XHJcbiAgcmV0dXJuIG5ldyBGZWF0dXJlTGF5ZXJTZXJ2aWNlKG9wdGlvbnMpO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmZWF0dXJlTGF5ZXJTZXJ2aWNlO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/esri-leaflet/src/Services/FeatureLayerService.js\n");

/***/ }),

/***/ "./node_modules/esri-leaflet/src/Services/ImageService.js":
/*!****************************************************************!*\
  !*** ./node_modules/esri-leaflet/src/Services/ImageService.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ImageService\": () => (/* binding */ ImageService),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"imageService\": () => (/* binding */ imageService)\n/* harmony export */ });\n/* harmony import */ var _Service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Service */ \"./node_modules/esri-leaflet/src/Services/Service.js\");\n/* harmony import */ var _Tasks_IdentifyImage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Tasks/IdentifyImage */ \"./node_modules/esri-leaflet/src/Tasks/IdentifyImage.js\");\n/* harmony import */ var _Tasks_Query__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Tasks/Query */ \"./node_modules/esri-leaflet/src/Tasks/Query.js\");\n\r\n\r\n\r\n\r\nvar ImageService = _Service__WEBPACK_IMPORTED_MODULE_0__.Service.extend({\r\n\r\n  query: function () {\r\n    return (0,_Tasks_Query__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this);\r\n  },\r\n\r\n  identify: function () {\r\n    return (0,_Tasks_IdentifyImage__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this);\r\n  }\r\n});\r\n\r\nfunction imageService (options) {\r\n  return new ImageService(options);\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (imageService);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXNyaS1sZWFmbGV0L3NyYy9TZXJ2aWNlcy9JbWFnZVNlcnZpY2UuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQW9DO0FBQ2U7QUFDaEI7QUFDbkM7QUFDTyxtQkFBbUIsb0RBQWM7QUFDeEM7QUFDQTtBQUNBLFdBQVcsd0RBQUs7QUFDaEIsR0FBRztBQUNIO0FBQ0E7QUFDQSxXQUFXLGdFQUFhO0FBQ3hCO0FBQ0EsQ0FBQztBQUNEO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxZQUFZLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXNyaS1sZWFmbGV0L3NyYy9TZXJ2aWNlcy9JbWFnZVNlcnZpY2UuanM/YjFhYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTZXJ2aWNlIH0gZnJvbSAnLi9TZXJ2aWNlJztcclxuaW1wb3J0IGlkZW50aWZ5SW1hZ2UgZnJvbSAnLi4vVGFza3MvSWRlbnRpZnlJbWFnZSc7XHJcbmltcG9ydCBxdWVyeSBmcm9tICcuLi9UYXNrcy9RdWVyeSc7XHJcblxyXG5leHBvcnQgdmFyIEltYWdlU2VydmljZSA9IFNlcnZpY2UuZXh0ZW5kKHtcclxuXHJcbiAgcXVlcnk6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBxdWVyeSh0aGlzKTtcclxuICB9LFxyXG5cclxuICBpZGVudGlmeTogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIGlkZW50aWZ5SW1hZ2UodGhpcyk7XHJcbiAgfVxyXG59KTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpbWFnZVNlcnZpY2UgKG9wdGlvbnMpIHtcclxuICByZXR1cm4gbmV3IEltYWdlU2VydmljZShvcHRpb25zKTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgaW1hZ2VTZXJ2aWNlO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/esri-leaflet/src/Services/ImageService.js\n");

/***/ }),

/***/ "./node_modules/esri-leaflet/src/Services/MapService.js":
/*!**************************************************************!*\
  !*** ./node_modules/esri-leaflet/src/Services/MapService.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MapService\": () => (/* binding */ MapService),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"mapService\": () => (/* binding */ mapService)\n/* harmony export */ });\n/* harmony import */ var _Service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Service */ \"./node_modules/esri-leaflet/src/Services/Service.js\");\n/* harmony import */ var _Tasks_IdentifyFeatures__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Tasks/IdentifyFeatures */ \"./node_modules/esri-leaflet/src/Tasks/IdentifyFeatures.js\");\n/* harmony import */ var _Tasks_Query__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Tasks/Query */ \"./node_modules/esri-leaflet/src/Tasks/Query.js\");\n/* harmony import */ var _Tasks_Find__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Tasks/Find */ \"./node_modules/esri-leaflet/src/Tasks/Find.js\");\n\r\n\r\n\r\n\r\n\r\nvar MapService = _Service__WEBPACK_IMPORTED_MODULE_0__.Service.extend({\r\n\r\n  identify: function () {\r\n    return (0,_Tasks_IdentifyFeatures__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this);\r\n  },\r\n\r\n  find: function () {\r\n    return (0,_Tasks_Find__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this);\r\n  },\r\n\r\n  query: function () {\r\n    return (0,_Tasks_Query__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this);\r\n  }\r\n\r\n});\r\n\r\nfunction mapService (options) {\r\n  return new MapService(options);\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (mapService);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXNyaS1sZWFmbGV0L3NyYy9TZXJ2aWNlcy9NYXBTZXJ2aWNlLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBb0M7QUFDcUI7QUFDdEI7QUFDRjtBQUNqQztBQUNPLGlCQUFpQixvREFBYztBQUN0QztBQUNBO0FBQ0EsV0FBVyxtRUFBZ0I7QUFDM0IsR0FBRztBQUNIO0FBQ0E7QUFDQSxXQUFXLHVEQUFJO0FBQ2YsR0FBRztBQUNIO0FBQ0E7QUFDQSxXQUFXLHdEQUFLO0FBQ2hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGlFQUFlLFVBQVUsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lc3JpLWxlYWZsZXQvc3JjL1NlcnZpY2VzL01hcFNlcnZpY2UuanM/ODE4OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTZXJ2aWNlIH0gZnJvbSAnLi9TZXJ2aWNlJztcclxuaW1wb3J0IGlkZW50aWZ5RmVhdHVyZXMgZnJvbSAnLi4vVGFza3MvSWRlbnRpZnlGZWF0dXJlcyc7XHJcbmltcG9ydCBxdWVyeSBmcm9tICcuLi9UYXNrcy9RdWVyeSc7XHJcbmltcG9ydCBmaW5kIGZyb20gJy4uL1Rhc2tzL0ZpbmQnO1xyXG5cclxuZXhwb3J0IHZhciBNYXBTZXJ2aWNlID0gU2VydmljZS5leHRlbmQoe1xyXG5cclxuICBpZGVudGlmeTogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIGlkZW50aWZ5RmVhdHVyZXModGhpcyk7XHJcbiAgfSxcclxuXHJcbiAgZmluZDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIGZpbmQodGhpcyk7XHJcbiAgfSxcclxuXHJcbiAgcXVlcnk6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBxdWVyeSh0aGlzKTtcclxuICB9XHJcblxyXG59KTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBtYXBTZXJ2aWNlIChvcHRpb25zKSB7XHJcbiAgcmV0dXJuIG5ldyBNYXBTZXJ2aWNlKG9wdGlvbnMpO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBtYXBTZXJ2aWNlO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/esri-leaflet/src/Services/MapService.js\n");

/***/ }),

/***/ "./node_modules/esri-leaflet/src/Services/Service.js":
/*!***********************************************************!*\
  !*** ./node_modules/esri-leaflet/src/Services/Service.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Service\": () => (/* binding */ Service),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"service\": () => (/* binding */ service)\n/* harmony export */ });\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! leaflet */ \"./node_modules/leaflet/dist/leaflet-src.js\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Support__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Support */ \"./node_modules/esri-leaflet/src/Support.js\");\n/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Util */ \"./node_modules/esri-leaflet/src/Util.js\");\n/* harmony import */ var _Request__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Request */ \"./node_modules/esri-leaflet/src/Request.js\");\n\r\n\r\n\r\n\r\n\r\nvar Service = leaflet__WEBPACK_IMPORTED_MODULE_0__.Evented.extend({\r\n\r\n  options: {\r\n    proxy: false,\r\n    useCors: _Support__WEBPACK_IMPORTED_MODULE_1__.cors,\r\n    timeout: 0\r\n  },\r\n\r\n  initialize: function (options) {\r\n    options = options || {};\r\n    this._requestQueue = [];\r\n    this._authenticating = false;\r\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.setOptions(this, options);\r\n    this.options.url = (0,_Util__WEBPACK_IMPORTED_MODULE_2__.cleanUrl)(this.options.url);\r\n  },\r\n\r\n  get: function (path, params, callback, context) {\r\n    return this._request('get', path, params, callback, context);\r\n  },\r\n\r\n  post: function (path, params, callback, context) {\r\n    return this._request('post', path, params, callback, context);\r\n  },\r\n\r\n  request: function (path, params, callback, context) {\r\n    return this._request('request', path, params, callback, context);\r\n  },\r\n\r\n  metadata: function (callback, context) {\r\n    return this._request('get', '', {}, callback, context);\r\n  },\r\n\r\n  authenticate: function (token) {\r\n    this._authenticating = false;\r\n    this.options.token = token;\r\n    this._runQueue();\r\n    return this;\r\n  },\r\n\r\n  getTimeout: function () {\r\n    return this.options.timeout;\r\n  },\r\n\r\n  setTimeout: function (timeout) {\r\n    this.options.timeout = timeout;\r\n  },\r\n\r\n  _request: function (method, path, params, callback, context) {\r\n    this.fire('requeststart', {\r\n      url: this.options.url + path,\r\n      params: params,\r\n      method: method\r\n    }, true);\r\n\r\n    var wrappedCallback = this._createServiceCallback(method, path, params, callback, context);\r\n\r\n    if (this.options.token) {\r\n      params.token = this.options.token;\r\n    }\r\n    if (this.options.requestParams) {\r\n      leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.extend(params, this.options.requestParams);\r\n    }\r\n    if (this._authenticating) {\r\n      this._requestQueue.push([method, path, params, callback, context]);\r\n    } else {\r\n      var url = (this.options.proxy) ? this.options.proxy + '?' + this.options.url + path : this.options.url + path;\r\n\r\n      if ((method === 'get' || method === 'request') && !this.options.useCors) {\r\n        return _Request__WEBPACK_IMPORTED_MODULE_3__[\"default\"].get.JSONP(url, params, wrappedCallback, context);\r\n      } else {\r\n        return _Request__WEBPACK_IMPORTED_MODULE_3__[\"default\"][method](url, params, wrappedCallback, context);\r\n      }\r\n    }\r\n  },\r\n\r\n  _createServiceCallback: function (method, path, params, callback, context) {\r\n    return leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.bind(function (error, response) {\r\n      if (error && (error.code === 499 || error.code === 498)) {\r\n        this._authenticating = true;\r\n\r\n        this._requestQueue.push([method, path, params, callback, context]);\r\n\r\n        // fire an event for users to handle and re-authenticate\r\n        this.fire('authenticationrequired', {\r\n          authenticate: leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.bind(this.authenticate, this)\r\n        }, true);\r\n\r\n        // if the user has access to a callback they can handle the auth error\r\n        error.authenticate = leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.bind(this.authenticate, this);\r\n      }\r\n\r\n      callback.call(context, error, response);\r\n\r\n      if (error) {\r\n        this.fire('requesterror', {\r\n          url: this.options.url + path,\r\n          params: params,\r\n          message: error.message,\r\n          code: error.code,\r\n          method: method\r\n        }, true);\r\n      } else {\r\n        this.fire('requestsuccess', {\r\n          url: this.options.url + path,\r\n          params: params,\r\n          response: response,\r\n          method: method\r\n        }, true);\r\n      }\r\n\r\n      this.fire('requestend', {\r\n        url: this.options.url + path,\r\n        params: params,\r\n        method: method\r\n      }, true);\r\n    }, this);\r\n  },\r\n\r\n  _runQueue: function () {\r\n    for (var i = this._requestQueue.length - 1; i >= 0; i--) {\r\n      var request = this._requestQueue[i];\r\n      var method = request.shift();\r\n      this[method].apply(this, request);\r\n    }\r\n    this._requestQueue = [];\r\n  }\r\n});\r\n\r\nfunction service (options) {\r\n  options = (0,_Util__WEBPACK_IMPORTED_MODULE_2__.getUrlParams)(options);\r\n  return new Service(options);\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (service);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXNyaS1sZWFmbGV0L3NyYy9TZXJ2aWNlcy9TZXJ2aWNlLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQXdDO0FBQ047QUFDZTtBQUNoQjtBQUNqQztBQUNPLGNBQWMsbURBQWM7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsYUFBYSwwQ0FBSTtBQUNqQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxvREFBZTtBQUNuQix1QkFBdUIsK0NBQVE7QUFDL0IsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sZ0RBQVc7QUFDakI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMERBQWlCO0FBQ2hDLFFBQVE7QUFDUixlQUFlLGdEQUFPO0FBQ3RCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFdBQVcsOENBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsOENBQVM7QUFDakMsU0FBUztBQUNUO0FBQ0E7QUFDQSw2QkFBNkIsOENBQVM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0RBQWdELFFBQVE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ087QUFDUCxZQUFZLG1EQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGlFQUFlLE9BQU8sRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lc3JpLWxlYWZsZXQvc3JjL1NlcnZpY2VzL1NlcnZpY2UuanM/YmIxMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBVdGlsLCBFdmVudGVkIH0gZnJvbSAnbGVhZmxldCc7XHJcbmltcG9ydCB7IGNvcnMgfSBmcm9tICcuLi9TdXBwb3J0JztcclxuaW1wb3J0IHsgY2xlYW5VcmwsIGdldFVybFBhcmFtcyB9IGZyb20gJy4uL1V0aWwnO1xyXG5pbXBvcnQgUmVxdWVzdCBmcm9tICcuLi9SZXF1ZXN0JztcclxuXHJcbmV4cG9ydCB2YXIgU2VydmljZSA9IEV2ZW50ZWQuZXh0ZW5kKHtcclxuXHJcbiAgb3B0aW9uczoge1xyXG4gICAgcHJveHk6IGZhbHNlLFxyXG4gICAgdXNlQ29yczogY29ycyxcclxuICAgIHRpbWVvdXQ6IDBcclxuICB9LFxyXG5cclxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICB0aGlzLl9yZXF1ZXN0UXVldWUgPSBbXTtcclxuICAgIHRoaXMuX2F1dGhlbnRpY2F0aW5nID0gZmFsc2U7XHJcbiAgICBVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcbiAgICB0aGlzLm9wdGlvbnMudXJsID0gY2xlYW5VcmwodGhpcy5vcHRpb25zLnVybCk7XHJcbiAgfSxcclxuXHJcbiAgZ2V0OiBmdW5jdGlvbiAocGF0aCwgcGFyYW1zLCBjYWxsYmFjaywgY29udGV4dCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QoJ2dldCcsIHBhdGgsIHBhcmFtcywgY2FsbGJhY2ssIGNvbnRleHQpO1xyXG4gIH0sXHJcblxyXG4gIHBvc3Q6IGZ1bmN0aW9uIChwYXRoLCBwYXJhbXMsIGNhbGxiYWNrLCBjb250ZXh0KSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgncG9zdCcsIHBhdGgsIHBhcmFtcywgY2FsbGJhY2ssIGNvbnRleHQpO1xyXG4gIH0sXHJcblxyXG4gIHJlcXVlc3Q6IGZ1bmN0aW9uIChwYXRoLCBwYXJhbXMsIGNhbGxiYWNrLCBjb250ZXh0KSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgncmVxdWVzdCcsIHBhdGgsIHBhcmFtcywgY2FsbGJhY2ssIGNvbnRleHQpO1xyXG4gIH0sXHJcblxyXG4gIG1ldGFkYXRhOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGNvbnRleHQpIHtcclxuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KCdnZXQnLCAnJywge30sIGNhbGxiYWNrLCBjb250ZXh0KTtcclxuICB9LFxyXG5cclxuICBhdXRoZW50aWNhdGU6IGZ1bmN0aW9uICh0b2tlbikge1xyXG4gICAgdGhpcy5fYXV0aGVudGljYXRpbmcgPSBmYWxzZTtcclxuICAgIHRoaXMub3B0aW9ucy50b2tlbiA9IHRva2VuO1xyXG4gICAgdGhpcy5fcnVuUXVldWUoKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0sXHJcblxyXG4gIGdldFRpbWVvdXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLm9wdGlvbnMudGltZW91dDtcclxuICB9LFxyXG5cclxuICBzZXRUaW1lb3V0OiBmdW5jdGlvbiAodGltZW91dCkge1xyXG4gICAgdGhpcy5vcHRpb25zLnRpbWVvdXQgPSB0aW1lb3V0O1xyXG4gIH0sXHJcblxyXG4gIF9yZXF1ZXN0OiBmdW5jdGlvbiAobWV0aG9kLCBwYXRoLCBwYXJhbXMsIGNhbGxiYWNrLCBjb250ZXh0KSB7XHJcbiAgICB0aGlzLmZpcmUoJ3JlcXVlc3RzdGFydCcsIHtcclxuICAgICAgdXJsOiB0aGlzLm9wdGlvbnMudXJsICsgcGF0aCxcclxuICAgICAgcGFyYW1zOiBwYXJhbXMsXHJcbiAgICAgIG1ldGhvZDogbWV0aG9kXHJcbiAgICB9LCB0cnVlKTtcclxuXHJcbiAgICB2YXIgd3JhcHBlZENhbGxiYWNrID0gdGhpcy5fY3JlYXRlU2VydmljZUNhbGxiYWNrKG1ldGhvZCwgcGF0aCwgcGFyYW1zLCBjYWxsYmFjaywgY29udGV4dCk7XHJcblxyXG4gICAgaWYgKHRoaXMub3B0aW9ucy50b2tlbikge1xyXG4gICAgICBwYXJhbXMudG9rZW4gPSB0aGlzLm9wdGlvbnMudG9rZW47XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5vcHRpb25zLnJlcXVlc3RQYXJhbXMpIHtcclxuICAgICAgVXRpbC5leHRlbmQocGFyYW1zLCB0aGlzLm9wdGlvbnMucmVxdWVzdFBhcmFtcyk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5fYXV0aGVudGljYXRpbmcpIHtcclxuICAgICAgdGhpcy5fcmVxdWVzdFF1ZXVlLnB1c2goW21ldGhvZCwgcGF0aCwgcGFyYW1zLCBjYWxsYmFjaywgY29udGV4dF0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFyIHVybCA9ICh0aGlzLm9wdGlvbnMucHJveHkpID8gdGhpcy5vcHRpb25zLnByb3h5ICsgJz8nICsgdGhpcy5vcHRpb25zLnVybCArIHBhdGggOiB0aGlzLm9wdGlvbnMudXJsICsgcGF0aDtcclxuXHJcbiAgICAgIGlmICgobWV0aG9kID09PSAnZ2V0JyB8fCBtZXRob2QgPT09ICdyZXF1ZXN0JykgJiYgIXRoaXMub3B0aW9ucy51c2VDb3JzKSB7XHJcbiAgICAgICAgcmV0dXJuIFJlcXVlc3QuZ2V0LkpTT05QKHVybCwgcGFyYW1zLCB3cmFwcGVkQ2FsbGJhY2ssIGNvbnRleHQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBSZXF1ZXN0W21ldGhvZF0odXJsLCBwYXJhbXMsIHdyYXBwZWRDYWxsYmFjaywgY29udGV4dCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG5cclxuICBfY3JlYXRlU2VydmljZUNhbGxiYWNrOiBmdW5jdGlvbiAobWV0aG9kLCBwYXRoLCBwYXJhbXMsIGNhbGxiYWNrLCBjb250ZXh0KSB7XHJcbiAgICByZXR1cm4gVXRpbC5iaW5kKGZ1bmN0aW9uIChlcnJvciwgcmVzcG9uc2UpIHtcclxuICAgICAgaWYgKGVycm9yICYmIChlcnJvci5jb2RlID09PSA0OTkgfHwgZXJyb3IuY29kZSA9PT0gNDk4KSkge1xyXG4gICAgICAgIHRoaXMuX2F1dGhlbnRpY2F0aW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgdGhpcy5fcmVxdWVzdFF1ZXVlLnB1c2goW21ldGhvZCwgcGF0aCwgcGFyYW1zLCBjYWxsYmFjaywgY29udGV4dF0pO1xyXG5cclxuICAgICAgICAvLyBmaXJlIGFuIGV2ZW50IGZvciB1c2VycyB0byBoYW5kbGUgYW5kIHJlLWF1dGhlbnRpY2F0ZVxyXG4gICAgICAgIHRoaXMuZmlyZSgnYXV0aGVudGljYXRpb25yZXF1aXJlZCcsIHtcclxuICAgICAgICAgIGF1dGhlbnRpY2F0ZTogVXRpbC5iaW5kKHRoaXMuYXV0aGVudGljYXRlLCB0aGlzKVxyXG4gICAgICAgIH0sIHRydWUpO1xyXG5cclxuICAgICAgICAvLyBpZiB0aGUgdXNlciBoYXMgYWNjZXNzIHRvIGEgY2FsbGJhY2sgdGhleSBjYW4gaGFuZGxlIHRoZSBhdXRoIGVycm9yXHJcbiAgICAgICAgZXJyb3IuYXV0aGVudGljYXRlID0gVXRpbC5iaW5kKHRoaXMuYXV0aGVudGljYXRlLCB0aGlzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY2FsbGJhY2suY2FsbChjb250ZXh0LCBlcnJvciwgcmVzcG9uc2UpO1xyXG5cclxuICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgdGhpcy5maXJlKCdyZXF1ZXN0ZXJyb3InLCB7XHJcbiAgICAgICAgICB1cmw6IHRoaXMub3B0aW9ucy51cmwgKyBwYXRoLFxyXG4gICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXHJcbiAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxyXG4gICAgICAgICAgY29kZTogZXJyb3IuY29kZSxcclxuICAgICAgICAgIG1ldGhvZDogbWV0aG9kXHJcbiAgICAgICAgfSwgdHJ1ZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5maXJlKCdyZXF1ZXN0c3VjY2VzcycsIHtcclxuICAgICAgICAgIHVybDogdGhpcy5vcHRpb25zLnVybCArIHBhdGgsXHJcbiAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcclxuICAgICAgICAgIHJlc3BvbnNlOiByZXNwb25zZSxcclxuICAgICAgICAgIG1ldGhvZDogbWV0aG9kXHJcbiAgICAgICAgfSwgdHJ1ZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuZmlyZSgncmVxdWVzdGVuZCcsIHtcclxuICAgICAgICB1cmw6IHRoaXMub3B0aW9ucy51cmwgKyBwYXRoLFxyXG4gICAgICAgIHBhcmFtczogcGFyYW1zLFxyXG4gICAgICAgIG1ldGhvZDogbWV0aG9kXHJcbiAgICAgIH0sIHRydWUpO1xyXG4gICAgfSwgdGhpcyk7XHJcbiAgfSxcclxuXHJcbiAgX3J1blF1ZXVlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICBmb3IgKHZhciBpID0gdGhpcy5fcmVxdWVzdFF1ZXVlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgIHZhciByZXF1ZXN0ID0gdGhpcy5fcmVxdWVzdFF1ZXVlW2ldO1xyXG4gICAgICB2YXIgbWV0aG9kID0gcmVxdWVzdC5zaGlmdCgpO1xyXG4gICAgICB0aGlzW21ldGhvZF0uYXBwbHkodGhpcywgcmVxdWVzdCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9yZXF1ZXN0UXVldWUgPSBbXTtcclxuICB9XHJcbn0pO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHNlcnZpY2UgKG9wdGlvbnMpIHtcclxuICBvcHRpb25zID0gZ2V0VXJsUGFyYW1zKG9wdGlvbnMpO1xyXG4gIHJldHVybiBuZXcgU2VydmljZShvcHRpb25zKTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgc2VydmljZTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/esri-leaflet/src/Services/Service.js\n");

/***/ }),

/***/ "./node_modules/esri-leaflet/src/Support.js":
/*!**************************************************!*\
  !*** ./node_modules/esri-leaflet/src/Support.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Support\": () => (/* binding */ Support),\n/* harmony export */   \"cors\": () => (/* binding */ cors),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"pointerEvents\": () => (/* binding */ pointerEvents)\n/* harmony export */ });\nvar cors = ((window.XMLHttpRequest && 'withCredentials' in new window.XMLHttpRequest()));\r\nvar pointerEvents = document.documentElement.style.pointerEvents === '';\r\n\r\nvar Support = {\r\n  cors: cors,\r\n  pointerEvents: pointerEvents\r\n};\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Support);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXNyaS1sZWFmbGV0L3NyYy9TdXBwb3J0LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBTztBQUNBO0FBQ1A7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWUsT0FBTyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VzcmktbGVhZmxldC9zcmMvU3VwcG9ydC5qcz83YTJhIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB2YXIgY29ycyA9ICgod2luZG93LlhNTEh0dHBSZXF1ZXN0ICYmICd3aXRoQ3JlZGVudGlhbHMnIGluIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKSkpO1xyXG5leHBvcnQgdmFyIHBvaW50ZXJFdmVudHMgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUucG9pbnRlckV2ZW50cyA9PT0gJyc7XHJcblxyXG5leHBvcnQgdmFyIFN1cHBvcnQgPSB7XHJcbiAgY29yczogY29ycyxcclxuICBwb2ludGVyRXZlbnRzOiBwb2ludGVyRXZlbnRzXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTdXBwb3J0O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/esri-leaflet/src/Support.js\n");

/***/ }),

/***/ "./node_modules/esri-leaflet/src/Tasks/Find.js":
/*!*****************************************************!*\
  !*** ./node_modules/esri-leaflet/src/Tasks/Find.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Find\": () => (/* binding */ Find),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"find\": () => (/* binding */ find)\n/* harmony export */ });\n/* harmony import */ var _Task__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Task */ \"./node_modules/esri-leaflet/src/Tasks/Task.js\");\n/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Util */ \"./node_modules/esri-leaflet/src/Util.js\");\n\r\n\r\n\r\nvar Find = _Task__WEBPACK_IMPORTED_MODULE_0__.Task.extend({\r\n  setters: {\r\n    // method name > param name\r\n    contains: 'contains',\r\n    text: 'searchText',\r\n    fields: 'searchFields', // denote an array or single string\r\n    spatialReference: 'sr',\r\n    sr: 'sr',\r\n    layers: 'layers',\r\n    returnGeometry: 'returnGeometry',\r\n    maxAllowableOffset: 'maxAllowableOffset',\r\n    precision: 'geometryPrecision',\r\n    dynamicLayers: 'dynamicLayers',\r\n    returnZ: 'returnZ',\r\n    returnM: 'returnM',\r\n    gdbVersion: 'gdbVersion',\r\n    // skipped implementing this (for now) because the REST service implementation isnt consistent between operations\r\n    // 'transform': 'datumTransformations',\r\n    token: 'token'\r\n  },\r\n\r\n  path: 'find',\r\n\r\n  params: {\r\n    sr: 4326,\r\n    contains: true,\r\n    returnGeometry: true,\r\n    returnZ: true,\r\n    returnM: false\r\n  },\r\n\r\n  layerDefs: function (id, where) {\r\n    this.params.layerDefs = (this.params.layerDefs) ? this.params.layerDefs + ';' : '';\r\n    this.params.layerDefs += ([id, where]).join(':');\r\n    return this;\r\n  },\r\n\r\n  simplify: function (map, factor) {\r\n    var mapWidth = Math.abs(map.getBounds().getWest() - map.getBounds().getEast());\r\n    this.params.maxAllowableOffset = (mapWidth / map.getSize().y) * factor;\r\n    return this;\r\n  },\r\n\r\n  run: function (callback, context) {\r\n    return this.request(function (error, response) {\r\n      callback.call(context, error, (response && (0,_Util__WEBPACK_IMPORTED_MODULE_1__.responseToFeatureCollection)(response)), response);\r\n    }, context);\r\n  }\r\n});\r\n\r\nfunction find (options) {\r\n  return new Find(options);\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (find);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXNyaS1sZWFmbGV0L3NyYy9UYXNrcy9GaW5kLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQThCO0FBQ3dCO0FBQ3REO0FBQ08sV0FBVyw4Q0FBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxrRUFBMkI7QUFDNUUsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxJQUFJLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXNyaS1sZWFmbGV0L3NyYy9UYXNrcy9GaW5kLmpzPzllNjkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVGFzayB9IGZyb20gJy4vVGFzayc7XHJcbmltcG9ydCB7IHJlc3BvbnNlVG9GZWF0dXJlQ29sbGVjdGlvbiB9IGZyb20gJy4uL1V0aWwnO1xyXG5cclxuZXhwb3J0IHZhciBGaW5kID0gVGFzay5leHRlbmQoe1xyXG4gIHNldHRlcnM6IHtcclxuICAgIC8vIG1ldGhvZCBuYW1lID4gcGFyYW0gbmFtZVxyXG4gICAgY29udGFpbnM6ICdjb250YWlucycsXHJcbiAgICB0ZXh0OiAnc2VhcmNoVGV4dCcsXHJcbiAgICBmaWVsZHM6ICdzZWFyY2hGaWVsZHMnLCAvLyBkZW5vdGUgYW4gYXJyYXkgb3Igc2luZ2xlIHN0cmluZ1xyXG4gICAgc3BhdGlhbFJlZmVyZW5jZTogJ3NyJyxcclxuICAgIHNyOiAnc3InLFxyXG4gICAgbGF5ZXJzOiAnbGF5ZXJzJyxcclxuICAgIHJldHVybkdlb21ldHJ5OiAncmV0dXJuR2VvbWV0cnknLFxyXG4gICAgbWF4QWxsb3dhYmxlT2Zmc2V0OiAnbWF4QWxsb3dhYmxlT2Zmc2V0JyxcclxuICAgIHByZWNpc2lvbjogJ2dlb21ldHJ5UHJlY2lzaW9uJyxcclxuICAgIGR5bmFtaWNMYXllcnM6ICdkeW5hbWljTGF5ZXJzJyxcclxuICAgIHJldHVyblo6ICdyZXR1cm5aJyxcclxuICAgIHJldHVybk06ICdyZXR1cm5NJyxcclxuICAgIGdkYlZlcnNpb246ICdnZGJWZXJzaW9uJyxcclxuICAgIC8vIHNraXBwZWQgaW1wbGVtZW50aW5nIHRoaXMgKGZvciBub3cpIGJlY2F1c2UgdGhlIFJFU1Qgc2VydmljZSBpbXBsZW1lbnRhdGlvbiBpc250IGNvbnNpc3RlbnQgYmV0d2VlbiBvcGVyYXRpb25zXHJcbiAgICAvLyAndHJhbnNmb3JtJzogJ2RhdHVtVHJhbnNmb3JtYXRpb25zJyxcclxuICAgIHRva2VuOiAndG9rZW4nXHJcbiAgfSxcclxuXHJcbiAgcGF0aDogJ2ZpbmQnLFxyXG5cclxuICBwYXJhbXM6IHtcclxuICAgIHNyOiA0MzI2LFxyXG4gICAgY29udGFpbnM6IHRydWUsXHJcbiAgICByZXR1cm5HZW9tZXRyeTogdHJ1ZSxcclxuICAgIHJldHVyblo6IHRydWUsXHJcbiAgICByZXR1cm5NOiBmYWxzZVxyXG4gIH0sXHJcblxyXG4gIGxheWVyRGVmczogZnVuY3Rpb24gKGlkLCB3aGVyZSkge1xyXG4gICAgdGhpcy5wYXJhbXMubGF5ZXJEZWZzID0gKHRoaXMucGFyYW1zLmxheWVyRGVmcykgPyB0aGlzLnBhcmFtcy5sYXllckRlZnMgKyAnOycgOiAnJztcclxuICAgIHRoaXMucGFyYW1zLmxheWVyRGVmcyArPSAoW2lkLCB3aGVyZV0pLmpvaW4oJzonKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0sXHJcblxyXG4gIHNpbXBsaWZ5OiBmdW5jdGlvbiAobWFwLCBmYWN0b3IpIHtcclxuICAgIHZhciBtYXBXaWR0aCA9IE1hdGguYWJzKG1hcC5nZXRCb3VuZHMoKS5nZXRXZXN0KCkgLSBtYXAuZ2V0Qm91bmRzKCkuZ2V0RWFzdCgpKTtcclxuICAgIHRoaXMucGFyYW1zLm1heEFsbG93YWJsZU9mZnNldCA9IChtYXBXaWR0aCAvIG1hcC5nZXRTaXplKCkueSkgKiBmYWN0b3I7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICBydW46IGZ1bmN0aW9uIChjYWxsYmFjaywgY29udGV4dCkge1xyXG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChmdW5jdGlvbiAoZXJyb3IsIHJlc3BvbnNlKSB7XHJcbiAgICAgIGNhbGxiYWNrLmNhbGwoY29udGV4dCwgZXJyb3IsIChyZXNwb25zZSAmJiByZXNwb25zZVRvRmVhdHVyZUNvbGxlY3Rpb24ocmVzcG9uc2UpKSwgcmVzcG9uc2UpO1xyXG4gICAgfSwgY29udGV4dCk7XHJcbiAgfVxyXG59KTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBmaW5kIChvcHRpb25zKSB7XHJcbiAgcmV0dXJuIG5ldyBGaW5kKG9wdGlvbnMpO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmaW5kO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/esri-leaflet/src/Tasks/Find.js\n");

/***/ }),

/***/ "./node_modules/esri-leaflet/src/Tasks/Identify.js":
/*!*********************************************************!*\
  !*** ./node_modules/esri-leaflet/src/Tasks/Identify.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Identify\": () => (/* binding */ Identify),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"identify\": () => (/* binding */ identify)\n/* harmony export */ });\n/* harmony import */ var _Task__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Task */ \"./node_modules/esri-leaflet/src/Tasks/Task.js\");\n\r\n\r\nvar Identify = _Task__WEBPACK_IMPORTED_MODULE_0__.Task.extend({\r\n  path: 'identify',\r\n\r\n  between: function (start, end) {\r\n    this.params.time = [start.valueOf(), end.valueOf()];\r\n    return this;\r\n  }\r\n});\r\n\r\nfunction identify (options) {\r\n  return new Identify(options);\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (identify);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXNyaS1sZWFmbGV0L3NyYy9UYXNrcy9JZGVudGlmeS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQThCO0FBQzlCO0FBQ08sZUFBZSw4Q0FBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGlFQUFlLFFBQVEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lc3JpLWxlYWZsZXQvc3JjL1Rhc2tzL0lkZW50aWZ5LmpzPzU0NDciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVGFzayB9IGZyb20gJy4vVGFzayc7XHJcblxyXG5leHBvcnQgdmFyIElkZW50aWZ5ID0gVGFzay5leHRlbmQoe1xyXG4gIHBhdGg6ICdpZGVudGlmeScsXHJcblxyXG4gIGJldHdlZW46IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XHJcbiAgICB0aGlzLnBhcmFtcy50aW1lID0gW3N0YXJ0LnZhbHVlT2YoKSwgZW5kLnZhbHVlT2YoKV07XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcbn0pO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlkZW50aWZ5IChvcHRpb25zKSB7XHJcbiAgcmV0dXJuIG5ldyBJZGVudGlmeShvcHRpb25zKTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgaWRlbnRpZnk7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/esri-leaflet/src/Tasks/Identify.js\n");

/***/ }),

/***/ "./node_modules/esri-leaflet/src/Tasks/IdentifyFeatures.js":
/*!*****************************************************************!*\
  !*** ./node_modules/esri-leaflet/src/Tasks/IdentifyFeatures.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"IdentifyFeatures\": () => (/* binding */ IdentifyFeatures),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"identifyFeatures\": () => (/* binding */ identifyFeatures)\n/* harmony export */ });\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! leaflet */ \"./node_modules/leaflet/dist/leaflet-src.js\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Identify__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Identify */ \"./node_modules/esri-leaflet/src/Tasks/Identify.js\");\n/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Util */ \"./node_modules/esri-leaflet/src/Util.js\");\n\r\n\r\n\r\n\r\nvar IdentifyFeatures = _Identify__WEBPACK_IMPORTED_MODULE_1__.Identify.extend({\r\n  setters: {\r\n    layers: 'layers',\r\n    precision: 'geometryPrecision',\r\n    tolerance: 'tolerance',\r\n    // skipped implementing this (for now) because the REST service implementation isnt consistent between operations.\r\n    // 'transform': 'datumTransformations'\r\n    returnGeometry: 'returnGeometry'\r\n  },\r\n\r\n  params: {\r\n    sr: 4326,\r\n    layers: 'all',\r\n    tolerance: 3,\r\n    returnGeometry: true\r\n  },\r\n\r\n  on: function (map) {\r\n    var extent = (0,_Util__WEBPACK_IMPORTED_MODULE_2__.boundsToExtent)(map.getBounds());\r\n    var size = map.getSize();\r\n    this.params.imageDisplay = [size.x, size.y, 96];\r\n    this.params.mapExtent = [extent.xmin, extent.ymin, extent.xmax, extent.ymax];\r\n    return this;\r\n  },\r\n\r\n  at: function (geometry) {\r\n    // cast lat, long pairs in raw array form manually\r\n    if (geometry.length === 2) {\r\n      geometry = (0,leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng)(geometry);\r\n    }\r\n    this._setGeometryParams(geometry);\r\n    return this;\r\n  },\r\n\r\n  layerDef: function (id, where) {\r\n    this.params.layerDefs = (this.params.layerDefs) ? this.params.layerDefs + ';' : '';\r\n    this.params.layerDefs += ([id, where]).join(':');\r\n    return this;\r\n  },\r\n\r\n  simplify: function (map, factor) {\r\n    var mapWidth = Math.abs(map.getBounds().getWest() - map.getBounds().getEast());\r\n    this.params.maxAllowableOffset = (mapWidth / map.getSize().y) * factor;\r\n    return this;\r\n  },\r\n\r\n  run: function (callback, context) {\r\n    return this.request(function (error, response) {\r\n      // immediately invoke with an error\r\n      if (error) {\r\n        callback.call(context, error, undefined, response);\r\n\r\n      // ok no error lets just assume we have features...\r\n      } else {\r\n        var featureCollection = (0,_Util__WEBPACK_IMPORTED_MODULE_2__.responseToFeatureCollection)(response);\r\n        response.results = response.results.reverse();\r\n        for (var i = 0; i < featureCollection.features.length; i++) {\r\n          var feature = featureCollection.features[i];\r\n          feature.layerId = response.results[i].layerId;\r\n        }\r\n        callback.call(context, undefined, featureCollection, response);\r\n      }\r\n    });\r\n  },\r\n\r\n  _setGeometryParams: function (geometry) {\r\n    var converted = (0,_Util__WEBPACK_IMPORTED_MODULE_2__._setGeometry)(geometry);\r\n    this.params.geometry = converted.geometry;\r\n    this.params.geometryType = converted.geometryType;\r\n  }\r\n});\r\n\r\nfunction identifyFeatures (options) {\r\n  return new IdentifyFeatures(options);\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (identifyFeatures);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXNyaS1sZWFmbGV0L3NyYy9UYXNrcy9JZGVudGlmeUZlYXR1cmVzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBaUM7QUFDSztBQUlyQjtBQUNqQjtBQUNPLHVCQUF1QixzREFBZTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGlCQUFpQixxREFBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwrQ0FBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixnQ0FBZ0Msa0VBQTJCO0FBQzNEO0FBQ0Esd0JBQXdCLHVDQUF1QztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0Esb0JBQW9CLG1EQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsaUVBQWUsZ0JBQWdCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXNyaS1sZWFmbGV0L3NyYy9UYXNrcy9JZGVudGlmeUZlYXR1cmVzLmpzPzI4ZjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbGF0TG5nIH0gZnJvbSAnbGVhZmxldCc7XHJcbmltcG9ydCB7IElkZW50aWZ5IH0gZnJvbSAnLi9JZGVudGlmeSc7XHJcbmltcG9ydCB7IHJlc3BvbnNlVG9GZWF0dXJlQ29sbGVjdGlvbixcclxuICBib3VuZHNUb0V4dGVudCxcclxuICBfc2V0R2VvbWV0cnlcclxufSBmcm9tICcuLi9VdGlsJztcclxuXHJcbmV4cG9ydCB2YXIgSWRlbnRpZnlGZWF0dXJlcyA9IElkZW50aWZ5LmV4dGVuZCh7XHJcbiAgc2V0dGVyczoge1xyXG4gICAgbGF5ZXJzOiAnbGF5ZXJzJyxcclxuICAgIHByZWNpc2lvbjogJ2dlb21ldHJ5UHJlY2lzaW9uJyxcclxuICAgIHRvbGVyYW5jZTogJ3RvbGVyYW5jZScsXHJcbiAgICAvLyBza2lwcGVkIGltcGxlbWVudGluZyB0aGlzIChmb3Igbm93KSBiZWNhdXNlIHRoZSBSRVNUIHNlcnZpY2UgaW1wbGVtZW50YXRpb24gaXNudCBjb25zaXN0ZW50IGJldHdlZW4gb3BlcmF0aW9ucy5cclxuICAgIC8vICd0cmFuc2Zvcm0nOiAnZGF0dW1UcmFuc2Zvcm1hdGlvbnMnXHJcbiAgICByZXR1cm5HZW9tZXRyeTogJ3JldHVybkdlb21ldHJ5J1xyXG4gIH0sXHJcblxyXG4gIHBhcmFtczoge1xyXG4gICAgc3I6IDQzMjYsXHJcbiAgICBsYXllcnM6ICdhbGwnLFxyXG4gICAgdG9sZXJhbmNlOiAzLFxyXG4gICAgcmV0dXJuR2VvbWV0cnk6IHRydWVcclxuICB9LFxyXG5cclxuICBvbjogZnVuY3Rpb24gKG1hcCkge1xyXG4gICAgdmFyIGV4dGVudCA9IGJvdW5kc1RvRXh0ZW50KG1hcC5nZXRCb3VuZHMoKSk7XHJcbiAgICB2YXIgc2l6ZSA9IG1hcC5nZXRTaXplKCk7XHJcbiAgICB0aGlzLnBhcmFtcy5pbWFnZURpc3BsYXkgPSBbc2l6ZS54LCBzaXplLnksIDk2XTtcclxuICAgIHRoaXMucGFyYW1zLm1hcEV4dGVudCA9IFtleHRlbnQueG1pbiwgZXh0ZW50LnltaW4sIGV4dGVudC54bWF4LCBleHRlbnQueW1heF07XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICBhdDogZnVuY3Rpb24gKGdlb21ldHJ5KSB7XHJcbiAgICAvLyBjYXN0IGxhdCwgbG9uZyBwYWlycyBpbiByYXcgYXJyYXkgZm9ybSBtYW51YWxseVxyXG4gICAgaWYgKGdlb21ldHJ5Lmxlbmd0aCA9PT0gMikge1xyXG4gICAgICBnZW9tZXRyeSA9IGxhdExuZyhnZW9tZXRyeSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9zZXRHZW9tZXRyeVBhcmFtcyhnZW9tZXRyeSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICBsYXllckRlZjogZnVuY3Rpb24gKGlkLCB3aGVyZSkge1xyXG4gICAgdGhpcy5wYXJhbXMubGF5ZXJEZWZzID0gKHRoaXMucGFyYW1zLmxheWVyRGVmcykgPyB0aGlzLnBhcmFtcy5sYXllckRlZnMgKyAnOycgOiAnJztcclxuICAgIHRoaXMucGFyYW1zLmxheWVyRGVmcyArPSAoW2lkLCB3aGVyZV0pLmpvaW4oJzonKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0sXHJcblxyXG4gIHNpbXBsaWZ5OiBmdW5jdGlvbiAobWFwLCBmYWN0b3IpIHtcclxuICAgIHZhciBtYXBXaWR0aCA9IE1hdGguYWJzKG1hcC5nZXRCb3VuZHMoKS5nZXRXZXN0KCkgLSBtYXAuZ2V0Qm91bmRzKCkuZ2V0RWFzdCgpKTtcclxuICAgIHRoaXMucGFyYW1zLm1heEFsbG93YWJsZU9mZnNldCA9IChtYXBXaWR0aCAvIG1hcC5nZXRTaXplKCkueSkgKiBmYWN0b3I7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICBydW46IGZ1bmN0aW9uIChjYWxsYmFjaywgY29udGV4dCkge1xyXG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChmdW5jdGlvbiAoZXJyb3IsIHJlc3BvbnNlKSB7XHJcbiAgICAgIC8vIGltbWVkaWF0ZWx5IGludm9rZSB3aXRoIGFuIGVycm9yXHJcbiAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgIGNhbGxiYWNrLmNhbGwoY29udGV4dCwgZXJyb3IsIHVuZGVmaW5lZCwgcmVzcG9uc2UpO1xyXG5cclxuICAgICAgLy8gb2sgbm8gZXJyb3IgbGV0cyBqdXN0IGFzc3VtZSB3ZSBoYXZlIGZlYXR1cmVzLi4uXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIGZlYXR1cmVDb2xsZWN0aW9uID0gcmVzcG9uc2VUb0ZlYXR1cmVDb2xsZWN0aW9uKHJlc3BvbnNlKTtcclxuICAgICAgICByZXNwb25zZS5yZXN1bHRzID0gcmVzcG9uc2UucmVzdWx0cy5yZXZlcnNlKCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmZWF0dXJlQ29sbGVjdGlvbi5mZWF0dXJlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgdmFyIGZlYXR1cmUgPSBmZWF0dXJlQ29sbGVjdGlvbi5mZWF0dXJlc1tpXTtcclxuICAgICAgICAgIGZlYXR1cmUubGF5ZXJJZCA9IHJlc3BvbnNlLnJlc3VsdHNbaV0ubGF5ZXJJZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FsbGJhY2suY2FsbChjb250ZXh0LCB1bmRlZmluZWQsIGZlYXR1cmVDb2xsZWN0aW9uLCByZXNwb25zZSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH0sXHJcblxyXG4gIF9zZXRHZW9tZXRyeVBhcmFtczogZnVuY3Rpb24gKGdlb21ldHJ5KSB7XHJcbiAgICB2YXIgY29udmVydGVkID0gX3NldEdlb21ldHJ5KGdlb21ldHJ5KTtcclxuICAgIHRoaXMucGFyYW1zLmdlb21ldHJ5ID0gY29udmVydGVkLmdlb21ldHJ5O1xyXG4gICAgdGhpcy5wYXJhbXMuZ2VvbWV0cnlUeXBlID0gY29udmVydGVkLmdlb21ldHJ5VHlwZTtcclxuICB9XHJcbn0pO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlkZW50aWZ5RmVhdHVyZXMgKG9wdGlvbnMpIHtcclxuICByZXR1cm4gbmV3IElkZW50aWZ5RmVhdHVyZXMob3B0aW9ucyk7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGlkZW50aWZ5RmVhdHVyZXM7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/esri-leaflet/src/Tasks/IdentifyFeatures.js\n");

/***/ }),

/***/ "./node_modules/esri-leaflet/src/Tasks/IdentifyImage.js":
/*!**************************************************************!*\
  !*** ./node_modules/esri-leaflet/src/Tasks/IdentifyImage.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"IdentifyImage\": () => (/* binding */ IdentifyImage),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"identifyImage\": () => (/* binding */ identifyImage)\n/* harmony export */ });\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! leaflet */ \"./node_modules/leaflet/dist/leaflet-src.js\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Identify__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Identify */ \"./node_modules/esri-leaflet/src/Tasks/Identify.js\");\n/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Util */ \"./node_modules/esri-leaflet/src/Util.js\");\n\r\n\r\n\r\n\r\nvar IdentifyImage = _Identify__WEBPACK_IMPORTED_MODULE_1__.Identify.extend({\r\n  setters: {\r\n    setMosaicRule: 'mosaicRule',\r\n    setRenderingRule: 'renderingRule',\r\n    setPixelSize: 'pixelSize',\r\n    returnCatalogItems: 'returnCatalogItems',\r\n    returnGeometry: 'returnGeometry'\r\n  },\r\n\r\n  params: {\r\n    returnGeometry: false\r\n  },\r\n\r\n  at: function (latlng) {\r\n    latlng = (0,leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng)(latlng);\r\n    this.params.geometry = JSON.stringify({\r\n      x: latlng.lng,\r\n      y: latlng.lat,\r\n      spatialReference: {\r\n        wkid: 4326\r\n      }\r\n    });\r\n    this.params.geometryType = 'esriGeometryPoint';\r\n    return this;\r\n  },\r\n\r\n  getMosaicRule: function () {\r\n    return this.params.mosaicRule;\r\n  },\r\n\r\n  getRenderingRule: function () {\r\n    return this.params.renderingRule;\r\n  },\r\n\r\n  getPixelSize: function () {\r\n    return this.params.pixelSize;\r\n  },\r\n\r\n  run: function (callback, context) {\r\n    return this.request(function (error, response) {\r\n      callback.call(context, error, (response && this._responseToGeoJSON(response)), response);\r\n    }, this);\r\n  },\r\n\r\n  // get pixel data and return as geoJSON point\r\n  // populate catalog items (if any)\r\n  // merging in any catalogItemVisibilities as a propery of each feature\r\n  _responseToGeoJSON: function (response) {\r\n    var location = response.location;\r\n    var catalogItems = response.catalogItems;\r\n    var catalogItemVisibilities = response.catalogItemVisibilities;\r\n    var geoJSON = {\r\n      pixel: {\r\n        type: 'Feature',\r\n        geometry: {\r\n          type: 'Point',\r\n          coordinates: [location.x, location.y]\r\n        },\r\n        crs: {\r\n          type: 'EPSG',\r\n          properties: {\r\n            code: location.spatialReference.wkid\r\n          }\r\n        },\r\n        properties: {\r\n          OBJECTID: response.objectId,\r\n          name: response.name,\r\n          value: response.value\r\n        },\r\n        id: response.objectId\r\n      }\r\n    };\r\n\r\n    if (response.properties && response.properties.Values) {\r\n      geoJSON.pixel.properties.values = response.properties.Values;\r\n    }\r\n\r\n    if (catalogItems && catalogItems.features) {\r\n      geoJSON.catalogItems = (0,_Util__WEBPACK_IMPORTED_MODULE_2__.responseToFeatureCollection)(catalogItems);\r\n      if (catalogItemVisibilities && catalogItemVisibilities.length === geoJSON.catalogItems.features.length) {\r\n        for (var i = catalogItemVisibilities.length - 1; i >= 0; i--) {\r\n          geoJSON.catalogItems.features[i].properties.catalogItemVisibility = catalogItemVisibilities[i];\r\n        }\r\n      }\r\n    }\r\n    return geoJSON;\r\n  }\r\n\r\n});\r\n\r\nfunction identifyImage (params) {\r\n  return new IdentifyImage(params);\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (identifyImage);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXNyaS1sZWFmbGV0L3NyYy9UYXNrcy9JZGVudGlmeUltYWdlLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBaUM7QUFDSztBQUNnQjtBQUN0RDtBQUNPLG9CQUFvQixzREFBZTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxhQUFhLCtDQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGtFQUEyQjtBQUN4RDtBQUNBLHlEQUF5RCxRQUFRO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxhQUFhLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXNyaS1sZWFmbGV0L3NyYy9UYXNrcy9JZGVudGlmeUltYWdlLmpzPzE2ZjgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbGF0TG5nIH0gZnJvbSAnbGVhZmxldCc7XHJcbmltcG9ydCB7IElkZW50aWZ5IH0gZnJvbSAnLi9JZGVudGlmeSc7XHJcbmltcG9ydCB7IHJlc3BvbnNlVG9GZWF0dXJlQ29sbGVjdGlvbiB9IGZyb20gJy4uL1V0aWwnO1xyXG5cclxuZXhwb3J0IHZhciBJZGVudGlmeUltYWdlID0gSWRlbnRpZnkuZXh0ZW5kKHtcclxuICBzZXR0ZXJzOiB7XHJcbiAgICBzZXRNb3NhaWNSdWxlOiAnbW9zYWljUnVsZScsXHJcbiAgICBzZXRSZW5kZXJpbmdSdWxlOiAncmVuZGVyaW5nUnVsZScsXHJcbiAgICBzZXRQaXhlbFNpemU6ICdwaXhlbFNpemUnLFxyXG4gICAgcmV0dXJuQ2F0YWxvZ0l0ZW1zOiAncmV0dXJuQ2F0YWxvZ0l0ZW1zJyxcclxuICAgIHJldHVybkdlb21ldHJ5OiAncmV0dXJuR2VvbWV0cnknXHJcbiAgfSxcclxuXHJcbiAgcGFyYW1zOiB7XHJcbiAgICByZXR1cm5HZW9tZXRyeTogZmFsc2VcclxuICB9LFxyXG5cclxuICBhdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG4gICAgbGF0bG5nID0gbGF0TG5nKGxhdGxuZyk7XHJcbiAgICB0aGlzLnBhcmFtcy5nZW9tZXRyeSA9IEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgeDogbGF0bG5nLmxuZyxcclxuICAgICAgeTogbGF0bG5nLmxhdCxcclxuICAgICAgc3BhdGlhbFJlZmVyZW5jZToge1xyXG4gICAgICAgIHdraWQ6IDQzMjZcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICB0aGlzLnBhcmFtcy5nZW9tZXRyeVR5cGUgPSAnZXNyaUdlb21ldHJ5UG9pbnQnO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuXHJcbiAgZ2V0TW9zYWljUnVsZTogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucGFyYW1zLm1vc2FpY1J1bGU7XHJcbiAgfSxcclxuXHJcbiAgZ2V0UmVuZGVyaW5nUnVsZTogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucGFyYW1zLnJlbmRlcmluZ1J1bGU7XHJcbiAgfSxcclxuXHJcbiAgZ2V0UGl4ZWxTaXplOiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5wYXJhbXMucGl4ZWxTaXplO1xyXG4gIH0sXHJcblxyXG4gIHJ1bjogZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XHJcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGZ1bmN0aW9uIChlcnJvciwgcmVzcG9uc2UpIHtcclxuICAgICAgY2FsbGJhY2suY2FsbChjb250ZXh0LCBlcnJvciwgKHJlc3BvbnNlICYmIHRoaXMuX3Jlc3BvbnNlVG9HZW9KU09OKHJlc3BvbnNlKSksIHJlc3BvbnNlKTtcclxuICAgIH0sIHRoaXMpO1xyXG4gIH0sXHJcblxyXG4gIC8vIGdldCBwaXhlbCBkYXRhIGFuZCByZXR1cm4gYXMgZ2VvSlNPTiBwb2ludFxyXG4gIC8vIHBvcHVsYXRlIGNhdGFsb2cgaXRlbXMgKGlmIGFueSlcclxuICAvLyBtZXJnaW5nIGluIGFueSBjYXRhbG9nSXRlbVZpc2liaWxpdGllcyBhcyBhIHByb3Blcnkgb2YgZWFjaCBmZWF0dXJlXHJcbiAgX3Jlc3BvbnNlVG9HZW9KU09OOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcclxuICAgIHZhciBsb2NhdGlvbiA9IHJlc3BvbnNlLmxvY2F0aW9uO1xyXG4gICAgdmFyIGNhdGFsb2dJdGVtcyA9IHJlc3BvbnNlLmNhdGFsb2dJdGVtcztcclxuICAgIHZhciBjYXRhbG9nSXRlbVZpc2liaWxpdGllcyA9IHJlc3BvbnNlLmNhdGFsb2dJdGVtVmlzaWJpbGl0aWVzO1xyXG4gICAgdmFyIGdlb0pTT04gPSB7XHJcbiAgICAgIHBpeGVsOiB7XHJcbiAgICAgICAgdHlwZTogJ0ZlYXR1cmUnLFxyXG4gICAgICAgIGdlb21ldHJ5OiB7XHJcbiAgICAgICAgICB0eXBlOiAnUG9pbnQnLFxyXG4gICAgICAgICAgY29vcmRpbmF0ZXM6IFtsb2NhdGlvbi54LCBsb2NhdGlvbi55XVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY3JzOiB7XHJcbiAgICAgICAgICB0eXBlOiAnRVBTRycsXHJcbiAgICAgICAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgICAgIGNvZGU6IGxvY2F0aW9uLnNwYXRpYWxSZWZlcmVuY2Uud2tpZFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcHJvcGVydGllczoge1xyXG4gICAgICAgICAgT0JKRUNUSUQ6IHJlc3BvbnNlLm9iamVjdElkLFxyXG4gICAgICAgICAgbmFtZTogcmVzcG9uc2UubmFtZSxcclxuICAgICAgICAgIHZhbHVlOiByZXNwb25zZS52YWx1ZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaWQ6IHJlc3BvbnNlLm9iamVjdElkXHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgaWYgKHJlc3BvbnNlLnByb3BlcnRpZXMgJiYgcmVzcG9uc2UucHJvcGVydGllcy5WYWx1ZXMpIHtcclxuICAgICAgZ2VvSlNPTi5waXhlbC5wcm9wZXJ0aWVzLnZhbHVlcyA9IHJlc3BvbnNlLnByb3BlcnRpZXMuVmFsdWVzO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjYXRhbG9nSXRlbXMgJiYgY2F0YWxvZ0l0ZW1zLmZlYXR1cmVzKSB7XHJcbiAgICAgIGdlb0pTT04uY2F0YWxvZ0l0ZW1zID0gcmVzcG9uc2VUb0ZlYXR1cmVDb2xsZWN0aW9uKGNhdGFsb2dJdGVtcyk7XHJcbiAgICAgIGlmIChjYXRhbG9nSXRlbVZpc2liaWxpdGllcyAmJiBjYXRhbG9nSXRlbVZpc2liaWxpdGllcy5sZW5ndGggPT09IGdlb0pTT04uY2F0YWxvZ0l0ZW1zLmZlYXR1cmVzLmxlbmd0aCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBjYXRhbG9nSXRlbVZpc2liaWxpdGllcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgZ2VvSlNPTi5jYXRhbG9nSXRlbXMuZmVhdHVyZXNbaV0ucHJvcGVydGllcy5jYXRhbG9nSXRlbVZpc2liaWxpdHkgPSBjYXRhbG9nSXRlbVZpc2liaWxpdGllc1tpXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBnZW9KU09OO1xyXG4gIH1cclxuXHJcbn0pO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlkZW50aWZ5SW1hZ2UgKHBhcmFtcykge1xyXG4gIHJldHVybiBuZXcgSWRlbnRpZnlJbWFnZShwYXJhbXMpO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBpZGVudGlmeUltYWdlO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/esri-leaflet/src/Tasks/IdentifyImage.js\n");

/***/ }),

/***/ "./node_modules/esri-leaflet/src/Tasks/Query.js":
/*!******************************************************!*\
  !*** ./node_modules/esri-leaflet/src/Tasks/Query.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Query\": () => (/* binding */ Query),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"query\": () => (/* binding */ query)\n/* harmony export */ });\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! leaflet */ \"./node_modules/leaflet/dist/leaflet-src.js\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Task__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Task */ \"./node_modules/esri-leaflet/src/Tasks/Task.js\");\n/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Util */ \"./node_modules/esri-leaflet/src/Util.js\");\n\r\n\r\n\r\n\r\nvar Query = _Task__WEBPACK_IMPORTED_MODULE_1__.Task.extend({\r\n  setters: {\r\n    offset: 'resultOffset',\r\n    limit: 'resultRecordCount',\r\n    fields: 'outFields',\r\n    precision: 'geometryPrecision',\r\n    featureIds: 'objectIds',\r\n    returnGeometry: 'returnGeometry',\r\n    returnM: 'returnM',\r\n    transform: 'datumTransformation',\r\n    token: 'token'\r\n  },\r\n\r\n  path: 'query',\r\n\r\n  params: {\r\n    returnGeometry: true,\r\n    where: '1=1',\r\n    outSR: 4326,\r\n    outFields: '*'\r\n  },\r\n\r\n  // Returns a feature if its shape is wholly contained within the search geometry. Valid for all shape type combinations.\r\n  within: function (geometry) {\r\n    this._setGeometryParams(geometry);\r\n    this.params.spatialRel = 'esriSpatialRelContains'; // to the REST api this reads geometry **contains** layer\r\n    return this;\r\n  },\r\n\r\n  // Returns a feature if any spatial relationship is found. Applies to all shape type combinations.\r\n  intersects: function (geometry) {\r\n    this._setGeometryParams(geometry);\r\n    this.params.spatialRel = 'esriSpatialRelIntersects';\r\n    return this;\r\n  },\r\n\r\n  // Returns a feature if its shape wholly contains the search geometry. Valid for all shape type combinations.\r\n  contains: function (geometry) {\r\n    this._setGeometryParams(geometry);\r\n    this.params.spatialRel = 'esriSpatialRelWithin'; // to the REST api this reads geometry **within** layer\r\n    return this;\r\n  },\r\n\r\n  // Returns a feature if the intersection of the interiors of the two shapes is not empty and has a lower dimension than the maximum dimension of the two shapes. Two lines that share an endpoint in common do not cross. Valid for Line/Line, Line/Area, Multi-point/Area, and Multi-point/Line shape type combinations.\r\n  crosses: function (geometry) {\r\n    this._setGeometryParams(geometry);\r\n    this.params.spatialRel = 'esriSpatialRelCrosses';\r\n    return this;\r\n  },\r\n\r\n  // Returns a feature if the two shapes share a common boundary. However, the intersection of the interiors of the two shapes must be empty. In the Point/Line case, the point may touch an endpoint only of the line. Applies to all combinations except Point/Point.\r\n  touches: function (geometry) {\r\n    this._setGeometryParams(geometry);\r\n    this.params.spatialRel = 'esriSpatialRelTouches';\r\n    return this;\r\n  },\r\n\r\n  // Returns a feature if the intersection of the two shapes results in an object of the same dimension, but different from both of the shapes. Applies to Area/Area, Line/Line, and Multi-point/Multi-point shape type combinations.\r\n  overlaps: function (geometry) {\r\n    this._setGeometryParams(geometry);\r\n    this.params.spatialRel = 'esriSpatialRelOverlaps';\r\n    return this;\r\n  },\r\n\r\n  // Returns a feature if the envelope of the two shapes intersects.\r\n  bboxIntersects: function (geometry) {\r\n    this._setGeometryParams(geometry);\r\n    this.params.spatialRel = 'esriSpatialRelEnvelopeIntersects';\r\n    return this;\r\n  },\r\n\r\n  // if someone can help decipher the ArcObjects explanation and translate to plain speak, we should mention this method in the doc\r\n  indexIntersects: function (geometry) {\r\n    this._setGeometryParams(geometry);\r\n    this.params.spatialRel = 'esriSpatialRelIndexIntersects'; // Returns a feature if the envelope of the query geometry intersects the index entry for the target geometry\r\n    return this;\r\n  },\r\n\r\n  // only valid for Feature Services running on ArcGIS Server 10.3+ or ArcGIS Online\r\n  nearby: function (latlng, radius) {\r\n    latlng = (0,leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng)(latlng);\r\n    this.params.geometry = [latlng.lng, latlng.lat];\r\n    this.params.geometryType = 'esriGeometryPoint';\r\n    this.params.spatialRel = 'esriSpatialRelIntersects';\r\n    this.params.units = 'esriSRUnit_Meter';\r\n    this.params.distance = radius;\r\n    this.params.inSR = 4326;\r\n    return this;\r\n  },\r\n\r\n  where: function (string) {\r\n    // instead of converting double-quotes to single quotes, pass as is, and provide a more informative message if a 400 is encountered\r\n    this.params.where = string;\r\n    return this;\r\n  },\r\n\r\n  between: function (start, end) {\r\n    this.params.time = [start.valueOf(), end.valueOf()];\r\n    return this;\r\n  },\r\n\r\n  simplify: function (map, factor) {\r\n    var mapWidth = Math.abs(map.getBounds().getWest() - map.getBounds().getEast());\r\n    this.params.maxAllowableOffset = (mapWidth / map.getSize().y) * factor;\r\n    return this;\r\n  },\r\n\r\n  orderBy: function (fieldName, order) {\r\n    order = order || 'ASC';\r\n    this.params.orderByFields = (this.params.orderByFields) ? this.params.orderByFields + ',' : '';\r\n    this.params.orderByFields += ([fieldName, order]).join(' ');\r\n    return this;\r\n  },\r\n\r\n  run: function (callback, context) {\r\n    this._cleanParams();\r\n\r\n    // services hosted on ArcGIS Online and ArcGIS Server 10.3.1+ support requesting geojson directly\r\n    if (this.options.isModern || ((0,_Util__WEBPACK_IMPORTED_MODULE_2__.isArcgisOnline)(this.options.url) && this.options.isModern === undefined)) {\r\n      this.params.f = 'geojson';\r\n\r\n      return this.request(function (error, response) {\r\n        this._trapSQLerrors(error);\r\n        callback.call(context, error, response, response);\r\n      }, this);\r\n\r\n      // otherwise convert it in the callback then pass it on\r\n    } else {\r\n      return this.request(function (error, response) {\r\n        this._trapSQLerrors(error);\r\n        callback.call(context, error, (response && (0,_Util__WEBPACK_IMPORTED_MODULE_2__.responseToFeatureCollection)(response)), response);\r\n      }, this);\r\n    }\r\n  },\r\n\r\n  count: function (callback, context) {\r\n    this._cleanParams();\r\n    this.params.returnCountOnly = true;\r\n    return this.request(function (error, response) {\r\n      callback.call(this, error, (response && response.count), response);\r\n    }, context);\r\n  },\r\n\r\n  ids: function (callback, context) {\r\n    this._cleanParams();\r\n    this.params.returnIdsOnly = true;\r\n    return this.request(function (error, response) {\r\n      callback.call(this, error, (response && response.objectIds), response);\r\n    }, context);\r\n  },\r\n\r\n  // only valid for Feature Services running on ArcGIS Server 10.3+ or ArcGIS Online\r\n  bounds: function (callback, context) {\r\n    this._cleanParams();\r\n    this.params.returnExtentOnly = true;\r\n    return this.request(function (error, response) {\r\n      if (response && response.extent && (0,_Util__WEBPACK_IMPORTED_MODULE_2__.extentToBounds)(response.extent)) {\r\n        callback.call(context, error, (0,_Util__WEBPACK_IMPORTED_MODULE_2__.extentToBounds)(response.extent), response);\r\n      } else {\r\n        error = {\r\n          message: 'Invalid Bounds'\r\n        };\r\n        callback.call(context, error, null, response);\r\n      }\r\n    }, context);\r\n  },\r\n\r\n  distinct: function () {\r\n    // geometry must be omitted for queries requesting distinct values\r\n    this.params.returnGeometry = false;\r\n    this.params.returnDistinctValues = true;\r\n    return this;\r\n  },\r\n\r\n  // only valid for image services\r\n  pixelSize: function (rawPoint) {\r\n    var castPoint = (0,leaflet__WEBPACK_IMPORTED_MODULE_0__.point)(rawPoint);\r\n    this.params.pixelSize = [castPoint.x, castPoint.y];\r\n    return this;\r\n  },\r\n\r\n  // only valid for map services\r\n  layer: function (layer) {\r\n    this.path = layer + '/query';\r\n    return this;\r\n  },\r\n\r\n  _trapSQLerrors: function (error) {\r\n    if (error) {\r\n      if (error.code === '400') {\r\n        (0,_Util__WEBPACK_IMPORTED_MODULE_2__.warn)('one common syntax error in query requests is encasing string values in double quotes instead of single quotes');\r\n      }\r\n    }\r\n  },\r\n\r\n  _cleanParams: function () {\r\n    delete this.params.returnIdsOnly;\r\n    delete this.params.returnExtentOnly;\r\n    delete this.params.returnCountOnly;\r\n  },\r\n\r\n  _setGeometryParams: function (geometry) {\r\n    this.params.inSR = 4326;\r\n    var converted = (0,_Util__WEBPACK_IMPORTED_MODULE_2__._setGeometry)(geometry);\r\n    this.params.geometry = converted.geometry;\r\n    this.params.geometryType = converted.geometryType;\r\n  }\r\n\r\n});\r\n\r\nfunction query (options) {\r\n  return new Query(options);\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (query);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXNyaS1sZWFmbGV0L3NyYy9UYXNrcy9RdWVyeS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXdDO0FBQ1Y7QUFPYjtBQUNqQjtBQUNPLFlBQVksOENBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsK0NBQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHFEQUFjO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsbURBQW1ELGtFQUEyQjtBQUM5RSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxxREFBYztBQUN2RCxzQ0FBc0MscURBQWM7QUFDcEQsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsOENBQUs7QUFDekI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyQ0FBSTtBQUNaO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbURBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGlFQUFlLEtBQUssRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lc3JpLWxlYWZsZXQvc3JjL1Rhc2tzL1F1ZXJ5LmpzP2IxOGEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcG9pbnQsIGxhdExuZyB9IGZyb20gJ2xlYWZsZXQnO1xyXG5pbXBvcnQgeyBUYXNrIH0gZnJvbSAnLi9UYXNrJztcclxuaW1wb3J0IHtcclxuICB3YXJuLFxyXG4gIHJlc3BvbnNlVG9GZWF0dXJlQ29sbGVjdGlvbixcclxuICBpc0FyY2dpc09ubGluZSxcclxuICBleHRlbnRUb0JvdW5kcyxcclxuICBfc2V0R2VvbWV0cnlcclxufSBmcm9tICcuLi9VdGlsJztcclxuXHJcbmV4cG9ydCB2YXIgUXVlcnkgPSBUYXNrLmV4dGVuZCh7XHJcbiAgc2V0dGVyczoge1xyXG4gICAgb2Zmc2V0OiAncmVzdWx0T2Zmc2V0JyxcclxuICAgIGxpbWl0OiAncmVzdWx0UmVjb3JkQ291bnQnLFxyXG4gICAgZmllbGRzOiAnb3V0RmllbGRzJyxcclxuICAgIHByZWNpc2lvbjogJ2dlb21ldHJ5UHJlY2lzaW9uJyxcclxuICAgIGZlYXR1cmVJZHM6ICdvYmplY3RJZHMnLFxyXG4gICAgcmV0dXJuR2VvbWV0cnk6ICdyZXR1cm5HZW9tZXRyeScsXHJcbiAgICByZXR1cm5NOiAncmV0dXJuTScsXHJcbiAgICB0cmFuc2Zvcm06ICdkYXR1bVRyYW5zZm9ybWF0aW9uJyxcclxuICAgIHRva2VuOiAndG9rZW4nXHJcbiAgfSxcclxuXHJcbiAgcGF0aDogJ3F1ZXJ5JyxcclxuXHJcbiAgcGFyYW1zOiB7XHJcbiAgICByZXR1cm5HZW9tZXRyeTogdHJ1ZSxcclxuICAgIHdoZXJlOiAnMT0xJyxcclxuICAgIG91dFNSOiA0MzI2LFxyXG4gICAgb3V0RmllbGRzOiAnKidcclxuICB9LFxyXG5cclxuICAvLyBSZXR1cm5zIGEgZmVhdHVyZSBpZiBpdHMgc2hhcGUgaXMgd2hvbGx5IGNvbnRhaW5lZCB3aXRoaW4gdGhlIHNlYXJjaCBnZW9tZXRyeS4gVmFsaWQgZm9yIGFsbCBzaGFwZSB0eXBlIGNvbWJpbmF0aW9ucy5cclxuICB3aXRoaW46IGZ1bmN0aW9uIChnZW9tZXRyeSkge1xyXG4gICAgdGhpcy5fc2V0R2VvbWV0cnlQYXJhbXMoZ2VvbWV0cnkpO1xyXG4gICAgdGhpcy5wYXJhbXMuc3BhdGlhbFJlbCA9ICdlc3JpU3BhdGlhbFJlbENvbnRhaW5zJzsgLy8gdG8gdGhlIFJFU1QgYXBpIHRoaXMgcmVhZHMgZ2VvbWV0cnkgKipjb250YWlucyoqIGxheWVyXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICAvLyBSZXR1cm5zIGEgZmVhdHVyZSBpZiBhbnkgc3BhdGlhbCByZWxhdGlvbnNoaXAgaXMgZm91bmQuIEFwcGxpZXMgdG8gYWxsIHNoYXBlIHR5cGUgY29tYmluYXRpb25zLlxyXG4gIGludGVyc2VjdHM6IGZ1bmN0aW9uIChnZW9tZXRyeSkge1xyXG4gICAgdGhpcy5fc2V0R2VvbWV0cnlQYXJhbXMoZ2VvbWV0cnkpO1xyXG4gICAgdGhpcy5wYXJhbXMuc3BhdGlhbFJlbCA9ICdlc3JpU3BhdGlhbFJlbEludGVyc2VjdHMnO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuXHJcbiAgLy8gUmV0dXJucyBhIGZlYXR1cmUgaWYgaXRzIHNoYXBlIHdob2xseSBjb250YWlucyB0aGUgc2VhcmNoIGdlb21ldHJ5LiBWYWxpZCBmb3IgYWxsIHNoYXBlIHR5cGUgY29tYmluYXRpb25zLlxyXG4gIGNvbnRhaW5zOiBmdW5jdGlvbiAoZ2VvbWV0cnkpIHtcclxuICAgIHRoaXMuX3NldEdlb21ldHJ5UGFyYW1zKGdlb21ldHJ5KTtcclxuICAgIHRoaXMucGFyYW1zLnNwYXRpYWxSZWwgPSAnZXNyaVNwYXRpYWxSZWxXaXRoaW4nOyAvLyB0byB0aGUgUkVTVCBhcGkgdGhpcyByZWFkcyBnZW9tZXRyeSAqKndpdGhpbioqIGxheWVyXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICAvLyBSZXR1cm5zIGEgZmVhdHVyZSBpZiB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoZSBpbnRlcmlvcnMgb2YgdGhlIHR3byBzaGFwZXMgaXMgbm90IGVtcHR5IGFuZCBoYXMgYSBsb3dlciBkaW1lbnNpb24gdGhhbiB0aGUgbWF4aW11bSBkaW1lbnNpb24gb2YgdGhlIHR3byBzaGFwZXMuIFR3byBsaW5lcyB0aGF0IHNoYXJlIGFuIGVuZHBvaW50IGluIGNvbW1vbiBkbyBub3QgY3Jvc3MuIFZhbGlkIGZvciBMaW5lL0xpbmUsIExpbmUvQXJlYSwgTXVsdGktcG9pbnQvQXJlYSwgYW5kIE11bHRpLXBvaW50L0xpbmUgc2hhcGUgdHlwZSBjb21iaW5hdGlvbnMuXHJcbiAgY3Jvc3NlczogZnVuY3Rpb24gKGdlb21ldHJ5KSB7XHJcbiAgICB0aGlzLl9zZXRHZW9tZXRyeVBhcmFtcyhnZW9tZXRyeSk7XHJcbiAgICB0aGlzLnBhcmFtcy5zcGF0aWFsUmVsID0gJ2VzcmlTcGF0aWFsUmVsQ3Jvc3Nlcyc7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICAvLyBSZXR1cm5zIGEgZmVhdHVyZSBpZiB0aGUgdHdvIHNoYXBlcyBzaGFyZSBhIGNvbW1vbiBib3VuZGFyeS4gSG93ZXZlciwgdGhlIGludGVyc2VjdGlvbiBvZiB0aGUgaW50ZXJpb3JzIG9mIHRoZSB0d28gc2hhcGVzIG11c3QgYmUgZW1wdHkuIEluIHRoZSBQb2ludC9MaW5lIGNhc2UsIHRoZSBwb2ludCBtYXkgdG91Y2ggYW4gZW5kcG9pbnQgb25seSBvZiB0aGUgbGluZS4gQXBwbGllcyB0byBhbGwgY29tYmluYXRpb25zIGV4Y2VwdCBQb2ludC9Qb2ludC5cclxuICB0b3VjaGVzOiBmdW5jdGlvbiAoZ2VvbWV0cnkpIHtcclxuICAgIHRoaXMuX3NldEdlb21ldHJ5UGFyYW1zKGdlb21ldHJ5KTtcclxuICAgIHRoaXMucGFyYW1zLnNwYXRpYWxSZWwgPSAnZXNyaVNwYXRpYWxSZWxUb3VjaGVzJztcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0sXHJcblxyXG4gIC8vIFJldHVybnMgYSBmZWF0dXJlIGlmIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhlIHR3byBzaGFwZXMgcmVzdWx0cyBpbiBhbiBvYmplY3Qgb2YgdGhlIHNhbWUgZGltZW5zaW9uLCBidXQgZGlmZmVyZW50IGZyb20gYm90aCBvZiB0aGUgc2hhcGVzLiBBcHBsaWVzIHRvIEFyZWEvQXJlYSwgTGluZS9MaW5lLCBhbmQgTXVsdGktcG9pbnQvTXVsdGktcG9pbnQgc2hhcGUgdHlwZSBjb21iaW5hdGlvbnMuXHJcbiAgb3ZlcmxhcHM6IGZ1bmN0aW9uIChnZW9tZXRyeSkge1xyXG4gICAgdGhpcy5fc2V0R2VvbWV0cnlQYXJhbXMoZ2VvbWV0cnkpO1xyXG4gICAgdGhpcy5wYXJhbXMuc3BhdGlhbFJlbCA9ICdlc3JpU3BhdGlhbFJlbE92ZXJsYXBzJztcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0sXHJcblxyXG4gIC8vIFJldHVybnMgYSBmZWF0dXJlIGlmIHRoZSBlbnZlbG9wZSBvZiB0aGUgdHdvIHNoYXBlcyBpbnRlcnNlY3RzLlxyXG4gIGJib3hJbnRlcnNlY3RzOiBmdW5jdGlvbiAoZ2VvbWV0cnkpIHtcclxuICAgIHRoaXMuX3NldEdlb21ldHJ5UGFyYW1zKGdlb21ldHJ5KTtcclxuICAgIHRoaXMucGFyYW1zLnNwYXRpYWxSZWwgPSAnZXNyaVNwYXRpYWxSZWxFbnZlbG9wZUludGVyc2VjdHMnO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuXHJcbiAgLy8gaWYgc29tZW9uZSBjYW4gaGVscCBkZWNpcGhlciB0aGUgQXJjT2JqZWN0cyBleHBsYW5hdGlvbiBhbmQgdHJhbnNsYXRlIHRvIHBsYWluIHNwZWFrLCB3ZSBzaG91bGQgbWVudGlvbiB0aGlzIG1ldGhvZCBpbiB0aGUgZG9jXHJcbiAgaW5kZXhJbnRlcnNlY3RzOiBmdW5jdGlvbiAoZ2VvbWV0cnkpIHtcclxuICAgIHRoaXMuX3NldEdlb21ldHJ5UGFyYW1zKGdlb21ldHJ5KTtcclxuICAgIHRoaXMucGFyYW1zLnNwYXRpYWxSZWwgPSAnZXNyaVNwYXRpYWxSZWxJbmRleEludGVyc2VjdHMnOyAvLyBSZXR1cm5zIGEgZmVhdHVyZSBpZiB0aGUgZW52ZWxvcGUgb2YgdGhlIHF1ZXJ5IGdlb21ldHJ5IGludGVyc2VjdHMgdGhlIGluZGV4IGVudHJ5IGZvciB0aGUgdGFyZ2V0IGdlb21ldHJ5XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICAvLyBvbmx5IHZhbGlkIGZvciBGZWF0dXJlIFNlcnZpY2VzIHJ1bm5pbmcgb24gQXJjR0lTIFNlcnZlciAxMC4zKyBvciBBcmNHSVMgT25saW5lXHJcbiAgbmVhcmJ5OiBmdW5jdGlvbiAobGF0bG5nLCByYWRpdXMpIHtcclxuICAgIGxhdGxuZyA9IGxhdExuZyhsYXRsbmcpO1xyXG4gICAgdGhpcy5wYXJhbXMuZ2VvbWV0cnkgPSBbbGF0bG5nLmxuZywgbGF0bG5nLmxhdF07XHJcbiAgICB0aGlzLnBhcmFtcy5nZW9tZXRyeVR5cGUgPSAnZXNyaUdlb21ldHJ5UG9pbnQnO1xyXG4gICAgdGhpcy5wYXJhbXMuc3BhdGlhbFJlbCA9ICdlc3JpU3BhdGlhbFJlbEludGVyc2VjdHMnO1xyXG4gICAgdGhpcy5wYXJhbXMudW5pdHMgPSAnZXNyaVNSVW5pdF9NZXRlcic7XHJcbiAgICB0aGlzLnBhcmFtcy5kaXN0YW5jZSA9IHJhZGl1cztcclxuICAgIHRoaXMucGFyYW1zLmluU1IgPSA0MzI2O1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuXHJcbiAgd2hlcmU6IGZ1bmN0aW9uIChzdHJpbmcpIHtcclxuICAgIC8vIGluc3RlYWQgb2YgY29udmVydGluZyBkb3VibGUtcXVvdGVzIHRvIHNpbmdsZSBxdW90ZXMsIHBhc3MgYXMgaXMsIGFuZCBwcm92aWRlIGEgbW9yZSBpbmZvcm1hdGl2ZSBtZXNzYWdlIGlmIGEgNDAwIGlzIGVuY291bnRlcmVkXHJcbiAgICB0aGlzLnBhcmFtcy53aGVyZSA9IHN0cmluZztcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0sXHJcblxyXG4gIGJldHdlZW46IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XHJcbiAgICB0aGlzLnBhcmFtcy50aW1lID0gW3N0YXJ0LnZhbHVlT2YoKSwgZW5kLnZhbHVlT2YoKV07XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICBzaW1wbGlmeTogZnVuY3Rpb24gKG1hcCwgZmFjdG9yKSB7XHJcbiAgICB2YXIgbWFwV2lkdGggPSBNYXRoLmFicyhtYXAuZ2V0Qm91bmRzKCkuZ2V0V2VzdCgpIC0gbWFwLmdldEJvdW5kcygpLmdldEVhc3QoKSk7XHJcbiAgICB0aGlzLnBhcmFtcy5tYXhBbGxvd2FibGVPZmZzZXQgPSAobWFwV2lkdGggLyBtYXAuZ2V0U2l6ZSgpLnkpICogZmFjdG9yO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuXHJcbiAgb3JkZXJCeTogZnVuY3Rpb24gKGZpZWxkTmFtZSwgb3JkZXIpIHtcclxuICAgIG9yZGVyID0gb3JkZXIgfHwgJ0FTQyc7XHJcbiAgICB0aGlzLnBhcmFtcy5vcmRlckJ5RmllbGRzID0gKHRoaXMucGFyYW1zLm9yZGVyQnlGaWVsZHMpID8gdGhpcy5wYXJhbXMub3JkZXJCeUZpZWxkcyArICcsJyA6ICcnO1xyXG4gICAgdGhpcy5wYXJhbXMub3JkZXJCeUZpZWxkcyArPSAoW2ZpZWxkTmFtZSwgb3JkZXJdKS5qb2luKCcgJyk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICBydW46IGZ1bmN0aW9uIChjYWxsYmFjaywgY29udGV4dCkge1xyXG4gICAgdGhpcy5fY2xlYW5QYXJhbXMoKTtcclxuXHJcbiAgICAvLyBzZXJ2aWNlcyBob3N0ZWQgb24gQXJjR0lTIE9ubGluZSBhbmQgQXJjR0lTIFNlcnZlciAxMC4zLjErIHN1cHBvcnQgcmVxdWVzdGluZyBnZW9qc29uIGRpcmVjdGx5XHJcbiAgICBpZiAodGhpcy5vcHRpb25zLmlzTW9kZXJuIHx8IChpc0FyY2dpc09ubGluZSh0aGlzLm9wdGlvbnMudXJsKSAmJiB0aGlzLm9wdGlvbnMuaXNNb2Rlcm4gPT09IHVuZGVmaW5lZCkpIHtcclxuICAgICAgdGhpcy5wYXJhbXMuZiA9ICdnZW9qc29uJztcclxuXHJcbiAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoZnVuY3Rpb24gKGVycm9yLCByZXNwb25zZSkge1xyXG4gICAgICAgIHRoaXMuX3RyYXBTUUxlcnJvcnMoZXJyb3IpO1xyXG4gICAgICAgIGNhbGxiYWNrLmNhbGwoY29udGV4dCwgZXJyb3IsIHJlc3BvbnNlLCByZXNwb25zZSk7XHJcbiAgICAgIH0sIHRoaXMpO1xyXG5cclxuICAgICAgLy8gb3RoZXJ3aXNlIGNvbnZlcnQgaXQgaW4gdGhlIGNhbGxiYWNrIHRoZW4gcGFzcyBpdCBvblxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChmdW5jdGlvbiAoZXJyb3IsIHJlc3BvbnNlKSB7XHJcbiAgICAgICAgdGhpcy5fdHJhcFNRTGVycm9ycyhlcnJvcik7XHJcbiAgICAgICAgY2FsbGJhY2suY2FsbChjb250ZXh0LCBlcnJvciwgKHJlc3BvbnNlICYmIHJlc3BvbnNlVG9GZWF0dXJlQ29sbGVjdGlvbihyZXNwb25zZSkpLCByZXNwb25zZSk7XHJcbiAgICAgIH0sIHRoaXMpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGNvdW50OiBmdW5jdGlvbiAoY2FsbGJhY2ssIGNvbnRleHQpIHtcclxuICAgIHRoaXMuX2NsZWFuUGFyYW1zKCk7XHJcbiAgICB0aGlzLnBhcmFtcy5yZXR1cm5Db3VudE9ubHkgPSB0cnVlO1xyXG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChmdW5jdGlvbiAoZXJyb3IsIHJlc3BvbnNlKSB7XHJcbiAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgZXJyb3IsIChyZXNwb25zZSAmJiByZXNwb25zZS5jb3VudCksIHJlc3BvbnNlKTtcclxuICAgIH0sIGNvbnRleHQpO1xyXG4gIH0sXHJcblxyXG4gIGlkczogZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XHJcbiAgICB0aGlzLl9jbGVhblBhcmFtcygpO1xyXG4gICAgdGhpcy5wYXJhbXMucmV0dXJuSWRzT25seSA9IHRydWU7XHJcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGZ1bmN0aW9uIChlcnJvciwgcmVzcG9uc2UpIHtcclxuICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBlcnJvciwgKHJlc3BvbnNlICYmIHJlc3BvbnNlLm9iamVjdElkcyksIHJlc3BvbnNlKTtcclxuICAgIH0sIGNvbnRleHQpO1xyXG4gIH0sXHJcblxyXG4gIC8vIG9ubHkgdmFsaWQgZm9yIEZlYXR1cmUgU2VydmljZXMgcnVubmluZyBvbiBBcmNHSVMgU2VydmVyIDEwLjMrIG9yIEFyY0dJUyBPbmxpbmVcclxuICBib3VuZHM6IGZ1bmN0aW9uIChjYWxsYmFjaywgY29udGV4dCkge1xyXG4gICAgdGhpcy5fY2xlYW5QYXJhbXMoKTtcclxuICAgIHRoaXMucGFyYW1zLnJldHVybkV4dGVudE9ubHkgPSB0cnVlO1xyXG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChmdW5jdGlvbiAoZXJyb3IsIHJlc3BvbnNlKSB7XHJcbiAgICAgIGlmIChyZXNwb25zZSAmJiByZXNwb25zZS5leHRlbnQgJiYgZXh0ZW50VG9Cb3VuZHMocmVzcG9uc2UuZXh0ZW50KSkge1xyXG4gICAgICAgIGNhbGxiYWNrLmNhbGwoY29udGV4dCwgZXJyb3IsIGV4dGVudFRvQm91bmRzKHJlc3BvbnNlLmV4dGVudCksIHJlc3BvbnNlKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBlcnJvciA9IHtcclxuICAgICAgICAgIG1lc3NhZ2U6ICdJbnZhbGlkIEJvdW5kcydcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNhbGxiYWNrLmNhbGwoY29udGV4dCwgZXJyb3IsIG51bGwsIHJlc3BvbnNlKTtcclxuICAgICAgfVxyXG4gICAgfSwgY29udGV4dCk7XHJcbiAgfSxcclxuXHJcbiAgZGlzdGluY3Q6IGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIGdlb21ldHJ5IG11c3QgYmUgb21pdHRlZCBmb3IgcXVlcmllcyByZXF1ZXN0aW5nIGRpc3RpbmN0IHZhbHVlc1xyXG4gICAgdGhpcy5wYXJhbXMucmV0dXJuR2VvbWV0cnkgPSBmYWxzZTtcclxuICAgIHRoaXMucGFyYW1zLnJldHVybkRpc3RpbmN0VmFsdWVzID0gdHJ1ZTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0sXHJcblxyXG4gIC8vIG9ubHkgdmFsaWQgZm9yIGltYWdlIHNlcnZpY2VzXHJcbiAgcGl4ZWxTaXplOiBmdW5jdGlvbiAocmF3UG9pbnQpIHtcclxuICAgIHZhciBjYXN0UG9pbnQgPSBwb2ludChyYXdQb2ludCk7XHJcbiAgICB0aGlzLnBhcmFtcy5waXhlbFNpemUgPSBbY2FzdFBvaW50LngsIGNhc3RQb2ludC55XTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0sXHJcblxyXG4gIC8vIG9ubHkgdmFsaWQgZm9yIG1hcCBzZXJ2aWNlc1xyXG4gIGxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuICAgIHRoaXMucGF0aCA9IGxheWVyICsgJy9xdWVyeSc7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICBfdHJhcFNRTGVycm9yczogZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgaWYgKGVycm9yLmNvZGUgPT09ICc0MDAnKSB7XHJcbiAgICAgICAgd2Fybignb25lIGNvbW1vbiBzeW50YXggZXJyb3IgaW4gcXVlcnkgcmVxdWVzdHMgaXMgZW5jYXNpbmcgc3RyaW5nIHZhbHVlcyBpbiBkb3VibGUgcXVvdGVzIGluc3RlYWQgb2Ygc2luZ2xlIHF1b3RlcycpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgX2NsZWFuUGFyYW1zOiBmdW5jdGlvbiAoKSB7XHJcbiAgICBkZWxldGUgdGhpcy5wYXJhbXMucmV0dXJuSWRzT25seTtcclxuICAgIGRlbGV0ZSB0aGlzLnBhcmFtcy5yZXR1cm5FeHRlbnRPbmx5O1xyXG4gICAgZGVsZXRlIHRoaXMucGFyYW1zLnJldHVybkNvdW50T25seTtcclxuICB9LFxyXG5cclxuICBfc2V0R2VvbWV0cnlQYXJhbXM6IGZ1bmN0aW9uIChnZW9tZXRyeSkge1xyXG4gICAgdGhpcy5wYXJhbXMuaW5TUiA9IDQzMjY7XHJcbiAgICB2YXIgY29udmVydGVkID0gX3NldEdlb21ldHJ5KGdlb21ldHJ5KTtcclxuICAgIHRoaXMucGFyYW1zLmdlb21ldHJ5ID0gY29udmVydGVkLmdlb21ldHJ5O1xyXG4gICAgdGhpcy5wYXJhbXMuZ2VvbWV0cnlUeXBlID0gY29udmVydGVkLmdlb21ldHJ5VHlwZTtcclxuICB9XHJcblxyXG59KTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBxdWVyeSAob3B0aW9ucykge1xyXG4gIHJldHVybiBuZXcgUXVlcnkob3B0aW9ucyk7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHF1ZXJ5O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/esri-leaflet/src/Tasks/Query.js\n");

/***/ }),

/***/ "./node_modules/esri-leaflet/src/Tasks/Task.js":
/*!*****************************************************!*\
  !*** ./node_modules/esri-leaflet/src/Tasks/Task.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Task\": () => (/* binding */ Task),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"task\": () => (/* binding */ task)\n/* harmony export */ });\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! leaflet */ \"./node_modules/leaflet/dist/leaflet-src.js\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Support__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Support */ \"./node_modules/esri-leaflet/src/Support.js\");\n/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Util */ \"./node_modules/esri-leaflet/src/Util.js\");\n/* harmony import */ var _Request__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Request */ \"./node_modules/esri-leaflet/src/Request.js\");\n\r\n\r\n\r\n\r\n\r\nvar Task = leaflet__WEBPACK_IMPORTED_MODULE_0__.Class.extend({\r\n\r\n  options: {\r\n    proxy: false,\r\n    useCors: _Support__WEBPACK_IMPORTED_MODULE_1__.cors\r\n  },\r\n\r\n  // Generate a method for each methodName:paramName in the setters for this task.\r\n  generateSetter: function (param, context) {\r\n    return leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.bind(function (value) {\r\n      this.params[param] = value;\r\n      return this;\r\n    }, context);\r\n  },\r\n\r\n  initialize: function (endpoint) {\r\n    // endpoint can be either a url (and options) for an ArcGIS Rest Service or an instance of EsriLeaflet.Service\r\n    if (endpoint.request && endpoint.options) {\r\n      this._service = endpoint;\r\n      leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.setOptions(this, endpoint.options);\r\n    } else {\r\n      leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.setOptions(this, endpoint);\r\n      this.options.url = (0,_Util__WEBPACK_IMPORTED_MODULE_2__.cleanUrl)(endpoint.url);\r\n    }\r\n\r\n    // clone default params into this object\r\n    this.params = leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.extend({}, this.params || {});\r\n\r\n    // generate setter methods based on the setters object implimented a child class\r\n    if (this.setters) {\r\n      for (var setter in this.setters) {\r\n        var param = this.setters[setter];\r\n        this[setter] = this.generateSetter(param, this);\r\n      }\r\n    }\r\n  },\r\n\r\n  token: function (token) {\r\n    if (this._service) {\r\n      this._service.authenticate(token);\r\n    } else {\r\n      this.params.token = token;\r\n    }\r\n    return this;\r\n  },\r\n\r\n  apikey: function (apikey) {\r\n    return this.token(apikey);\r\n  },\r\n\r\n  // ArcGIS Server Find/Identify 10.5+\r\n  format: function (boolean) {\r\n    // use double negative to expose a more intuitive positive method name\r\n    this.params.returnUnformattedValues = !boolean;\r\n    return this;\r\n  },\r\n\r\n  request: function (callback, context) {\r\n    if (this.options.requestParams) {\r\n      leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.extend(this.params, this.options.requestParams);\r\n    }\r\n    if (this._service) {\r\n      return this._service.request(this.path, this.params, callback, context);\r\n    }\r\n\r\n    return this._request('request', this.path, this.params, callback, context);\r\n  },\r\n\r\n  _request: function (method, path, params, callback, context) {\r\n    var url = (this.options.proxy) ? this.options.proxy + '?' + this.options.url + path : this.options.url + path;\r\n\r\n    if ((method === 'get' || method === 'request') && !this.options.useCors) {\r\n      return _Request__WEBPACK_IMPORTED_MODULE_3__[\"default\"].get.JSONP(url, params, callback, context);\r\n    }\r\n\r\n    return _Request__WEBPACK_IMPORTED_MODULE_3__[\"default\"][method](url, params, callback, context);\r\n  }\r\n});\r\n\r\nfunction task (options) {\r\n  options = (0,_Util__WEBPACK_IMPORTED_MODULE_2__.getUrlParams)(options);\r\n  return new Task(options);\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (task);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXNyaS1sZWFmbGV0L3NyYy9UYXNrcy9UYXNrLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQXNDO0FBQ0o7QUFDZTtBQUNoQjtBQUNqQztBQUNPLFdBQVcsaURBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsYUFBYSwwQ0FBSTtBQUNqQixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4Q0FBUztBQUNwQjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxvREFBZTtBQUNyQixNQUFNO0FBQ04sTUFBTSxvREFBZTtBQUNyQix5QkFBeUIsK0NBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdEQUFXLEdBQUcsbUJBQW1CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTSxnREFBVztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMERBQWlCO0FBQzlCO0FBQ0E7QUFDQSxXQUFXLGdEQUFPO0FBQ2xCO0FBQ0EsQ0FBQztBQUNEO0FBQ087QUFDUCxZQUFZLG1EQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGlFQUFlLElBQUksRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lc3JpLWxlYWZsZXQvc3JjL1Rhc2tzL1Rhc2suanM/ZGJjMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDbGFzcywgVXRpbCB9IGZyb20gJ2xlYWZsZXQnO1xyXG5pbXBvcnQgeyBjb3JzIH0gZnJvbSAnLi4vU3VwcG9ydCc7XHJcbmltcG9ydCB7IGNsZWFuVXJsLCBnZXRVcmxQYXJhbXMgfSBmcm9tICcuLi9VdGlsJztcclxuaW1wb3J0IFJlcXVlc3QgZnJvbSAnLi4vUmVxdWVzdCc7XHJcblxyXG5leHBvcnQgdmFyIFRhc2sgPSBDbGFzcy5leHRlbmQoe1xyXG5cclxuICBvcHRpb25zOiB7XHJcbiAgICBwcm94eTogZmFsc2UsXHJcbiAgICB1c2VDb3JzOiBjb3JzXHJcbiAgfSxcclxuXHJcbiAgLy8gR2VuZXJhdGUgYSBtZXRob2QgZm9yIGVhY2ggbWV0aG9kTmFtZTpwYXJhbU5hbWUgaW4gdGhlIHNldHRlcnMgZm9yIHRoaXMgdGFzay5cclxuICBnZW5lcmF0ZVNldHRlcjogZnVuY3Rpb24gKHBhcmFtLCBjb250ZXh0KSB7XHJcbiAgICByZXR1cm4gVXRpbC5iaW5kKGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICB0aGlzLnBhcmFtc1twYXJhbV0gPSB2YWx1ZTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LCBjb250ZXh0KTtcclxuICB9LFxyXG5cclxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoZW5kcG9pbnQpIHtcclxuICAgIC8vIGVuZHBvaW50IGNhbiBiZSBlaXRoZXIgYSB1cmwgKGFuZCBvcHRpb25zKSBmb3IgYW4gQXJjR0lTIFJlc3QgU2VydmljZSBvciBhbiBpbnN0YW5jZSBvZiBFc3JpTGVhZmxldC5TZXJ2aWNlXHJcbiAgICBpZiAoZW5kcG9pbnQucmVxdWVzdCAmJiBlbmRwb2ludC5vcHRpb25zKSB7XHJcbiAgICAgIHRoaXMuX3NlcnZpY2UgPSBlbmRwb2ludDtcclxuICAgICAgVXRpbC5zZXRPcHRpb25zKHRoaXMsIGVuZHBvaW50Lm9wdGlvbnMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgVXRpbC5zZXRPcHRpb25zKHRoaXMsIGVuZHBvaW50KTtcclxuICAgICAgdGhpcy5vcHRpb25zLnVybCA9IGNsZWFuVXJsKGVuZHBvaW50LnVybCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY2xvbmUgZGVmYXVsdCBwYXJhbXMgaW50byB0aGlzIG9iamVjdFxyXG4gICAgdGhpcy5wYXJhbXMgPSBVdGlsLmV4dGVuZCh7fSwgdGhpcy5wYXJhbXMgfHwge30pO1xyXG5cclxuICAgIC8vIGdlbmVyYXRlIHNldHRlciBtZXRob2RzIGJhc2VkIG9uIHRoZSBzZXR0ZXJzIG9iamVjdCBpbXBsaW1lbnRlZCBhIGNoaWxkIGNsYXNzXHJcbiAgICBpZiAodGhpcy5zZXR0ZXJzKSB7XHJcbiAgICAgIGZvciAodmFyIHNldHRlciBpbiB0aGlzLnNldHRlcnMpIHtcclxuICAgICAgICB2YXIgcGFyYW0gPSB0aGlzLnNldHRlcnNbc2V0dGVyXTtcclxuICAgICAgICB0aGlzW3NldHRlcl0gPSB0aGlzLmdlbmVyYXRlU2V0dGVyKHBhcmFtLCB0aGlzKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHRva2VuOiBmdW5jdGlvbiAodG9rZW4pIHtcclxuICAgIGlmICh0aGlzLl9zZXJ2aWNlKSB7XHJcbiAgICAgIHRoaXMuX3NlcnZpY2UuYXV0aGVudGljYXRlKHRva2VuKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMucGFyYW1zLnRva2VuID0gdG9rZW47XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICBhcGlrZXk6IGZ1bmN0aW9uIChhcGlrZXkpIHtcclxuICAgIHJldHVybiB0aGlzLnRva2VuKGFwaWtleSk7XHJcbiAgfSxcclxuXHJcbiAgLy8gQXJjR0lTIFNlcnZlciBGaW5kL0lkZW50aWZ5IDEwLjUrXHJcbiAgZm9ybWF0OiBmdW5jdGlvbiAoYm9vbGVhbikge1xyXG4gICAgLy8gdXNlIGRvdWJsZSBuZWdhdGl2ZSB0byBleHBvc2UgYSBtb3JlIGludHVpdGl2ZSBwb3NpdGl2ZSBtZXRob2QgbmFtZVxyXG4gICAgdGhpcy5wYXJhbXMucmV0dXJuVW5mb3JtYXR0ZWRWYWx1ZXMgPSAhYm9vbGVhbjtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0sXHJcblxyXG4gIHJlcXVlc3Q6IGZ1bmN0aW9uIChjYWxsYmFjaywgY29udGV4dCkge1xyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXF1ZXN0UGFyYW1zKSB7XHJcbiAgICAgIFV0aWwuZXh0ZW5kKHRoaXMucGFyYW1zLCB0aGlzLm9wdGlvbnMucmVxdWVzdFBhcmFtcyk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5fc2VydmljZSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5fc2VydmljZS5yZXF1ZXN0KHRoaXMucGF0aCwgdGhpcy5wYXJhbXMsIGNhbGxiYWNrLCBjb250ZXh0KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdCgncmVxdWVzdCcsIHRoaXMucGF0aCwgdGhpcy5wYXJhbXMsIGNhbGxiYWNrLCBjb250ZXh0KTtcclxuICB9LFxyXG5cclxuICBfcmVxdWVzdDogZnVuY3Rpb24gKG1ldGhvZCwgcGF0aCwgcGFyYW1zLCBjYWxsYmFjaywgY29udGV4dCkge1xyXG4gICAgdmFyIHVybCA9ICh0aGlzLm9wdGlvbnMucHJveHkpID8gdGhpcy5vcHRpb25zLnByb3h5ICsgJz8nICsgdGhpcy5vcHRpb25zLnVybCArIHBhdGggOiB0aGlzLm9wdGlvbnMudXJsICsgcGF0aDtcclxuXHJcbiAgICBpZiAoKG1ldGhvZCA9PT0gJ2dldCcgfHwgbWV0aG9kID09PSAncmVxdWVzdCcpICYmICF0aGlzLm9wdGlvbnMudXNlQ29ycykge1xyXG4gICAgICByZXR1cm4gUmVxdWVzdC5nZXQuSlNPTlAodXJsLCBwYXJhbXMsIGNhbGxiYWNrLCBjb250ZXh0KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gUmVxdWVzdFttZXRob2RdKHVybCwgcGFyYW1zLCBjYWxsYmFjaywgY29udGV4dCk7XHJcbiAgfVxyXG59KTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB0YXNrIChvcHRpb25zKSB7XHJcbiAgb3B0aW9ucyA9IGdldFVybFBhcmFtcyhvcHRpb25zKTtcclxuICByZXR1cm4gbmV3IFRhc2sob3B0aW9ucyk7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHRhc2s7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/esri-leaflet/src/Tasks/Task.js\n");

/***/ }),

/***/ "./node_modules/esri-leaflet/src/Util.js":
/*!***********************************************!*\
  !*** ./node_modules/esri-leaflet/src/Util.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EsriUtil\": () => (/* binding */ EsriUtil),\n/* harmony export */   \"_findIdAttributeFromFeature\": () => (/* binding */ _findIdAttributeFromFeature),\n/* harmony export */   \"_findIdAttributeFromResponse\": () => (/* binding */ _findIdAttributeFromResponse),\n/* harmony export */   \"_getAttributionData\": () => (/* binding */ _getAttributionData),\n/* harmony export */   \"_setGeometry\": () => (/* binding */ _setGeometry),\n/* harmony export */   \"_updateMapAttribution\": () => (/* binding */ _updateMapAttribution),\n/* harmony export */   \"arcgisToGeoJSON\": () => (/* binding */ arcgisToGeoJSON),\n/* harmony export */   \"boundsToExtent\": () => (/* binding */ boundsToExtent),\n/* harmony export */   \"calcAttributionWidth\": () => (/* binding */ calcAttributionWidth),\n/* harmony export */   \"cleanUrl\": () => (/* binding */ cleanUrl),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"extentToBounds\": () => (/* binding */ extentToBounds),\n/* harmony export */   \"geojsonToArcGIS\": () => (/* binding */ geojsonToArcGIS),\n/* harmony export */   \"geojsonTypeToArcGIS\": () => (/* binding */ geojsonTypeToArcGIS),\n/* harmony export */   \"getUrlParams\": () => (/* binding */ getUrlParams),\n/* harmony export */   \"isArcgisOnline\": () => (/* binding */ isArcgisOnline),\n/* harmony export */   \"removeEsriAttribution\": () => (/* binding */ removeEsriAttribution),\n/* harmony export */   \"responseToFeatureCollection\": () => (/* binding */ responseToFeatureCollection),\n/* harmony export */   \"setEsriAttribution\": () => (/* binding */ setEsriAttribution),\n/* harmony export */   \"warn\": () => (/* reexport safe */ _Request__WEBPACK_IMPORTED_MODULE_1__.warn)\n/* harmony export */ });\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! leaflet */ \"./node_modules/leaflet/dist/leaflet-src.js\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Request__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Request */ \"./node_modules/esri-leaflet/src/Request.js\");\n/* harmony import */ var _Options__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Options */ \"./node_modules/esri-leaflet/src/Options.js\");\n/* harmony import */ var _Support__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Support */ \"./node_modules/esri-leaflet/src/Support.js\");\n/* harmony import */ var _terraformer_arcgis__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @terraformer/arcgis */ \"./node_modules/@terraformer/arcgis/dist/t-arcgis.esm.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar BASE_LEAFLET_ATTRIBUTION_STRING = '<a href=\"http://leafletjs.com\" title=\"A JS library for interactive maps\">Leaflet</a>';\r\nvar POWERED_BY_ESRI_ATTRIBUTION_STRING = 'Powered by <a href=\"https://www.esri.com\">Esri</a>';\r\n\r\nfunction geojsonToArcGIS (geojson, idAttr) {\r\n  return (0,_terraformer_arcgis__WEBPACK_IMPORTED_MODULE_4__.geojsonToArcGIS)(geojson, idAttr);\r\n}\r\n\r\nfunction arcgisToGeoJSON (arcgis, idAttr) {\r\n  return (0,_terraformer_arcgis__WEBPACK_IMPORTED_MODULE_4__.arcgisToGeoJSON)(arcgis, idAttr);\r\n}\r\n\r\n// convert an extent (ArcGIS) to LatLngBounds (Leaflet)\r\nfunction extentToBounds (extent) {\r\n  // \"NaN\" coordinates from ArcGIS Server indicate a null geometry\r\n  if (extent.xmin !== 'NaN' && extent.ymin !== 'NaN' && extent.xmax !== 'NaN' && extent.ymax !== 'NaN') {\r\n    var sw = (0,leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng)(extent.ymin, extent.xmin);\r\n    var ne = (0,leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng)(extent.ymax, extent.xmax);\r\n    return (0,leaflet__WEBPACK_IMPORTED_MODULE_0__.latLngBounds)(sw, ne);\r\n  } else {\r\n    return null;\r\n  }\r\n}\r\n\r\n// convert an LatLngBounds (Leaflet) to extent (ArcGIS)\r\nfunction boundsToExtent (bounds) {\r\n  bounds = (0,leaflet__WEBPACK_IMPORTED_MODULE_0__.latLngBounds)(bounds);\r\n  return {\r\n    xmin: bounds.getSouthWest().lng,\r\n    ymin: bounds.getSouthWest().lat,\r\n    xmax: bounds.getNorthEast().lng,\r\n    ymax: bounds.getNorthEast().lat,\r\n    spatialReference: {\r\n      wkid: 4326\r\n    }\r\n  };\r\n}\r\n\r\nvar knownFieldNames = /^(OBJECTID|FID|OID|ID)$/i;\r\n\r\n// Attempts to find the ID Field from response\r\nfunction _findIdAttributeFromResponse (response) {\r\n  var result;\r\n\r\n  if (response.objectIdFieldName) {\r\n    // Find Id Field directly\r\n    result = response.objectIdFieldName;\r\n  } else if (response.fields) {\r\n    // Find ID Field based on field type\r\n    for (var j = 0; j <= response.fields.length - 1; j++) {\r\n      if (response.fields[j].type === 'esriFieldTypeOID') {\r\n        result = response.fields[j].name;\r\n        break;\r\n      }\r\n    }\r\n    if (!result) {\r\n      // If no field was marked as being the esriFieldTypeOID try well known field names\r\n      for (j = 0; j <= response.fields.length - 1; j++) {\r\n        if (response.fields[j].name.match(knownFieldNames)) {\r\n          result = response.fields[j].name;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\n// This is the 'last' resort, find the Id field from the specified feature\r\nfunction _findIdAttributeFromFeature (feature) {\r\n  for (var key in feature.attributes) {\r\n    if (key.match(knownFieldNames)) {\r\n      return key;\r\n    }\r\n  }\r\n}\r\n\r\nfunction responseToFeatureCollection (response, idAttribute) {\r\n  var objectIdField;\r\n  var features = response.features || response.results;\r\n  var count = features && features.length;\r\n\r\n  if (idAttribute) {\r\n    objectIdField = idAttribute;\r\n  } else {\r\n    objectIdField = _findIdAttributeFromResponse(response);\r\n  }\r\n\r\n  var featureCollection = {\r\n    type: 'FeatureCollection',\r\n    features: []\r\n  };\r\n\r\n  if (count) {\r\n    for (var i = features.length - 1; i >= 0; i--) {\r\n      var feature = arcgisToGeoJSON(features[i], objectIdField || _findIdAttributeFromFeature(features[i]));\r\n      featureCollection.features.push(feature);\r\n    }\r\n  }\r\n\r\n  return featureCollection;\r\n}\r\n\r\n// trim url whitespace and add a trailing slash if needed\r\nfunction cleanUrl (url) {\r\n  // trim leading and trailing spaces, but not spaces inside the url\r\n  url = leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.trim(url);\r\n\r\n  // add a trailing slash to the url if the user omitted it\r\n  if (url[url.length - 1] !== '/') {\r\n    url += '/';\r\n  }\r\n\r\n  return url;\r\n}\r\n\r\n/* Extract url params if any and store them in requestParams attribute.\r\n   Return the options params updated */\r\nfunction getUrlParams (options) {\r\n  if (options.url.indexOf('?') !== -1) {\r\n    options.requestParams = options.requestParams || {};\r\n    var queryString = options.url.substring(options.url.indexOf('?') + 1);\r\n    options.url = options.url.split('?')[0];\r\n    options.requestParams = JSON.parse('{\"' + decodeURI(queryString).replace(/\"/g, '\\\\\"').replace(/&/g, '\",\"').replace(/=/g, '\":\"') + '\"}');\r\n  }\r\n  options.url = cleanUrl(options.url.split('?')[0]);\r\n  return options;\r\n}\r\n\r\nfunction isArcgisOnline (url) {\r\n  /* hosted feature services support geojson as an output format\r\n  utility.arcgis.com services are proxied from a variety of ArcGIS Server vintages, and may not */\r\n  return (/^(?!.*utility\\.arcgis\\.com).*\\.arcgis\\.com.*FeatureServer/i).test(url);\r\n}\r\n\r\nfunction geojsonTypeToArcGIS (geoJsonType) {\r\n  var arcgisGeometryType;\r\n  switch (geoJsonType) {\r\n    case 'Point':\r\n      arcgisGeometryType = 'esriGeometryPoint';\r\n      break;\r\n    case 'MultiPoint':\r\n      arcgisGeometryType = 'esriGeometryMultipoint';\r\n      break;\r\n    case 'LineString':\r\n      arcgisGeometryType = 'esriGeometryPolyline';\r\n      break;\r\n    case 'MultiLineString':\r\n      arcgisGeometryType = 'esriGeometryPolyline';\r\n      break;\r\n    case 'Polygon':\r\n      arcgisGeometryType = 'esriGeometryPolygon';\r\n      break;\r\n    case 'MultiPolygon':\r\n      arcgisGeometryType = 'esriGeometryPolygon';\r\n      break;\r\n  }\r\n\r\n  return arcgisGeometryType;\r\n}\r\n\r\nfunction calcAttributionWidth (map) {\r\n  // either crop at 55px or user defined buffer\r\n  return (map.getSize().x - _Options__WEBPACK_IMPORTED_MODULE_2__.options.attributionWidthOffset) + 'px';\r\n}\r\n\r\nfunction setEsriAttribution (map) {\r\n  if (!map.attributionControl) {\r\n    return;\r\n  }\r\n\r\n  if (!map.attributionControl._esriAttributionLayerCount) {\r\n    map.attributionControl._esriAttributionLayerCount = 0;\r\n  }\r\n\r\n  if (map.attributionControl._esriAttributionLayerCount === 0) {\r\n    // Dynamically creating the CSS rules, only run this once per page load:\r\n    if (!map.attributionControl._esriAttributionAddedOnce) {\r\n      var hoverAttributionStyle = document.createElement('style');\r\n      hoverAttributionStyle.type = 'text/css';\r\n      hoverAttributionStyle.innerHTML = '.esri-truncated-attribution:hover {' +\r\n        'white-space: normal;' +\r\n      '}';\r\n      document.getElementsByTagName('head')[0].appendChild(hoverAttributionStyle);\r\n\r\n      // define a new css class in JS to trim attribution into a single line\r\n      var attributionStyle = document.createElement('style');\r\n      attributionStyle.type = 'text/css';\r\n      attributionStyle.innerHTML = '.esri-truncated-attribution {' +\r\n        'vertical-align: -3px;' +\r\n        'white-space: nowrap;' +\r\n        'overflow: hidden;' +\r\n        'text-overflow: ellipsis;' +\r\n        'display: inline-block;' +\r\n        'transition: 0s white-space;' +\r\n        'transition-delay: 1s;' +\r\n        'max-width: ' + calcAttributionWidth(map) + ';' +\r\n      '}';\r\n      document.getElementsByTagName('head')[0].appendChild(attributionStyle);\r\n\r\n      // update the width used to truncate when the map itself is resized\r\n      map.on('resize', function (e) {\r\n        if (map.attributionControl) {\r\n          map.attributionControl._container.style.maxWidth = calcAttributionWidth(e.target);\r\n        }\r\n      });\r\n\r\n      map.attributionControl._esriAttributionAddedOnce = true;\r\n    }\r\n\r\n    map.attributionControl.setPrefix(BASE_LEAFLET_ATTRIBUTION_STRING + ' | ' + POWERED_BY_ESRI_ATTRIBUTION_STRING);\r\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.addClass(map.attributionControl._container, 'esri-truncated-attribution:hover');\r\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.addClass(map.attributionControl._container, 'esri-truncated-attribution');\r\n  }\r\n\r\n  // Track the number of esri-leaflet layers that are on the map so we can know when we can remove the attribution (below in removeEsriAttribution)\r\n  map.attributionControl._esriAttributionLayerCount = map.attributionControl._esriAttributionLayerCount + 1;\r\n}\r\n\r\nfunction removeEsriAttribution (map) {\r\n  if (!map.attributionControl) {\r\n    return;\r\n  }\r\n\r\n  // Only remove the attribution if we're about to remove the LAST esri-leaflet layer (_esriAttributionLayerCount)\r\n  if (map.attributionControl._esriAttributionLayerCount && map.attributionControl._esriAttributionLayerCount === 1) {\r\n    map.attributionControl.setPrefix(BASE_LEAFLET_ATTRIBUTION_STRING);\r\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.removeClass(map.attributionControl._container, 'esri-truncated-attribution:hover');\r\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.removeClass(map.attributionControl._container, 'esri-truncated-attribution');\r\n  }\r\n  map.attributionControl._esriAttributionLayerCount = map.attributionControl._esriAttributionLayerCount - 1;\r\n}\r\n\r\nfunction _setGeometry (geometry) {\r\n  var params = {\r\n    geometry: null,\r\n    geometryType: null\r\n  };\r\n\r\n  // convert bounds to extent and finish\r\n  if (geometry instanceof leaflet__WEBPACK_IMPORTED_MODULE_0__.LatLngBounds) {\r\n    // set geometry + geometryType\r\n    params.geometry = boundsToExtent(geometry);\r\n    params.geometryType = 'esriGeometryEnvelope';\r\n    return params;\r\n  }\r\n\r\n  // convert L.Marker > L.LatLng\r\n  if (geometry.getLatLng) {\r\n    geometry = geometry.getLatLng();\r\n  }\r\n\r\n  // convert L.LatLng to a geojson point and continue;\r\n  if (geometry instanceof leaflet__WEBPACK_IMPORTED_MODULE_0__.LatLng) {\r\n    geometry = {\r\n      type: 'Point',\r\n      coordinates: [geometry.lng, geometry.lat]\r\n    };\r\n  }\r\n\r\n  // handle L.GeoJSON, pull out the first geometry\r\n  if (geometry instanceof leaflet__WEBPACK_IMPORTED_MODULE_0__.GeoJSON) {\r\n    // reassign geometry to the GeoJSON value  (we are assuming that only one feature is present)\r\n    geometry = geometry.getLayers()[0].feature.geometry;\r\n    params.geometry = geojsonToArcGIS(geometry);\r\n    params.geometryType = geojsonTypeToArcGIS(geometry.type);\r\n  }\r\n\r\n  // Handle L.Polyline and L.Polygon\r\n  if (geometry.toGeoJSON) {\r\n    geometry = geometry.toGeoJSON();\r\n  }\r\n\r\n  // handle GeoJSON feature by pulling out the geometry\r\n  if (geometry.type === 'Feature') {\r\n    // get the geometry of the geojson feature\r\n    geometry = geometry.geometry;\r\n  }\r\n\r\n  // confirm that our GeoJSON is a point, line or polygon\r\n  if (geometry.type === 'Point' || geometry.type === 'LineString' || geometry.type === 'Polygon' || geometry.type === 'MultiPolygon') {\r\n    params.geometry = geojsonToArcGIS(geometry);\r\n    params.geometryType = geojsonTypeToArcGIS(geometry.type);\r\n    return params;\r\n  }\r\n\r\n  // warn the user if we havn't found an appropriate object\r\n  (0,_Request__WEBPACK_IMPORTED_MODULE_1__.warn)('invalid geometry passed to spatial query. Should be L.LatLng, L.LatLngBounds, L.Marker or a GeoJSON Point, Line, Polygon or MultiPolygon object');\r\n}\r\n\r\nfunction _getAttributionData (url, map) {\r\n  if (_Support__WEBPACK_IMPORTED_MODULE_3__.Support.cors) {\r\n    (0,_Request__WEBPACK_IMPORTED_MODULE_1__.request)(url, {}, leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.bind(function (error, attributions) {\r\n      if (error) { return; }\r\n      map._esriAttributions = [];\r\n      for (var c = 0; c < attributions.contributors.length; c++) {\r\n        var contributor = attributions.contributors[c];\r\n\r\n        for (var i = 0; i < contributor.coverageAreas.length; i++) {\r\n          var coverageArea = contributor.coverageAreas[i];\r\n          var southWest = (0,leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng)(coverageArea.bbox[0], coverageArea.bbox[1]);\r\n          var northEast = (0,leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng)(coverageArea.bbox[2], coverageArea.bbox[3]);\r\n          map._esriAttributions.push({\r\n            attribution: contributor.attribution,\r\n            score: coverageArea.score,\r\n            bounds: (0,leaflet__WEBPACK_IMPORTED_MODULE_0__.latLngBounds)(southWest, northEast),\r\n            minZoom: coverageArea.zoomMin,\r\n            maxZoom: coverageArea.zoomMax\r\n          });\r\n        }\r\n      }\r\n\r\n      map._esriAttributions.sort(function (a, b) {\r\n        return b.score - a.score;\r\n      });\r\n\r\n      // pass the same argument as the map's 'moveend' event\r\n      var obj = { target: map };\r\n      _updateMapAttribution(obj);\r\n    }, this));\r\n  }\r\n}\r\n\r\nfunction _updateMapAttribution (evt) {\r\n  var map = evt.target;\r\n  var oldAttributions = map._esriAttributions;\r\n\r\n  if (!map || !map.attributionControl) return;\r\n\r\n  var attributionElement = map.attributionControl._container.querySelector('.esri-dynamic-attribution');\r\n\r\n  if (attributionElement && oldAttributions) {\r\n    var newAttributions = '';\r\n    var bounds = map.getBounds();\r\n    var wrappedBounds = (0,leaflet__WEBPACK_IMPORTED_MODULE_0__.latLngBounds)(\r\n      bounds.getSouthWest().wrap(),\r\n      bounds.getNorthEast().wrap()\r\n    );\r\n    var zoom = map.getZoom();\r\n\r\n    for (var i = 0; i < oldAttributions.length; i++) {\r\n      var attribution = oldAttributions[i];\r\n      var text = attribution.attribution;\r\n\r\n      if (!newAttributions.match(text) && attribution.bounds.intersects(wrappedBounds) && zoom >= attribution.minZoom && zoom <= attribution.maxZoom) {\r\n        newAttributions += (', ' + text);\r\n      }\r\n    }\r\n\r\n    newAttributions = newAttributions.substr(2);\r\n    attributionElement.innerHTML = newAttributions;\r\n    attributionElement.style.maxWidth = calcAttributionWidth(map);\r\n\r\n    map.fire('attributionupdated', {\r\n      attribution: newAttributions\r\n    });\r\n  }\r\n}\r\n\r\n// for backwards compatibility\r\n\r\n\r\nvar EsriUtil = {\r\n  warn: _Request__WEBPACK_IMPORTED_MODULE_1__.warn,\r\n  cleanUrl: cleanUrl,\r\n  getUrlParams: getUrlParams,\r\n  isArcgisOnline: isArcgisOnline,\r\n  geojsonTypeToArcGIS: geojsonTypeToArcGIS,\r\n  responseToFeatureCollection: responseToFeatureCollection,\r\n  geojsonToArcGIS: geojsonToArcGIS,\r\n  arcgisToGeoJSON: arcgisToGeoJSON,\r\n  boundsToExtent: boundsToExtent,\r\n  extentToBounds: extentToBounds,\r\n  calcAttributionWidth: calcAttributionWidth,\r\n  setEsriAttribution: setEsriAttribution,\r\n  _setGeometry: _setGeometry,\r\n  _getAttributionData: _getAttributionData,\r\n  _updateMapAttribution: _updateMapAttribution,\r\n  _findIdAttributeFromFeature: _findIdAttributeFromFeature,\r\n  _findIdAttributeFromResponse: _findIdAttributeFromResponse\r\n};\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EsriUtil);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXNyaS1sZWFmbGV0L3NyYy9VdGlsLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTZGO0FBQ25EO0FBQ047QUFDQTtBQUNwQztBQUk2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsU0FBUyxvRUFBRztBQUNaO0FBQ0E7QUFDTztBQUNQLFNBQVMsb0VBQUc7QUFDWjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxhQUFhLCtDQUFNO0FBQ25CLGFBQWEsK0NBQU07QUFDbkIsV0FBVyxxREFBWTtBQUN2QixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVyxxREFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esb0JBQW9CLGlDQUFpQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQ0FBaUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsUUFBUSw4Q0FBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxnR0FBZ0c7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsNEJBQTRCLG9FQUE4QjtBQUMxRDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RSw2QkFBNkI7QUFDN0IsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakUsOEJBQThCO0FBQzlCLDZCQUE2QjtBQUM3QiwwQkFBMEI7QUFDMUIsaUNBQWlDO0FBQ2pDLCtCQUErQjtBQUMvQixvQ0FBb0M7QUFDcEMsOEJBQThCO0FBQzlCLHNEQUFzRDtBQUN0RCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUkscURBQWdCO0FBQ3BCLElBQUkscURBQWdCO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHdEQUFtQjtBQUN2QixJQUFJLHdEQUFtQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlEQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwyQ0FBTTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw0Q0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsOENBQUk7QUFDTjtBQUNBO0FBQ087QUFDUCxNQUFNLGtEQUFZO0FBQ2xCLElBQUksaURBQU8sUUFBUSxFQUFFLDhDQUFTO0FBQzlCLG1CQUFtQjtBQUNuQjtBQUNBLHNCQUFzQixzQ0FBc0M7QUFDNUQ7QUFDQTtBQUNBLHdCQUF3QixzQ0FBc0M7QUFDOUQ7QUFDQSwwQkFBMEIsK0NBQU07QUFDaEMsMEJBQTBCLCtDQUFNO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxREFBWTtBQUNoQztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFEQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNEJBQTRCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDZ0I7QUFDaEI7QUFDTztBQUNQLFFBQVEsMENBQUk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxRQUFRLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXNyaS1sZWFmbGV0L3NyYy9VdGlsLmpzPzY0ZjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbGF0TG5nLCBsYXRMbmdCb3VuZHMsIExhdExuZywgTGF0TG5nQm91bmRzLCBVdGlsLCBEb21VdGlsLCBHZW9KU09OIH0gZnJvbSAnbGVhZmxldCc7XHJcbmltcG9ydCB7IHJlcXVlc3QsIHdhcm4gfSBmcm9tICcuL1JlcXVlc3QnO1xyXG5pbXBvcnQgeyBvcHRpb25zIH0gZnJvbSAnLi9PcHRpb25zJztcclxuaW1wb3J0IHsgU3VwcG9ydCB9IGZyb20gJy4vU3VwcG9ydCc7XHJcblxyXG5pbXBvcnQge1xyXG4gIGdlb2pzb25Ub0FyY0dJUyBhcyBnMmEsXHJcbiAgYXJjZ2lzVG9HZW9KU09OIGFzIGEyZ1xyXG59IGZyb20gJ0B0ZXJyYWZvcm1lci9hcmNnaXMnO1xyXG5cclxudmFyIEJBU0VfTEVBRkxFVF9BVFRSSUJVVElPTl9TVFJJTkcgPSAnPGEgaHJlZj1cImh0dHA6Ly9sZWFmbGV0anMuY29tXCIgdGl0bGU9XCJBIEpTIGxpYnJhcnkgZm9yIGludGVyYWN0aXZlIG1hcHNcIj5MZWFmbGV0PC9hPic7XHJcbnZhciBQT1dFUkVEX0JZX0VTUklfQVRUUklCVVRJT05fU1RSSU5HID0gJ1Bvd2VyZWQgYnkgPGEgaHJlZj1cImh0dHBzOi8vd3d3LmVzcmkuY29tXCI+RXNyaTwvYT4nO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdlb2pzb25Ub0FyY0dJUyAoZ2VvanNvbiwgaWRBdHRyKSB7XHJcbiAgcmV0dXJuIGcyYShnZW9qc29uLCBpZEF0dHIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYXJjZ2lzVG9HZW9KU09OIChhcmNnaXMsIGlkQXR0cikge1xyXG4gIHJldHVybiBhMmcoYXJjZ2lzLCBpZEF0dHIpO1xyXG59XHJcblxyXG4vLyBjb252ZXJ0IGFuIGV4dGVudCAoQXJjR0lTKSB0byBMYXRMbmdCb3VuZHMgKExlYWZsZXQpXHJcbmV4cG9ydCBmdW5jdGlvbiBleHRlbnRUb0JvdW5kcyAoZXh0ZW50KSB7XHJcbiAgLy8gXCJOYU5cIiBjb29yZGluYXRlcyBmcm9tIEFyY0dJUyBTZXJ2ZXIgaW5kaWNhdGUgYSBudWxsIGdlb21ldHJ5XHJcbiAgaWYgKGV4dGVudC54bWluICE9PSAnTmFOJyAmJiBleHRlbnQueW1pbiAhPT0gJ05hTicgJiYgZXh0ZW50LnhtYXggIT09ICdOYU4nICYmIGV4dGVudC55bWF4ICE9PSAnTmFOJykge1xyXG4gICAgdmFyIHN3ID0gbGF0TG5nKGV4dGVudC55bWluLCBleHRlbnQueG1pbik7XHJcbiAgICB2YXIgbmUgPSBsYXRMbmcoZXh0ZW50LnltYXgsIGV4dGVudC54bWF4KTtcclxuICAgIHJldHVybiBsYXRMbmdCb3VuZHMoc3csIG5lKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBjb252ZXJ0IGFuIExhdExuZ0JvdW5kcyAoTGVhZmxldCkgdG8gZXh0ZW50IChBcmNHSVMpXHJcbmV4cG9ydCBmdW5jdGlvbiBib3VuZHNUb0V4dGVudCAoYm91bmRzKSB7XHJcbiAgYm91bmRzID0gbGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcbiAgcmV0dXJuIHtcclxuICAgIHhtaW46IGJvdW5kcy5nZXRTb3V0aFdlc3QoKS5sbmcsXHJcbiAgICB5bWluOiBib3VuZHMuZ2V0U291dGhXZXN0KCkubGF0LFxyXG4gICAgeG1heDogYm91bmRzLmdldE5vcnRoRWFzdCgpLmxuZyxcclxuICAgIHltYXg6IGJvdW5kcy5nZXROb3J0aEVhc3QoKS5sYXQsXHJcbiAgICBzcGF0aWFsUmVmZXJlbmNlOiB7XHJcbiAgICAgIHdraWQ6IDQzMjZcclxuICAgIH1cclxuICB9O1xyXG59XHJcblxyXG52YXIga25vd25GaWVsZE5hbWVzID0gL14oT0JKRUNUSUR8RklEfE9JRHxJRCkkL2k7XHJcblxyXG4vLyBBdHRlbXB0cyB0byBmaW5kIHRoZSBJRCBGaWVsZCBmcm9tIHJlc3BvbnNlXHJcbmV4cG9ydCBmdW5jdGlvbiBfZmluZElkQXR0cmlidXRlRnJvbVJlc3BvbnNlIChyZXNwb25zZSkge1xyXG4gIHZhciByZXN1bHQ7XHJcblxyXG4gIGlmIChyZXNwb25zZS5vYmplY3RJZEZpZWxkTmFtZSkge1xyXG4gICAgLy8gRmluZCBJZCBGaWVsZCBkaXJlY3RseVxyXG4gICAgcmVzdWx0ID0gcmVzcG9uc2Uub2JqZWN0SWRGaWVsZE5hbWU7XHJcbiAgfSBlbHNlIGlmIChyZXNwb25zZS5maWVsZHMpIHtcclxuICAgIC8vIEZpbmQgSUQgRmllbGQgYmFzZWQgb24gZmllbGQgdHlwZVxyXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPD0gcmVzcG9uc2UuZmllbGRzLmxlbmd0aCAtIDE7IGorKykge1xyXG4gICAgICBpZiAocmVzcG9uc2UuZmllbGRzW2pdLnR5cGUgPT09ICdlc3JpRmllbGRUeXBlT0lEJykge1xyXG4gICAgICAgIHJlc3VsdCA9IHJlc3BvbnNlLmZpZWxkc1tqXS5uYW1lO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIXJlc3VsdCkge1xyXG4gICAgICAvLyBJZiBubyBmaWVsZCB3YXMgbWFya2VkIGFzIGJlaW5nIHRoZSBlc3JpRmllbGRUeXBlT0lEIHRyeSB3ZWxsIGtub3duIGZpZWxkIG5hbWVzXHJcbiAgICAgIGZvciAoaiA9IDA7IGogPD0gcmVzcG9uc2UuZmllbGRzLmxlbmd0aCAtIDE7IGorKykge1xyXG4gICAgICAgIGlmIChyZXNwb25zZS5maWVsZHNbal0ubmFtZS5tYXRjaChrbm93bkZpZWxkTmFtZXMpKSB7XHJcbiAgICAgICAgICByZXN1bHQgPSByZXNwb25zZS5maWVsZHNbal0ubmFtZTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG4vLyBUaGlzIGlzIHRoZSAnbGFzdCcgcmVzb3J0LCBmaW5kIHRoZSBJZCBmaWVsZCBmcm9tIHRoZSBzcGVjaWZpZWQgZmVhdHVyZVxyXG5leHBvcnQgZnVuY3Rpb24gX2ZpbmRJZEF0dHJpYnV0ZUZyb21GZWF0dXJlIChmZWF0dXJlKSB7XHJcbiAgZm9yICh2YXIga2V5IGluIGZlYXR1cmUuYXR0cmlidXRlcykge1xyXG4gICAgaWYgKGtleS5tYXRjaChrbm93bkZpZWxkTmFtZXMpKSB7XHJcbiAgICAgIHJldHVybiBrZXk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcmVzcG9uc2VUb0ZlYXR1cmVDb2xsZWN0aW9uIChyZXNwb25zZSwgaWRBdHRyaWJ1dGUpIHtcclxuICB2YXIgb2JqZWN0SWRGaWVsZDtcclxuICB2YXIgZmVhdHVyZXMgPSByZXNwb25zZS5mZWF0dXJlcyB8fCByZXNwb25zZS5yZXN1bHRzO1xyXG4gIHZhciBjb3VudCA9IGZlYXR1cmVzICYmIGZlYXR1cmVzLmxlbmd0aDtcclxuXHJcbiAgaWYgKGlkQXR0cmlidXRlKSB7XHJcbiAgICBvYmplY3RJZEZpZWxkID0gaWRBdHRyaWJ1dGU7XHJcbiAgfSBlbHNlIHtcclxuICAgIG9iamVjdElkRmllbGQgPSBfZmluZElkQXR0cmlidXRlRnJvbVJlc3BvbnNlKHJlc3BvbnNlKTtcclxuICB9XHJcblxyXG4gIHZhciBmZWF0dXJlQ29sbGVjdGlvbiA9IHtcclxuICAgIHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXHJcbiAgICBmZWF0dXJlczogW11cclxuICB9O1xyXG5cclxuICBpZiAoY291bnQpIHtcclxuICAgIGZvciAodmFyIGkgPSBmZWF0dXJlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICB2YXIgZmVhdHVyZSA9IGFyY2dpc1RvR2VvSlNPTihmZWF0dXJlc1tpXSwgb2JqZWN0SWRGaWVsZCB8fCBfZmluZElkQXR0cmlidXRlRnJvbUZlYXR1cmUoZmVhdHVyZXNbaV0pKTtcclxuICAgICAgZmVhdHVyZUNvbGxlY3Rpb24uZmVhdHVyZXMucHVzaChmZWF0dXJlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBmZWF0dXJlQ29sbGVjdGlvbjtcclxufVxyXG5cclxuLy8gdHJpbSB1cmwgd2hpdGVzcGFjZSBhbmQgYWRkIGEgdHJhaWxpbmcgc2xhc2ggaWYgbmVlZGVkXHJcbmV4cG9ydCBmdW5jdGlvbiBjbGVhblVybCAodXJsKSB7XHJcbiAgLy8gdHJpbSBsZWFkaW5nIGFuZCB0cmFpbGluZyBzcGFjZXMsIGJ1dCBub3Qgc3BhY2VzIGluc2lkZSB0aGUgdXJsXHJcbiAgdXJsID0gVXRpbC50cmltKHVybCk7XHJcblxyXG4gIC8vIGFkZCBhIHRyYWlsaW5nIHNsYXNoIHRvIHRoZSB1cmwgaWYgdGhlIHVzZXIgb21pdHRlZCBpdFxyXG4gIGlmICh1cmxbdXJsLmxlbmd0aCAtIDFdICE9PSAnLycpIHtcclxuICAgIHVybCArPSAnLyc7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdXJsO1xyXG59XHJcblxyXG4vKiBFeHRyYWN0IHVybCBwYXJhbXMgaWYgYW55IGFuZCBzdG9yZSB0aGVtIGluIHJlcXVlc3RQYXJhbXMgYXR0cmlidXRlLlxyXG4gICBSZXR1cm4gdGhlIG9wdGlvbnMgcGFyYW1zIHVwZGF0ZWQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFVybFBhcmFtcyAob3B0aW9ucykge1xyXG4gIGlmIChvcHRpb25zLnVybC5pbmRleE9mKCc/JykgIT09IC0xKSB7XHJcbiAgICBvcHRpb25zLnJlcXVlc3RQYXJhbXMgPSBvcHRpb25zLnJlcXVlc3RQYXJhbXMgfHwge307XHJcbiAgICB2YXIgcXVlcnlTdHJpbmcgPSBvcHRpb25zLnVybC5zdWJzdHJpbmcob3B0aW9ucy51cmwuaW5kZXhPZignPycpICsgMSk7XHJcbiAgICBvcHRpb25zLnVybCA9IG9wdGlvbnMudXJsLnNwbGl0KCc/JylbMF07XHJcbiAgICBvcHRpb25zLnJlcXVlc3RQYXJhbXMgPSBKU09OLnBhcnNlKCd7XCInICsgZGVjb2RlVVJJKHF1ZXJ5U3RyaW5nKS5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJykucmVwbGFjZSgvJi9nLCAnXCIsXCInKS5yZXBsYWNlKC89L2csICdcIjpcIicpICsgJ1wifScpO1xyXG4gIH1cclxuICBvcHRpb25zLnVybCA9IGNsZWFuVXJsKG9wdGlvbnMudXJsLnNwbGl0KCc/JylbMF0pO1xyXG4gIHJldHVybiBvcHRpb25zO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNBcmNnaXNPbmxpbmUgKHVybCkge1xyXG4gIC8qIGhvc3RlZCBmZWF0dXJlIHNlcnZpY2VzIHN1cHBvcnQgZ2VvanNvbiBhcyBhbiBvdXRwdXQgZm9ybWF0XHJcbiAgdXRpbGl0eS5hcmNnaXMuY29tIHNlcnZpY2VzIGFyZSBwcm94aWVkIGZyb20gYSB2YXJpZXR5IG9mIEFyY0dJUyBTZXJ2ZXIgdmludGFnZXMsIGFuZCBtYXkgbm90ICovXHJcbiAgcmV0dXJuICgvXig/IS4qdXRpbGl0eVxcLmFyY2dpc1xcLmNvbSkuKlxcLmFyY2dpc1xcLmNvbS4qRmVhdHVyZVNlcnZlci9pKS50ZXN0KHVybCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZW9qc29uVHlwZVRvQXJjR0lTIChnZW9Kc29uVHlwZSkge1xyXG4gIHZhciBhcmNnaXNHZW9tZXRyeVR5cGU7XHJcbiAgc3dpdGNoIChnZW9Kc29uVHlwZSkge1xyXG4gICAgY2FzZSAnUG9pbnQnOlxyXG4gICAgICBhcmNnaXNHZW9tZXRyeVR5cGUgPSAnZXNyaUdlb21ldHJ5UG9pbnQnO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgJ011bHRpUG9pbnQnOlxyXG4gICAgICBhcmNnaXNHZW9tZXRyeVR5cGUgPSAnZXNyaUdlb21ldHJ5TXVsdGlwb2ludCc7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAnTGluZVN0cmluZyc6XHJcbiAgICAgIGFyY2dpc0dlb21ldHJ5VHlwZSA9ICdlc3JpR2VvbWV0cnlQb2x5bGluZSc7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcclxuICAgICAgYXJjZ2lzR2VvbWV0cnlUeXBlID0gJ2VzcmlHZW9tZXRyeVBvbHlsaW5lJztcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlICdQb2x5Z29uJzpcclxuICAgICAgYXJjZ2lzR2VvbWV0cnlUeXBlID0gJ2VzcmlHZW9tZXRyeVBvbHlnb24nO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgJ011bHRpUG9seWdvbic6XHJcbiAgICAgIGFyY2dpc0dlb21ldHJ5VHlwZSA9ICdlc3JpR2VvbWV0cnlQb2x5Z29uJztcclxuICAgICAgYnJlYWs7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gYXJjZ2lzR2VvbWV0cnlUeXBlO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY2FsY0F0dHJpYnV0aW9uV2lkdGggKG1hcCkge1xyXG4gIC8vIGVpdGhlciBjcm9wIGF0IDU1cHggb3IgdXNlciBkZWZpbmVkIGJ1ZmZlclxyXG4gIHJldHVybiAobWFwLmdldFNpemUoKS54IC0gb3B0aW9ucy5hdHRyaWJ1dGlvbldpZHRoT2Zmc2V0KSArICdweCc7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRFc3JpQXR0cmlidXRpb24gKG1hcCkge1xyXG4gIGlmICghbWFwLmF0dHJpYnV0aW9uQ29udHJvbCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgaWYgKCFtYXAuYXR0cmlidXRpb25Db250cm9sLl9lc3JpQXR0cmlidXRpb25MYXllckNvdW50KSB7XHJcbiAgICBtYXAuYXR0cmlidXRpb25Db250cm9sLl9lc3JpQXR0cmlidXRpb25MYXllckNvdW50ID0gMDtcclxuICB9XHJcblxyXG4gIGlmIChtYXAuYXR0cmlidXRpb25Db250cm9sLl9lc3JpQXR0cmlidXRpb25MYXllckNvdW50ID09PSAwKSB7XHJcbiAgICAvLyBEeW5hbWljYWxseSBjcmVhdGluZyB0aGUgQ1NTIHJ1bGVzLCBvbmx5IHJ1biB0aGlzIG9uY2UgcGVyIHBhZ2UgbG9hZDpcclxuICAgIGlmICghbWFwLmF0dHJpYnV0aW9uQ29udHJvbC5fZXNyaUF0dHJpYnV0aW9uQWRkZWRPbmNlKSB7XHJcbiAgICAgIHZhciBob3ZlckF0dHJpYnV0aW9uU3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xyXG4gICAgICBob3ZlckF0dHJpYnV0aW9uU3R5bGUudHlwZSA9ICd0ZXh0L2Nzcyc7XHJcbiAgICAgIGhvdmVyQXR0cmlidXRpb25TdHlsZS5pbm5lckhUTUwgPSAnLmVzcmktdHJ1bmNhdGVkLWF0dHJpYnV0aW9uOmhvdmVyIHsnICtcclxuICAgICAgICAnd2hpdGUtc3BhY2U6IG5vcm1hbDsnICtcclxuICAgICAgJ30nO1xyXG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKGhvdmVyQXR0cmlidXRpb25TdHlsZSk7XHJcblxyXG4gICAgICAvLyBkZWZpbmUgYSBuZXcgY3NzIGNsYXNzIGluIEpTIHRvIHRyaW0gYXR0cmlidXRpb24gaW50byBhIHNpbmdsZSBsaW5lXHJcbiAgICAgIHZhciBhdHRyaWJ1dGlvblN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcclxuICAgICAgYXR0cmlidXRpb25TdHlsZS50eXBlID0gJ3RleHQvY3NzJztcclxuICAgICAgYXR0cmlidXRpb25TdHlsZS5pbm5lckhUTUwgPSAnLmVzcmktdHJ1bmNhdGVkLWF0dHJpYnV0aW9uIHsnICtcclxuICAgICAgICAndmVydGljYWwtYWxpZ246IC0zcHg7JyArXHJcbiAgICAgICAgJ3doaXRlLXNwYWNlOiBub3dyYXA7JyArXHJcbiAgICAgICAgJ292ZXJmbG93OiBoaWRkZW47JyArXHJcbiAgICAgICAgJ3RleHQtb3ZlcmZsb3c6IGVsbGlwc2lzOycgK1xyXG4gICAgICAgICdkaXNwbGF5OiBpbmxpbmUtYmxvY2s7JyArXHJcbiAgICAgICAgJ3RyYW5zaXRpb246IDBzIHdoaXRlLXNwYWNlOycgK1xyXG4gICAgICAgICd0cmFuc2l0aW9uLWRlbGF5OiAxczsnICtcclxuICAgICAgICAnbWF4LXdpZHRoOiAnICsgY2FsY0F0dHJpYnV0aW9uV2lkdGgobWFwKSArICc7JyArXHJcbiAgICAgICd9JztcclxuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZChhdHRyaWJ1dGlvblN0eWxlKTtcclxuXHJcbiAgICAgIC8vIHVwZGF0ZSB0aGUgd2lkdGggdXNlZCB0byB0cnVuY2F0ZSB3aGVuIHRoZSBtYXAgaXRzZWxmIGlzIHJlc2l6ZWRcclxuICAgICAgbWFwLm9uKCdyZXNpemUnLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGlmIChtYXAuYXR0cmlidXRpb25Db250cm9sKSB7XHJcbiAgICAgICAgICBtYXAuYXR0cmlidXRpb25Db250cm9sLl9jb250YWluZXIuc3R5bGUubWF4V2lkdGggPSBjYWxjQXR0cmlidXRpb25XaWR0aChlLnRhcmdldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIG1hcC5hdHRyaWJ1dGlvbkNvbnRyb2wuX2VzcmlBdHRyaWJ1dGlvbkFkZGVkT25jZSA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgbWFwLmF0dHJpYnV0aW9uQ29udHJvbC5zZXRQcmVmaXgoQkFTRV9MRUFGTEVUX0FUVFJJQlVUSU9OX1NUUklORyArICcgfCAnICsgUE9XRVJFRF9CWV9FU1JJX0FUVFJJQlVUSU9OX1NUUklORyk7XHJcbiAgICBEb21VdGlsLmFkZENsYXNzKG1hcC5hdHRyaWJ1dGlvbkNvbnRyb2wuX2NvbnRhaW5lciwgJ2VzcmktdHJ1bmNhdGVkLWF0dHJpYnV0aW9uOmhvdmVyJyk7XHJcbiAgICBEb21VdGlsLmFkZENsYXNzKG1hcC5hdHRyaWJ1dGlvbkNvbnRyb2wuX2NvbnRhaW5lciwgJ2VzcmktdHJ1bmNhdGVkLWF0dHJpYnV0aW9uJyk7XHJcbiAgfVxyXG5cclxuICAvLyBUcmFjayB0aGUgbnVtYmVyIG9mIGVzcmktbGVhZmxldCBsYXllcnMgdGhhdCBhcmUgb24gdGhlIG1hcCBzbyB3ZSBjYW4ga25vdyB3aGVuIHdlIGNhbiByZW1vdmUgdGhlIGF0dHJpYnV0aW9uIChiZWxvdyBpbiByZW1vdmVFc3JpQXR0cmlidXRpb24pXHJcbiAgbWFwLmF0dHJpYnV0aW9uQ29udHJvbC5fZXNyaUF0dHJpYnV0aW9uTGF5ZXJDb3VudCA9IG1hcC5hdHRyaWJ1dGlvbkNvbnRyb2wuX2VzcmlBdHRyaWJ1dGlvbkxheWVyQ291bnQgKyAxO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlRXNyaUF0dHJpYnV0aW9uIChtYXApIHtcclxuICBpZiAoIW1hcC5hdHRyaWJ1dGlvbkNvbnRyb2wpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIC8vIE9ubHkgcmVtb3ZlIHRoZSBhdHRyaWJ1dGlvbiBpZiB3ZSdyZSBhYm91dCB0byByZW1vdmUgdGhlIExBU1QgZXNyaS1sZWFmbGV0IGxheWVyIChfZXNyaUF0dHJpYnV0aW9uTGF5ZXJDb3VudClcclxuICBpZiAobWFwLmF0dHJpYnV0aW9uQ29udHJvbC5fZXNyaUF0dHJpYnV0aW9uTGF5ZXJDb3VudCAmJiBtYXAuYXR0cmlidXRpb25Db250cm9sLl9lc3JpQXR0cmlidXRpb25MYXllckNvdW50ID09PSAxKSB7XHJcbiAgICBtYXAuYXR0cmlidXRpb25Db250cm9sLnNldFByZWZpeChCQVNFX0xFQUZMRVRfQVRUUklCVVRJT05fU1RSSU5HKTtcclxuICAgIERvbVV0aWwucmVtb3ZlQ2xhc3MobWFwLmF0dHJpYnV0aW9uQ29udHJvbC5fY29udGFpbmVyLCAnZXNyaS10cnVuY2F0ZWQtYXR0cmlidXRpb246aG92ZXInKTtcclxuICAgIERvbVV0aWwucmVtb3ZlQ2xhc3MobWFwLmF0dHJpYnV0aW9uQ29udHJvbC5fY29udGFpbmVyLCAnZXNyaS10cnVuY2F0ZWQtYXR0cmlidXRpb24nKTtcclxuICB9XHJcbiAgbWFwLmF0dHJpYnV0aW9uQ29udHJvbC5fZXNyaUF0dHJpYnV0aW9uTGF5ZXJDb3VudCA9IG1hcC5hdHRyaWJ1dGlvbkNvbnRyb2wuX2VzcmlBdHRyaWJ1dGlvbkxheWVyQ291bnQgLSAxO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX3NldEdlb21ldHJ5IChnZW9tZXRyeSkge1xyXG4gIHZhciBwYXJhbXMgPSB7XHJcbiAgICBnZW9tZXRyeTogbnVsbCxcclxuICAgIGdlb21ldHJ5VHlwZTogbnVsbFxyXG4gIH07XHJcblxyXG4gIC8vIGNvbnZlcnQgYm91bmRzIHRvIGV4dGVudCBhbmQgZmluaXNoXHJcbiAgaWYgKGdlb21ldHJ5IGluc3RhbmNlb2YgTGF0TG5nQm91bmRzKSB7XHJcbiAgICAvLyBzZXQgZ2VvbWV0cnkgKyBnZW9tZXRyeVR5cGVcclxuICAgIHBhcmFtcy5nZW9tZXRyeSA9IGJvdW5kc1RvRXh0ZW50KGdlb21ldHJ5KTtcclxuICAgIHBhcmFtcy5nZW9tZXRyeVR5cGUgPSAnZXNyaUdlb21ldHJ5RW52ZWxvcGUnO1xyXG4gICAgcmV0dXJuIHBhcmFtcztcclxuICB9XHJcblxyXG4gIC8vIGNvbnZlcnQgTC5NYXJrZXIgPiBMLkxhdExuZ1xyXG4gIGlmIChnZW9tZXRyeS5nZXRMYXRMbmcpIHtcclxuICAgIGdlb21ldHJ5ID0gZ2VvbWV0cnkuZ2V0TGF0TG5nKCk7XHJcbiAgfVxyXG5cclxuICAvLyBjb252ZXJ0IEwuTGF0TG5nIHRvIGEgZ2VvanNvbiBwb2ludCBhbmQgY29udGludWU7XHJcbiAgaWYgKGdlb21ldHJ5IGluc3RhbmNlb2YgTGF0TG5nKSB7XHJcbiAgICBnZW9tZXRyeSA9IHtcclxuICAgICAgdHlwZTogJ1BvaW50JyxcclxuICAgICAgY29vcmRpbmF0ZXM6IFtnZW9tZXRyeS5sbmcsIGdlb21ldHJ5LmxhdF1cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBoYW5kbGUgTC5HZW9KU09OLCBwdWxsIG91dCB0aGUgZmlyc3QgZ2VvbWV0cnlcclxuICBpZiAoZ2VvbWV0cnkgaW5zdGFuY2VvZiBHZW9KU09OKSB7XHJcbiAgICAvLyByZWFzc2lnbiBnZW9tZXRyeSB0byB0aGUgR2VvSlNPTiB2YWx1ZSAgKHdlIGFyZSBhc3N1bWluZyB0aGF0IG9ubHkgb25lIGZlYXR1cmUgaXMgcHJlc2VudClcclxuICAgIGdlb21ldHJ5ID0gZ2VvbWV0cnkuZ2V0TGF5ZXJzKClbMF0uZmVhdHVyZS5nZW9tZXRyeTtcclxuICAgIHBhcmFtcy5nZW9tZXRyeSA9IGdlb2pzb25Ub0FyY0dJUyhnZW9tZXRyeSk7XHJcbiAgICBwYXJhbXMuZ2VvbWV0cnlUeXBlID0gZ2VvanNvblR5cGVUb0FyY0dJUyhnZW9tZXRyeS50eXBlKTtcclxuICB9XHJcblxyXG4gIC8vIEhhbmRsZSBMLlBvbHlsaW5lIGFuZCBMLlBvbHlnb25cclxuICBpZiAoZ2VvbWV0cnkudG9HZW9KU09OKSB7XHJcbiAgICBnZW9tZXRyeSA9IGdlb21ldHJ5LnRvR2VvSlNPTigpO1xyXG4gIH1cclxuXHJcbiAgLy8gaGFuZGxlIEdlb0pTT04gZmVhdHVyZSBieSBwdWxsaW5nIG91dCB0aGUgZ2VvbWV0cnlcclxuICBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gJ0ZlYXR1cmUnKSB7XHJcbiAgICAvLyBnZXQgdGhlIGdlb21ldHJ5IG9mIHRoZSBnZW9qc29uIGZlYXR1cmVcclxuICAgIGdlb21ldHJ5ID0gZ2VvbWV0cnkuZ2VvbWV0cnk7XHJcbiAgfVxyXG5cclxuICAvLyBjb25maXJtIHRoYXQgb3VyIEdlb0pTT04gaXMgYSBwb2ludCwgbGluZSBvciBwb2x5Z29uXHJcbiAgaWYgKGdlb21ldHJ5LnR5cGUgPT09ICdQb2ludCcgfHwgZ2VvbWV0cnkudHlwZSA9PT0gJ0xpbmVTdHJpbmcnIHx8IGdlb21ldHJ5LnR5cGUgPT09ICdQb2x5Z29uJyB8fCBnZW9tZXRyeS50eXBlID09PSAnTXVsdGlQb2x5Z29uJykge1xyXG4gICAgcGFyYW1zLmdlb21ldHJ5ID0gZ2VvanNvblRvQXJjR0lTKGdlb21ldHJ5KTtcclxuICAgIHBhcmFtcy5nZW9tZXRyeVR5cGUgPSBnZW9qc29uVHlwZVRvQXJjR0lTKGdlb21ldHJ5LnR5cGUpO1xyXG4gICAgcmV0dXJuIHBhcmFtcztcclxuICB9XHJcblxyXG4gIC8vIHdhcm4gdGhlIHVzZXIgaWYgd2UgaGF2bid0IGZvdW5kIGFuIGFwcHJvcHJpYXRlIG9iamVjdFxyXG4gIHdhcm4oJ2ludmFsaWQgZ2VvbWV0cnkgcGFzc2VkIHRvIHNwYXRpYWwgcXVlcnkuIFNob3VsZCBiZSBMLkxhdExuZywgTC5MYXRMbmdCb3VuZHMsIEwuTWFya2VyIG9yIGEgR2VvSlNPTiBQb2ludCwgTGluZSwgUG9seWdvbiBvciBNdWx0aVBvbHlnb24gb2JqZWN0Jyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfZ2V0QXR0cmlidXRpb25EYXRhICh1cmwsIG1hcCkge1xyXG4gIGlmIChTdXBwb3J0LmNvcnMpIHtcclxuICAgIHJlcXVlc3QodXJsLCB7fSwgVXRpbC5iaW5kKGZ1bmN0aW9uIChlcnJvciwgYXR0cmlidXRpb25zKSB7XHJcbiAgICAgIGlmIChlcnJvcikgeyByZXR1cm47IH1cclxuICAgICAgbWFwLl9lc3JpQXR0cmlidXRpb25zID0gW107XHJcbiAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgYXR0cmlidXRpb25zLmNvbnRyaWJ1dG9ycy5sZW5ndGg7IGMrKykge1xyXG4gICAgICAgIHZhciBjb250cmlidXRvciA9IGF0dHJpYnV0aW9ucy5jb250cmlidXRvcnNbY107XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udHJpYnV0b3IuY292ZXJhZ2VBcmVhcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgdmFyIGNvdmVyYWdlQXJlYSA9IGNvbnRyaWJ1dG9yLmNvdmVyYWdlQXJlYXNbaV07XHJcbiAgICAgICAgICB2YXIgc291dGhXZXN0ID0gbGF0TG5nKGNvdmVyYWdlQXJlYS5iYm94WzBdLCBjb3ZlcmFnZUFyZWEuYmJveFsxXSk7XHJcbiAgICAgICAgICB2YXIgbm9ydGhFYXN0ID0gbGF0TG5nKGNvdmVyYWdlQXJlYS5iYm94WzJdLCBjb3ZlcmFnZUFyZWEuYmJveFszXSk7XHJcbiAgICAgICAgICBtYXAuX2VzcmlBdHRyaWJ1dGlvbnMucHVzaCh7XHJcbiAgICAgICAgICAgIGF0dHJpYnV0aW9uOiBjb250cmlidXRvci5hdHRyaWJ1dGlvbixcclxuICAgICAgICAgICAgc2NvcmU6IGNvdmVyYWdlQXJlYS5zY29yZSxcclxuICAgICAgICAgICAgYm91bmRzOiBsYXRMbmdCb3VuZHMoc291dGhXZXN0LCBub3J0aEVhc3QpLFxyXG4gICAgICAgICAgICBtaW5ab29tOiBjb3ZlcmFnZUFyZWEuem9vbU1pbixcclxuICAgICAgICAgICAgbWF4Wm9vbTogY292ZXJhZ2VBcmVhLnpvb21NYXhcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgbWFwLl9lc3JpQXR0cmlidXRpb25zLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICByZXR1cm4gYi5zY29yZSAtIGEuc2NvcmU7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gcGFzcyB0aGUgc2FtZSBhcmd1bWVudCBhcyB0aGUgbWFwJ3MgJ21vdmVlbmQnIGV2ZW50XHJcbiAgICAgIHZhciBvYmogPSB7IHRhcmdldDogbWFwIH07XHJcbiAgICAgIF91cGRhdGVNYXBBdHRyaWJ1dGlvbihvYmopO1xyXG4gICAgfSwgdGhpcykpO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF91cGRhdGVNYXBBdHRyaWJ1dGlvbiAoZXZ0KSB7XHJcbiAgdmFyIG1hcCA9IGV2dC50YXJnZXQ7XHJcbiAgdmFyIG9sZEF0dHJpYnV0aW9ucyA9IG1hcC5fZXNyaUF0dHJpYnV0aW9ucztcclxuXHJcbiAgaWYgKCFtYXAgfHwgIW1hcC5hdHRyaWJ1dGlvbkNvbnRyb2wpIHJldHVybjtcclxuXHJcbiAgdmFyIGF0dHJpYnV0aW9uRWxlbWVudCA9IG1hcC5hdHRyaWJ1dGlvbkNvbnRyb2wuX2NvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcuZXNyaS1keW5hbWljLWF0dHJpYnV0aW9uJyk7XHJcblxyXG4gIGlmIChhdHRyaWJ1dGlvbkVsZW1lbnQgJiYgb2xkQXR0cmlidXRpb25zKSB7XHJcbiAgICB2YXIgbmV3QXR0cmlidXRpb25zID0gJyc7XHJcbiAgICB2YXIgYm91bmRzID0gbWFwLmdldEJvdW5kcygpO1xyXG4gICAgdmFyIHdyYXBwZWRCb3VuZHMgPSBsYXRMbmdCb3VuZHMoXHJcbiAgICAgIGJvdW5kcy5nZXRTb3V0aFdlc3QoKS53cmFwKCksXHJcbiAgICAgIGJvdW5kcy5nZXROb3J0aEVhc3QoKS53cmFwKClcclxuICAgICk7XHJcbiAgICB2YXIgem9vbSA9IG1hcC5nZXRab29tKCk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvbGRBdHRyaWJ1dGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIGF0dHJpYnV0aW9uID0gb2xkQXR0cmlidXRpb25zW2ldO1xyXG4gICAgICB2YXIgdGV4dCA9IGF0dHJpYnV0aW9uLmF0dHJpYnV0aW9uO1xyXG5cclxuICAgICAgaWYgKCFuZXdBdHRyaWJ1dGlvbnMubWF0Y2godGV4dCkgJiYgYXR0cmlidXRpb24uYm91bmRzLmludGVyc2VjdHMod3JhcHBlZEJvdW5kcykgJiYgem9vbSA+PSBhdHRyaWJ1dGlvbi5taW5ab29tICYmIHpvb20gPD0gYXR0cmlidXRpb24ubWF4Wm9vbSkge1xyXG4gICAgICAgIG5ld0F0dHJpYnV0aW9ucyArPSAoJywgJyArIHRleHQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbmV3QXR0cmlidXRpb25zID0gbmV3QXR0cmlidXRpb25zLnN1YnN0cigyKTtcclxuICAgIGF0dHJpYnV0aW9uRWxlbWVudC5pbm5lckhUTUwgPSBuZXdBdHRyaWJ1dGlvbnM7XHJcbiAgICBhdHRyaWJ1dGlvbkVsZW1lbnQuc3R5bGUubWF4V2lkdGggPSBjYWxjQXR0cmlidXRpb25XaWR0aChtYXApO1xyXG5cclxuICAgIG1hcC5maXJlKCdhdHRyaWJ1dGlvbnVwZGF0ZWQnLCB7XHJcbiAgICAgIGF0dHJpYnV0aW9uOiBuZXdBdHRyaWJ1dGlvbnNcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuLy8gZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XHJcbmV4cG9ydCB7IHdhcm4gfTtcclxuXHJcbmV4cG9ydCB2YXIgRXNyaVV0aWwgPSB7XHJcbiAgd2Fybjogd2FybixcclxuICBjbGVhblVybDogY2xlYW5VcmwsXHJcbiAgZ2V0VXJsUGFyYW1zOiBnZXRVcmxQYXJhbXMsXHJcbiAgaXNBcmNnaXNPbmxpbmU6IGlzQXJjZ2lzT25saW5lLFxyXG4gIGdlb2pzb25UeXBlVG9BcmNHSVM6IGdlb2pzb25UeXBlVG9BcmNHSVMsXHJcbiAgcmVzcG9uc2VUb0ZlYXR1cmVDb2xsZWN0aW9uOiByZXNwb25zZVRvRmVhdHVyZUNvbGxlY3Rpb24sXHJcbiAgZ2VvanNvblRvQXJjR0lTOiBnZW9qc29uVG9BcmNHSVMsXHJcbiAgYXJjZ2lzVG9HZW9KU09OOiBhcmNnaXNUb0dlb0pTT04sXHJcbiAgYm91bmRzVG9FeHRlbnQ6IGJvdW5kc1RvRXh0ZW50LFxyXG4gIGV4dGVudFRvQm91bmRzOiBleHRlbnRUb0JvdW5kcyxcclxuICBjYWxjQXR0cmlidXRpb25XaWR0aDogY2FsY0F0dHJpYnV0aW9uV2lkdGgsXHJcbiAgc2V0RXNyaUF0dHJpYnV0aW9uOiBzZXRFc3JpQXR0cmlidXRpb24sXHJcbiAgX3NldEdlb21ldHJ5OiBfc2V0R2VvbWV0cnksXHJcbiAgX2dldEF0dHJpYnV0aW9uRGF0YTogX2dldEF0dHJpYnV0aW9uRGF0YSxcclxuICBfdXBkYXRlTWFwQXR0cmlidXRpb246IF91cGRhdGVNYXBBdHRyaWJ1dGlvbixcclxuICBfZmluZElkQXR0cmlidXRlRnJvbUZlYXR1cmU6IF9maW5kSWRBdHRyaWJ1dGVGcm9tRmVhdHVyZSxcclxuICBfZmluZElkQXR0cmlidXRlRnJvbVJlc3BvbnNlOiBfZmluZElkQXR0cmlidXRlRnJvbVJlc3BvbnNlXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBFc3JpVXRpbDtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/esri-leaflet/src/Util.js\n");

/***/ }),

/***/ "./node_modules/leaflet/dist/leaflet-src.js":
/*!**************************************************!*\
  !*** ./node_modules/leaflet/dist/leaflet-src.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("/* @preserve\n * Leaflet 1.9.3, a JS library for interactive maps. https://leafletjs.com\n * (c) 2010-2022 Vladimir Agafonkin, (c) 2010-2011 CloudMade\n */\n\n(function (global, factory) {\n   true ? factory(exports) :\n  0;\n})(this, (function (exports) { 'use strict';\n\n  var version = \"1.9.3\";\n\n  /*\r\n   * @namespace Util\r\n   *\r\n   * Various utility functions, used by Leaflet internally.\r\n   */\r\n\r\n  // @function extend(dest: Object, src?: Object): Object\r\n  // Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut.\r\n  function extend(dest) {\r\n  \tvar i, j, len, src;\r\n\r\n  \tfor (j = 1, len = arguments.length; j < len; j++) {\r\n  \t\tsrc = arguments[j];\r\n  \t\tfor (i in src) {\r\n  \t\t\tdest[i] = src[i];\r\n  \t\t}\r\n  \t}\r\n  \treturn dest;\r\n  }\r\n\r\n  // @function create(proto: Object, properties?: Object): Object\r\n  // Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)\r\n  var create$2 = Object.create || (function () {\r\n  \tfunction F() {}\r\n  \treturn function (proto) {\r\n  \t\tF.prototype = proto;\r\n  \t\treturn new F();\r\n  \t};\r\n  })();\r\n\r\n  // @function bind(fn: Function, ): Function\r\n  // Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).\r\n  // Has a `L.bind()` shortcut.\r\n  function bind(fn, obj) {\r\n  \tvar slice = Array.prototype.slice;\r\n\r\n  \tif (fn.bind) {\r\n  \t\treturn fn.bind.apply(fn, slice.call(arguments, 1));\r\n  \t}\r\n\r\n  \tvar args = slice.call(arguments, 2);\r\n\r\n  \treturn function () {\r\n  \t\treturn fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);\r\n  \t};\r\n  }\r\n\r\n  // @property lastId: Number\r\n  // Last unique ID used by [`stamp()`](#util-stamp)\r\n  var lastId = 0;\r\n\r\n  // @function stamp(obj: Object): Number\r\n  // Returns the unique ID of an object, assigning it one if it doesn't have it.\r\n  function stamp(obj) {\r\n  \tif (!('_leaflet_id' in obj)) {\r\n  \t\tobj['_leaflet_id'] = ++lastId;\r\n  \t}\r\n  \treturn obj._leaflet_id;\r\n  }\r\n\r\n  // @function throttle(fn: Function, time: Number, context: Object): Function\r\n  // Returns a function which executes function `fn` with the given scope `context`\r\n  // (so that the `this` keyword refers to `context` inside `fn`'s code). The function\r\n  // `fn` will be called no more than one time per given amount of `time`. The arguments\r\n  // received by the bound function will be any arguments passed when binding the\r\n  // function, followed by any arguments passed when invoking the bound function.\r\n  // Has an `L.throttle` shortcut.\r\n  function throttle(fn, time, context) {\r\n  \tvar lock, args, wrapperFn, later;\r\n\r\n  \tlater = function () {\r\n  \t\t// reset lock and call if queued\r\n  \t\tlock = false;\r\n  \t\tif (args) {\r\n  \t\t\twrapperFn.apply(context, args);\r\n  \t\t\targs = false;\r\n  \t\t}\r\n  \t};\r\n\r\n  \twrapperFn = function () {\r\n  \t\tif (lock) {\r\n  \t\t\t// called too soon, queue to call later\r\n  \t\t\targs = arguments;\r\n\r\n  \t\t} else {\r\n  \t\t\t// call and lock until later\r\n  \t\t\tfn.apply(context, arguments);\r\n  \t\t\tsetTimeout(later, time);\r\n  \t\t\tlock = true;\r\n  \t\t}\r\n  \t};\r\n\r\n  \treturn wrapperFn;\r\n  }\r\n\r\n  // @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number\r\n  // Returns the number `num` modulo `range` in such a way so it lies within\r\n  // `range[0]` and `range[1]`. The returned value will be always smaller than\r\n  // `range[1]` unless `includeMax` is set to `true`.\r\n  function wrapNum(x, range, includeMax) {\r\n  \tvar max = range[1],\r\n  \t    min = range[0],\r\n  \t    d = max - min;\r\n  \treturn x === max && includeMax ? x : ((x - min) % d + d) % d + min;\r\n  }\r\n\r\n  // @function falseFn(): Function\r\n  // Returns a function which always returns `false`.\r\n  function falseFn() { return false; }\r\n\r\n  // @function formatNum(num: Number, precision?: Number|false): Number\r\n  // Returns the number `num` rounded with specified `precision`.\r\n  // The default `precision` value is 6 decimal places.\r\n  // `false` can be passed to skip any processing (can be useful to avoid round-off errors).\r\n  function formatNum(num, precision) {\r\n  \tif (precision === false) { return num; }\r\n  \tvar pow = Math.pow(10, precision === undefined ? 6 : precision);\r\n  \treturn Math.round(num * pow) / pow;\r\n  }\r\n\r\n  // @function trim(str: String): String\r\n  // Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)\r\n  function trim(str) {\r\n  \treturn str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, '');\r\n  }\r\n\r\n  // @function splitWords(str: String): String[]\r\n  // Trims and splits the string on whitespace and returns the array of parts.\r\n  function splitWords(str) {\r\n  \treturn trim(str).split(/\\s+/);\r\n  }\r\n\r\n  // @function setOptions(obj: Object, options: Object): Object\r\n  // Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `L.setOptions` shortcut.\r\n  function setOptions(obj, options) {\r\n  \tif (!Object.prototype.hasOwnProperty.call(obj, 'options')) {\r\n  \t\tobj.options = obj.options ? create$2(obj.options) : {};\r\n  \t}\r\n  \tfor (var i in options) {\r\n  \t\tobj.options[i] = options[i];\r\n  \t}\r\n  \treturn obj.options;\r\n  }\r\n\r\n  // @function getParamString(obj: Object, existingUrl?: String, uppercase?: Boolean): String\r\n  // Converts an object into a parameter URL string, e.g. `{a: \"foo\", b: \"bar\"}`\r\n  // translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will\r\n  // be appended at the end. If `uppercase` is `true`, the parameter names will\r\n  // be uppercased (e.g. `'?A=foo&B=bar'`)\r\n  function getParamString(obj, existingUrl, uppercase) {\r\n  \tvar params = [];\r\n  \tfor (var i in obj) {\r\n  \t\tparams.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));\r\n  \t}\r\n  \treturn ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');\r\n  }\r\n\r\n  var templateRe = /\\{ *([\\w_ -]+) *\\}/g;\r\n\r\n  // @function template(str: String, data: Object): String\r\n  // Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`\r\n  // and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string\r\n  // `('Hello foo, bar')`. You can also specify functions instead of strings for\r\n  // data values  they will be evaluated passing `data` as an argument.\r\n  function template(str, data) {\r\n  \treturn str.replace(templateRe, function (str, key) {\r\n  \t\tvar value = data[key];\r\n\r\n  \t\tif (value === undefined) {\r\n  \t\t\tthrow new Error('No value provided for variable ' + str);\r\n\r\n  \t\t} else if (typeof value === 'function') {\r\n  \t\t\tvalue = value(data);\r\n  \t\t}\r\n  \t\treturn value;\r\n  \t});\r\n  }\r\n\r\n  // @function isArray(obj): Boolean\r\n  // Compatibility polyfill for [Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)\r\n  var isArray = Array.isArray || function (obj) {\r\n  \treturn (Object.prototype.toString.call(obj) === '[object Array]');\r\n  };\r\n\r\n  // @function indexOf(array: Array, el: Object): Number\r\n  // Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)\r\n  function indexOf(array, el) {\r\n  \tfor (var i = 0; i < array.length; i++) {\r\n  \t\tif (array[i] === el) { return i; }\r\n  \t}\r\n  \treturn -1;\r\n  }\r\n\r\n  // @property emptyImageUrl: String\r\n  // Data URI string containing a base64-encoded empty GIF image.\r\n  // Used as a hack to free memory from unused images on WebKit-powered\r\n  // mobile devices (by setting image `src` to this string).\r\n  var emptyImageUrl = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';\r\n\r\n  // inspired by https://paulirish.com/2011/requestanimationframe-for-smart-animating/\r\n\r\n  function getPrefixed(name) {\r\n  \treturn window['webkit' + name] || window['moz' + name] || window['ms' + name];\r\n  }\r\n\r\n  var lastTime = 0;\r\n\r\n  // fallback for IE 7-8\r\n  function timeoutDefer(fn) {\r\n  \tvar time = +new Date(),\r\n  \t    timeToCall = Math.max(0, 16 - (time - lastTime));\r\n\r\n  \tlastTime = time + timeToCall;\r\n  \treturn window.setTimeout(fn, timeToCall);\r\n  }\r\n\r\n  var requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer;\r\n  var cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') ||\r\n  \t\tgetPrefixed('CancelRequestAnimationFrame') || function (id) { window.clearTimeout(id); };\r\n\r\n  // @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number\r\n  // Schedules `fn` to be executed when the browser repaints. `fn` is bound to\r\n  // `context` if given. When `immediate` is set, `fn` is called immediately if\r\n  // the browser doesn't have native support for\r\n  // [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),\r\n  // otherwise it's delayed. Returns a request ID that can be used to cancel the request.\r\n  function requestAnimFrame(fn, context, immediate) {\r\n  \tif (immediate && requestFn === timeoutDefer) {\r\n  \t\tfn.call(context);\r\n  \t} else {\r\n  \t\treturn requestFn.call(window, bind(fn, context));\r\n  \t}\r\n  }\r\n\r\n  // @function cancelAnimFrame(id: Number): undefined\r\n  // Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).\r\n  function cancelAnimFrame(id) {\r\n  \tif (id) {\r\n  \t\tcancelFn.call(window, id);\r\n  \t}\r\n  }\n\n  var Util = {\n    __proto__: null,\n    extend: extend,\n    create: create$2,\n    bind: bind,\n    get lastId () { return lastId; },\n    stamp: stamp,\n    throttle: throttle,\n    wrapNum: wrapNum,\n    falseFn: falseFn,\n    formatNum: formatNum,\n    trim: trim,\n    splitWords: splitWords,\n    setOptions: setOptions,\n    getParamString: getParamString,\n    template: template,\n    isArray: isArray,\n    indexOf: indexOf,\n    emptyImageUrl: emptyImageUrl,\n    requestFn: requestFn,\n    cancelFn: cancelFn,\n    requestAnimFrame: requestAnimFrame,\n    cancelAnimFrame: cancelAnimFrame\n  };\n\n  // @class Class\r\n  // @aka L.Class\r\n\r\n  // @section\r\n  // @uninheritable\r\n\r\n  // Thanks to John Resig and Dean Edwards for inspiration!\r\n\r\n  function Class() {}\r\n\r\n  Class.extend = function (props) {\r\n\r\n  \t// @function extend(props: Object): Function\r\n  \t// [Extends the current class](#class-inheritance) given the properties to be included.\r\n  \t// Returns a Javascript function that is a class constructor (to be called with `new`).\r\n  \tvar NewClass = function () {\r\n\r\n  \t\tsetOptions(this);\r\n\r\n  \t\t// call the constructor\r\n  \t\tif (this.initialize) {\r\n  \t\t\tthis.initialize.apply(this, arguments);\r\n  \t\t}\r\n\r\n  \t\t// call all constructor hooks\r\n  \t\tthis.callInitHooks();\r\n  \t};\r\n\r\n  \tvar parentProto = NewClass.__super__ = this.prototype;\r\n\r\n  \tvar proto = create$2(parentProto);\r\n  \tproto.constructor = NewClass;\r\n\r\n  \tNewClass.prototype = proto;\r\n\r\n  \t// inherit parent's statics\r\n  \tfor (var i in this) {\r\n  \t\tif (Object.prototype.hasOwnProperty.call(this, i) && i !== 'prototype' && i !== '__super__') {\r\n  \t\t\tNewClass[i] = this[i];\r\n  \t\t}\r\n  \t}\r\n\r\n  \t// mix static properties into the class\r\n  \tif (props.statics) {\r\n  \t\textend(NewClass, props.statics);\r\n  \t}\r\n\r\n  \t// mix includes into the prototype\r\n  \tif (props.includes) {\r\n  \t\tcheckDeprecatedMixinEvents(props.includes);\r\n  \t\textend.apply(null, [proto].concat(props.includes));\r\n  \t}\r\n\r\n  \t// mix given properties into the prototype\r\n  \textend(proto, props);\r\n  \tdelete proto.statics;\r\n  \tdelete proto.includes;\r\n\r\n  \t// merge options\r\n  \tif (proto.options) {\r\n  \t\tproto.options = parentProto.options ? create$2(parentProto.options) : {};\r\n  \t\textend(proto.options, props.options);\r\n  \t}\r\n\r\n  \tproto._initHooks = [];\r\n\r\n  \t// add method for calling all hooks\r\n  \tproto.callInitHooks = function () {\r\n\r\n  \t\tif (this._initHooksCalled) { return; }\r\n\r\n  \t\tif (parentProto.callInitHooks) {\r\n  \t\t\tparentProto.callInitHooks.call(this);\r\n  \t\t}\r\n\r\n  \t\tthis._initHooksCalled = true;\r\n\r\n  \t\tfor (var i = 0, len = proto._initHooks.length; i < len; i++) {\r\n  \t\t\tproto._initHooks[i].call(this);\r\n  \t\t}\r\n  \t};\r\n\r\n  \treturn NewClass;\r\n  };\r\n\r\n\r\n  // @function include(properties: Object): this\r\n  // [Includes a mixin](#class-includes) into the current class.\r\n  Class.include = function (props) {\r\n  \tvar parentOptions = this.prototype.options;\r\n  \textend(this.prototype, props);\r\n  \tif (props.options) {\r\n  \t\tthis.prototype.options = parentOptions;\r\n  \t\tthis.mergeOptions(props.options);\r\n  \t}\r\n  \treturn this;\r\n  };\r\n\r\n  // @function mergeOptions(options: Object): this\r\n  // [Merges `options`](#class-options) into the defaults of the class.\r\n  Class.mergeOptions = function (options) {\r\n  \textend(this.prototype.options, options);\r\n  \treturn this;\r\n  };\r\n\r\n  // @function addInitHook(fn: Function): this\r\n  // Adds a [constructor hook](#class-constructor-hooks) to the class.\r\n  Class.addInitHook = function (fn) { // (Function) || (String, args...)\r\n  \tvar args = Array.prototype.slice.call(arguments, 1);\r\n\r\n  \tvar init = typeof fn === 'function' ? fn : function () {\r\n  \t\tthis[fn].apply(this, args);\r\n  \t};\r\n\r\n  \tthis.prototype._initHooks = this.prototype._initHooks || [];\r\n  \tthis.prototype._initHooks.push(init);\r\n  \treturn this;\r\n  };\r\n\r\n  function checkDeprecatedMixinEvents(includes) {\r\n  \t/* global L: true */\r\n  \tif (typeof L === 'undefined' || !L || !L.Mixin) { return; }\r\n\r\n  \tincludes = isArray(includes) ? includes : [includes];\r\n\r\n  \tfor (var i = 0; i < includes.length; i++) {\r\n  \t\tif (includes[i] === L.Mixin.Events) {\r\n  \t\t\tconsole.warn('Deprecated include of L.Mixin.Events: ' +\r\n  \t\t\t\t'this property will be removed in future releases, ' +\r\n  \t\t\t\t'please inherit from L.Evented instead.', new Error().stack);\r\n  \t\t}\r\n  \t}\r\n  }\n\n  /*\r\n   * @class Evented\r\n   * @aka L.Evented\r\n   * @inherits Class\r\n   *\r\n   * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * map.on('click', function(e) {\r\n   * \talert(e.latlng);\r\n   * } );\r\n   * ```\r\n   *\r\n   * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:\r\n   *\r\n   * ```js\r\n   * function onClick(e) { ... }\r\n   *\r\n   * map.on('click', onClick);\r\n   * map.off('click', onClick);\r\n   * ```\r\n   */\r\n\r\n  var Events = {\r\n  \t/* @method on(type: String, fn: Function, context?: Object): this\r\n  \t * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).\r\n  \t *\r\n  \t * @alternative\r\n  \t * @method on(eventMap: Object): this\r\n  \t * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\r\n  \t */\r\n  \ton: function (types, fn, context) {\r\n\r\n  \t\t// types can be a map of types/handlers\r\n  \t\tif (typeof types === 'object') {\r\n  \t\t\tfor (var type in types) {\r\n  \t\t\t\t// we don't process space-separated events here for performance;\r\n  \t\t\t\t// it's a hot path since Layer uses the on(obj) syntax\r\n  \t\t\t\tthis._on(type, types[type], fn);\r\n  \t\t\t}\r\n\r\n  \t\t} else {\r\n  \t\t\t// types can be a string of space-separated words\r\n  \t\t\ttypes = splitWords(types);\r\n\r\n  \t\t\tfor (var i = 0, len = types.length; i < len; i++) {\r\n  \t\t\t\tthis._on(types[i], fn, context);\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t/* @method off(type: String, fn?: Function, context?: Object): this\r\n  \t * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.\r\n  \t *\r\n  \t * @alternative\r\n  \t * @method off(eventMap: Object): this\r\n  \t * Removes a set of type/listener pairs.\r\n  \t *\r\n  \t * @alternative\r\n  \t * @method off: this\r\n  \t * Removes all listeners to all events on the object. This includes implicitly attached events.\r\n  \t */\r\n  \toff: function (types, fn, context) {\r\n\r\n  \t\tif (!arguments.length) {\r\n  \t\t\t// clear all listeners if called without arguments\r\n  \t\t\tdelete this._events;\r\n\r\n  \t\t} else if (typeof types === 'object') {\r\n  \t\t\tfor (var type in types) {\r\n  \t\t\t\tthis._off(type, types[type], fn);\r\n  \t\t\t}\r\n\r\n  \t\t} else {\r\n  \t\t\ttypes = splitWords(types);\r\n\r\n  \t\t\tvar removeAll = arguments.length === 1;\r\n  \t\t\tfor (var i = 0, len = types.length; i < len; i++) {\r\n  \t\t\t\tif (removeAll) {\r\n  \t\t\t\t\tthis._off(types[i]);\r\n  \t\t\t\t} else {\r\n  \t\t\t\t\tthis._off(types[i], fn, context);\r\n  \t\t\t\t}\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// attach listener (without syntactic sugar now)\r\n  \t_on: function (type, fn, context, _once) {\r\n  \t\tif (typeof fn !== 'function') {\r\n  \t\t\tconsole.warn('wrong listener type: ' + typeof fn);\r\n  \t\t\treturn;\r\n  \t\t}\r\n\r\n  \t\t// check if fn already there\r\n  \t\tif (this._listens(type, fn, context) !== false) {\r\n  \t\t\treturn;\r\n  \t\t}\r\n\r\n  \t\tif (context === this) {\r\n  \t\t\t// Less memory footprint.\r\n  \t\t\tcontext = undefined;\r\n  \t\t}\r\n\r\n  \t\tvar newListener = {fn: fn, ctx: context};\r\n  \t\tif (_once) {\r\n  \t\t\tnewListener.once = true;\r\n  \t\t}\r\n\r\n  \t\tthis._events = this._events || {};\r\n  \t\tthis._events[type] = this._events[type] || [];\r\n  \t\tthis._events[type].push(newListener);\r\n  \t},\r\n\r\n  \t_off: function (type, fn, context) {\r\n  \t\tvar listeners,\r\n  \t\t    i,\r\n  \t\t    len;\r\n\r\n  \t\tif (!this._events) {\r\n  \t\t\treturn;\r\n  \t\t}\r\n\r\n  \t\tlisteners = this._events[type];\r\n  \t\tif (!listeners) {\r\n  \t\t\treturn;\r\n  \t\t}\r\n\r\n  \t\tif (arguments.length === 1) { // remove all\r\n  \t\t\tif (this._firingCount) {\r\n  \t\t\t\t// Set all removed listeners to noop\r\n  \t\t\t\t// so they are not called if remove happens in fire\r\n  \t\t\t\tfor (i = 0, len = listeners.length; i < len; i++) {\r\n  \t\t\t\t\tlisteners[i].fn = falseFn;\r\n  \t\t\t\t}\r\n  \t\t\t}\r\n  \t\t\t// clear all listeners for a type if function isn't specified\r\n  \t\t\tdelete this._events[type];\r\n  \t\t\treturn;\r\n  \t\t}\r\n\r\n  \t\tif (typeof fn !== 'function') {\r\n  \t\t\tconsole.warn('wrong listener type: ' + typeof fn);\r\n  \t\t\treturn;\r\n  \t\t}\r\n\r\n  \t\t// find fn and remove it\r\n  \t\tvar index = this._listens(type, fn, context);\r\n  \t\tif (index !== false) {\r\n  \t\t\tvar listener = listeners[index];\r\n  \t\t\tif (this._firingCount) {\r\n  \t\t\t\t// set the removed listener to noop so that's not called if remove happens in fire\r\n  \t\t\t\tlistener.fn = falseFn;\r\n\r\n  \t\t\t\t/* copy array in case events are being fired */\r\n  \t\t\t\tthis._events[type] = listeners = listeners.slice();\r\n  \t\t\t}\r\n  \t\t\tlisteners.splice(index, 1);\r\n  \t\t}\r\n  \t},\r\n\r\n  \t// @method fire(type: String, data?: Object, propagate?: Boolean): this\r\n  \t// Fires an event of the specified type. You can optionally provide a data\r\n  \t// object  the first argument of the listener function will contain its\r\n  \t// properties. The event can optionally be propagated to event parents.\r\n  \tfire: function (type, data, propagate) {\r\n  \t\tif (!this.listens(type, propagate)) { return this; }\r\n\r\n  \t\tvar event = extend({}, data, {\r\n  \t\t\ttype: type,\r\n  \t\t\ttarget: this,\r\n  \t\t\tsourceTarget: data && data.sourceTarget || this\r\n  \t\t});\r\n\r\n  \t\tif (this._events) {\r\n  \t\t\tvar listeners = this._events[type];\r\n  \t\t\tif (listeners) {\r\n  \t\t\t\tthis._firingCount = (this._firingCount + 1) || 1;\r\n  \t\t\t\tfor (var i = 0, len = listeners.length; i < len; i++) {\r\n  \t\t\t\t\tvar l = listeners[i];\r\n  \t\t\t\t\t// off overwrites l.fn, so we need to copy fn to a var\r\n  \t\t\t\t\tvar fn = l.fn;\r\n  \t\t\t\t\tif (l.once) {\r\n  \t\t\t\t\t\tthis.off(type, fn, l.ctx);\r\n  \t\t\t\t\t}\r\n  \t\t\t\t\tfn.call(l.ctx || this, event);\r\n  \t\t\t\t}\r\n\r\n  \t\t\t\tthis._firingCount--;\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\tif (propagate) {\r\n  \t\t\t// propagate the event to parents (set with addEventParent)\r\n  \t\t\tthis._propagateEvent(event);\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method listens(type: String, propagate?: Boolean): Boolean\r\n  \t// @method listens(type: String, fn: Function, context?: Object, propagate?: Boolean): Boolean\r\n  \t// Returns `true` if a particular event type has any listeners attached to it.\r\n  \t// The verification can optionally be propagated, it will return `true` if parents have the listener attached to it.\r\n  \tlistens: function (type, fn, context, propagate) {\r\n  \t\tif (typeof type !== 'string') {\r\n  \t\t\tconsole.warn('\"string\" type argument expected');\r\n  \t\t}\r\n\r\n  \t\t// we don't overwrite the input `fn` value, because we need to use it for propagation\r\n  \t\tvar _fn = fn;\r\n  \t\tif (typeof fn !== 'function') {\r\n  \t\t\tpropagate = !!fn;\r\n  \t\t\t_fn = undefined;\r\n  \t\t\tcontext = undefined;\r\n  \t\t}\r\n\r\n  \t\tvar listeners = this._events && this._events[type];\r\n  \t\tif (listeners && listeners.length) {\r\n  \t\t\tif (this._listens(type, _fn, context) !== false) {\r\n  \t\t\t\treturn true;\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\tif (propagate) {\r\n  \t\t\t// also check parents for listeners if event propagates\r\n  \t\t\tfor (var id in this._eventParents) {\r\n  \t\t\t\tif (this._eventParents[id].listens(type, fn, context, propagate)) { return true; }\r\n  \t\t\t}\r\n  \t\t}\r\n  \t\treturn false;\r\n  \t},\r\n\r\n  \t// returns the index (number) or false\r\n  \t_listens: function (type, fn, context) {\r\n  \t\tif (!this._events) {\r\n  \t\t\treturn false;\r\n  \t\t}\r\n\r\n  \t\tvar listeners = this._events[type] || [];\r\n  \t\tif (!fn) {\r\n  \t\t\treturn !!listeners.length;\r\n  \t\t}\r\n\r\n  \t\tif (context === this) {\r\n  \t\t\t// Less memory footprint.\r\n  \t\t\tcontext = undefined;\r\n  \t\t}\r\n\r\n  \t\tfor (var i = 0, len = listeners.length; i < len; i++) {\r\n  \t\t\tif (listeners[i].fn === fn && listeners[i].ctx === context) {\r\n  \t\t\t\treturn i;\r\n  \t\t\t}\r\n  \t\t}\r\n  \t\treturn false;\r\n\r\n  \t},\r\n\r\n  \t// @method once(): this\r\n  \t// Behaves as [`on()`](#evented-on), except the listener will only get fired once and then removed.\r\n  \tonce: function (types, fn, context) {\r\n\r\n  \t\t// types can be a map of types/handlers\r\n  \t\tif (typeof types === 'object') {\r\n  \t\t\tfor (var type in types) {\r\n  \t\t\t\t// we don't process space-separated events here for performance;\r\n  \t\t\t\t// it's a hot path since Layer uses the on(obj) syntax\r\n  \t\t\t\tthis._on(type, types[type], fn, true);\r\n  \t\t\t}\r\n\r\n  \t\t} else {\r\n  \t\t\t// types can be a string of space-separated words\r\n  \t\t\ttypes = splitWords(types);\r\n\r\n  \t\t\tfor (var i = 0, len = types.length; i < len; i++) {\r\n  \t\t\t\tthis._on(types[i], fn, context, true);\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method addEventParent(obj: Evented): this\r\n  \t// Adds an event parent - an `Evented` that will receive propagated events\r\n  \taddEventParent: function (obj) {\r\n  \t\tthis._eventParents = this._eventParents || {};\r\n  \t\tthis._eventParents[stamp(obj)] = obj;\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method removeEventParent(obj: Evented): this\r\n  \t// Removes an event parent, so it will stop receiving propagated events\r\n  \tremoveEventParent: function (obj) {\r\n  \t\tif (this._eventParents) {\r\n  \t\t\tdelete this._eventParents[stamp(obj)];\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t_propagateEvent: function (e) {\r\n  \t\tfor (var id in this._eventParents) {\r\n  \t\t\tthis._eventParents[id].fire(e.type, extend({\r\n  \t\t\t\tlayer: e.target,\r\n  \t\t\t\tpropagatedFrom: e.target\r\n  \t\t\t}, e), true);\r\n  \t\t}\r\n  \t}\r\n  };\r\n\r\n  // aliases; we should ditch those eventually\r\n\r\n  // @method addEventListener(): this\r\n  // Alias to [`on()`](#evented-on)\r\n  Events.addEventListener = Events.on;\r\n\r\n  // @method removeEventListener(): this\r\n  // Alias to [`off()`](#evented-off)\r\n\r\n  // @method clearAllEventListeners(): this\r\n  // Alias to [`off()`](#evented-off)\r\n  Events.removeEventListener = Events.clearAllEventListeners = Events.off;\r\n\r\n  // @method addOneTimeEventListener(): this\r\n  // Alias to [`once()`](#evented-once)\r\n  Events.addOneTimeEventListener = Events.once;\r\n\r\n  // @method fireEvent(): this\r\n  // Alias to [`fire()`](#evented-fire)\r\n  Events.fireEvent = Events.fire;\r\n\r\n  // @method hasEventListeners(): Boolean\r\n  // Alias to [`listens()`](#evented-listens)\r\n  Events.hasEventListeners = Events.listens;\r\n\r\n  var Evented = Class.extend(Events);\n\n  /*\r\n   * @class Point\r\n   * @aka L.Point\r\n   *\r\n   * Represents a point with `x` and `y` coordinates in pixels.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var point = L.point(200, 300);\r\n   * ```\r\n   *\r\n   * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:\r\n   *\r\n   * ```js\r\n   * map.panBy([200, 300]);\r\n   * map.panBy(L.point(200, 300));\r\n   * ```\r\n   *\r\n   * Note that `Point` does not inherit from Leaflet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\r\n\r\n  function Point(x, y, round) {\r\n  \t// @property x: Number; The `x` coordinate of the point\r\n  \tthis.x = (round ? Math.round(x) : x);\r\n  \t// @property y: Number; The `y` coordinate of the point\r\n  \tthis.y = (round ? Math.round(y) : y);\r\n  }\r\n\r\n  var trunc = Math.trunc || function (v) {\r\n  \treturn v > 0 ? Math.floor(v) : Math.ceil(v);\r\n  };\r\n\r\n  Point.prototype = {\r\n\r\n  \t// @method clone(): Point\r\n  \t// Returns a copy of the current point.\r\n  \tclone: function () {\r\n  \t\treturn new Point(this.x, this.y);\r\n  \t},\r\n\r\n  \t// @method add(otherPoint: Point): Point\r\n  \t// Returns the result of addition of the current and the given points.\r\n  \tadd: function (point) {\r\n  \t\t// non-destructive, returns a new point\r\n  \t\treturn this.clone()._add(toPoint(point));\r\n  \t},\r\n\r\n  \t_add: function (point) {\r\n  \t\t// destructive, used directly for performance in situations where it's safe to modify existing point\r\n  \t\tthis.x += point.x;\r\n  \t\tthis.y += point.y;\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method subtract(otherPoint: Point): Point\r\n  \t// Returns the result of subtraction of the given point from the current.\r\n  \tsubtract: function (point) {\r\n  \t\treturn this.clone()._subtract(toPoint(point));\r\n  \t},\r\n\r\n  \t_subtract: function (point) {\r\n  \t\tthis.x -= point.x;\r\n  \t\tthis.y -= point.y;\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method divideBy(num: Number): Point\r\n  \t// Returns the result of division of the current point by the given number.\r\n  \tdivideBy: function (num) {\r\n  \t\treturn this.clone()._divideBy(num);\r\n  \t},\r\n\r\n  \t_divideBy: function (num) {\r\n  \t\tthis.x /= num;\r\n  \t\tthis.y /= num;\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method multiplyBy(num: Number): Point\r\n  \t// Returns the result of multiplication of the current point by the given number.\r\n  \tmultiplyBy: function (num) {\r\n  \t\treturn this.clone()._multiplyBy(num);\r\n  \t},\r\n\r\n  \t_multiplyBy: function (num) {\r\n  \t\tthis.x *= num;\r\n  \t\tthis.y *= num;\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method scaleBy(scale: Point): Point\r\n  \t// Multiply each coordinate of the current point by each coordinate of\r\n  \t// `scale`. In linear algebra terms, multiply the point by the\r\n  \t// [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)\r\n  \t// defined by `scale`.\r\n  \tscaleBy: function (point) {\r\n  \t\treturn new Point(this.x * point.x, this.y * point.y);\r\n  \t},\r\n\r\n  \t// @method unscaleBy(scale: Point): Point\r\n  \t// Inverse of `scaleBy`. Divide each coordinate of the current point by\r\n  \t// each coordinate of `scale`.\r\n  \tunscaleBy: function (point) {\r\n  \t\treturn new Point(this.x / point.x, this.y / point.y);\r\n  \t},\r\n\r\n  \t// @method round(): Point\r\n  \t// Returns a copy of the current point with rounded coordinates.\r\n  \tround: function () {\r\n  \t\treturn this.clone()._round();\r\n  \t},\r\n\r\n  \t_round: function () {\r\n  \t\tthis.x = Math.round(this.x);\r\n  \t\tthis.y = Math.round(this.y);\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method floor(): Point\r\n  \t// Returns a copy of the current point with floored coordinates (rounded down).\r\n  \tfloor: function () {\r\n  \t\treturn this.clone()._floor();\r\n  \t},\r\n\r\n  \t_floor: function () {\r\n  \t\tthis.x = Math.floor(this.x);\r\n  \t\tthis.y = Math.floor(this.y);\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method ceil(): Point\r\n  \t// Returns a copy of the current point with ceiled coordinates (rounded up).\r\n  \tceil: function () {\r\n  \t\treturn this.clone()._ceil();\r\n  \t},\r\n\r\n  \t_ceil: function () {\r\n  \t\tthis.x = Math.ceil(this.x);\r\n  \t\tthis.y = Math.ceil(this.y);\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method trunc(): Point\r\n  \t// Returns a copy of the current point with truncated coordinates (rounded towards zero).\r\n  \ttrunc: function () {\r\n  \t\treturn this.clone()._trunc();\r\n  \t},\r\n\r\n  \t_trunc: function () {\r\n  \t\tthis.x = trunc(this.x);\r\n  \t\tthis.y = trunc(this.y);\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method distanceTo(otherPoint: Point): Number\r\n  \t// Returns the cartesian distance between the current and the given points.\r\n  \tdistanceTo: function (point) {\r\n  \t\tpoint = toPoint(point);\r\n\r\n  \t\tvar x = point.x - this.x,\r\n  \t\t    y = point.y - this.y;\r\n\r\n  \t\treturn Math.sqrt(x * x + y * y);\r\n  \t},\r\n\r\n  \t// @method equals(otherPoint: Point): Boolean\r\n  \t// Returns `true` if the given point has the same coordinates.\r\n  \tequals: function (point) {\r\n  \t\tpoint = toPoint(point);\r\n\r\n  \t\treturn point.x === this.x &&\r\n  \t\t       point.y === this.y;\r\n  \t},\r\n\r\n  \t// @method contains(otherPoint: Point): Boolean\r\n  \t// Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).\r\n  \tcontains: function (point) {\r\n  \t\tpoint = toPoint(point);\r\n\r\n  \t\treturn Math.abs(point.x) <= Math.abs(this.x) &&\r\n  \t\t       Math.abs(point.y) <= Math.abs(this.y);\r\n  \t},\r\n\r\n  \t// @method toString(): String\r\n  \t// Returns a string representation of the point for debugging purposes.\r\n  \ttoString: function () {\r\n  \t\treturn 'Point(' +\r\n  \t\t        formatNum(this.x) + ', ' +\r\n  \t\t        formatNum(this.y) + ')';\r\n  \t}\r\n  };\r\n\r\n  // @factory L.point(x: Number, y: Number, round?: Boolean)\r\n  // Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.\r\n\r\n  // @alternative\r\n  // @factory L.point(coords: Number[])\r\n  // Expects an array of the form `[x, y]` instead.\r\n\r\n  // @alternative\r\n  // @factory L.point(coords: Object)\r\n  // Expects a plain object of the form `{x: Number, y: Number}` instead.\r\n  function toPoint(x, y, round) {\r\n  \tif (x instanceof Point) {\r\n  \t\treturn x;\r\n  \t}\r\n  \tif (isArray(x)) {\r\n  \t\treturn new Point(x[0], x[1]);\r\n  \t}\r\n  \tif (x === undefined || x === null) {\r\n  \t\treturn x;\r\n  \t}\r\n  \tif (typeof x === 'object' && 'x' in x && 'y' in x) {\r\n  \t\treturn new Point(x.x, x.y);\r\n  \t}\r\n  \treturn new Point(x, y, round);\r\n  }\n\n  /*\r\n   * @class Bounds\r\n   * @aka L.Bounds\r\n   *\r\n   * Represents a rectangular area in pixel coordinates.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var p1 = L.point(10, 10),\r\n   * p2 = L.point(40, 60),\r\n   * bounds = L.bounds(p1, p2);\r\n   * ```\r\n   *\r\n   * All Leaflet methods that accept `Bounds` objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:\r\n   *\r\n   * ```js\r\n   * otherBounds.intersects([[10, 10], [40, 60]]);\r\n   * ```\r\n   *\r\n   * Note that `Bounds` does not inherit from Leaflet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\r\n\r\n  function Bounds(a, b) {\r\n  \tif (!a) { return; }\r\n\r\n  \tvar points = b ? [a, b] : a;\r\n\r\n  \tfor (var i = 0, len = points.length; i < len; i++) {\r\n  \t\tthis.extend(points[i]);\r\n  \t}\r\n  }\r\n\r\n  Bounds.prototype = {\r\n  \t// @method extend(point: Point): this\r\n  \t// Extends the bounds to contain the given point.\r\n\r\n  \t// @alternative\r\n  \t// @method extend(otherBounds: Bounds): this\r\n  \t// Extend the bounds to contain the given bounds\r\n  \textend: function (obj) {\r\n  \t\tvar min2, max2;\r\n  \t\tif (!obj) { return this; }\r\n\r\n  \t\tif (obj instanceof Point || typeof obj[0] === 'number' || 'x' in obj) {\r\n  \t\t\tmin2 = max2 = toPoint(obj);\r\n  \t\t} else {\r\n  \t\t\tobj = toBounds(obj);\r\n  \t\t\tmin2 = obj.min;\r\n  \t\t\tmax2 = obj.max;\r\n\r\n  \t\t\tif (!min2 || !max2) { return this; }\r\n  \t\t}\r\n\r\n  \t\t// @property min: Point\r\n  \t\t// The top left corner of the rectangle.\r\n  \t\t// @property max: Point\r\n  \t\t// The bottom right corner of the rectangle.\r\n  \t\tif (!this.min && !this.max) {\r\n  \t\t\tthis.min = min2.clone();\r\n  \t\t\tthis.max = max2.clone();\r\n  \t\t} else {\r\n  \t\t\tthis.min.x = Math.min(min2.x, this.min.x);\r\n  \t\t\tthis.max.x = Math.max(max2.x, this.max.x);\r\n  \t\t\tthis.min.y = Math.min(min2.y, this.min.y);\r\n  \t\t\tthis.max.y = Math.max(max2.y, this.max.y);\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method getCenter(round?: Boolean): Point\r\n  \t// Returns the center point of the bounds.\r\n  \tgetCenter: function (round) {\r\n  \t\treturn toPoint(\r\n  \t\t        (this.min.x + this.max.x) / 2,\r\n  \t\t        (this.min.y + this.max.y) / 2, round);\r\n  \t},\r\n\r\n  \t// @method getBottomLeft(): Point\r\n  \t// Returns the bottom-left point of the bounds.\r\n  \tgetBottomLeft: function () {\r\n  \t\treturn toPoint(this.min.x, this.max.y);\r\n  \t},\r\n\r\n  \t// @method getTopRight(): Point\r\n  \t// Returns the top-right point of the bounds.\r\n  \tgetTopRight: function () { // -> Point\r\n  \t\treturn toPoint(this.max.x, this.min.y);\r\n  \t},\r\n\r\n  \t// @method getTopLeft(): Point\r\n  \t// Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).\r\n  \tgetTopLeft: function () {\r\n  \t\treturn this.min; // left, top\r\n  \t},\r\n\r\n  \t// @method getBottomRight(): Point\r\n  \t// Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).\r\n  \tgetBottomRight: function () {\r\n  \t\treturn this.max; // right, bottom\r\n  \t},\r\n\r\n  \t// @method getSize(): Point\r\n  \t// Returns the size of the given bounds\r\n  \tgetSize: function () {\r\n  \t\treturn this.max.subtract(this.min);\r\n  \t},\r\n\r\n  \t// @method contains(otherBounds: Bounds): Boolean\r\n  \t// Returns `true` if the rectangle contains the given one.\r\n  \t// @alternative\r\n  \t// @method contains(point: Point): Boolean\r\n  \t// Returns `true` if the rectangle contains the given point.\r\n  \tcontains: function (obj) {\r\n  \t\tvar min, max;\r\n\r\n  \t\tif (typeof obj[0] === 'number' || obj instanceof Point) {\r\n  \t\t\tobj = toPoint(obj);\r\n  \t\t} else {\r\n  \t\t\tobj = toBounds(obj);\r\n  \t\t}\r\n\r\n  \t\tif (obj instanceof Bounds) {\r\n  \t\t\tmin = obj.min;\r\n  \t\t\tmax = obj.max;\r\n  \t\t} else {\r\n  \t\t\tmin = max = obj;\r\n  \t\t}\r\n\r\n  \t\treturn (min.x >= this.min.x) &&\r\n  \t\t       (max.x <= this.max.x) &&\r\n  \t\t       (min.y >= this.min.y) &&\r\n  \t\t       (max.y <= this.max.y);\r\n  \t},\r\n\r\n  \t// @method intersects(otherBounds: Bounds): Boolean\r\n  \t// Returns `true` if the rectangle intersects the given bounds. Two bounds\r\n  \t// intersect if they have at least one point in common.\r\n  \tintersects: function (bounds) { // (Bounds) -> Boolean\r\n  \t\tbounds = toBounds(bounds);\r\n\r\n  \t\tvar min = this.min,\r\n  \t\t    max = this.max,\r\n  \t\t    min2 = bounds.min,\r\n  \t\t    max2 = bounds.max,\r\n  \t\t    xIntersects = (max2.x >= min.x) && (min2.x <= max.x),\r\n  \t\t    yIntersects = (max2.y >= min.y) && (min2.y <= max.y);\r\n\r\n  \t\treturn xIntersects && yIntersects;\r\n  \t},\r\n\r\n  \t// @method overlaps(otherBounds: Bounds): Boolean\r\n  \t// Returns `true` if the rectangle overlaps the given bounds. Two bounds\r\n  \t// overlap if their intersection is an area.\r\n  \toverlaps: function (bounds) { // (Bounds) -> Boolean\r\n  \t\tbounds = toBounds(bounds);\r\n\r\n  \t\tvar min = this.min,\r\n  \t\t    max = this.max,\r\n  \t\t    min2 = bounds.min,\r\n  \t\t    max2 = bounds.max,\r\n  \t\t    xOverlaps = (max2.x > min.x) && (min2.x < max.x),\r\n  \t\t    yOverlaps = (max2.y > min.y) && (min2.y < max.y);\r\n\r\n  \t\treturn xOverlaps && yOverlaps;\r\n  \t},\r\n\r\n  \t// @method isValid(): Boolean\r\n  \t// Returns `true` if the bounds are properly initialized.\r\n  \tisValid: function () {\r\n  \t\treturn !!(this.min && this.max);\r\n  \t},\r\n\r\n\r\n  \t// @method pad(bufferRatio: Number): Bounds\r\n  \t// Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.\r\n  \t// For example, a ratio of 0.5 extends the bounds by 50% in each direction.\r\n  \t// Negative values will retract the bounds.\r\n  \tpad: function (bufferRatio) {\r\n  \t\tvar min = this.min,\r\n  \t\tmax = this.max,\r\n  \t\theightBuffer = Math.abs(min.x - max.x) * bufferRatio,\r\n  \t\twidthBuffer = Math.abs(min.y - max.y) * bufferRatio;\r\n\r\n\r\n  \t\treturn toBounds(\r\n  \t\t\ttoPoint(min.x - heightBuffer, min.y - widthBuffer),\r\n  \t\t\ttoPoint(max.x + heightBuffer, max.y + widthBuffer));\r\n  \t},\r\n\r\n\r\n  \t// @method equals(otherBounds: Bounds): Boolean\r\n  \t// Returns `true` if the rectangle is equivalent to the given bounds.\r\n  \tequals: function (bounds) {\r\n  \t\tif (!bounds) { return false; }\r\n\r\n  \t\tbounds = toBounds(bounds);\r\n\r\n  \t\treturn this.min.equals(bounds.getTopLeft()) &&\r\n  \t\t\tthis.max.equals(bounds.getBottomRight());\r\n  \t},\r\n  };\r\n\r\n\r\n  // @factory L.bounds(corner1: Point, corner2: Point)\r\n  // Creates a Bounds object from two corners coordinate pairs.\r\n  // @alternative\r\n  // @factory L.bounds(points: Point[])\r\n  // Creates a Bounds object from the given array of points.\r\n  function toBounds(a, b) {\r\n  \tif (!a || a instanceof Bounds) {\r\n  \t\treturn a;\r\n  \t}\r\n  \treturn new Bounds(a, b);\r\n  }\n\n  /*\r\n   * @class LatLngBounds\r\n   * @aka L.LatLngBounds\r\n   *\r\n   * Represents a rectangular geographical area on a map.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var corner1 = L.latLng(40.712, -74.227),\r\n   * corner2 = L.latLng(40.774, -74.125),\r\n   * bounds = L.latLngBounds(corner1, corner2);\r\n   * ```\r\n   *\r\n   * All Leaflet methods that accept LatLngBounds objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:\r\n   *\r\n   * ```js\r\n   * map.fitBounds([\r\n   * \t[40.712, -74.227],\r\n   * \t[40.774, -74.125]\r\n   * ]);\r\n   * ```\r\n   *\r\n   * Caution: if the area crosses the antimeridian (often confused with the International Date Line), you must specify corners _outside_ the [-180, 180] degrees longitude range.\r\n   *\r\n   * Note that `LatLngBounds` does not inherit from Leaflet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\r\n\r\n  function LatLngBounds(corner1, corner2) { // (LatLng, LatLng) or (LatLng[])\r\n  \tif (!corner1) { return; }\r\n\r\n  \tvar latlngs = corner2 ? [corner1, corner2] : corner1;\r\n\r\n  \tfor (var i = 0, len = latlngs.length; i < len; i++) {\r\n  \t\tthis.extend(latlngs[i]);\r\n  \t}\r\n  }\r\n\r\n  LatLngBounds.prototype = {\r\n\r\n  \t// @method extend(latlng: LatLng): this\r\n  \t// Extend the bounds to contain the given point\r\n\r\n  \t// @alternative\r\n  \t// @method extend(otherBounds: LatLngBounds): this\r\n  \t// Extend the bounds to contain the given bounds\r\n  \textend: function (obj) {\r\n  \t\tvar sw = this._southWest,\r\n  \t\t    ne = this._northEast,\r\n  \t\t    sw2, ne2;\r\n\r\n  \t\tif (obj instanceof LatLng) {\r\n  \t\t\tsw2 = obj;\r\n  \t\t\tne2 = obj;\r\n\r\n  \t\t} else if (obj instanceof LatLngBounds) {\r\n  \t\t\tsw2 = obj._southWest;\r\n  \t\t\tne2 = obj._northEast;\r\n\r\n  \t\t\tif (!sw2 || !ne2) { return this; }\r\n\r\n  \t\t} else {\r\n  \t\t\treturn obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;\r\n  \t\t}\r\n\r\n  \t\tif (!sw && !ne) {\r\n  \t\t\tthis._southWest = new LatLng(sw2.lat, sw2.lng);\r\n  \t\t\tthis._northEast = new LatLng(ne2.lat, ne2.lng);\r\n  \t\t} else {\r\n  \t\t\tsw.lat = Math.min(sw2.lat, sw.lat);\r\n  \t\t\tsw.lng = Math.min(sw2.lng, sw.lng);\r\n  \t\t\tne.lat = Math.max(ne2.lat, ne.lat);\r\n  \t\t\tne.lng = Math.max(ne2.lng, ne.lng);\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method pad(bufferRatio: Number): LatLngBounds\r\n  \t// Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.\r\n  \t// For example, a ratio of 0.5 extends the bounds by 50% in each direction.\r\n  \t// Negative values will retract the bounds.\r\n  \tpad: function (bufferRatio) {\r\n  \t\tvar sw = this._southWest,\r\n  \t\t    ne = this._northEast,\r\n  \t\t    heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,\r\n  \t\t    widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;\r\n\r\n  \t\treturn new LatLngBounds(\r\n  \t\t        new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),\r\n  \t\t        new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));\r\n  \t},\r\n\r\n  \t// @method getCenter(): LatLng\r\n  \t// Returns the center point of the bounds.\r\n  \tgetCenter: function () {\r\n  \t\treturn new LatLng(\r\n  \t\t        (this._southWest.lat + this._northEast.lat) / 2,\r\n  \t\t        (this._southWest.lng + this._northEast.lng) / 2);\r\n  \t},\r\n\r\n  \t// @method getSouthWest(): LatLng\r\n  \t// Returns the south-west point of the bounds.\r\n  \tgetSouthWest: function () {\r\n  \t\treturn this._southWest;\r\n  \t},\r\n\r\n  \t// @method getNorthEast(): LatLng\r\n  \t// Returns the north-east point of the bounds.\r\n  \tgetNorthEast: function () {\r\n  \t\treturn this._northEast;\r\n  \t},\r\n\r\n  \t// @method getNorthWest(): LatLng\r\n  \t// Returns the north-west point of the bounds.\r\n  \tgetNorthWest: function () {\r\n  \t\treturn new LatLng(this.getNorth(), this.getWest());\r\n  \t},\r\n\r\n  \t// @method getSouthEast(): LatLng\r\n  \t// Returns the south-east point of the bounds.\r\n  \tgetSouthEast: function () {\r\n  \t\treturn new LatLng(this.getSouth(), this.getEast());\r\n  \t},\r\n\r\n  \t// @method getWest(): Number\r\n  \t// Returns the west longitude of the bounds\r\n  \tgetWest: function () {\r\n  \t\treturn this._southWest.lng;\r\n  \t},\r\n\r\n  \t// @method getSouth(): Number\r\n  \t// Returns the south latitude of the bounds\r\n  \tgetSouth: function () {\r\n  \t\treturn this._southWest.lat;\r\n  \t},\r\n\r\n  \t// @method getEast(): Number\r\n  \t// Returns the east longitude of the bounds\r\n  \tgetEast: function () {\r\n  \t\treturn this._northEast.lng;\r\n  \t},\r\n\r\n  \t// @method getNorth(): Number\r\n  \t// Returns the north latitude of the bounds\r\n  \tgetNorth: function () {\r\n  \t\treturn this._northEast.lat;\r\n  \t},\r\n\r\n  \t// @method contains(otherBounds: LatLngBounds): Boolean\r\n  \t// Returns `true` if the rectangle contains the given one.\r\n\r\n  \t// @alternative\r\n  \t// @method contains (latlng: LatLng): Boolean\r\n  \t// Returns `true` if the rectangle contains the given point.\r\n  \tcontains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean\r\n  \t\tif (typeof obj[0] === 'number' || obj instanceof LatLng || 'lat' in obj) {\r\n  \t\t\tobj = toLatLng(obj);\r\n  \t\t} else {\r\n  \t\t\tobj = toLatLngBounds(obj);\r\n  \t\t}\r\n\r\n  \t\tvar sw = this._southWest,\r\n  \t\t    ne = this._northEast,\r\n  \t\t    sw2, ne2;\r\n\r\n  \t\tif (obj instanceof LatLngBounds) {\r\n  \t\t\tsw2 = obj.getSouthWest();\r\n  \t\t\tne2 = obj.getNorthEast();\r\n  \t\t} else {\r\n  \t\t\tsw2 = ne2 = obj;\r\n  \t\t}\r\n\r\n  \t\treturn (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&\r\n  \t\t       (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);\r\n  \t},\r\n\r\n  \t// @method intersects(otherBounds: LatLngBounds): Boolean\r\n  \t// Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.\r\n  \tintersects: function (bounds) {\r\n  \t\tbounds = toLatLngBounds(bounds);\r\n\r\n  \t\tvar sw = this._southWest,\r\n  \t\t    ne = this._northEast,\r\n  \t\t    sw2 = bounds.getSouthWest(),\r\n  \t\t    ne2 = bounds.getNorthEast(),\r\n\r\n  \t\t    latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),\r\n  \t\t    lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);\r\n\r\n  \t\treturn latIntersects && lngIntersects;\r\n  \t},\r\n\r\n  \t// @method overlaps(otherBounds: LatLngBounds): Boolean\r\n  \t// Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.\r\n  \toverlaps: function (bounds) {\r\n  \t\tbounds = toLatLngBounds(bounds);\r\n\r\n  \t\tvar sw = this._southWest,\r\n  \t\t    ne = this._northEast,\r\n  \t\t    sw2 = bounds.getSouthWest(),\r\n  \t\t    ne2 = bounds.getNorthEast(),\r\n\r\n  \t\t    latOverlaps = (ne2.lat > sw.lat) && (sw2.lat < ne.lat),\r\n  \t\t    lngOverlaps = (ne2.lng > sw.lng) && (sw2.lng < ne.lng);\r\n\r\n  \t\treturn latOverlaps && lngOverlaps;\r\n  \t},\r\n\r\n  \t// @method toBBoxString(): String\r\n  \t// Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.\r\n  \ttoBBoxString: function () {\r\n  \t\treturn [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');\r\n  \t},\r\n\r\n  \t// @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean\r\n  \t// Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.\r\n  \tequals: function (bounds, maxMargin) {\r\n  \t\tif (!bounds) { return false; }\r\n\r\n  \t\tbounds = toLatLngBounds(bounds);\r\n\r\n  \t\treturn this._southWest.equals(bounds.getSouthWest(), maxMargin) &&\r\n  \t\t       this._northEast.equals(bounds.getNorthEast(), maxMargin);\r\n  \t},\r\n\r\n  \t// @method isValid(): Boolean\r\n  \t// Returns `true` if the bounds are properly initialized.\r\n  \tisValid: function () {\r\n  \t\treturn !!(this._southWest && this._northEast);\r\n  \t}\r\n  };\r\n\r\n  // TODO International date line?\r\n\r\n  // @factory L.latLngBounds(corner1: LatLng, corner2: LatLng)\r\n  // Creates a `LatLngBounds` object by defining two diagonally opposite corners of the rectangle.\r\n\r\n  // @alternative\r\n  // @factory L.latLngBounds(latlngs: LatLng[])\r\n  // Creates a `LatLngBounds` object defined by the geographical points it contains. Very useful for zooming the map to fit a particular set of locations with [`fitBounds`](#map-fitbounds).\r\n  function toLatLngBounds(a, b) {\r\n  \tif (a instanceof LatLngBounds) {\r\n  \t\treturn a;\r\n  \t}\r\n  \treturn new LatLngBounds(a, b);\r\n  }\n\n  /* @class LatLng\r\n   * @aka L.LatLng\r\n   *\r\n   * Represents a geographical point with a certain latitude and longitude.\r\n   *\r\n   * @example\r\n   *\r\n   * ```\r\n   * var latlng = L.latLng(50.5, 30.5);\r\n   * ```\r\n   *\r\n   * All Leaflet methods that accept LatLng objects also accept them in a simple Array form and simple object form (unless noted otherwise), so these lines are equivalent:\r\n   *\r\n   * ```\r\n   * map.panTo([50, 30]);\r\n   * map.panTo({lon: 30, lat: 50});\r\n   * map.panTo({lat: 50, lng: 30});\r\n   * map.panTo(L.latLng(50, 30));\r\n   * ```\r\n   *\r\n   * Note that `LatLng` does not inherit from Leaflet's `Class` object,\r\n   * which means new classes can't inherit from it, and new methods\r\n   * can't be added to it with the `include` function.\r\n   */\r\n\r\n  function LatLng(lat, lng, alt) {\r\n  \tif (isNaN(lat) || isNaN(lng)) {\r\n  \t\tthrow new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');\r\n  \t}\r\n\r\n  \t// @property lat: Number\r\n  \t// Latitude in degrees\r\n  \tthis.lat = +lat;\r\n\r\n  \t// @property lng: Number\r\n  \t// Longitude in degrees\r\n  \tthis.lng = +lng;\r\n\r\n  \t// @property alt: Number\r\n  \t// Altitude in meters (optional)\r\n  \tif (alt !== undefined) {\r\n  \t\tthis.alt = +alt;\r\n  \t}\r\n  }\r\n\r\n  LatLng.prototype = {\r\n  \t// @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean\r\n  \t// Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.\r\n  \tequals: function (obj, maxMargin) {\r\n  \t\tif (!obj) { return false; }\r\n\r\n  \t\tobj = toLatLng(obj);\r\n\r\n  \t\tvar margin = Math.max(\r\n  \t\t        Math.abs(this.lat - obj.lat),\r\n  \t\t        Math.abs(this.lng - obj.lng));\r\n\r\n  \t\treturn margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);\r\n  \t},\r\n\r\n  \t// @method toString(): String\r\n  \t// Returns a string representation of the point (for debugging purposes).\r\n  \ttoString: function (precision) {\r\n  \t\treturn 'LatLng(' +\r\n  \t\t        formatNum(this.lat, precision) + ', ' +\r\n  \t\t        formatNum(this.lng, precision) + ')';\r\n  \t},\r\n\r\n  \t// @method distanceTo(otherLatLng: LatLng): Number\r\n  \t// Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).\r\n  \tdistanceTo: function (other) {\r\n  \t\treturn Earth.distance(this, toLatLng(other));\r\n  \t},\r\n\r\n  \t// @method wrap(): LatLng\r\n  \t// Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.\r\n  \twrap: function () {\r\n  \t\treturn Earth.wrapLatLng(this);\r\n  \t},\r\n\r\n  \t// @method toBounds(sizeInMeters: Number): LatLngBounds\r\n  \t// Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.\r\n  \ttoBounds: function (sizeInMeters) {\r\n  \t\tvar latAccuracy = 180 * sizeInMeters / 40075017,\r\n  \t\t    lngAccuracy = latAccuracy / Math.cos((Math.PI / 180) * this.lat);\r\n\r\n  \t\treturn toLatLngBounds(\r\n  \t\t        [this.lat - latAccuracy, this.lng - lngAccuracy],\r\n  \t\t        [this.lat + latAccuracy, this.lng + lngAccuracy]);\r\n  \t},\r\n\r\n  \tclone: function () {\r\n  \t\treturn new LatLng(this.lat, this.lng, this.alt);\r\n  \t}\r\n  };\r\n\r\n\r\n\r\n  // @factory L.latLng(latitude: Number, longitude: Number, altitude?: Number): LatLng\r\n  // Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).\r\n\r\n  // @alternative\r\n  // @factory L.latLng(coords: Array): LatLng\r\n  // Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.\r\n\r\n  // @alternative\r\n  // @factory L.latLng(coords: Object): LatLng\r\n  // Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.\r\n\r\n  function toLatLng(a, b, c) {\r\n  \tif (a instanceof LatLng) {\r\n  \t\treturn a;\r\n  \t}\r\n  \tif (isArray(a) && typeof a[0] !== 'object') {\r\n  \t\tif (a.length === 3) {\r\n  \t\t\treturn new LatLng(a[0], a[1], a[2]);\r\n  \t\t}\r\n  \t\tif (a.length === 2) {\r\n  \t\t\treturn new LatLng(a[0], a[1]);\r\n  \t\t}\r\n  \t\treturn null;\r\n  \t}\r\n  \tif (a === undefined || a === null) {\r\n  \t\treturn a;\r\n  \t}\r\n  \tif (typeof a === 'object' && 'lat' in a) {\r\n  \t\treturn new LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt);\r\n  \t}\r\n  \tif (b === undefined) {\r\n  \t\treturn null;\r\n  \t}\r\n  \treturn new LatLng(a, b, c);\r\n  }\n\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.Base\r\n   * Object that defines coordinate reference systems for projecting\r\n   * geographical points into pixel (screen) coordinates and back (and to\r\n   * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See\r\n   * [spatial reference system](https://en.wikipedia.org/wiki/Spatial_reference_system).\r\n   *\r\n   * Leaflet defines the most usual CRSs by default. If you want to use a\r\n   * CRS not defined by default, take a look at the\r\n   * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.\r\n   *\r\n   * Note that the CRS instances do not inherit from Leaflet's `Class` object,\r\n   * and can't be instantiated. Also, new classes can't inherit from them,\r\n   * and methods can't be added to them with the `include` function.\r\n   */\r\n\r\n  var CRS = {\r\n  \t// @method latLngToPoint(latlng: LatLng, zoom: Number): Point\r\n  \t// Projects geographical coordinates into pixel coordinates for a given zoom.\r\n  \tlatLngToPoint: function (latlng, zoom) {\r\n  \t\tvar projectedPoint = this.projection.project(latlng),\r\n  \t\t    scale = this.scale(zoom);\r\n\r\n  \t\treturn this.transformation._transform(projectedPoint, scale);\r\n  \t},\r\n\r\n  \t// @method pointToLatLng(point: Point, zoom: Number): LatLng\r\n  \t// The inverse of `latLngToPoint`. Projects pixel coordinates on a given\r\n  \t// zoom into geographical coordinates.\r\n  \tpointToLatLng: function (point, zoom) {\r\n  \t\tvar scale = this.scale(zoom),\r\n  \t\t    untransformedPoint = this.transformation.untransform(point, scale);\r\n\r\n  \t\treturn this.projection.unproject(untransformedPoint);\r\n  \t},\r\n\r\n  \t// @method project(latlng: LatLng): Point\r\n  \t// Projects geographical coordinates into coordinates in units accepted for\r\n  \t// this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).\r\n  \tproject: function (latlng) {\r\n  \t\treturn this.projection.project(latlng);\r\n  \t},\r\n\r\n  \t// @method unproject(point: Point): LatLng\r\n  \t// Given a projected coordinate returns the corresponding LatLng.\r\n  \t// The inverse of `project`.\r\n  \tunproject: function (point) {\r\n  \t\treturn this.projection.unproject(point);\r\n  \t},\r\n\r\n  \t// @method scale(zoom: Number): Number\r\n  \t// Returns the scale used when transforming projected coordinates into\r\n  \t// pixel coordinates for a particular zoom. For example, it returns\r\n  \t// `256 * 2^zoom` for Mercator-based CRS.\r\n  \tscale: function (zoom) {\r\n  \t\treturn 256 * Math.pow(2, zoom);\r\n  \t},\r\n\r\n  \t// @method zoom(scale: Number): Number\r\n  \t// Inverse of `scale()`, returns the zoom level corresponding to a scale\r\n  \t// factor of `scale`.\r\n  \tzoom: function (scale) {\r\n  \t\treturn Math.log(scale / 256) / Math.LN2;\r\n  \t},\r\n\r\n  \t// @method getProjectedBounds(zoom: Number): Bounds\r\n  \t// Returns the projection's bounds scaled and transformed for the provided `zoom`.\r\n  \tgetProjectedBounds: function (zoom) {\r\n  \t\tif (this.infinite) { return null; }\r\n\r\n  \t\tvar b = this.projection.bounds,\r\n  \t\t    s = this.scale(zoom),\r\n  \t\t    min = this.transformation.transform(b.min, s),\r\n  \t\t    max = this.transformation.transform(b.max, s);\r\n\r\n  \t\treturn new Bounds(min, max);\r\n  \t},\r\n\r\n  \t// @method distance(latlng1: LatLng, latlng2: LatLng): Number\r\n  \t// Returns the distance between two geographical coordinates.\r\n\r\n  \t// @property code: String\r\n  \t// Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)\r\n  \t//\r\n  \t// @property wrapLng: Number[]\r\n  \t// An array of two numbers defining whether the longitude (horizontal) coordinate\r\n  \t// axis wraps around a given range and how. Defaults to `[-180, 180]` in most\r\n  \t// geographical CRSs. If `undefined`, the longitude axis does not wrap around.\r\n  \t//\r\n  \t// @property wrapLat: Number[]\r\n  \t// Like `wrapLng`, but for the latitude (vertical) axis.\r\n\r\n  \t// wrapLng: [min, max],\r\n  \t// wrapLat: [min, max],\r\n\r\n  \t// @property infinite: Boolean\r\n  \t// If true, the coordinate space will be unbounded (infinite in both axes)\r\n  \tinfinite: false,\r\n\r\n  \t// @method wrapLatLng(latlng: LatLng): LatLng\r\n  \t// Returns a `LatLng` where lat and lng has been wrapped according to the\r\n  \t// CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.\r\n  \twrapLatLng: function (latlng) {\r\n  \t\tvar lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,\r\n  \t\t    lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,\r\n  \t\t    alt = latlng.alt;\r\n\r\n  \t\treturn new LatLng(lat, lng, alt);\r\n  \t},\r\n\r\n  \t// @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds\r\n  \t// Returns a `LatLngBounds` with the same size as the given one, ensuring\r\n  \t// that its center is within the CRS's bounds.\r\n  \t// Only accepts actual `L.LatLngBounds` instances, not arrays.\r\n  \twrapLatLngBounds: function (bounds) {\r\n  \t\tvar center = bounds.getCenter(),\r\n  \t\t    newCenter = this.wrapLatLng(center),\r\n  \t\t    latShift = center.lat - newCenter.lat,\r\n  \t\t    lngShift = center.lng - newCenter.lng;\r\n\r\n  \t\tif (latShift === 0 && lngShift === 0) {\r\n  \t\t\treturn bounds;\r\n  \t\t}\r\n\r\n  \t\tvar sw = bounds.getSouthWest(),\r\n  \t\t    ne = bounds.getNorthEast(),\r\n  \t\t    newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift),\r\n  \t\t    newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);\r\n\r\n  \t\treturn new LatLngBounds(newSw, newNe);\r\n  \t}\r\n  };\n\n  /*\n   * @namespace CRS\n   * @crs L.CRS.Earth\n   *\n   * Serves as the base for CRS that are global such that they cover the earth.\n   * Can only be used as the base for other CRS and cannot be used directly,\n   * since it does not have a `code`, `projection` or `transformation`. `distance()` returns\n   * meters.\n   */\n\n  var Earth = extend({}, CRS, {\n  \twrapLng: [-180, 180],\n\n  \t// Mean Earth Radius, as recommended for use by\n  \t// the International Union of Geodesy and Geophysics,\n  \t// see https://rosettacode.org/wiki/Haversine_formula\n  \tR: 6371000,\n\n  \t// distance between two geographical points using spherical law of cosines approximation\n  \tdistance: function (latlng1, latlng2) {\n  \t\tvar rad = Math.PI / 180,\n  \t\t    lat1 = latlng1.lat * rad,\n  \t\t    lat2 = latlng2.lat * rad,\n  \t\t    sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2),\n  \t\t    sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2),\n  \t\t    a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon,\n  \t\t    c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  \t\treturn this.R * c;\n  \t}\n  });\n\n  /*\r\n   * @namespace Projection\r\n   * @projection L.Projection.SphericalMercator\r\n   *\r\n   * Spherical Mercator projection  the most common projection for online maps,\r\n   * used by almost all free and commercial tile providers. Assumes that Earth is\r\n   * a sphere. Used by the `EPSG:3857` CRS.\r\n   */\r\n\r\n  var earthRadius = 6378137;\r\n\r\n  var SphericalMercator = {\r\n\r\n  \tR: earthRadius,\r\n  \tMAX_LATITUDE: 85.0511287798,\r\n\r\n  \tproject: function (latlng) {\r\n  \t\tvar d = Math.PI / 180,\r\n  \t\t    max = this.MAX_LATITUDE,\r\n  \t\t    lat = Math.max(Math.min(max, latlng.lat), -max),\r\n  \t\t    sin = Math.sin(lat * d);\r\n\r\n  \t\treturn new Point(\r\n  \t\t\tthis.R * latlng.lng * d,\r\n  \t\t\tthis.R * Math.log((1 + sin) / (1 - sin)) / 2);\r\n  \t},\r\n\r\n  \tunproject: function (point) {\r\n  \t\tvar d = 180 / Math.PI;\r\n\r\n  \t\treturn new LatLng(\r\n  \t\t\t(2 * Math.atan(Math.exp(point.y / this.R)) - (Math.PI / 2)) * d,\r\n  \t\t\tpoint.x * d / this.R);\r\n  \t},\r\n\r\n  \tbounds: (function () {\r\n  \t\tvar d = earthRadius * Math.PI;\r\n  \t\treturn new Bounds([-d, -d], [d, d]);\r\n  \t})()\r\n  };\n\n  /*\r\n   * @class Transformation\r\n   * @aka L.Transformation\r\n   *\r\n   * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`\r\n   * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing\r\n   * the reverse. Used by Leaflet in its projections code.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var transformation = L.transformation(2, 5, -1, 10),\r\n   * \tp = L.point(1, 2),\r\n   * \tp2 = transformation.transform(p), //  L.point(7, 8)\r\n   * \tp3 = transformation.untransform(p2); //  L.point(1, 2)\r\n   * ```\r\n   */\r\n\r\n\r\n  // factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)\r\n  // Creates a `Transformation` object with the given coefficients.\r\n  function Transformation(a, b, c, d) {\r\n  \tif (isArray(a)) {\r\n  \t\t// use array properties\r\n  \t\tthis._a = a[0];\r\n  \t\tthis._b = a[1];\r\n  \t\tthis._c = a[2];\r\n  \t\tthis._d = a[3];\r\n  \t\treturn;\r\n  \t}\r\n  \tthis._a = a;\r\n  \tthis._b = b;\r\n  \tthis._c = c;\r\n  \tthis._d = d;\r\n  }\r\n\r\n  Transformation.prototype = {\r\n  \t// @method transform(point: Point, scale?: Number): Point\r\n  \t// Returns a transformed point, optionally multiplied by the given scale.\r\n  \t// Only accepts actual `L.Point` instances, not arrays.\r\n  \ttransform: function (point, scale) { // (Point, Number) -> Point\r\n  \t\treturn this._transform(point.clone(), scale);\r\n  \t},\r\n\r\n  \t// destructive transform (faster)\r\n  \t_transform: function (point, scale) {\r\n  \t\tscale = scale || 1;\r\n  \t\tpoint.x = scale * (this._a * point.x + this._b);\r\n  \t\tpoint.y = scale * (this._c * point.y + this._d);\r\n  \t\treturn point;\r\n  \t},\r\n\r\n  \t// @method untransform(point: Point, scale?: Number): Point\r\n  \t// Returns the reverse transformation of the given point, optionally divided\r\n  \t// by the given scale. Only accepts actual `L.Point` instances, not arrays.\r\n  \tuntransform: function (point, scale) {\r\n  \t\tscale = scale || 1;\r\n  \t\treturn new Point(\r\n  \t\t        (point.x / scale - this._b) / this._a,\r\n  \t\t        (point.y / scale - this._d) / this._c);\r\n  \t}\r\n  };\r\n\r\n  // factory L.transformation(a: Number, b: Number, c: Number, d: Number)\r\n\r\n  // @factory L.transformation(a: Number, b: Number, c: Number, d: Number)\r\n  // Instantiates a Transformation object with the given coefficients.\r\n\r\n  // @alternative\r\n  // @factory L.transformation(coefficients: Array): Transformation\r\n  // Expects an coefficients array of the form\r\n  // `[a: Number, b: Number, c: Number, d: Number]`.\r\n\r\n  function toTransformation(a, b, c, d) {\r\n  \treturn new Transformation(a, b, c, d);\r\n  }\n\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.EPSG3857\r\n   *\r\n   * The most common CRS for online maps, used by almost all free and commercial\r\n   * tile providers. Uses Spherical Mercator projection. Set in by default in\r\n   * Map's `crs` option.\r\n   */\r\n\r\n  var EPSG3857 = extend({}, Earth, {\r\n  \tcode: 'EPSG:3857',\r\n  \tprojection: SphericalMercator,\r\n\r\n  \ttransformation: (function () {\r\n  \t\tvar scale = 0.5 / (Math.PI * SphericalMercator.R);\r\n  \t\treturn toTransformation(scale, 0.5, -scale, 0.5);\r\n  \t}())\r\n  });\r\n\r\n  var EPSG900913 = extend({}, EPSG3857, {\r\n  \tcode: 'EPSG:900913'\r\n  });\n\n  // @namespace SVG; @section\n  // There are several static functions which can be called without instantiating L.SVG:\n\n  // @function create(name: String): SVGElement\n  // Returns a instance of [SVGElement](https://developer.mozilla.org/docs/Web/API/SVGElement),\n  // corresponding to the class name passed. For example, using 'line' will return\n  // an instance of [SVGLineElement](https://developer.mozilla.org/docs/Web/API/SVGLineElement).\n  function svgCreate(name) {\n  \treturn document.createElementNS('http://www.w3.org/2000/svg', name);\n  }\n\n  // @function pointsToPath(rings: Point[], closed: Boolean): String\n  // Generates a SVG path string for multiple rings, with each ring turning\n  // into \"M..L..L..\" instructions\n  function pointsToPath(rings, closed) {\n  \tvar str = '',\n  \ti, j, len, len2, points, p;\n\n  \tfor (i = 0, len = rings.length; i < len; i++) {\n  \t\tpoints = rings[i];\n\n  \t\tfor (j = 0, len2 = points.length; j < len2; j++) {\n  \t\t\tp = points[j];\n  \t\t\tstr += (j ? 'L' : 'M') + p.x + ' ' + p.y;\n  \t\t}\n\n  \t\t// closes the ring for polygons; \"x\" is VML syntax\n  \t\tstr += closed ? (Browser.svg ? 'z' : 'x') : '';\n  \t}\n\n  \t// SVG complains about empty path strings\n  \treturn str || 'M0 0';\n  }\n\n  /*\r\n   * @namespace Browser\r\n   * @aka L.Browser\r\n   *\r\n   * A namespace with static properties for browser/feature detection used by Leaflet internally.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * if (L.Browser.ielt9) {\r\n   *   alert('Upgrade your browser, dude!');\r\n   * }\r\n   * ```\r\n   */\r\n\r\n  var style = document.documentElement.style;\r\n\r\n  // @property ie: Boolean; `true` for all Internet Explorer versions (not Edge).\r\n  var ie = 'ActiveXObject' in window;\r\n\r\n  // @property ielt9: Boolean; `true` for Internet Explorer versions less than 9.\r\n  var ielt9 = ie && !document.addEventListener;\r\n\r\n  // @property edge: Boolean; `true` for the Edge web browser.\r\n  var edge = 'msLaunchUri' in navigator && !('documentMode' in document);\r\n\r\n  // @property webkit: Boolean;\r\n  // `true` for webkit-based browsers like Chrome and Safari (including mobile versions).\r\n  var webkit = userAgentContains('webkit');\r\n\r\n  // @property android: Boolean\r\n  // **Deprecated.** `true` for any browser running on an Android platform.\r\n  var android = userAgentContains('android');\r\n\r\n  // @property android23: Boolean; **Deprecated.** `true` for browsers running on Android 2 or Android 3.\r\n  var android23 = userAgentContains('android 2') || userAgentContains('android 3');\r\n\r\n  /* See https://stackoverflow.com/a/17961266 for details on detecting stock Android */\r\n  var webkitVer = parseInt(/WebKit\\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10); // also matches AppleWebKit\r\n  // @property androidStock: Boolean; **Deprecated.** `true` for the Android stock browser (i.e. not Chrome)\r\n  var androidStock = android && userAgentContains('Google') && webkitVer < 537 && !('AudioNode' in window);\r\n\r\n  // @property opera: Boolean; `true` for the Opera browser\r\n  var opera = !!window.opera;\r\n\r\n  // @property chrome: Boolean; `true` for the Chrome browser.\r\n  var chrome = !edge && userAgentContains('chrome');\r\n\r\n  // @property gecko: Boolean; `true` for gecko-based browsers like Firefox.\r\n  var gecko = userAgentContains('gecko') && !webkit && !opera && !ie;\r\n\r\n  // @property safari: Boolean; `true` for the Safari browser.\r\n  var safari = !chrome && userAgentContains('safari');\r\n\r\n  var phantom = userAgentContains('phantom');\r\n\r\n  // @property opera12: Boolean\r\n  // `true` for the Opera browser supporting CSS transforms (version 12 or later).\r\n  var opera12 = 'OTransition' in style;\r\n\r\n  // @property win: Boolean; `true` when the browser is running in a Windows platform\r\n  var win = navigator.platform.indexOf('Win') === 0;\r\n\r\n  // @property ie3d: Boolean; `true` for all Internet Explorer versions supporting CSS transforms.\r\n  var ie3d = ie && ('transition' in style);\r\n\r\n  // @property webkit3d: Boolean; `true` for webkit-based browsers supporting CSS transforms.\r\n  var webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23;\r\n\r\n  // @property gecko3d: Boolean; `true` for gecko-based browsers supporting CSS transforms.\r\n  var gecko3d = 'MozPerspective' in style;\r\n\r\n  // @property any3d: Boolean\r\n  // `true` for all browsers supporting CSS transforms.\r\n  var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;\r\n\r\n  // @property mobile: Boolean; `true` for all browsers running in a mobile device.\r\n  var mobile = typeof orientation !== 'undefined' || userAgentContains('mobile');\r\n\r\n  // @property mobileWebkit: Boolean; `true` for all webkit-based browsers in a mobile device.\r\n  var mobileWebkit = mobile && webkit;\r\n\r\n  // @property mobileWebkit3d: Boolean\r\n  // `true` for all webkit-based browsers in a mobile device supporting CSS transforms.\r\n  var mobileWebkit3d = mobile && webkit3d;\r\n\r\n  // @property msPointer: Boolean\r\n  // `true` for browsers implementing the Microsoft touch events model (notably IE10).\r\n  var msPointer = !window.PointerEvent && window.MSPointerEvent;\r\n\r\n  // @property pointer: Boolean\r\n  // `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).\r\n  var pointer = !!(window.PointerEvent || msPointer);\r\n\r\n  // @property touchNative: Boolean\r\n  // `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).\r\n  // **This does not necessarily mean** that the browser is running in a computer with\r\n  // a touchscreen, it only means that the browser is capable of understanding\r\n  // touch events.\r\n  var touchNative = 'ontouchstart' in window || !!window.TouchEvent;\r\n\r\n  // @property touch: Boolean\r\n  // `true` for all browsers supporting either [touch](#browser-touch) or [pointer](#browser-pointer) events.\r\n  // Note: pointer events will be preferred (if available), and processed for all `touch*` listeners.\r\n  var touch = !window.L_NO_TOUCH && (touchNative || pointer);\r\n\r\n  // @property mobileOpera: Boolean; `true` for the Opera browser in a mobile device.\r\n  var mobileOpera = mobile && opera;\r\n\r\n  // @property mobileGecko: Boolean\r\n  // `true` for gecko-based browsers running in a mobile device.\r\n  var mobileGecko = mobile && gecko;\r\n\r\n  // @property retina: Boolean\r\n  // `true` for browsers on a high-resolution \"retina\" screen or on any screen when browser's display zoom is more than 100%.\r\n  var retina = (window.devicePixelRatio || (window.screen.deviceXDPI / window.screen.logicalXDPI)) > 1;\r\n\r\n  // @property passiveEvents: Boolean\r\n  // `true` for browsers that support passive events.\r\n  var passiveEvents = (function () {\r\n  \tvar supportsPassiveOption = false;\r\n  \ttry {\r\n  \t\tvar opts = Object.defineProperty({}, 'passive', {\r\n  \t\t\tget: function () { // eslint-disable-line getter-return\r\n  \t\t\t\tsupportsPassiveOption = true;\r\n  \t\t\t}\r\n  \t\t});\r\n  \t\twindow.addEventListener('testPassiveEventSupport', falseFn, opts);\r\n  \t\twindow.removeEventListener('testPassiveEventSupport', falseFn, opts);\r\n  \t} catch (e) {\r\n  \t\t// Errors can safely be ignored since this is only a browser support test.\r\n  \t}\r\n  \treturn supportsPassiveOption;\r\n  }());\r\n\r\n  // @property canvas: Boolean\r\n  // `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).\r\n  var canvas$1 = (function () {\r\n  \treturn !!document.createElement('canvas').getContext;\r\n  }());\r\n\r\n  // @property svg: Boolean\r\n  // `true` when the browser supports [SVG](https://developer.mozilla.org/docs/Web/SVG).\r\n  var svg$1 = !!(document.createElementNS && svgCreate('svg').createSVGRect);\r\n\r\n  var inlineSvg = !!svg$1 && (function () {\r\n  \tvar div = document.createElement('div');\r\n  \tdiv.innerHTML = '<svg/>';\r\n  \treturn (div.firstChild && div.firstChild.namespaceURI) === 'http://www.w3.org/2000/svg';\r\n  })();\r\n\r\n  // @property vml: Boolean\r\n  // `true` if the browser supports [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language).\r\n  var vml = !svg$1 && (function () {\r\n  \ttry {\r\n  \t\tvar div = document.createElement('div');\r\n  \t\tdiv.innerHTML = '<v:shape adj=\"1\"/>';\r\n\r\n  \t\tvar shape = div.firstChild;\r\n  \t\tshape.style.behavior = 'url(#default#VML)';\r\n\r\n  \t\treturn shape && (typeof shape.adj === 'object');\r\n\r\n  \t} catch (e) {\r\n  \t\treturn false;\r\n  \t}\r\n  }());\r\n\r\n\r\n  // @property mac: Boolean; `true` when the browser is running in a Mac platform\r\n  var mac = navigator.platform.indexOf('Mac') === 0;\r\n\r\n  // @property mac: Boolean; `true` when the browser is running in a Linux platform\r\n  var linux = navigator.platform.indexOf('Linux') === 0;\r\n\r\n  function userAgentContains(str) {\r\n  \treturn navigator.userAgent.toLowerCase().indexOf(str) >= 0;\r\n  }\r\n\r\n\r\n  var Browser = {\r\n  \tie: ie,\r\n  \tielt9: ielt9,\r\n  \tedge: edge,\r\n  \twebkit: webkit,\r\n  \tandroid: android,\r\n  \tandroid23: android23,\r\n  \tandroidStock: androidStock,\r\n  \topera: opera,\r\n  \tchrome: chrome,\r\n  \tgecko: gecko,\r\n  \tsafari: safari,\r\n  \tphantom: phantom,\r\n  \topera12: opera12,\r\n  \twin: win,\r\n  \tie3d: ie3d,\r\n  \twebkit3d: webkit3d,\r\n  \tgecko3d: gecko3d,\r\n  \tany3d: any3d,\r\n  \tmobile: mobile,\r\n  \tmobileWebkit: mobileWebkit,\r\n  \tmobileWebkit3d: mobileWebkit3d,\r\n  \tmsPointer: msPointer,\r\n  \tpointer: pointer,\r\n  \ttouch: touch,\r\n  \ttouchNative: touchNative,\r\n  \tmobileOpera: mobileOpera,\r\n  \tmobileGecko: mobileGecko,\r\n  \tretina: retina,\r\n  \tpassiveEvents: passiveEvents,\r\n  \tcanvas: canvas$1,\r\n  \tsvg: svg$1,\r\n  \tvml: vml,\r\n  \tinlineSvg: inlineSvg,\r\n  \tmac: mac,\r\n  \tlinux: linux\r\n  };\n\n  /*\n   * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.\n   */\n\n  var POINTER_DOWN =   Browser.msPointer ? 'MSPointerDown'   : 'pointerdown';\n  var POINTER_MOVE =   Browser.msPointer ? 'MSPointerMove'   : 'pointermove';\n  var POINTER_UP =     Browser.msPointer ? 'MSPointerUp'     : 'pointerup';\n  var POINTER_CANCEL = Browser.msPointer ? 'MSPointerCancel' : 'pointercancel';\n  var pEvent = {\n  \ttouchstart  : POINTER_DOWN,\n  \ttouchmove   : POINTER_MOVE,\n  \ttouchend    : POINTER_UP,\n  \ttouchcancel : POINTER_CANCEL\n  };\n  var handle = {\n  \ttouchstart  : _onPointerStart,\n  \ttouchmove   : _handlePointer,\n  \ttouchend    : _handlePointer,\n  \ttouchcancel : _handlePointer\n  };\n  var _pointers = {};\n  var _pointerDocListener = false;\n\n  // Provides a touch events wrapper for (ms)pointer events.\n  // ref https://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890\n\n  function addPointerListener(obj, type, handler) {\n  \tif (type === 'touchstart') {\n  \t\t_addPointerDocListener();\n  \t}\n  \tif (!handle[type]) {\n  \t\tconsole.warn('wrong event specified:', type);\n  \t\treturn falseFn;\n  \t}\n  \thandler = handle[type].bind(this, handler);\n  \tobj.addEventListener(pEvent[type], handler, false);\n  \treturn handler;\n  }\n\n  function removePointerListener(obj, type, handler) {\n  \tif (!pEvent[type]) {\n  \t\tconsole.warn('wrong event specified:', type);\n  \t\treturn;\n  \t}\n  \tobj.removeEventListener(pEvent[type], handler, false);\n  }\n\n  function _globalPointerDown(e) {\n  \t_pointers[e.pointerId] = e;\n  }\n\n  function _globalPointerMove(e) {\n  \tif (_pointers[e.pointerId]) {\n  \t\t_pointers[e.pointerId] = e;\n  \t}\n  }\n\n  function _globalPointerUp(e) {\n  \tdelete _pointers[e.pointerId];\n  }\n\n  function _addPointerDocListener() {\n  \t// need to keep track of what pointers and how many are active to provide e.touches emulation\n  \tif (!_pointerDocListener) {\n  \t\t// we listen document as any drags that end by moving the touch off the screen get fired there\n  \t\tdocument.addEventListener(POINTER_DOWN, _globalPointerDown, true);\n  \t\tdocument.addEventListener(POINTER_MOVE, _globalPointerMove, true);\n  \t\tdocument.addEventListener(POINTER_UP, _globalPointerUp, true);\n  \t\tdocument.addEventListener(POINTER_CANCEL, _globalPointerUp, true);\n\n  \t\t_pointerDocListener = true;\n  \t}\n  }\n\n  function _handlePointer(handler, e) {\n  \tif (e.pointerType === (e.MSPOINTER_TYPE_MOUSE || 'mouse')) { return; }\n\n  \te.touches = [];\n  \tfor (var i in _pointers) {\n  \t\te.touches.push(_pointers[i]);\n  \t}\n  \te.changedTouches = [e];\n\n  \thandler(e);\n  }\n\n  function _onPointerStart(handler, e) {\n  \t// IE10 specific: MsTouch needs preventDefault. See #2000\n  \tif (e.MSPOINTER_TYPE_TOUCH && e.pointerType === e.MSPOINTER_TYPE_TOUCH) {\n  \t\tpreventDefault(e);\n  \t}\n  \t_handlePointer(handler, e);\n  }\n\n  /*\r\n   * Extends the event handling code with double tap support for mobile browsers.\r\n   *\r\n   * Note: currently most browsers fire native dblclick, with only a few exceptions\r\n   * (see https://github.com/Leaflet/Leaflet/issues/7012#issuecomment-595087386)\r\n   */\r\n\r\n  function makeDblclick(event) {\r\n  \t// in modern browsers `type` cannot be just overridden:\r\n  \t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Getter_only\r\n  \tvar newEvent = {},\r\n  \t    prop, i;\r\n  \tfor (i in event) {\r\n  \t\tprop = event[i];\r\n  \t\tnewEvent[i] = prop && prop.bind ? prop.bind(event) : prop;\r\n  \t}\r\n  \tevent = newEvent;\r\n  \tnewEvent.type = 'dblclick';\r\n  \tnewEvent.detail = 2;\r\n  \tnewEvent.isTrusted = false;\r\n  \tnewEvent._simulated = true; // for debug purposes\r\n  \treturn newEvent;\r\n  }\r\n\r\n  var delay = 200;\r\n  function addDoubleTapListener(obj, handler) {\r\n  \t// Most browsers handle double tap natively\r\n  \tobj.addEventListener('dblclick', handler);\r\n\r\n  \t// On some platforms the browser doesn't fire native dblclicks for touch events.\r\n  \t// It seems that in all such cases `detail` property of `click` event is always `1`.\r\n  \t// So here we rely on that fact to avoid excessive 'dblclick' simulation when not needed.\r\n  \tvar last = 0,\r\n  \t    detail;\r\n  \tfunction simDblclick(e) {\r\n  \t\tif (e.detail !== 1) {\r\n  \t\t\tdetail = e.detail; // keep in sync to avoid false dblclick in some cases\r\n  \t\t\treturn;\r\n  \t\t}\r\n\r\n  \t\tif (e.pointerType === 'mouse' ||\r\n  \t\t\t(e.sourceCapabilities && !e.sourceCapabilities.firesTouchEvents)) {\r\n\r\n  \t\t\treturn;\r\n  \t\t}\r\n\r\n  \t\t// When clicking on an <input>, the browser generates a click on its\r\n  \t\t// <label> (and vice versa) triggering two clicks in quick succession.\r\n  \t\t// This ignores clicks on elements which are a label with a 'for'\r\n  \t\t// attribute (or children of such a label), but not children of\r\n  \t\t// a <input>.\r\n  \t\tvar path = getPropagationPath(e);\r\n  \t\tif (path.some(function (el) {\r\n  \t\t\treturn el instanceof HTMLLabelElement && el.attributes.for;\r\n  \t\t}) &&\r\n  \t\t\t!path.some(function (el) {\r\n  \t\t\t\treturn (\r\n  \t\t\t\t\tel instanceof HTMLInputElement ||\r\n  \t\t\t\t\tel instanceof HTMLSelectElement\r\n  \t\t\t\t);\r\n  \t\t\t})\r\n  \t\t) {\r\n  \t\t\treturn;\r\n  \t\t}\r\n\r\n  \t\tvar now = Date.now();\r\n  \t\tif (now - last <= delay) {\r\n  \t\t\tdetail++;\r\n  \t\t\tif (detail === 2) {\r\n  \t\t\t\thandler(makeDblclick(e));\r\n  \t\t\t}\r\n  \t\t} else {\r\n  \t\t\tdetail = 1;\r\n  \t\t}\r\n  \t\tlast = now;\r\n  \t}\r\n\r\n  \tobj.addEventListener('click', simDblclick);\r\n\r\n  \treturn {\r\n  \t\tdblclick: handler,\r\n  \t\tsimDblclick: simDblclick\r\n  \t};\r\n  }\r\n\r\n  function removeDoubleTapListener(obj, handlers) {\r\n  \tobj.removeEventListener('dblclick', handlers.dblclick);\r\n  \tobj.removeEventListener('click', handlers.simDblclick);\r\n  }\n\n  /*\r\n   * @namespace DomUtil\r\n   *\r\n   * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model)\r\n   * tree, used by Leaflet internally.\r\n   *\r\n   * Most functions expecting or returning a `HTMLElement` also work for\r\n   * SVG elements. The only difference is that classes refer to CSS classes\r\n   * in HTML and SVG classes in SVG.\r\n   */\r\n\r\n\r\n  // @property TRANSFORM: String\r\n  // Vendor-prefixed transform style name (e.g. `'webkitTransform'` for WebKit).\r\n  var TRANSFORM = testProp(\r\n  \t['transform', 'webkitTransform', 'OTransform', 'MozTransform', 'msTransform']);\r\n\r\n  // webkitTransition comes first because some browser versions that drop vendor prefix don't do\r\n  // the same for the transitionend event, in particular the Android 4.1 stock browser\r\n\r\n  // @property TRANSITION: String\r\n  // Vendor-prefixed transition style name.\r\n  var TRANSITION = testProp(\r\n  \t['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);\r\n\r\n  // @property TRANSITION_END: String\r\n  // Vendor-prefixed transitionend event name.\r\n  var TRANSITION_END =\r\n  \tTRANSITION === 'webkitTransition' || TRANSITION === 'OTransition' ? TRANSITION + 'End' : 'transitionend';\r\n\r\n\r\n  // @function get(id: String|HTMLElement): HTMLElement\r\n  // Returns an element given its DOM id, or returns the element itself\r\n  // if it was passed directly.\r\n  function get(id) {\r\n  \treturn typeof id === 'string' ? document.getElementById(id) : id;\r\n  }\r\n\r\n  // @function getStyle(el: HTMLElement, styleAttrib: String): String\r\n  // Returns the value for a certain style attribute on an element,\r\n  // including computed values or values set through CSS.\r\n  function getStyle(el, style) {\r\n  \tvar value = el.style[style] || (el.currentStyle && el.currentStyle[style]);\r\n\r\n  \tif ((!value || value === 'auto') && document.defaultView) {\r\n  \t\tvar css = document.defaultView.getComputedStyle(el, null);\r\n  \t\tvalue = css ? css[style] : null;\r\n  \t}\r\n  \treturn value === 'auto' ? null : value;\r\n  }\r\n\r\n  // @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement\r\n  // Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.\r\n  function create$1(tagName, className, container) {\r\n  \tvar el = document.createElement(tagName);\r\n  \tel.className = className || '';\r\n\r\n  \tif (container) {\r\n  \t\tcontainer.appendChild(el);\r\n  \t}\r\n  \treturn el;\r\n  }\r\n\r\n  // @function remove(el: HTMLElement)\r\n  // Removes `el` from its parent element\r\n  function remove(el) {\r\n  \tvar parent = el.parentNode;\r\n  \tif (parent) {\r\n  \t\tparent.removeChild(el);\r\n  \t}\r\n  }\r\n\r\n  // @function empty(el: HTMLElement)\r\n  // Removes all of `el`'s children elements from `el`\r\n  function empty(el) {\r\n  \twhile (el.firstChild) {\r\n  \t\tel.removeChild(el.firstChild);\r\n  \t}\r\n  }\r\n\r\n  // @function toFront(el: HTMLElement)\r\n  // Makes `el` the last child of its parent, so it renders in front of the other children.\r\n  function toFront(el) {\r\n  \tvar parent = el.parentNode;\r\n  \tif (parent && parent.lastChild !== el) {\r\n  \t\tparent.appendChild(el);\r\n  \t}\r\n  }\r\n\r\n  // @function toBack(el: HTMLElement)\r\n  // Makes `el` the first child of its parent, so it renders behind the other children.\r\n  function toBack(el) {\r\n  \tvar parent = el.parentNode;\r\n  \tif (parent && parent.firstChild !== el) {\r\n  \t\tparent.insertBefore(el, parent.firstChild);\r\n  \t}\r\n  }\r\n\r\n  // @function hasClass(el: HTMLElement, name: String): Boolean\r\n  // Returns `true` if the element's class attribute contains `name`.\r\n  function hasClass(el, name) {\r\n  \tif (el.classList !== undefined) {\r\n  \t\treturn el.classList.contains(name);\r\n  \t}\r\n  \tvar className = getClass(el);\r\n  \treturn className.length > 0 && new RegExp('(^|\\\\s)' + name + '(\\\\s|$)').test(className);\r\n  }\r\n\r\n  // @function addClass(el: HTMLElement, name: String)\r\n  // Adds `name` to the element's class attribute.\r\n  function addClass(el, name) {\r\n  \tif (el.classList !== undefined) {\r\n  \t\tvar classes = splitWords(name);\r\n  \t\tfor (var i = 0, len = classes.length; i < len; i++) {\r\n  \t\t\tel.classList.add(classes[i]);\r\n  \t\t}\r\n  \t} else if (!hasClass(el, name)) {\r\n  \t\tvar className = getClass(el);\r\n  \t\tsetClass(el, (className ? className + ' ' : '') + name);\r\n  \t}\r\n  }\r\n\r\n  // @function removeClass(el: HTMLElement, name: String)\r\n  // Removes `name` from the element's class attribute.\r\n  function removeClass(el, name) {\r\n  \tif (el.classList !== undefined) {\r\n  \t\tel.classList.remove(name);\r\n  \t} else {\r\n  \t\tsetClass(el, trim((' ' + getClass(el) + ' ').replace(' ' + name + ' ', ' ')));\r\n  \t}\r\n  }\r\n\r\n  // @function setClass(el: HTMLElement, name: String)\r\n  // Sets the element's class.\r\n  function setClass(el, name) {\r\n  \tif (el.className.baseVal === undefined) {\r\n  \t\tel.className = name;\r\n  \t} else {\r\n  \t\t// in case of SVG element\r\n  \t\tel.className.baseVal = name;\r\n  \t}\r\n  }\r\n\r\n  // @function getClass(el: HTMLElement): String\r\n  // Returns the element's class.\r\n  function getClass(el) {\r\n  \t// Check if the element is an SVGElementInstance and use the correspondingElement instead\r\n  \t// (Required for linked SVG elements in IE11.)\r\n  \tif (el.correspondingElement) {\r\n  \t\tel = el.correspondingElement;\r\n  \t}\r\n  \treturn el.className.baseVal === undefined ? el.className : el.className.baseVal;\r\n  }\r\n\r\n  // @function setOpacity(el: HTMLElement, opacity: Number)\r\n  // Set the opacity of an element (including old IE support).\r\n  // `opacity` must be a number from `0` to `1`.\r\n  function setOpacity(el, value) {\r\n  \tif ('opacity' in el.style) {\r\n  \t\tel.style.opacity = value;\r\n  \t} else if ('filter' in el.style) {\r\n  \t\t_setOpacityIE(el, value);\r\n  \t}\r\n  }\r\n\r\n  function _setOpacityIE(el, value) {\r\n  \tvar filter = false,\r\n  \t    filterName = 'DXImageTransform.Microsoft.Alpha';\r\n\r\n  \t// filters collection throws an error if we try to retrieve a filter that doesn't exist\r\n  \ttry {\r\n  \t\tfilter = el.filters.item(filterName);\r\n  \t} catch (e) {\r\n  \t\t// don't set opacity to 1 if we haven't already set an opacity,\r\n  \t\t// it isn't needed and breaks transparent pngs.\r\n  \t\tif (value === 1) { return; }\r\n  \t}\r\n\r\n  \tvalue = Math.round(value * 100);\r\n\r\n  \tif (filter) {\r\n  \t\tfilter.Enabled = (value !== 100);\r\n  \t\tfilter.Opacity = value;\r\n  \t} else {\r\n  \t\tel.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';\r\n  \t}\r\n  }\r\n\r\n  // @function testProp(props: String[]): String|false\r\n  // Goes through the array of style names and returns the first name\r\n  // that is a valid style name for an element. If no such name is found,\r\n  // it returns false. Useful for vendor-prefixed styles like `transform`.\r\n  function testProp(props) {\r\n  \tvar style = document.documentElement.style;\r\n\r\n  \tfor (var i = 0; i < props.length; i++) {\r\n  \t\tif (props[i] in style) {\r\n  \t\t\treturn props[i];\r\n  \t\t}\r\n  \t}\r\n  \treturn false;\r\n  }\r\n\r\n  // @function setTransform(el: HTMLElement, offset: Point, scale?: Number)\r\n  // Resets the 3D CSS transform of `el` so it is translated by `offset` pixels\r\n  // and optionally scaled by `scale`. Does not have an effect if the\r\n  // browser doesn't support 3D CSS transforms.\r\n  function setTransform(el, offset, scale) {\r\n  \tvar pos = offset || new Point(0, 0);\r\n\r\n  \tel.style[TRANSFORM] =\r\n  \t\t(Browser.ie3d ?\r\n  \t\t\t'translate(' + pos.x + 'px,' + pos.y + 'px)' :\r\n  \t\t\t'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') +\r\n  \t\t(scale ? ' scale(' + scale + ')' : '');\r\n  }\r\n\r\n  // @function setPosition(el: HTMLElement, position: Point)\r\n  // Sets the position of `el` to coordinates specified by `position`,\r\n  // using CSS translate or top/left positioning depending on the browser\r\n  // (used by Leaflet internally to position its layers).\r\n  function setPosition(el, point) {\r\n\r\n  \t/*eslint-disable */\r\n  \tel._leaflet_pos = point;\r\n  \t/* eslint-enable */\r\n\r\n  \tif (Browser.any3d) {\r\n  \t\tsetTransform(el, point);\r\n  \t} else {\r\n  \t\tel.style.left = point.x + 'px';\r\n  \t\tel.style.top = point.y + 'px';\r\n  \t}\r\n  }\r\n\r\n  // @function getPosition(el: HTMLElement): Point\r\n  // Returns the coordinates of an element previously positioned with setPosition.\r\n  function getPosition(el) {\r\n  \t// this method is only used for elements previously positioned using setPosition,\r\n  \t// so it's safe to cache the position for performance\r\n\r\n  \treturn el._leaflet_pos || new Point(0, 0);\r\n  }\r\n\r\n  // @function disableTextSelection()\r\n  // Prevents the user from generating `selectstart` DOM events, usually generated\r\n  // when the user drags the mouse through a page with text. Used internally\r\n  // by Leaflet to override the behaviour of any click-and-drag interaction on\r\n  // the map. Affects drag interactions on the whole document.\r\n\r\n  // @function enableTextSelection()\r\n  // Cancels the effects of a previous [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection).\r\n  var disableTextSelection;\r\n  var enableTextSelection;\r\n  var _userSelect;\r\n  if ('onselectstart' in document) {\r\n  \tdisableTextSelection = function () {\r\n  \t\ton(window, 'selectstart', preventDefault);\r\n  \t};\r\n  \tenableTextSelection = function () {\r\n  \t\toff(window, 'selectstart', preventDefault);\r\n  \t};\r\n  } else {\r\n  \tvar userSelectProperty = testProp(\r\n  \t\t['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);\r\n\r\n  \tdisableTextSelection = function () {\r\n  \t\tif (userSelectProperty) {\r\n  \t\t\tvar style = document.documentElement.style;\r\n  \t\t\t_userSelect = style[userSelectProperty];\r\n  \t\t\tstyle[userSelectProperty] = 'none';\r\n  \t\t}\r\n  \t};\r\n  \tenableTextSelection = function () {\r\n  \t\tif (userSelectProperty) {\r\n  \t\t\tdocument.documentElement.style[userSelectProperty] = _userSelect;\r\n  \t\t\t_userSelect = undefined;\r\n  \t\t}\r\n  \t};\r\n  }\r\n\r\n  // @function disableImageDrag()\r\n  // As [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection), but\r\n  // for `dragstart` DOM events, usually generated when the user drags an image.\r\n  function disableImageDrag() {\r\n  \ton(window, 'dragstart', preventDefault);\r\n  }\r\n\r\n  // @function enableImageDrag()\r\n  // Cancels the effects of a previous [`L.DomUtil.disableImageDrag`](#domutil-disabletextselection).\r\n  function enableImageDrag() {\r\n  \toff(window, 'dragstart', preventDefault);\r\n  }\r\n\r\n  var _outlineElement, _outlineStyle;\r\n  // @function preventOutline(el: HTMLElement)\r\n  // Makes the [outline](https://developer.mozilla.org/docs/Web/CSS/outline)\r\n  // of the element `el` invisible. Used internally by Leaflet to prevent\r\n  // focusable elements from displaying an outline when the user performs a\r\n  // drag interaction on them.\r\n  function preventOutline(element) {\r\n  \twhile (element.tabIndex === -1) {\r\n  \t\telement = element.parentNode;\r\n  \t}\r\n  \tif (!element.style) { return; }\r\n  \trestoreOutline();\r\n  \t_outlineElement = element;\r\n  \t_outlineStyle = element.style.outline;\r\n  \telement.style.outline = 'none';\r\n  \ton(window, 'keydown', restoreOutline);\r\n  }\r\n\r\n  // @function restoreOutline()\r\n  // Cancels the effects of a previous [`L.DomUtil.preventOutline`]().\r\n  function restoreOutline() {\r\n  \tif (!_outlineElement) { return; }\r\n  \t_outlineElement.style.outline = _outlineStyle;\r\n  \t_outlineElement = undefined;\r\n  \t_outlineStyle = undefined;\r\n  \toff(window, 'keydown', restoreOutline);\r\n  }\r\n\r\n  // @function getSizedParentNode(el: HTMLElement): HTMLElement\r\n  // Finds the closest parent node which size (width and height) is not null.\r\n  function getSizedParentNode(element) {\r\n  \tdo {\r\n  \t\telement = element.parentNode;\r\n  \t} while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);\r\n  \treturn element;\r\n  }\r\n\r\n  // @function getScale(el: HTMLElement): Object\r\n  // Computes the CSS scale currently applied on the element.\r\n  // Returns an object with `x` and `y` members as horizontal and vertical scales respectively,\r\n  // and `boundingClientRect` as the result of [`getBoundingClientRect()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect).\r\n  function getScale(element) {\r\n  \tvar rect = element.getBoundingClientRect(); // Read-only in old browsers.\r\n\r\n  \treturn {\r\n  \t\tx: rect.width / element.offsetWidth || 1,\r\n  \t\ty: rect.height / element.offsetHeight || 1,\r\n  \t\tboundingClientRect: rect\r\n  \t};\r\n  }\n\n  var DomUtil = {\n    __proto__: null,\n    TRANSFORM: TRANSFORM,\n    TRANSITION: TRANSITION,\n    TRANSITION_END: TRANSITION_END,\n    get: get,\n    getStyle: getStyle,\n    create: create$1,\n    remove: remove,\n    empty: empty,\n    toFront: toFront,\n    toBack: toBack,\n    hasClass: hasClass,\n    addClass: addClass,\n    removeClass: removeClass,\n    setClass: setClass,\n    getClass: getClass,\n    setOpacity: setOpacity,\n    testProp: testProp,\n    setTransform: setTransform,\n    setPosition: setPosition,\n    getPosition: getPosition,\n    get disableTextSelection () { return disableTextSelection; },\n    get enableTextSelection () { return enableTextSelection; },\n    disableImageDrag: disableImageDrag,\n    enableImageDrag: enableImageDrag,\n    preventOutline: preventOutline,\n    restoreOutline: restoreOutline,\n    getSizedParentNode: getSizedParentNode,\n    getScale: getScale\n  };\n\n  /*\r\n   * @namespace DomEvent\r\n   * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally.\r\n   */\r\n\r\n  // Inspired by John Resig, Dean Edwards and YUI addEvent implementations.\r\n\r\n  // @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this\r\n  // Adds a listener function (`fn`) to a particular DOM event type of the\r\n  // element `el`. You can optionally specify the context of the listener\r\n  // (object the `this` keyword will point to). You can also pass several\r\n  // space-separated types (e.g. `'click dblclick'`).\r\n\r\n  // @alternative\r\n  // @function on(el: HTMLElement, eventMap: Object, context?: Object): this\r\n  // Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\r\n  function on(obj, types, fn, context) {\r\n\r\n  \tif (types && typeof types === 'object') {\r\n  \t\tfor (var type in types) {\r\n  \t\t\taddOne(obj, type, types[type], fn);\r\n  \t\t}\r\n  \t} else {\r\n  \t\ttypes = splitWords(types);\r\n\r\n  \t\tfor (var i = 0, len = types.length; i < len; i++) {\r\n  \t\t\taddOne(obj, types[i], fn, context);\r\n  \t\t}\r\n  \t}\r\n\r\n  \treturn this;\r\n  }\r\n\r\n  var eventsKey = '_leaflet_events';\r\n\r\n  // @function off(el: HTMLElement, types: String, fn: Function, context?: Object): this\r\n  // Removes a previously added listener function.\r\n  // Note that if you passed a custom context to on, you must pass the same\r\n  // context to `off` in order to remove the listener.\r\n\r\n  // @alternative\r\n  // @function off(el: HTMLElement, eventMap: Object, context?: Object): this\r\n  // Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`\r\n\r\n  // @alternative\r\n  // @function off(el: HTMLElement, types: String): this\r\n  // Removes all previously added listeners of given types.\r\n\r\n  // @alternative\r\n  // @function off(el: HTMLElement): this\r\n  // Removes all previously added listeners from given HTMLElement\r\n  function off(obj, types, fn, context) {\r\n\r\n  \tif (arguments.length === 1) {\r\n  \t\tbatchRemove(obj);\r\n  \t\tdelete obj[eventsKey];\r\n\r\n  \t} else if (types && typeof types === 'object') {\r\n  \t\tfor (var type in types) {\r\n  \t\t\tremoveOne(obj, type, types[type], fn);\r\n  \t\t}\r\n\r\n  \t} else {\r\n  \t\ttypes = splitWords(types);\r\n\r\n  \t\tif (arguments.length === 2) {\r\n  \t\t\tbatchRemove(obj, function (type) {\r\n  \t\t\t\treturn indexOf(types, type) !== -1;\r\n  \t\t\t});\r\n  \t\t} else {\r\n  \t\t\tfor (var i = 0, len = types.length; i < len; i++) {\r\n  \t\t\t\tremoveOne(obj, types[i], fn, context);\r\n  \t\t\t}\r\n  \t\t}\r\n  \t}\r\n\r\n  \treturn this;\r\n  }\r\n\r\n  function batchRemove(obj, filterFn) {\r\n  \tfor (var id in obj[eventsKey]) {\r\n  \t\tvar type = id.split(/\\d/)[0];\r\n  \t\tif (!filterFn || filterFn(type)) {\r\n  \t\t\tremoveOne(obj, type, null, null, id);\r\n  \t\t}\r\n  \t}\r\n  }\r\n\r\n  var mouseSubst = {\r\n  \tmouseenter: 'mouseover',\r\n  \tmouseleave: 'mouseout',\r\n  \twheel: !('onwheel' in window) && 'mousewheel'\r\n  };\r\n\r\n  function addOne(obj, type, fn, context) {\r\n  \tvar id = type + stamp(fn) + (context ? '_' + stamp(context) : '');\r\n\r\n  \tif (obj[eventsKey] && obj[eventsKey][id]) { return this; }\r\n\r\n  \tvar handler = function (e) {\r\n  \t\treturn fn.call(context || obj, e || window.event);\r\n  \t};\r\n\r\n  \tvar originalHandler = handler;\r\n\r\n  \tif (!Browser.touchNative && Browser.pointer && type.indexOf('touch') === 0) {\r\n  \t\t// Needs DomEvent.Pointer.js\r\n  \t\thandler = addPointerListener(obj, type, handler);\r\n\r\n  \t} else if (Browser.touch && (type === 'dblclick')) {\r\n  \t\thandler = addDoubleTapListener(obj, handler);\r\n\r\n  \t} else if ('addEventListener' in obj) {\r\n\r\n  \t\tif (type === 'touchstart' || type === 'touchmove' || type === 'wheel' ||  type === 'mousewheel') {\r\n  \t\t\tobj.addEventListener(mouseSubst[type] || type, handler, Browser.passiveEvents ? {passive: false} : false);\r\n\r\n  \t\t} else if (type === 'mouseenter' || type === 'mouseleave') {\r\n  \t\t\thandler = function (e) {\r\n  \t\t\t\te = e || window.event;\r\n  \t\t\t\tif (isExternalTarget(obj, e)) {\r\n  \t\t\t\t\toriginalHandler(e);\r\n  \t\t\t\t}\r\n  \t\t\t};\r\n  \t\t\tobj.addEventListener(mouseSubst[type], handler, false);\r\n\r\n  \t\t} else {\r\n  \t\t\tobj.addEventListener(type, originalHandler, false);\r\n  \t\t}\r\n\r\n  \t} else {\r\n  \t\tobj.attachEvent('on' + type, handler);\r\n  \t}\r\n\r\n  \tobj[eventsKey] = obj[eventsKey] || {};\r\n  \tobj[eventsKey][id] = handler;\r\n  }\r\n\r\n  function removeOne(obj, type, fn, context, id) {\r\n  \tid = id || type + stamp(fn) + (context ? '_' + stamp(context) : '');\r\n  \tvar handler = obj[eventsKey] && obj[eventsKey][id];\r\n\r\n  \tif (!handler) { return this; }\r\n\r\n  \tif (!Browser.touchNative && Browser.pointer && type.indexOf('touch') === 0) {\r\n  \t\tremovePointerListener(obj, type, handler);\r\n\r\n  \t} else if (Browser.touch && (type === 'dblclick')) {\r\n  \t\tremoveDoubleTapListener(obj, handler);\r\n\r\n  \t} else if ('removeEventListener' in obj) {\r\n\r\n  \t\tobj.removeEventListener(mouseSubst[type] || type, handler, false);\r\n\r\n  \t} else {\r\n  \t\tobj.detachEvent('on' + type, handler);\r\n  \t}\r\n\r\n  \tobj[eventsKey][id] = null;\r\n  }\r\n\r\n  // @function stopPropagation(ev: DOMEvent): this\r\n  // Stop the given event from propagation to parent elements. Used inside the listener functions:\r\n  // ```js\r\n  // L.DomEvent.on(div, 'click', function (ev) {\r\n  // \tL.DomEvent.stopPropagation(ev);\r\n  // });\r\n  // ```\r\n  function stopPropagation(e) {\r\n\r\n  \tif (e.stopPropagation) {\r\n  \t\te.stopPropagation();\r\n  \t} else if (e.originalEvent) {  // In case of Leaflet event.\r\n  \t\te.originalEvent._stopped = true;\r\n  \t} else {\r\n  \t\te.cancelBubble = true;\r\n  \t}\r\n\r\n  \treturn this;\r\n  }\r\n\r\n  // @function disableScrollPropagation(el: HTMLElement): this\r\n  // Adds `stopPropagation` to the element's `'wheel'` events (plus browser variants).\r\n  function disableScrollPropagation(el) {\r\n  \taddOne(el, 'wheel', stopPropagation);\r\n  \treturn this;\r\n  }\r\n\r\n  // @function disableClickPropagation(el: HTMLElement): this\r\n  // Adds `stopPropagation` to the element's `'click'`, `'dblclick'`, `'contextmenu'`,\r\n  // `'mousedown'` and `'touchstart'` events (plus browser variants).\r\n  function disableClickPropagation(el) {\r\n  \ton(el, 'mousedown touchstart dblclick contextmenu', stopPropagation);\r\n  \tel['_leaflet_disable_click'] = true;\r\n  \treturn this;\r\n  }\r\n\r\n  // @function preventDefault(ev: DOMEvent): this\r\n  // Prevents the default action of the DOM Event `ev` from happening (such as\r\n  // following a link in the href of the a element, or doing a POST request\r\n  // with page reload when a `<form>` is submitted).\r\n  // Use it inside listener functions.\r\n  function preventDefault(e) {\r\n  \tif (e.preventDefault) {\r\n  \t\te.preventDefault();\r\n  \t} else {\r\n  \t\te.returnValue = false;\r\n  \t}\r\n  \treturn this;\r\n  }\r\n\r\n  // @function stop(ev: DOMEvent): this\r\n  // Does `stopPropagation` and `preventDefault` at the same time.\r\n  function stop(e) {\r\n  \tpreventDefault(e);\r\n  \tstopPropagation(e);\r\n  \treturn this;\r\n  }\r\n\r\n  // @function getPropagationPath(ev: DOMEvent): Array\r\n  // Compatibility polyfill for [`Event.composedPath()`](https://developer.mozilla.org/en-US/docs/Web/API/Event/composedPath).\r\n  // Returns an array containing the `HTMLElement`s that the given DOM event\r\n  // should propagate to (if not stopped).\r\n  function getPropagationPath(ev) {\r\n  \tif (ev.composedPath) {\r\n  \t\treturn ev.composedPath();\r\n  \t}\r\n\r\n  \tvar path = [];\r\n  \tvar el = ev.target;\r\n\r\n  \twhile (el) {\r\n  \t\tpath.push(el);\r\n  \t\tel = el.parentNode;\r\n  \t}\r\n  \treturn path;\r\n  }\r\n\r\n\r\n  // @function getMousePosition(ev: DOMEvent, container?: HTMLElement): Point\r\n  // Gets normalized mouse position from a DOM event relative to the\r\n  // `container` (border excluded) or to the whole page if not specified.\r\n  function getMousePosition(e, container) {\r\n  \tif (!container) {\r\n  \t\treturn new Point(e.clientX, e.clientY);\r\n  \t}\r\n\r\n  \tvar scale = getScale(container),\r\n  \t    offset = scale.boundingClientRect; // left and top  values are in page scale (like the event clientX/Y)\r\n\r\n  \treturn new Point(\r\n  \t\t// offset.left/top values are in page scale (like clientX/Y),\r\n  \t\t// whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).\r\n  \t\t(e.clientX - offset.left) / scale.x - container.clientLeft,\r\n  \t\t(e.clientY - offset.top) / scale.y - container.clientTop\r\n  \t);\r\n  }\r\n\r\n\r\n  //  except , Safari and\r\n  // We need double the scroll pixels (see #7403 and #4538) for all Browsers\r\n  // except OSX (Mac) -> 3x, Chrome running on Linux 1x\r\n\r\n  var wheelPxFactor =\r\n  \t(Browser.linux && Browser.chrome) ? window.devicePixelRatio :\r\n  \tBrowser.mac ? window.devicePixelRatio * 3 :\r\n  \twindow.devicePixelRatio > 0 ? 2 * window.devicePixelRatio : 1;\r\n  // @function getWheelDelta(ev: DOMEvent): Number\r\n  // Gets normalized wheel delta from a wheel DOM event, in vertical\r\n  // pixels scrolled (negative if scrolling down).\r\n  // Events from pointing devices without precise scrolling are mapped to\r\n  // a best guess of 60 pixels.\r\n  function getWheelDelta(e) {\r\n  \treturn (Browser.edge) ? e.wheelDeltaY / 2 : // Don't trust window-geometry-based delta\r\n  \t       (e.deltaY && e.deltaMode === 0) ? -e.deltaY / wheelPxFactor : // Pixels\r\n  \t       (e.deltaY && e.deltaMode === 1) ? -e.deltaY * 20 : // Lines\r\n  \t       (e.deltaY && e.deltaMode === 2) ? -e.deltaY * 60 : // Pages\r\n  \t       (e.deltaX || e.deltaZ) ? 0 :\t// Skip horizontal/depth wheel events\r\n  \t       e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : // Legacy IE pixels\r\n  \t       (e.detail && Math.abs(e.detail) < 32765) ? -e.detail * 20 : // Legacy Moz lines\r\n  \t       e.detail ? e.detail / -32765 * 60 : // Legacy Moz pages\r\n  \t       0;\r\n  }\r\n\r\n  // check if element really left/entered the event target (for mouseenter/mouseleave)\r\n  function isExternalTarget(el, e) {\r\n\r\n  \tvar related = e.relatedTarget;\r\n\r\n  \tif (!related) { return true; }\r\n\r\n  \ttry {\r\n  \t\twhile (related && (related !== el)) {\r\n  \t\t\trelated = related.parentNode;\r\n  \t\t}\r\n  \t} catch (err) {\r\n  \t\treturn false;\r\n  \t}\r\n  \treturn (related !== el);\r\n  }\n\n  var DomEvent = {\n    __proto__: null,\n    on: on,\n    off: off,\n    stopPropagation: stopPropagation,\n    disableScrollPropagation: disableScrollPropagation,\n    disableClickPropagation: disableClickPropagation,\n    preventDefault: preventDefault,\n    stop: stop,\n    getPropagationPath: getPropagationPath,\n    getMousePosition: getMousePosition,\n    getWheelDelta: getWheelDelta,\n    isExternalTarget: isExternalTarget,\n    addListener: on,\n    removeListener: off\n  };\n\n  /*\n   * @class PosAnimation\n   * @aka L.PosAnimation\n   * @inherits Evented\n   * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9.\n   *\n   * @example\n   * ```js\n   * var myPositionMarker = L.marker([48.864716, 2.294694]).addTo(map);\n   *\n   * myPositionMarker.on(\"click\", function() {\n   * \tvar pos = map.latLngToLayerPoint(myPositionMarker.getLatLng());\n   * \tpos.y -= 25;\n   * \tvar fx = new L.PosAnimation();\n   *\n   * \tfx.once('end',function() {\n   * \t\tpos.y += 25;\n   * \t\tfx.run(myPositionMarker._icon, pos, 0.8);\n   * \t});\n   *\n   * \tfx.run(myPositionMarker._icon, pos, 0.3);\n   * });\n   *\n   * ```\n   *\n   * @constructor L.PosAnimation()\n   * Creates a `PosAnimation` object.\n   *\n   */\n\n  var PosAnimation = Evented.extend({\n\n  \t// @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)\n  \t// Run an animation of a given element to a new position, optionally setting\n  \t// duration in seconds (`0.25` by default) and easing linearity factor (3rd\n  \t// argument of the [cubic bezier curve](https://cubic-bezier.com/#0,0,.5,1),\n  \t// `0.5` by default).\n  \trun: function (el, newPos, duration, easeLinearity) {\n  \t\tthis.stop();\n\n  \t\tthis._el = el;\n  \t\tthis._inProgress = true;\n  \t\tthis._duration = duration || 0.25;\n  \t\tthis._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);\n\n  \t\tthis._startPos = getPosition(el);\n  \t\tthis._offset = newPos.subtract(this._startPos);\n  \t\tthis._startTime = +new Date();\n\n  \t\t// @event start: Event\n  \t\t// Fired when the animation starts\n  \t\tthis.fire('start');\n\n  \t\tthis._animate();\n  \t},\n\n  \t// @method stop()\n  \t// Stops the animation (if currently running).\n  \tstop: function () {\n  \t\tif (!this._inProgress) { return; }\n\n  \t\tthis._step(true);\n  \t\tthis._complete();\n  \t},\n\n  \t_animate: function () {\n  \t\t// animation loop\n  \t\tthis._animId = requestAnimFrame(this._animate, this);\n  \t\tthis._step();\n  \t},\n\n  \t_step: function (round) {\n  \t\tvar elapsed = (+new Date()) - this._startTime,\n  \t\t    duration = this._duration * 1000;\n\n  \t\tif (elapsed < duration) {\n  \t\t\tthis._runFrame(this._easeOut(elapsed / duration), round);\n  \t\t} else {\n  \t\t\tthis._runFrame(1);\n  \t\t\tthis._complete();\n  \t\t}\n  \t},\n\n  \t_runFrame: function (progress, round) {\n  \t\tvar pos = this._startPos.add(this._offset.multiplyBy(progress));\n  \t\tif (round) {\n  \t\t\tpos._round();\n  \t\t}\n  \t\tsetPosition(this._el, pos);\n\n  \t\t// @event step: Event\n  \t\t// Fired continuously during the animation.\n  \t\tthis.fire('step');\n  \t},\n\n  \t_complete: function () {\n  \t\tcancelAnimFrame(this._animId);\n\n  \t\tthis._inProgress = false;\n  \t\t// @event end: Event\n  \t\t// Fired when the animation ends.\n  \t\tthis.fire('end');\n  \t},\n\n  \t_easeOut: function (t) {\n  \t\treturn 1 - Math.pow(1 - t, this._easeOutPower);\n  \t}\n  });\n\n  /*\r\n   * @class Map\r\n   * @aka L.Map\r\n   * @inherits Evented\r\n   *\r\n   * The central class of the API  it is used to create a map on a page and manipulate it.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * // initialize the map on the \"map\" div with a given center and zoom\r\n   * var map = L.map('map', {\r\n   * \tcenter: [51.505, -0.09],\r\n   * \tzoom: 13\r\n   * });\r\n   * ```\r\n   *\r\n   */\r\n\r\n  var Map = Evented.extend({\r\n\r\n  \toptions: {\r\n  \t\t// @section Map State Options\r\n  \t\t// @option crs: CRS = L.CRS.EPSG3857\r\n  \t\t// The [Coordinate Reference System](#crs) to use. Don't change this if you're not\r\n  \t\t// sure what it means.\r\n  \t\tcrs: EPSG3857,\r\n\r\n  \t\t// @option center: LatLng = undefined\r\n  \t\t// Initial geographic center of the map\r\n  \t\tcenter: undefined,\r\n\r\n  \t\t// @option zoom: Number = undefined\r\n  \t\t// Initial map zoom level\r\n  \t\tzoom: undefined,\r\n\r\n  \t\t// @option minZoom: Number = *\r\n  \t\t// Minimum zoom level of the map.\r\n  \t\t// If not specified and at least one `GridLayer` or `TileLayer` is in the map,\r\n  \t\t// the lowest of their `minZoom` options will be used instead.\r\n  \t\tminZoom: undefined,\r\n\r\n  \t\t// @option maxZoom: Number = *\r\n  \t\t// Maximum zoom level of the map.\r\n  \t\t// If not specified and at least one `GridLayer` or `TileLayer` is in the map,\r\n  \t\t// the highest of their `maxZoom` options will be used instead.\r\n  \t\tmaxZoom: undefined,\r\n\r\n  \t\t// @option layers: Layer[] = []\r\n  \t\t// Array of layers that will be added to the map initially\r\n  \t\tlayers: [],\r\n\r\n  \t\t// @option maxBounds: LatLngBounds = null\r\n  \t\t// When this option is set, the map restricts the view to the given\r\n  \t\t// geographical bounds, bouncing the user back if the user tries to pan\r\n  \t\t// outside the view. To set the restriction dynamically, use\r\n  \t\t// [`setMaxBounds`](#map-setmaxbounds) method.\r\n  \t\tmaxBounds: undefined,\r\n\r\n  \t\t// @option renderer: Renderer = *\r\n  \t\t// The default method for drawing vector layers on the map. `L.SVG`\r\n  \t\t// or `L.Canvas` by default depending on browser support.\r\n  \t\trenderer: undefined,\r\n\r\n\r\n  \t\t// @section Animation Options\r\n  \t\t// @option zoomAnimation: Boolean = true\r\n  \t\t// Whether the map zoom animation is enabled. By default it's enabled\r\n  \t\t// in all browsers that support CSS3 Transitions except Android.\r\n  \t\tzoomAnimation: true,\r\n\r\n  \t\t// @option zoomAnimationThreshold: Number = 4\r\n  \t\t// Won't animate zoom if the zoom difference exceeds this value.\r\n  \t\tzoomAnimationThreshold: 4,\r\n\r\n  \t\t// @option fadeAnimation: Boolean = true\r\n  \t\t// Whether the tile fade animation is enabled. By default it's enabled\r\n  \t\t// in all browsers that support CSS3 Transitions except Android.\r\n  \t\tfadeAnimation: true,\r\n\r\n  \t\t// @option markerZoomAnimation: Boolean = true\r\n  \t\t// Whether markers animate their zoom with the zoom animation, if disabled\r\n  \t\t// they will disappear for the length of the animation. By default it's\r\n  \t\t// enabled in all browsers that support CSS3 Transitions except Android.\r\n  \t\tmarkerZoomAnimation: true,\r\n\r\n  \t\t// @option transform3DLimit: Number = 2^23\r\n  \t\t// Defines the maximum size of a CSS translation transform. The default\r\n  \t\t// value should not be changed unless a web browser positions layers in\r\n  \t\t// the wrong place after doing a large `panBy`.\r\n  \t\ttransform3DLimit: 8388608, // Precision limit of a 32-bit float\r\n\r\n  \t\t// @section Interaction Options\r\n  \t\t// @option zoomSnap: Number = 1\r\n  \t\t// Forces the map's zoom level to always be a multiple of this, particularly\r\n  \t\t// right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.\r\n  \t\t// By default, the zoom level snaps to the nearest integer; lower values\r\n  \t\t// (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`\r\n  \t\t// means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.\r\n  \t\tzoomSnap: 1,\r\n\r\n  \t\t// @option zoomDelta: Number = 1\r\n  \t\t// Controls how much the map's zoom level will change after a\r\n  \t\t// [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`\r\n  \t\t// or `-` on the keyboard, or using the [zoom controls](#control-zoom).\r\n  \t\t// Values smaller than `1` (e.g. `0.5`) allow for greater granularity.\r\n  \t\tzoomDelta: 1,\r\n\r\n  \t\t// @option trackResize: Boolean = true\r\n  \t\t// Whether the map automatically handles browser window resize to update itself.\r\n  \t\ttrackResize: true\r\n  \t},\r\n\r\n  \tinitialize: function (id, options) { // (HTMLElement or String, Object)\r\n  \t\toptions = setOptions(this, options);\r\n\r\n  \t\t// Make sure to assign internal flags at the beginning,\r\n  \t\t// to avoid inconsistent state in some edge cases.\r\n  \t\tthis._handlers = [];\r\n  \t\tthis._layers = {};\r\n  \t\tthis._zoomBoundLayers = {};\r\n  \t\tthis._sizeChanged = true;\r\n\r\n  \t\tthis._initContainer(id);\r\n  \t\tthis._initLayout();\r\n\r\n  \t\t// hack for https://github.com/Leaflet/Leaflet/issues/1980\r\n  \t\tthis._onResize = bind(this._onResize, this);\r\n\r\n  \t\tthis._initEvents();\r\n\r\n  \t\tif (options.maxBounds) {\r\n  \t\t\tthis.setMaxBounds(options.maxBounds);\r\n  \t\t}\r\n\r\n  \t\tif (options.zoom !== undefined) {\r\n  \t\t\tthis._zoom = this._limitZoom(options.zoom);\r\n  \t\t}\r\n\r\n  \t\tif (options.center && options.zoom !== undefined) {\r\n  \t\t\tthis.setView(toLatLng(options.center), options.zoom, {reset: true});\r\n  \t\t}\r\n\r\n  \t\tthis.callInitHooks();\r\n\r\n  \t\t// don't animate on browsers without hardware-accelerated transitions or old Android/Opera\r\n  \t\tthis._zoomAnimated = TRANSITION && Browser.any3d && !Browser.mobileOpera &&\r\n  \t\t\t\tthis.options.zoomAnimation;\r\n\r\n  \t\t// zoom transitions run with the same duration for all layers, so if one of transitionend events\r\n  \t\t// happens after starting zoom animation (propagating to the map pane), we know that it ended globally\r\n  \t\tif (this._zoomAnimated) {\r\n  \t\t\tthis._createAnimProxy();\r\n  \t\t\ton(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);\r\n  \t\t}\r\n\r\n  \t\tthis._addLayers(this.options.layers);\r\n  \t},\r\n\r\n\r\n  \t// @section Methods for modifying map state\r\n\r\n  \t// @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this\r\n  \t// Sets the view of the map (geographical center and zoom) with the given\r\n  \t// animation options.\r\n  \tsetView: function (center, zoom, options) {\r\n\r\n  \t\tzoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);\r\n  \t\tcenter = this._limitCenter(toLatLng(center), zoom, this.options.maxBounds);\r\n  \t\toptions = options || {};\r\n\r\n  \t\tthis._stop();\r\n\r\n  \t\tif (this._loaded && !options.reset && options !== true) {\r\n\r\n  \t\t\tif (options.animate !== undefined) {\r\n  \t\t\t\toptions.zoom = extend({animate: options.animate}, options.zoom);\r\n  \t\t\t\toptions.pan = extend({animate: options.animate, duration: options.duration}, options.pan);\r\n  \t\t\t}\r\n\r\n  \t\t\t// try animating pan or zoom\r\n  \t\t\tvar moved = (this._zoom !== zoom) ?\r\n  \t\t\t\tthis._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :\r\n  \t\t\t\tthis._tryAnimatedPan(center, options.pan);\r\n\r\n  \t\t\tif (moved) {\r\n  \t\t\t\t// prevent resize handler call, the view will refresh after animation anyway\r\n  \t\t\t\tclearTimeout(this._sizeTimer);\r\n  \t\t\t\treturn this;\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\t// animation didn't start, just reset the map view\r\n  \t\tthis._resetView(center, zoom, options.pan && options.pan.noMoveStart);\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method setZoom(zoom: Number, options?: Zoom/pan options): this\r\n  \t// Sets the zoom of the map.\r\n  \tsetZoom: function (zoom, options) {\r\n  \t\tif (!this._loaded) {\r\n  \t\t\tthis._zoom = zoom;\r\n  \t\t\treturn this;\r\n  \t\t}\r\n  \t\treturn this.setView(this.getCenter(), zoom, {zoom: options});\r\n  \t},\r\n\r\n  \t// @method zoomIn(delta?: Number, options?: Zoom options): this\r\n  \t// Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).\r\n  \tzoomIn: function (delta, options) {\r\n  \t\tdelta = delta || (Browser.any3d ? this.options.zoomDelta : 1);\r\n  \t\treturn this.setZoom(this._zoom + delta, options);\r\n  \t},\r\n\r\n  \t// @method zoomOut(delta?: Number, options?: Zoom options): this\r\n  \t// Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).\r\n  \tzoomOut: function (delta, options) {\r\n  \t\tdelta = delta || (Browser.any3d ? this.options.zoomDelta : 1);\r\n  \t\treturn this.setZoom(this._zoom - delta, options);\r\n  \t},\r\n\r\n  \t// @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this\r\n  \t// Zooms the map while keeping a specified geographical point on the map\r\n  \t// stationary (e.g. used internally for scroll zoom and double-click zoom).\r\n  \t// @alternative\r\n  \t// @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this\r\n  \t// Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.\r\n  \tsetZoomAround: function (latlng, zoom, options) {\r\n  \t\tvar scale = this.getZoomScale(zoom),\r\n  \t\t    viewHalf = this.getSize().divideBy(2),\r\n  \t\t    containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng),\r\n\r\n  \t\t    centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),\r\n  \t\t    newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));\r\n\r\n  \t\treturn this.setView(newCenter, zoom, {zoom: options});\r\n  \t},\r\n\r\n  \t_getBoundsCenterZoom: function (bounds, options) {\r\n\r\n  \t\toptions = options || {};\r\n  \t\tbounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);\r\n\r\n  \t\tvar paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),\r\n  \t\t    paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),\r\n\r\n  \t\t    zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));\r\n\r\n  \t\tzoom = (typeof options.maxZoom === 'number') ? Math.min(options.maxZoom, zoom) : zoom;\r\n\r\n  \t\tif (zoom === Infinity) {\r\n  \t\t\treturn {\r\n  \t\t\t\tcenter: bounds.getCenter(),\r\n  \t\t\t\tzoom: zoom\r\n  \t\t\t};\r\n  \t\t}\r\n\r\n  \t\tvar paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),\r\n\r\n  \t\t    swPoint = this.project(bounds.getSouthWest(), zoom),\r\n  \t\t    nePoint = this.project(bounds.getNorthEast(), zoom),\r\n  \t\t    center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);\r\n\r\n  \t\treturn {\r\n  \t\t\tcenter: center,\r\n  \t\t\tzoom: zoom\r\n  \t\t};\r\n  \t},\r\n\r\n  \t// @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this\r\n  \t// Sets a map view that contains the given geographical bounds with the\r\n  \t// maximum zoom level possible.\r\n  \tfitBounds: function (bounds, options) {\r\n\r\n  \t\tbounds = toLatLngBounds(bounds);\r\n\r\n  \t\tif (!bounds.isValid()) {\r\n  \t\t\tthrow new Error('Bounds are not valid.');\r\n  \t\t}\r\n\r\n  \t\tvar target = this._getBoundsCenterZoom(bounds, options);\r\n  \t\treturn this.setView(target.center, target.zoom, options);\r\n  \t},\r\n\r\n  \t// @method fitWorld(options?: fitBounds options): this\r\n  \t// Sets a map view that mostly contains the whole world with the maximum\r\n  \t// zoom level possible.\r\n  \tfitWorld: function (options) {\r\n  \t\treturn this.fitBounds([[-90, -180], [90, 180]], options);\r\n  \t},\r\n\r\n  \t// @method panTo(latlng: LatLng, options?: Pan options): this\r\n  \t// Pans the map to a given center.\r\n  \tpanTo: function (center, options) { // (LatLng)\r\n  \t\treturn this.setView(center, this._zoom, {pan: options});\r\n  \t},\r\n\r\n  \t// @method panBy(offset: Point, options?: Pan options): this\r\n  \t// Pans the map by a given number of pixels (animated).\r\n  \tpanBy: function (offset, options) {\r\n  \t\toffset = toPoint(offset).round();\r\n  \t\toptions = options || {};\r\n\r\n  \t\tif (!offset.x && !offset.y) {\r\n  \t\t\treturn this.fire('moveend');\r\n  \t\t}\r\n  \t\t// If we pan too far, Chrome gets issues with tiles\r\n  \t\t// and makes them disappear or appear in the wrong place (slightly offset) #2602\r\n  \t\tif (options.animate !== true && !this.getSize().contains(offset)) {\r\n  \t\t\tthis._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());\r\n  \t\t\treturn this;\r\n  \t\t}\r\n\r\n  \t\tif (!this._panAnim) {\r\n  \t\t\tthis._panAnim = new PosAnimation();\r\n\r\n  \t\t\tthis._panAnim.on({\r\n  \t\t\t\t'step': this._onPanTransitionStep,\r\n  \t\t\t\t'end': this._onPanTransitionEnd\r\n  \t\t\t}, this);\r\n  \t\t}\r\n\r\n  \t\t// don't fire movestart if animating inertia\r\n  \t\tif (!options.noMoveStart) {\r\n  \t\t\tthis.fire('movestart');\r\n  \t\t}\r\n\r\n  \t\t// animate pan unless animate: false specified\r\n  \t\tif (options.animate !== false) {\r\n  \t\t\taddClass(this._mapPane, 'leaflet-pan-anim');\r\n\r\n  \t\t\tvar newPos = this._getMapPanePos().subtract(offset).round();\r\n  \t\t\tthis._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);\r\n  \t\t} else {\r\n  \t\t\tthis._rawPanBy(offset);\r\n  \t\t\tthis.fire('move').fire('moveend');\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this\r\n  \t// Sets the view of the map (geographical center and zoom) performing a smooth\r\n  \t// pan-zoom animation.\r\n  \tflyTo: function (targetCenter, targetZoom, options) {\r\n\r\n  \t\toptions = options || {};\r\n  \t\tif (options.animate === false || !Browser.any3d) {\r\n  \t\t\treturn this.setView(targetCenter, targetZoom, options);\r\n  \t\t}\r\n\r\n  \t\tthis._stop();\r\n\r\n  \t\tvar from = this.project(this.getCenter()),\r\n  \t\t    to = this.project(targetCenter),\r\n  \t\t    size = this.getSize(),\r\n  \t\t    startZoom = this._zoom;\r\n\r\n  \t\ttargetCenter = toLatLng(targetCenter);\r\n  \t\ttargetZoom = targetZoom === undefined ? startZoom : targetZoom;\r\n\r\n  \t\tvar w0 = Math.max(size.x, size.y),\r\n  \t\t    w1 = w0 * this.getZoomScale(startZoom, targetZoom),\r\n  \t\t    u1 = (to.distanceTo(from)) || 1,\r\n  \t\t    rho = 1.42,\r\n  \t\t    rho2 = rho * rho;\r\n\r\n  \t\tfunction r(i) {\r\n  \t\t\tvar s1 = i ? -1 : 1,\r\n  \t\t\t    s2 = i ? w1 : w0,\r\n  \t\t\t    t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1,\r\n  \t\t\t    b1 = 2 * s2 * rho2 * u1,\r\n  \t\t\t    b = t1 / b1,\r\n  \t\t\t    sq = Math.sqrt(b * b + 1) - b;\r\n\r\n  \t\t\t    // workaround for floating point precision bug when sq = 0, log = -Infinite,\r\n  \t\t\t    // thus triggering an infinite loop in flyTo\r\n  \t\t\t    var log = sq < 0.000000001 ? -18 : Math.log(sq);\r\n\r\n  \t\t\treturn log;\r\n  \t\t}\r\n\r\n  \t\tfunction sinh(n) { return (Math.exp(n) - Math.exp(-n)) / 2; }\r\n  \t\tfunction cosh(n) { return (Math.exp(n) + Math.exp(-n)) / 2; }\r\n  \t\tfunction tanh(n) { return sinh(n) / cosh(n); }\r\n\r\n  \t\tvar r0 = r(0);\r\n\r\n  \t\tfunction w(s) { return w0 * (cosh(r0) / cosh(r0 + rho * s)); }\r\n  \t\tfunction u(s) { return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2; }\r\n\r\n  \t\tfunction easeOut(t) { return 1 - Math.pow(1 - t, 1.5); }\r\n\r\n  \t\tvar start = Date.now(),\r\n  \t\t    S = (r(1) - r0) / rho,\r\n  \t\t    duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;\r\n\r\n  \t\tfunction frame() {\r\n  \t\t\tvar t = (Date.now() - start) / duration,\r\n  \t\t\t    s = easeOut(t) * S;\r\n\r\n  \t\t\tif (t <= 1) {\r\n  \t\t\t\tthis._flyToFrame = requestAnimFrame(frame, this);\r\n\r\n  \t\t\t\tthis._move(\r\n  \t\t\t\t\tthis.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom),\r\n  \t\t\t\t\tthis.getScaleZoom(w0 / w(s), startZoom),\r\n  \t\t\t\t\t{flyTo: true});\r\n\r\n  \t\t\t} else {\r\n  \t\t\t\tthis\r\n  \t\t\t\t\t._move(targetCenter, targetZoom)\r\n  \t\t\t\t\t._moveEnd(true);\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\tthis._moveStart(true, options.noMoveStart);\r\n\r\n  \t\tframe.call(this);\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this\r\n  \t// Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),\r\n  \t// but takes a bounds parameter like [`fitBounds`](#map-fitbounds).\r\n  \tflyToBounds: function (bounds, options) {\r\n  \t\tvar target = this._getBoundsCenterZoom(bounds, options);\r\n  \t\treturn this.flyTo(target.center, target.zoom, options);\r\n  \t},\r\n\r\n  \t// @method setMaxBounds(bounds: LatLngBounds): this\r\n  \t// Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).\r\n  \tsetMaxBounds: function (bounds) {\r\n  \t\tbounds = toLatLngBounds(bounds);\r\n\r\n  \t\tif (this.listens('moveend', this._panInsideMaxBounds)) {\r\n  \t\t\tthis.off('moveend', this._panInsideMaxBounds);\r\n  \t\t}\r\n\r\n  \t\tif (!bounds.isValid()) {\r\n  \t\t\tthis.options.maxBounds = null;\r\n  \t\t\treturn this;\r\n  \t\t}\r\n\r\n  \t\tthis.options.maxBounds = bounds;\r\n\r\n  \t\tif (this._loaded) {\r\n  \t\t\tthis._panInsideMaxBounds();\r\n  \t\t}\r\n\r\n  \t\treturn this.on('moveend', this._panInsideMaxBounds);\r\n  \t},\r\n\r\n  \t// @method setMinZoom(zoom: Number): this\r\n  \t// Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).\r\n  \tsetMinZoom: function (zoom) {\r\n  \t\tvar oldZoom = this.options.minZoom;\r\n  \t\tthis.options.minZoom = zoom;\r\n\r\n  \t\tif (this._loaded && oldZoom !== zoom) {\r\n  \t\t\tthis.fire('zoomlevelschange');\r\n\r\n  \t\t\tif (this.getZoom() < this.options.minZoom) {\r\n  \t\t\t\treturn this.setZoom(zoom);\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method setMaxZoom(zoom: Number): this\r\n  \t// Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).\r\n  \tsetMaxZoom: function (zoom) {\r\n  \t\tvar oldZoom = this.options.maxZoom;\r\n  \t\tthis.options.maxZoom = zoom;\r\n\r\n  \t\tif (this._loaded && oldZoom !== zoom) {\r\n  \t\t\tthis.fire('zoomlevelschange');\r\n\r\n  \t\t\tif (this.getZoom() > this.options.maxZoom) {\r\n  \t\t\t\treturn this.setZoom(zoom);\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this\r\n  \t// Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.\r\n  \tpanInsideBounds: function (bounds, options) {\r\n  \t\tthis._enforcingBounds = true;\r\n  \t\tvar center = this.getCenter(),\r\n  \t\t    newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));\r\n\r\n  \t\tif (!center.equals(newCenter)) {\r\n  \t\t\tthis.panTo(newCenter, options);\r\n  \t\t}\r\n\r\n  \t\tthis._enforcingBounds = false;\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method panInside(latlng: LatLng, options?: padding options): this\r\n  \t// Pans the map the minimum amount to make the `latlng` visible. Use\r\n  \t// padding options to fit the display to more restricted bounds.\r\n  \t// If `latlng` is already within the (optionally padded) display bounds,\r\n  \t// the map will not be panned.\r\n  \tpanInside: function (latlng, options) {\r\n  \t\toptions = options || {};\r\n\r\n  \t\tvar paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),\r\n  \t\t    paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),\r\n  \t\t    pixelCenter = this.project(this.getCenter()),\r\n  \t\t    pixelPoint = this.project(latlng),\r\n  \t\t    pixelBounds = this.getPixelBounds(),\r\n  \t\t    paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]),\r\n  \t\t    paddedSize = paddedBounds.getSize();\r\n\r\n  \t\tif (!paddedBounds.contains(pixelPoint)) {\r\n  \t\t\tthis._enforcingBounds = true;\r\n  \t\t\tvar centerOffset = pixelPoint.subtract(paddedBounds.getCenter());\r\n  \t\t\tvar offset = paddedBounds.extend(pixelPoint).getSize().subtract(paddedSize);\r\n  \t\t\tpixelCenter.x += centerOffset.x < 0 ? -offset.x : offset.x;\r\n  \t\t\tpixelCenter.y += centerOffset.y < 0 ? -offset.y : offset.y;\r\n  \t\t\tthis.panTo(this.unproject(pixelCenter), options);\r\n  \t\t\tthis._enforcingBounds = false;\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method invalidateSize(options: Zoom/pan options): this\r\n  \t// Checks if the map container size changed and updates the map if so \r\n  \t// call it after you've changed the map size dynamically, also animating\r\n  \t// pan by default. If `options.pan` is `false`, panning will not occur.\r\n  \t// If `options.debounceMoveend` is `true`, it will delay `moveend` event so\r\n  \t// that it doesn't happen often even if the method is called many\r\n  \t// times in a row.\r\n\r\n  \t// @alternative\r\n  \t// @method invalidateSize(animate: Boolean): this\r\n  \t// Checks if the map container size changed and updates the map if so \r\n  \t// call it after you've changed the map size dynamically, also animating\r\n  \t// pan by default.\r\n  \tinvalidateSize: function (options) {\r\n  \t\tif (!this._loaded) { return this; }\r\n\r\n  \t\toptions = extend({\r\n  \t\t\tanimate: false,\r\n  \t\t\tpan: true\r\n  \t\t}, options === true ? {animate: true} : options);\r\n\r\n  \t\tvar oldSize = this.getSize();\r\n  \t\tthis._sizeChanged = true;\r\n  \t\tthis._lastCenter = null;\r\n\r\n  \t\tvar newSize = this.getSize(),\r\n  \t\t    oldCenter = oldSize.divideBy(2).round(),\r\n  \t\t    newCenter = newSize.divideBy(2).round(),\r\n  \t\t    offset = oldCenter.subtract(newCenter);\r\n\r\n  \t\tif (!offset.x && !offset.y) { return this; }\r\n\r\n  \t\tif (options.animate && options.pan) {\r\n  \t\t\tthis.panBy(offset);\r\n\r\n  \t\t} else {\r\n  \t\t\tif (options.pan) {\r\n  \t\t\t\tthis._rawPanBy(offset);\r\n  \t\t\t}\r\n\r\n  \t\t\tthis.fire('move');\r\n\r\n  \t\t\tif (options.debounceMoveend) {\r\n  \t\t\t\tclearTimeout(this._sizeTimer);\r\n  \t\t\t\tthis._sizeTimer = setTimeout(bind(this.fire, this, 'moveend'), 200);\r\n  \t\t\t} else {\r\n  \t\t\t\tthis.fire('moveend');\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\t// @section Map state change events\r\n  \t\t// @event resize: ResizeEvent\r\n  \t\t// Fired when the map is resized.\r\n  \t\treturn this.fire('resize', {\r\n  \t\t\toldSize: oldSize,\r\n  \t\t\tnewSize: newSize\r\n  \t\t});\r\n  \t},\r\n\r\n  \t// @section Methods for modifying map state\r\n  \t// @method stop(): this\r\n  \t// Stops the currently running `panTo` or `flyTo` animation, if any.\r\n  \tstop: function () {\r\n  \t\tthis.setZoom(this._limitZoom(this._zoom));\r\n  \t\tif (!this.options.zoomSnap) {\r\n  \t\t\tthis.fire('viewreset');\r\n  \t\t}\r\n  \t\treturn this._stop();\r\n  \t},\r\n\r\n  \t// @section Geolocation methods\r\n  \t// @method locate(options?: Locate options): this\r\n  \t// Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)\r\n  \t// event with location data on success or a [`locationerror`](#map-locationerror) event on failure,\r\n  \t// and optionally sets the map view to the user's location with respect to\r\n  \t// detection accuracy (or to the world view if geolocation failed).\r\n  \t// Note that, if your page doesn't use HTTPS, this method will fail in\r\n  \t// modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))\r\n  \t// See `Locate options` for more details.\r\n  \tlocate: function (options) {\r\n\r\n  \t\toptions = this._locateOptions = extend({\r\n  \t\t\ttimeout: 10000,\r\n  \t\t\twatch: false\r\n  \t\t\t// setView: false\r\n  \t\t\t// maxZoom: <Number>\r\n  \t\t\t// maximumAge: 0\r\n  \t\t\t// enableHighAccuracy: false\r\n  \t\t}, options);\r\n\r\n  \t\tif (!('geolocation' in navigator)) {\r\n  \t\t\tthis._handleGeolocationError({\r\n  \t\t\t\tcode: 0,\r\n  \t\t\t\tmessage: 'Geolocation not supported.'\r\n  \t\t\t});\r\n  \t\t\treturn this;\r\n  \t\t}\r\n\r\n  \t\tvar onResponse = bind(this._handleGeolocationResponse, this),\r\n  \t\t    onError = bind(this._handleGeolocationError, this);\r\n\r\n  \t\tif (options.watch) {\r\n  \t\t\tthis._locationWatchId =\r\n  \t\t\t        navigator.geolocation.watchPosition(onResponse, onError, options);\r\n  \t\t} else {\r\n  \t\t\tnavigator.geolocation.getCurrentPosition(onResponse, onError, options);\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method stopLocate(): this\r\n  \t// Stops watching location previously initiated by `map.locate({watch: true})`\r\n  \t// and aborts resetting the map view if map.locate was called with\r\n  \t// `{setView: true}`.\r\n  \tstopLocate: function () {\r\n  \t\tif (navigator.geolocation && navigator.geolocation.clearWatch) {\r\n  \t\t\tnavigator.geolocation.clearWatch(this._locationWatchId);\r\n  \t\t}\r\n  \t\tif (this._locateOptions) {\r\n  \t\t\tthis._locateOptions.setView = false;\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t_handleGeolocationError: function (error) {\r\n  \t\tif (!this._container._leaflet_id) { return; }\r\n\r\n  \t\tvar c = error.code,\r\n  \t\t    message = error.message ||\r\n  \t\t            (c === 1 ? 'permission denied' :\r\n  \t\t            (c === 2 ? 'position unavailable' : 'timeout'));\r\n\r\n  \t\tif (this._locateOptions.setView && !this._loaded) {\r\n  \t\t\tthis.fitWorld();\r\n  \t\t}\r\n\r\n  \t\t// @section Location events\r\n  \t\t// @event locationerror: ErrorEvent\r\n  \t\t// Fired when geolocation (using the [`locate`](#map-locate) method) failed.\r\n  \t\tthis.fire('locationerror', {\r\n  \t\t\tcode: c,\r\n  \t\t\tmessage: 'Geolocation error: ' + message + '.'\r\n  \t\t});\r\n  \t},\r\n\r\n  \t_handleGeolocationResponse: function (pos) {\r\n  \t\tif (!this._container._leaflet_id) { return; }\r\n\r\n  \t\tvar lat = pos.coords.latitude,\r\n  \t\t    lng = pos.coords.longitude,\r\n  \t\t    latlng = new LatLng(lat, lng),\r\n  \t\t    bounds = latlng.toBounds(pos.coords.accuracy * 2),\r\n  \t\t    options = this._locateOptions;\r\n\r\n  \t\tif (options.setView) {\r\n  \t\t\tvar zoom = this.getBoundsZoom(bounds);\r\n  \t\t\tthis.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);\r\n  \t\t}\r\n\r\n  \t\tvar data = {\r\n  \t\t\tlatlng: latlng,\r\n  \t\t\tbounds: bounds,\r\n  \t\t\ttimestamp: pos.timestamp\r\n  \t\t};\r\n\r\n  \t\tfor (var i in pos.coords) {\r\n  \t\t\tif (typeof pos.coords[i] === 'number') {\r\n  \t\t\t\tdata[i] = pos.coords[i];\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\t// @event locationfound: LocationEvent\r\n  \t\t// Fired when geolocation (using the [`locate`](#map-locate) method)\r\n  \t\t// went successfully.\r\n  \t\tthis.fire('locationfound', data);\r\n  \t},\r\n\r\n  \t// TODO Appropriate docs section?\r\n  \t// @section Other Methods\r\n  \t// @method addHandler(name: String, HandlerClass: Function): this\r\n  \t// Adds a new `Handler` to the map, given its name and constructor function.\r\n  \taddHandler: function (name, HandlerClass) {\r\n  \t\tif (!HandlerClass) { return this; }\r\n\r\n  \t\tvar handler = this[name] = new HandlerClass(this);\r\n\r\n  \t\tthis._handlers.push(handler);\r\n\r\n  \t\tif (this.options[name]) {\r\n  \t\t\thandler.enable();\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method remove(): this\r\n  \t// Destroys the map and clears all related event listeners.\r\n  \tremove: function () {\r\n\r\n  \t\tthis._initEvents(true);\r\n  \t\tif (this.options.maxBounds) { this.off('moveend', this._panInsideMaxBounds); }\r\n\r\n  \t\tif (this._containerId !== this._container._leaflet_id) {\r\n  \t\t\tthrow new Error('Map container is being reused by another instance');\r\n  \t\t}\r\n\r\n  \t\ttry {\r\n  \t\t\t// throws error in IE6-8\r\n  \t\t\tdelete this._container._leaflet_id;\r\n  \t\t\tdelete this._containerId;\r\n  \t\t} catch (e) {\r\n  \t\t\t/*eslint-disable */\r\n  \t\t\tthis._container._leaflet_id = undefined;\r\n  \t\t\t/* eslint-enable */\r\n  \t\t\tthis._containerId = undefined;\r\n  \t\t}\r\n\r\n  \t\tif (this._locationWatchId !== undefined) {\r\n  \t\t\tthis.stopLocate();\r\n  \t\t}\r\n\r\n  \t\tthis._stop();\r\n\r\n  \t\tremove(this._mapPane);\r\n\r\n  \t\tif (this._clearControlPos) {\r\n  \t\t\tthis._clearControlPos();\r\n  \t\t}\r\n  \t\tif (this._resizeRequest) {\r\n  \t\t\tcancelAnimFrame(this._resizeRequest);\r\n  \t\t\tthis._resizeRequest = null;\r\n  \t\t}\r\n\r\n  \t\tthis._clearHandlers();\r\n\r\n  \t\tif (this._loaded) {\r\n  \t\t\t// @section Map state change events\r\n  \t\t\t// @event unload: Event\r\n  \t\t\t// Fired when the map is destroyed with [remove](#map-remove) method.\r\n  \t\t\tthis.fire('unload');\r\n  \t\t}\r\n\r\n  \t\tvar i;\r\n  \t\tfor (i in this._layers) {\r\n  \t\t\tthis._layers[i].remove();\r\n  \t\t}\r\n  \t\tfor (i in this._panes) {\r\n  \t\t\tremove(this._panes[i]);\r\n  \t\t}\r\n\r\n  \t\tthis._layers = [];\r\n  \t\tthis._panes = [];\r\n  \t\tdelete this._mapPane;\r\n  \t\tdelete this._renderer;\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @section Other Methods\r\n  \t// @method createPane(name: String, container?: HTMLElement): HTMLElement\r\n  \t// Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,\r\n  \t// then returns it. The pane is created as a child of `container`, or\r\n  \t// as a child of the main map pane if not set.\r\n  \tcreatePane: function (name, container) {\r\n  \t\tvar className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),\r\n  \t\t    pane = create$1('div', className, container || this._mapPane);\r\n\r\n  \t\tif (name) {\r\n  \t\t\tthis._panes[name] = pane;\r\n  \t\t}\r\n  \t\treturn pane;\r\n  \t},\r\n\r\n  \t// @section Methods for Getting Map State\r\n\r\n  \t// @method getCenter(): LatLng\r\n  \t// Returns the geographical center of the map view\r\n  \tgetCenter: function () {\r\n  \t\tthis._checkIfLoaded();\r\n\r\n  \t\tif (this._lastCenter && !this._moved()) {\r\n  \t\t\treturn this._lastCenter.clone();\r\n  \t\t}\r\n  \t\treturn this.layerPointToLatLng(this._getCenterLayerPoint());\r\n  \t},\r\n\r\n  \t// @method getZoom(): Number\r\n  \t// Returns the current zoom level of the map view\r\n  \tgetZoom: function () {\r\n  \t\treturn this._zoom;\r\n  \t},\r\n\r\n  \t// @method getBounds(): LatLngBounds\r\n  \t// Returns the geographical bounds visible in the current map view\r\n  \tgetBounds: function () {\r\n  \t\tvar bounds = this.getPixelBounds(),\r\n  \t\t    sw = this.unproject(bounds.getBottomLeft()),\r\n  \t\t    ne = this.unproject(bounds.getTopRight());\r\n\r\n  \t\treturn new LatLngBounds(sw, ne);\r\n  \t},\r\n\r\n  \t// @method getMinZoom(): Number\r\n  \t// Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.\r\n  \tgetMinZoom: function () {\r\n  \t\treturn this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;\r\n  \t},\r\n\r\n  \t// @method getMaxZoom(): Number\r\n  \t// Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).\r\n  \tgetMaxZoom: function () {\r\n  \t\treturn this.options.maxZoom === undefined ?\r\n  \t\t\t(this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :\r\n  \t\t\tthis.options.maxZoom;\r\n  \t},\r\n\r\n  \t// @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number\r\n  \t// Returns the maximum zoom level on which the given bounds fit to the map\r\n  \t// view in its entirety. If `inside` (optional) is set to `true`, the method\r\n  \t// instead returns the minimum zoom level on which the map view fits into\r\n  \t// the given bounds in its entirety.\r\n  \tgetBoundsZoom: function (bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number\r\n  \t\tbounds = toLatLngBounds(bounds);\r\n  \t\tpadding = toPoint(padding || [0, 0]);\r\n\r\n  \t\tvar zoom = this.getZoom() || 0,\r\n  \t\t    min = this.getMinZoom(),\r\n  \t\t    max = this.getMaxZoom(),\r\n  \t\t    nw = bounds.getNorthWest(),\r\n  \t\t    se = bounds.getSouthEast(),\r\n  \t\t    size = this.getSize().subtract(padding),\r\n  \t\t    boundsSize = toBounds(this.project(se, zoom), this.project(nw, zoom)).getSize(),\r\n  \t\t    snap = Browser.any3d ? this.options.zoomSnap : 1,\r\n  \t\t    scalex = size.x / boundsSize.x,\r\n  \t\t    scaley = size.y / boundsSize.y,\r\n  \t\t    scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);\r\n\r\n  \t\tzoom = this.getScaleZoom(scale, zoom);\r\n\r\n  \t\tif (snap) {\r\n  \t\t\tzoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level\r\n  \t\t\tzoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;\r\n  \t\t}\r\n\r\n  \t\treturn Math.max(min, Math.min(max, zoom));\r\n  \t},\r\n\r\n  \t// @method getSize(): Point\r\n  \t// Returns the current size of the map container (in pixels).\r\n  \tgetSize: function () {\r\n  \t\tif (!this._size || this._sizeChanged) {\r\n  \t\t\tthis._size = new Point(\r\n  \t\t\t\tthis._container.clientWidth || 0,\r\n  \t\t\t\tthis._container.clientHeight || 0);\r\n\r\n  \t\t\tthis._sizeChanged = false;\r\n  \t\t}\r\n  \t\treturn this._size.clone();\r\n  \t},\r\n\r\n  \t// @method getPixelBounds(): Bounds\r\n  \t// Returns the bounds of the current map view in projected pixel\r\n  \t// coordinates (sometimes useful in layer and overlay implementations).\r\n  \tgetPixelBounds: function (center, zoom) {\r\n  \t\tvar topLeftPoint = this._getTopLeftPoint(center, zoom);\r\n  \t\treturn new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));\r\n  \t},\r\n\r\n  \t// TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to\r\n  \t// the map pane? \"left point of the map layer\" can be confusing, specially\r\n  \t// since there can be negative offsets.\r\n  \t// @method getPixelOrigin(): Point\r\n  \t// Returns the projected pixel coordinates of the top left point of\r\n  \t// the map layer (useful in custom layer and overlay implementations).\r\n  \tgetPixelOrigin: function () {\r\n  \t\tthis._checkIfLoaded();\r\n  \t\treturn this._pixelOrigin;\r\n  \t},\r\n\r\n  \t// @method getPixelWorldBounds(zoom?: Number): Bounds\r\n  \t// Returns the world's bounds in pixel coordinates for zoom level `zoom`.\r\n  \t// If `zoom` is omitted, the map's current zoom level is used.\r\n  \tgetPixelWorldBounds: function (zoom) {\r\n  \t\treturn this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);\r\n  \t},\r\n\r\n  \t// @section Other Methods\r\n\r\n  \t// @method getPane(pane: String|HTMLElement): HTMLElement\r\n  \t// Returns a [map pane](#map-pane), given its name or its HTML element (its identity).\r\n  \tgetPane: function (pane) {\r\n  \t\treturn typeof pane === 'string' ? this._panes[pane] : pane;\r\n  \t},\r\n\r\n  \t// @method getPanes(): Object\r\n  \t// Returns a plain object containing the names of all [panes](#map-pane) as keys and\r\n  \t// the panes as values.\r\n  \tgetPanes: function () {\r\n  \t\treturn this._panes;\r\n  \t},\r\n\r\n  \t// @method getContainer: HTMLElement\r\n  \t// Returns the HTML element that contains the map.\r\n  \tgetContainer: function () {\r\n  \t\treturn this._container;\r\n  \t},\r\n\r\n\r\n  \t// @section Conversion Methods\r\n\r\n  \t// @method getZoomScale(toZoom: Number, fromZoom: Number): Number\r\n  \t// Returns the scale factor to be applied to a map transition from zoom level\r\n  \t// `fromZoom` to `toZoom`. Used internally to help with zoom animations.\r\n  \tgetZoomScale: function (toZoom, fromZoom) {\r\n  \t\t// TODO replace with universal implementation after refactoring projections\r\n  \t\tvar crs = this.options.crs;\r\n  \t\tfromZoom = fromZoom === undefined ? this._zoom : fromZoom;\r\n  \t\treturn crs.scale(toZoom) / crs.scale(fromZoom);\r\n  \t},\r\n\r\n  \t// @method getScaleZoom(scale: Number, fromZoom: Number): Number\r\n  \t// Returns the zoom level that the map would end up at, if it is at `fromZoom`\r\n  \t// level and everything is scaled by a factor of `scale`. Inverse of\r\n  \t// [`getZoomScale`](#map-getZoomScale).\r\n  \tgetScaleZoom: function (scale, fromZoom) {\r\n  \t\tvar crs = this.options.crs;\r\n  \t\tfromZoom = fromZoom === undefined ? this._zoom : fromZoom;\r\n  \t\tvar zoom = crs.zoom(scale * crs.scale(fromZoom));\r\n  \t\treturn isNaN(zoom) ? Infinity : zoom;\r\n  \t},\r\n\r\n  \t// @method project(latlng: LatLng, zoom: Number): Point\r\n  \t// Projects a geographical coordinate `LatLng` according to the projection\r\n  \t// of the map's CRS, then scales it according to `zoom` and the CRS's\r\n  \t// `Transformation`. The result is pixel coordinate relative to\r\n  \t// the CRS origin.\r\n  \tproject: function (latlng, zoom) {\r\n  \t\tzoom = zoom === undefined ? this._zoom : zoom;\r\n  \t\treturn this.options.crs.latLngToPoint(toLatLng(latlng), zoom);\r\n  \t},\r\n\r\n  \t// @method unproject(point: Point, zoom: Number): LatLng\r\n  \t// Inverse of [`project`](#map-project).\r\n  \tunproject: function (point, zoom) {\r\n  \t\tzoom = zoom === undefined ? this._zoom : zoom;\r\n  \t\treturn this.options.crs.pointToLatLng(toPoint(point), zoom);\r\n  \t},\r\n\r\n  \t// @method layerPointToLatLng(point: Point): LatLng\r\n  \t// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),\r\n  \t// returns the corresponding geographical coordinate (for the current zoom level).\r\n  \tlayerPointToLatLng: function (point) {\r\n  \t\tvar projectedPoint = toPoint(point).add(this.getPixelOrigin());\r\n  \t\treturn this.unproject(projectedPoint);\r\n  \t},\r\n\r\n  \t// @method latLngToLayerPoint(latlng: LatLng): Point\r\n  \t// Given a geographical coordinate, returns the corresponding pixel coordinate\r\n  \t// relative to the [origin pixel](#map-getpixelorigin).\r\n  \tlatLngToLayerPoint: function (latlng) {\r\n  \t\tvar projectedPoint = this.project(toLatLng(latlng))._round();\r\n  \t\treturn projectedPoint._subtract(this.getPixelOrigin());\r\n  \t},\r\n\r\n  \t// @method wrapLatLng(latlng: LatLng): LatLng\r\n  \t// Returns a `LatLng` where `lat` and `lng` has been wrapped according to the\r\n  \t// map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the\r\n  \t// CRS's bounds.\r\n  \t// By default this means longitude is wrapped around the dateline so its\r\n  \t// value is between -180 and +180 degrees.\r\n  \twrapLatLng: function (latlng) {\r\n  \t\treturn this.options.crs.wrapLatLng(toLatLng(latlng));\r\n  \t},\r\n\r\n  \t// @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds\r\n  \t// Returns a `LatLngBounds` with the same size as the given one, ensuring that\r\n  \t// its center is within the CRS's bounds.\r\n  \t// By default this means the center longitude is wrapped around the dateline so its\r\n  \t// value is between -180 and +180 degrees, and the majority of the bounds\r\n  \t// overlaps the CRS's bounds.\r\n  \twrapLatLngBounds: function (latlng) {\r\n  \t\treturn this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));\r\n  \t},\r\n\r\n  \t// @method distance(latlng1: LatLng, latlng2: LatLng): Number\r\n  \t// Returns the distance between two geographical coordinates according to\r\n  \t// the map's CRS. By default this measures distance in meters.\r\n  \tdistance: function (latlng1, latlng2) {\r\n  \t\treturn this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));\r\n  \t},\r\n\r\n  \t// @method containerPointToLayerPoint(point: Point): Point\r\n  \t// Given a pixel coordinate relative to the map container, returns the corresponding\r\n  \t// pixel coordinate relative to the [origin pixel](#map-getpixelorigin).\r\n  \tcontainerPointToLayerPoint: function (point) { // (Point)\r\n  \t\treturn toPoint(point).subtract(this._getMapPanePos());\r\n  \t},\r\n\r\n  \t// @method layerPointToContainerPoint(point: Point): Point\r\n  \t// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),\r\n  \t// returns the corresponding pixel coordinate relative to the map container.\r\n  \tlayerPointToContainerPoint: function (point) { // (Point)\r\n  \t\treturn toPoint(point).add(this._getMapPanePos());\r\n  \t},\r\n\r\n  \t// @method containerPointToLatLng(point: Point): LatLng\r\n  \t// Given a pixel coordinate relative to the map container, returns\r\n  \t// the corresponding geographical coordinate (for the current zoom level).\r\n  \tcontainerPointToLatLng: function (point) {\r\n  \t\tvar layerPoint = this.containerPointToLayerPoint(toPoint(point));\r\n  \t\treturn this.layerPointToLatLng(layerPoint);\r\n  \t},\r\n\r\n  \t// @method latLngToContainerPoint(latlng: LatLng): Point\r\n  \t// Given a geographical coordinate, returns the corresponding pixel coordinate\r\n  \t// relative to the map container.\r\n  \tlatLngToContainerPoint: function (latlng) {\r\n  \t\treturn this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));\r\n  \t},\r\n\r\n  \t// @method mouseEventToContainerPoint(ev: MouseEvent): Point\r\n  \t// Given a MouseEvent object, returns the pixel coordinate relative to the\r\n  \t// map container where the event took place.\r\n  \tmouseEventToContainerPoint: function (e) {\r\n  \t\treturn getMousePosition(e, this._container);\r\n  \t},\r\n\r\n  \t// @method mouseEventToLayerPoint(ev: MouseEvent): Point\r\n  \t// Given a MouseEvent object, returns the pixel coordinate relative to\r\n  \t// the [origin pixel](#map-getpixelorigin) where the event took place.\r\n  \tmouseEventToLayerPoint: function (e) {\r\n  \t\treturn this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));\r\n  \t},\r\n\r\n  \t// @method mouseEventToLatLng(ev: MouseEvent): LatLng\r\n  \t// Given a MouseEvent object, returns geographical coordinate where the\r\n  \t// event took place.\r\n  \tmouseEventToLatLng: function (e) { // (MouseEvent)\r\n  \t\treturn this.layerPointToLatLng(this.mouseEventToLayerPoint(e));\r\n  \t},\r\n\r\n\r\n  \t// map initialization methods\r\n\r\n  \t_initContainer: function (id) {\r\n  \t\tvar container = this._container = get(id);\r\n\r\n  \t\tif (!container) {\r\n  \t\t\tthrow new Error('Map container not found.');\r\n  \t\t} else if (container._leaflet_id) {\r\n  \t\t\tthrow new Error('Map container is already initialized.');\r\n  \t\t}\r\n\r\n  \t\ton(container, 'scroll', this._onScroll, this);\r\n  \t\tthis._containerId = stamp(container);\r\n  \t},\r\n\r\n  \t_initLayout: function () {\r\n  \t\tvar container = this._container;\r\n\r\n  \t\tthis._fadeAnimated = this.options.fadeAnimation && Browser.any3d;\r\n\r\n  \t\taddClass(container, 'leaflet-container' +\r\n  \t\t\t(Browser.touch ? ' leaflet-touch' : '') +\r\n  \t\t\t(Browser.retina ? ' leaflet-retina' : '') +\r\n  \t\t\t(Browser.ielt9 ? ' leaflet-oldie' : '') +\r\n  \t\t\t(Browser.safari ? ' leaflet-safari' : '') +\r\n  \t\t\t(this._fadeAnimated ? ' leaflet-fade-anim' : ''));\r\n\r\n  \t\tvar position = getStyle(container, 'position');\r\n\r\n  \t\tif (position !== 'absolute' && position !== 'relative' && position !== 'fixed' && position !== 'sticky') {\r\n  \t\t\tcontainer.style.position = 'relative';\r\n  \t\t}\r\n\r\n  \t\tthis._initPanes();\r\n\r\n  \t\tif (this._initControlPos) {\r\n  \t\t\tthis._initControlPos();\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_initPanes: function () {\r\n  \t\tvar panes = this._panes = {};\r\n  \t\tthis._paneRenderers = {};\r\n\r\n  \t\t// @section\r\n  \t\t//\r\n  \t\t// Panes are DOM elements used to control the ordering of layers on the map. You\r\n  \t\t// can access panes with [`map.getPane`](#map-getpane) or\r\n  \t\t// [`map.getPanes`](#map-getpanes) methods. New panes can be created with the\r\n  \t\t// [`map.createPane`](#map-createpane) method.\r\n  \t\t//\r\n  \t\t// Every map has the following default panes that differ only in zIndex.\r\n  \t\t//\r\n  \t\t// @pane mapPane: HTMLElement = 'auto'\r\n  \t\t// Pane that contains all other map panes\r\n\r\n  \t\tthis._mapPane = this.createPane('mapPane', this._container);\r\n  \t\tsetPosition(this._mapPane, new Point(0, 0));\r\n\r\n  \t\t// @pane tilePane: HTMLElement = 200\r\n  \t\t// Pane for `GridLayer`s and `TileLayer`s\r\n  \t\tthis.createPane('tilePane');\r\n  \t\t// @pane overlayPane: HTMLElement = 400\r\n  \t\t// Pane for vectors (`Path`s, like `Polyline`s and `Polygon`s), `ImageOverlay`s and `VideoOverlay`s\r\n  \t\tthis.createPane('overlayPane');\r\n  \t\t// @pane shadowPane: HTMLElement = 500\r\n  \t\t// Pane for overlay shadows (e.g. `Marker` shadows)\r\n  \t\tthis.createPane('shadowPane');\r\n  \t\t// @pane markerPane: HTMLElement = 600\r\n  \t\t// Pane for `Icon`s of `Marker`s\r\n  \t\tthis.createPane('markerPane');\r\n  \t\t// @pane tooltipPane: HTMLElement = 650\r\n  \t\t// Pane for `Tooltip`s.\r\n  \t\tthis.createPane('tooltipPane');\r\n  \t\t// @pane popupPane: HTMLElement = 700\r\n  \t\t// Pane for `Popup`s.\r\n  \t\tthis.createPane('popupPane');\r\n\r\n  \t\tif (!this.options.markerZoomAnimation) {\r\n  \t\t\taddClass(panes.markerPane, 'leaflet-zoom-hide');\r\n  \t\t\taddClass(panes.shadowPane, 'leaflet-zoom-hide');\r\n  \t\t}\r\n  \t},\r\n\r\n\r\n  \t// private methods that modify map state\r\n\r\n  \t// @section Map state change events\r\n  \t_resetView: function (center, zoom, noMoveStart) {\r\n  \t\tsetPosition(this._mapPane, new Point(0, 0));\r\n\r\n  \t\tvar loading = !this._loaded;\r\n  \t\tthis._loaded = true;\r\n  \t\tzoom = this._limitZoom(zoom);\r\n\r\n  \t\tthis.fire('viewprereset');\r\n\r\n  \t\tvar zoomChanged = this._zoom !== zoom;\r\n  \t\tthis\r\n  \t\t\t._moveStart(zoomChanged, noMoveStart)\r\n  \t\t\t._move(center, zoom)\r\n  \t\t\t._moveEnd(zoomChanged);\r\n\r\n  \t\t// @event viewreset: Event\r\n  \t\t// Fired when the map needs to redraw its content (this usually happens\r\n  \t\t// on map zoom or load). Very useful for creating custom overlays.\r\n  \t\tthis.fire('viewreset');\r\n\r\n  \t\t// @event load: Event\r\n  \t\t// Fired when the map is initialized (when its center and zoom are set\r\n  \t\t// for the first time).\r\n  \t\tif (loading) {\r\n  \t\t\tthis.fire('load');\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_moveStart: function (zoomChanged, noMoveStart) {\r\n  \t\t// @event zoomstart: Event\r\n  \t\t// Fired when the map zoom is about to change (e.g. before zoom animation).\r\n  \t\t// @event movestart: Event\r\n  \t\t// Fired when the view of the map starts changing (e.g. user starts dragging the map).\r\n  \t\tif (zoomChanged) {\r\n  \t\t\tthis.fire('zoomstart');\r\n  \t\t}\r\n  \t\tif (!noMoveStart) {\r\n  \t\t\tthis.fire('movestart');\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t_move: function (center, zoom, data, supressEvent) {\r\n  \t\tif (zoom === undefined) {\r\n  \t\t\tzoom = this._zoom;\r\n  \t\t}\r\n  \t\tvar zoomChanged = this._zoom !== zoom;\r\n\r\n  \t\tthis._zoom = zoom;\r\n  \t\tthis._lastCenter = center;\r\n  \t\tthis._pixelOrigin = this._getNewPixelOrigin(center);\r\n\r\n  \t\tif (!supressEvent) {\r\n  \t\t\t// @event zoom: Event\r\n  \t\t\t// Fired repeatedly during any change in zoom level,\r\n  \t\t\t// including zoom and fly animations.\r\n  \t\t\tif (zoomChanged || (data && data.pinch)) {\t// Always fire 'zoom' if pinching because #3530\r\n  \t\t\t\tthis.fire('zoom', data);\r\n  \t\t\t}\r\n\r\n  \t\t\t// @event move: Event\r\n  \t\t\t// Fired repeatedly during any movement of the map,\r\n  \t\t\t// including pan and fly animations.\r\n  \t\t\tthis.fire('move', data);\r\n  \t\t} else if (data && data.pinch) {\t// Always fire 'zoom' if pinching because #3530\r\n  \t\t\tthis.fire('zoom', data);\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t_moveEnd: function (zoomChanged) {\r\n  \t\t// @event zoomend: Event\r\n  \t\t// Fired when the map zoom changed, after any animations.\r\n  \t\tif (zoomChanged) {\r\n  \t\t\tthis.fire('zoomend');\r\n  \t\t}\r\n\r\n  \t\t// @event moveend: Event\r\n  \t\t// Fired when the center of the map stops changing\r\n  \t\t// (e.g. user stopped dragging the map or after non-centered zoom).\r\n  \t\treturn this.fire('moveend');\r\n  \t},\r\n\r\n  \t_stop: function () {\r\n  \t\tcancelAnimFrame(this._flyToFrame);\r\n  \t\tif (this._panAnim) {\r\n  \t\t\tthis._panAnim.stop();\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t_rawPanBy: function (offset) {\r\n  \t\tsetPosition(this._mapPane, this._getMapPanePos().subtract(offset));\r\n  \t},\r\n\r\n  \t_getZoomSpan: function () {\r\n  \t\treturn this.getMaxZoom() - this.getMinZoom();\r\n  \t},\r\n\r\n  \t_panInsideMaxBounds: function () {\r\n  \t\tif (!this._enforcingBounds) {\r\n  \t\t\tthis.panInsideBounds(this.options.maxBounds);\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_checkIfLoaded: function () {\r\n  \t\tif (!this._loaded) {\r\n  \t\t\tthrow new Error('Set map center and zoom first.');\r\n  \t\t}\r\n  \t},\r\n\r\n  \t// DOM event handling\r\n\r\n  \t// @section Interaction events\r\n  \t_initEvents: function (remove) {\r\n  \t\tthis._targets = {};\r\n  \t\tthis._targets[stamp(this._container)] = this;\r\n\r\n  \t\tvar onOff = remove ? off : on;\r\n\r\n  \t\t// @event click: MouseEvent\r\n  \t\t// Fired when the user clicks (or taps) the map.\r\n  \t\t// @event dblclick: MouseEvent\r\n  \t\t// Fired when the user double-clicks (or double-taps) the map.\r\n  \t\t// @event mousedown: MouseEvent\r\n  \t\t// Fired when the user pushes the mouse button on the map.\r\n  \t\t// @event mouseup: MouseEvent\r\n  \t\t// Fired when the user releases the mouse button on the map.\r\n  \t\t// @event mouseover: MouseEvent\r\n  \t\t// Fired when the mouse enters the map.\r\n  \t\t// @event mouseout: MouseEvent\r\n  \t\t// Fired when the mouse leaves the map.\r\n  \t\t// @event mousemove: MouseEvent\r\n  \t\t// Fired while the mouse moves over the map.\r\n  \t\t// @event contextmenu: MouseEvent\r\n  \t\t// Fired when the user pushes the right mouse button on the map, prevents\r\n  \t\t// default browser context menu from showing if there are listeners on\r\n  \t\t// this event. Also fired on mobile when the user holds a single touch\r\n  \t\t// for a second (also called long press).\r\n  \t\t// @event keypress: KeyboardEvent\r\n  \t\t// Fired when the user presses a key from the keyboard that produces a character value while the map is focused.\r\n  \t\t// @event keydown: KeyboardEvent\r\n  \t\t// Fired when the user presses a key from the keyboard while the map is focused. Unlike the `keypress` event,\r\n  \t\t// the `keydown` event is fired for keys that produce a character value and for keys\r\n  \t\t// that do not produce a character value.\r\n  \t\t// @event keyup: KeyboardEvent\r\n  \t\t// Fired when the user releases a key from the keyboard while the map is focused.\r\n  \t\tonOff(this._container, 'click dblclick mousedown mouseup ' +\r\n  \t\t\t'mouseover mouseout mousemove contextmenu keypress keydown keyup', this._handleDOMEvent, this);\r\n\r\n  \t\tif (this.options.trackResize) {\r\n  \t\t\tonOff(window, 'resize', this._onResize, this);\r\n  \t\t}\r\n\r\n  \t\tif (Browser.any3d && this.options.transform3DLimit) {\r\n  \t\t\t(remove ? this.off : this.on).call(this, 'moveend', this._onMoveEnd);\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_onResize: function () {\r\n  \t\tcancelAnimFrame(this._resizeRequest);\r\n  \t\tthis._resizeRequest = requestAnimFrame(\r\n  \t\t        function () { this.invalidateSize({debounceMoveend: true}); }, this);\r\n  \t},\r\n\r\n  \t_onScroll: function () {\r\n  \t\tthis._container.scrollTop  = 0;\r\n  \t\tthis._container.scrollLeft = 0;\r\n  \t},\r\n\r\n  \t_onMoveEnd: function () {\r\n  \t\tvar pos = this._getMapPanePos();\r\n  \t\tif (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {\r\n  \t\t\t// https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have\r\n  \t\t\t// a pixel offset on very high values, see: https://jsfiddle.net/dg6r5hhb/\r\n  \t\t\tthis._resetView(this.getCenter(), this.getZoom());\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_findEventTargets: function (e, type) {\r\n  \t\tvar targets = [],\r\n  \t\t    target,\r\n  \t\t    isHover = type === 'mouseout' || type === 'mouseover',\r\n  \t\t    src = e.target || e.srcElement,\r\n  \t\t    dragging = false;\r\n\r\n  \t\twhile (src) {\r\n  \t\t\ttarget = this._targets[stamp(src)];\r\n  \t\t\tif (target && (type === 'click' || type === 'preclick') && this._draggableMoved(target)) {\r\n  \t\t\t\t// Prevent firing click after you just dragged an object.\r\n  \t\t\t\tdragging = true;\r\n  \t\t\t\tbreak;\r\n  \t\t\t}\r\n  \t\t\tif (target && target.listens(type, true)) {\r\n  \t\t\t\tif (isHover && !isExternalTarget(src, e)) { break; }\r\n  \t\t\t\ttargets.push(target);\r\n  \t\t\t\tif (isHover) { break; }\r\n  \t\t\t}\r\n  \t\t\tif (src === this._container) { break; }\r\n  \t\t\tsrc = src.parentNode;\r\n  \t\t}\r\n  \t\tif (!targets.length && !dragging && !isHover && this.listens(type, true)) {\r\n  \t\t\ttargets = [this];\r\n  \t\t}\r\n  \t\treturn targets;\r\n  \t},\r\n\r\n  \t_isClickDisabled: function (el) {\r\n  \t\twhile (el && el !== this._container) {\r\n  \t\t\tif (el['_leaflet_disable_click']) { return true; }\r\n  \t\t\tel = el.parentNode;\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_handleDOMEvent: function (e) {\r\n  \t\tvar el = (e.target || e.srcElement);\r\n  \t\tif (!this._loaded || el['_leaflet_disable_events'] || e.type === 'click' && this._isClickDisabled(el)) {\r\n  \t\t\treturn;\r\n  \t\t}\r\n\r\n  \t\tvar type = e.type;\r\n\r\n  \t\tif (type === 'mousedown') {\r\n  \t\t\t// prevents outline when clicking on keyboard-focusable element\r\n  \t\t\tpreventOutline(el);\r\n  \t\t}\r\n\r\n  \t\tthis._fireDOMEvent(e, type);\r\n  \t},\r\n\r\n  \t_mouseEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu'],\r\n\r\n  \t_fireDOMEvent: function (e, type, canvasTargets) {\r\n\r\n  \t\tif (e.type === 'click') {\r\n  \t\t\t// Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).\r\n  \t\t\t// @event preclick: MouseEvent\r\n  \t\t\t// Fired before mouse click on the map (sometimes useful when you\r\n  \t\t\t// want something to happen on click before any existing click\r\n  \t\t\t// handlers start running).\r\n  \t\t\tvar synth = extend({}, e);\r\n  \t\t\tsynth.type = 'preclick';\r\n  \t\t\tthis._fireDOMEvent(synth, synth.type, canvasTargets);\r\n  \t\t}\r\n\r\n  \t\t// Find the layer the event is propagating from and its parents.\r\n  \t\tvar targets = this._findEventTargets(e, type);\r\n\r\n  \t\tif (canvasTargets) {\r\n  \t\t\tvar filtered = []; // pick only targets with listeners\r\n  \t\t\tfor (var i = 0; i < canvasTargets.length; i++) {\r\n  \t\t\t\tif (canvasTargets[i].listens(type, true)) {\r\n  \t\t\t\t\tfiltered.push(canvasTargets[i]);\r\n  \t\t\t\t}\r\n  \t\t\t}\r\n  \t\t\ttargets = filtered.concat(targets);\r\n  \t\t}\r\n\r\n  \t\tif (!targets.length) { return; }\r\n\r\n  \t\tif (type === 'contextmenu') {\r\n  \t\t\tpreventDefault(e);\r\n  \t\t}\r\n\r\n  \t\tvar target = targets[0];\r\n  \t\tvar data = {\r\n  \t\t\toriginalEvent: e\r\n  \t\t};\r\n\r\n  \t\tif (e.type !== 'keypress' && e.type !== 'keydown' && e.type !== 'keyup') {\r\n  \t\t\tvar isMarker = target.getLatLng && (!target._radius || target._radius <= 10);\r\n  \t\t\tdata.containerPoint = isMarker ?\r\n  \t\t\t\tthis.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);\r\n  \t\t\tdata.layerPoint = this.containerPointToLayerPoint(data.containerPoint);\r\n  \t\t\tdata.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);\r\n  \t\t}\r\n\r\n  \t\tfor (i = 0; i < targets.length; i++) {\r\n  \t\t\ttargets[i].fire(type, data, true);\r\n  \t\t\tif (data.originalEvent._stopped ||\r\n  \t\t\t\t(targets[i].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1)) { return; }\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_draggableMoved: function (obj) {\r\n  \t\tobj = obj.dragging && obj.dragging.enabled() ? obj : this;\r\n  \t\treturn (obj.dragging && obj.dragging.moved()) || (this.boxZoom && this.boxZoom.moved());\r\n  \t},\r\n\r\n  \t_clearHandlers: function () {\r\n  \t\tfor (var i = 0, len = this._handlers.length; i < len; i++) {\r\n  \t\t\tthis._handlers[i].disable();\r\n  \t\t}\r\n  \t},\r\n\r\n  \t// @section Other Methods\r\n\r\n  \t// @method whenReady(fn: Function, context?: Object): this\r\n  \t// Runs the given function `fn` when the map gets initialized with\r\n  \t// a view (center and zoom) and at least one layer, or immediately\r\n  \t// if it's already initialized, optionally passing a function context.\r\n  \twhenReady: function (callback, context) {\r\n  \t\tif (this._loaded) {\r\n  \t\t\tcallback.call(context || this, {target: this});\r\n  \t\t} else {\r\n  \t\t\tthis.on('load', callback, context);\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n\r\n  \t// private methods for getting map state\r\n\r\n  \t_getMapPanePos: function () {\r\n  \t\treturn getPosition(this._mapPane) || new Point(0, 0);\r\n  \t},\r\n\r\n  \t_moved: function () {\r\n  \t\tvar pos = this._getMapPanePos();\r\n  \t\treturn pos && !pos.equals([0, 0]);\r\n  \t},\r\n\r\n  \t_getTopLeftPoint: function (center, zoom) {\r\n  \t\tvar pixelOrigin = center && zoom !== undefined ?\r\n  \t\t\tthis._getNewPixelOrigin(center, zoom) :\r\n  \t\t\tthis.getPixelOrigin();\r\n  \t\treturn pixelOrigin.subtract(this._getMapPanePos());\r\n  \t},\r\n\r\n  \t_getNewPixelOrigin: function (center, zoom) {\r\n  \t\tvar viewHalf = this.getSize()._divideBy(2);\r\n  \t\treturn this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();\r\n  \t},\r\n\r\n  \t_latLngToNewLayerPoint: function (latlng, zoom, center) {\r\n  \t\tvar topLeft = this._getNewPixelOrigin(center, zoom);\r\n  \t\treturn this.project(latlng, zoom)._subtract(topLeft);\r\n  \t},\r\n\r\n  \t_latLngBoundsToNewLayerBounds: function (latLngBounds, zoom, center) {\r\n  \t\tvar topLeft = this._getNewPixelOrigin(center, zoom);\r\n  \t\treturn toBounds([\r\n  \t\t\tthis.project(latLngBounds.getSouthWest(), zoom)._subtract(topLeft),\r\n  \t\t\tthis.project(latLngBounds.getNorthWest(), zoom)._subtract(topLeft),\r\n  \t\t\tthis.project(latLngBounds.getSouthEast(), zoom)._subtract(topLeft),\r\n  \t\t\tthis.project(latLngBounds.getNorthEast(), zoom)._subtract(topLeft)\r\n  \t\t]);\r\n  \t},\r\n\r\n  \t// layer point of the current center\r\n  \t_getCenterLayerPoint: function () {\r\n  \t\treturn this.containerPointToLayerPoint(this.getSize()._divideBy(2));\r\n  \t},\r\n\r\n  \t// offset of the specified place to the current center in pixels\r\n  \t_getCenterOffset: function (latlng) {\r\n  \t\treturn this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());\r\n  \t},\r\n\r\n  \t// adjust center for view to get inside bounds\r\n  \t_limitCenter: function (center, zoom, bounds) {\r\n\r\n  \t\tif (!bounds) { return center; }\r\n\r\n  \t\tvar centerPoint = this.project(center, zoom),\r\n  \t\t    viewHalf = this.getSize().divideBy(2),\r\n  \t\t    viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),\r\n  \t\t    offset = this._getBoundsOffset(viewBounds, bounds, zoom);\r\n\r\n  \t\t// If offset is less than a pixel, ignore.\r\n  \t\t// This prevents unstable projections from getting into\r\n  \t\t// an infinite loop of tiny offsets.\r\n  \t\tif (Math.abs(offset.x) <= 1 && Math.abs(offset.y) <= 1) {\r\n  \t\t\treturn center;\r\n  \t\t}\r\n\r\n  \t\treturn this.unproject(centerPoint.add(offset), zoom);\r\n  \t},\r\n\r\n  \t// adjust offset for view to get inside bounds\r\n  \t_limitOffset: function (offset, bounds) {\r\n  \t\tif (!bounds) { return offset; }\r\n\r\n  \t\tvar viewBounds = this.getPixelBounds(),\r\n  \t\t    newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));\r\n\r\n  \t\treturn offset.add(this._getBoundsOffset(newBounds, bounds));\r\n  \t},\r\n\r\n  \t// returns offset needed for pxBounds to get inside maxBounds at a specified zoom\r\n  \t_getBoundsOffset: function (pxBounds, maxBounds, zoom) {\r\n  \t\tvar projectedMaxBounds = toBounds(\r\n  \t\t        this.project(maxBounds.getNorthEast(), zoom),\r\n  \t\t        this.project(maxBounds.getSouthWest(), zoom)\r\n  \t\t    ),\r\n  \t\t    minOffset = projectedMaxBounds.min.subtract(pxBounds.min),\r\n  \t\t    maxOffset = projectedMaxBounds.max.subtract(pxBounds.max),\r\n\r\n  \t\t    dx = this._rebound(minOffset.x, -maxOffset.x),\r\n  \t\t    dy = this._rebound(minOffset.y, -maxOffset.y);\r\n\r\n  \t\treturn new Point(dx, dy);\r\n  \t},\r\n\r\n  \t_rebound: function (left, right) {\r\n  \t\treturn left + right > 0 ?\r\n  \t\t\tMath.round(left - right) / 2 :\r\n  \t\t\tMath.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));\r\n  \t},\r\n\r\n  \t_limitZoom: function (zoom) {\r\n  \t\tvar min = this.getMinZoom(),\r\n  \t\t    max = this.getMaxZoom(),\r\n  \t\t    snap = Browser.any3d ? this.options.zoomSnap : 1;\r\n  \t\tif (snap) {\r\n  \t\t\tzoom = Math.round(zoom / snap) * snap;\r\n  \t\t}\r\n  \t\treturn Math.max(min, Math.min(max, zoom));\r\n  \t},\r\n\r\n  \t_onPanTransitionStep: function () {\r\n  \t\tthis.fire('move');\r\n  \t},\r\n\r\n  \t_onPanTransitionEnd: function () {\r\n  \t\tremoveClass(this._mapPane, 'leaflet-pan-anim');\r\n  \t\tthis.fire('moveend');\r\n  \t},\r\n\r\n  \t_tryAnimatedPan: function (center, options) {\r\n  \t\t// difference between the new and current centers in pixels\r\n  \t\tvar offset = this._getCenterOffset(center)._trunc();\r\n\r\n  \t\t// don't animate too far unless animate: true specified in options\r\n  \t\tif ((options && options.animate) !== true && !this.getSize().contains(offset)) { return false; }\r\n\r\n  \t\tthis.panBy(offset, options);\r\n\r\n  \t\treturn true;\r\n  \t},\r\n\r\n  \t_createAnimProxy: function () {\r\n\r\n  \t\tvar proxy = this._proxy = create$1('div', 'leaflet-proxy leaflet-zoom-animated');\r\n  \t\tthis._panes.mapPane.appendChild(proxy);\r\n\r\n  \t\tthis.on('zoomanim', function (e) {\r\n  \t\t\tvar prop = TRANSFORM,\r\n  \t\t\t    transform = this._proxy.style[prop];\r\n\r\n  \t\t\tsetTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));\r\n\r\n  \t\t\t// workaround for case when transform is the same and so transitionend event is not fired\r\n  \t\t\tif (transform === this._proxy.style[prop] && this._animatingZoom) {\r\n  \t\t\t\tthis._onZoomTransitionEnd();\r\n  \t\t\t}\r\n  \t\t}, this);\r\n\r\n  \t\tthis.on('load moveend', this._animMoveEnd, this);\r\n\r\n  \t\tthis._on('unload', this._destroyAnimProxy, this);\r\n  \t},\r\n\r\n  \t_destroyAnimProxy: function () {\r\n  \t\tremove(this._proxy);\r\n  \t\tthis.off('load moveend', this._animMoveEnd, this);\r\n  \t\tdelete this._proxy;\r\n  \t},\r\n\r\n  \t_animMoveEnd: function () {\r\n  \t\tvar c = this.getCenter(),\r\n  \t\t    z = this.getZoom();\r\n  \t\tsetTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));\r\n  \t},\r\n\r\n  \t_catchTransitionEnd: function (e) {\r\n  \t\tif (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {\r\n  \t\t\tthis._onZoomTransitionEnd();\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_nothingToAnimate: function () {\r\n  \t\treturn !this._container.getElementsByClassName('leaflet-zoom-animated').length;\r\n  \t},\r\n\r\n  \t_tryAnimatedZoom: function (center, zoom, options) {\r\n\r\n  \t\tif (this._animatingZoom) { return true; }\r\n\r\n  \t\toptions = options || {};\r\n\r\n  \t\t// don't animate if disabled, not supported or zoom difference is too large\r\n  \t\tif (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||\r\n  \t\t        Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) { return false; }\r\n\r\n  \t\t// offset is the pixel coords of the zoom origin relative to the current center\r\n  \t\tvar scale = this.getZoomScale(zoom),\r\n  \t\t    offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);\r\n\r\n  \t\t// don't animate if the zoom origin isn't within one screen from the current center, unless forced\r\n  \t\tif (options.animate !== true && !this.getSize().contains(offset)) { return false; }\r\n\r\n  \t\trequestAnimFrame(function () {\r\n  \t\t\tthis\r\n  \t\t\t    ._moveStart(true, false)\r\n  \t\t\t    ._animateZoom(center, zoom, true);\r\n  \t\t}, this);\r\n\r\n  \t\treturn true;\r\n  \t},\r\n\r\n  \t_animateZoom: function (center, zoom, startAnim, noUpdate) {\r\n  \t\tif (!this._mapPane) { return; }\r\n\r\n  \t\tif (startAnim) {\r\n  \t\t\tthis._animatingZoom = true;\r\n\r\n  \t\t\t// remember what center/zoom to set after animation\r\n  \t\t\tthis._animateToCenter = center;\r\n  \t\t\tthis._animateToZoom = zoom;\r\n\r\n  \t\t\taddClass(this._mapPane, 'leaflet-zoom-anim');\r\n  \t\t}\r\n\r\n  \t\t// @section Other Events\r\n  \t\t// @event zoomanim: ZoomAnimEvent\r\n  \t\t// Fired at least once per zoom animation. For continuous zoom, like pinch zooming, fired once per frame during zoom.\r\n  \t\tthis.fire('zoomanim', {\r\n  \t\t\tcenter: center,\r\n  \t\t\tzoom: zoom,\r\n  \t\t\tnoUpdate: noUpdate\r\n  \t\t});\r\n\r\n  \t\tif (!this._tempFireZoomEvent) {\r\n  \t\t\tthis._tempFireZoomEvent = this._zoom !== this._animateToZoom;\r\n  \t\t}\r\n\r\n  \t\tthis._move(this._animateToCenter, this._animateToZoom, undefined, true);\r\n\r\n  \t\t// Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693\r\n  \t\tsetTimeout(bind(this._onZoomTransitionEnd, this), 250);\r\n  \t},\r\n\r\n  \t_onZoomTransitionEnd: function () {\r\n  \t\tif (!this._animatingZoom) { return; }\r\n\r\n  \t\tif (this._mapPane) {\r\n  \t\t\tremoveClass(this._mapPane, 'leaflet-zoom-anim');\r\n  \t\t}\r\n\r\n  \t\tthis._animatingZoom = false;\r\n\r\n  \t\tthis._move(this._animateToCenter, this._animateToZoom, undefined, true);\r\n\r\n  \t\tif (this._tempFireZoomEvent) {\r\n  \t\t\tthis.fire('zoom');\r\n  \t\t}\r\n  \t\tdelete this._tempFireZoomEvent;\r\n\r\n  \t\tthis.fire('move');\r\n\r\n  \t\tthis._moveEnd(true);\r\n  \t}\r\n  });\r\n\r\n  // @section\r\n\r\n  // @factory L.map(id: String, options?: Map options)\r\n  // Instantiates a map object given the DOM ID of a `<div>` element\r\n  // and optionally an object literal with `Map options`.\r\n  //\r\n  // @alternative\r\n  // @factory L.map(el: HTMLElement, options?: Map options)\r\n  // Instantiates a map object given an instance of a `<div>` HTML element\r\n  // and optionally an object literal with `Map options`.\r\n  function createMap(id, options) {\r\n  \treturn new Map(id, options);\r\n  }\n\n  /*\r\n   * @class Control\r\n   * @aka L.Control\r\n   * @inherits Class\r\n   *\r\n   * L.Control is a base class for implementing map controls. Handles positioning.\r\n   * All other controls extend from this class.\r\n   */\r\n\r\n  var Control = Class.extend({\r\n  \t// @section\r\n  \t// @aka Control Options\r\n  \toptions: {\r\n  \t\t// @option position: String = 'topright'\r\n  \t\t// The position of the control (one of the map corners). Possible values are `'topleft'`,\r\n  \t\t// `'topright'`, `'bottomleft'` or `'bottomright'`\r\n  \t\tposition: 'topright'\r\n  \t},\r\n\r\n  \tinitialize: function (options) {\r\n  \t\tsetOptions(this, options);\r\n  \t},\r\n\r\n  \t/* @section\r\n  \t * Classes extending L.Control will inherit the following methods:\r\n  \t *\r\n  \t * @method getPosition: string\r\n  \t * Returns the position of the control.\r\n  \t */\r\n  \tgetPosition: function () {\r\n  \t\treturn this.options.position;\r\n  \t},\r\n\r\n  \t// @method setPosition(position: string): this\r\n  \t// Sets the position of the control.\r\n  \tsetPosition: function (position) {\r\n  \t\tvar map = this._map;\r\n\r\n  \t\tif (map) {\r\n  \t\t\tmap.removeControl(this);\r\n  \t\t}\r\n\r\n  \t\tthis.options.position = position;\r\n\r\n  \t\tif (map) {\r\n  \t\t\tmap.addControl(this);\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method getContainer: HTMLElement\r\n  \t// Returns the HTMLElement that contains the control.\r\n  \tgetContainer: function () {\r\n  \t\treturn this._container;\r\n  \t},\r\n\r\n  \t// @method addTo(map: Map): this\r\n  \t// Adds the control to the given map.\r\n  \taddTo: function (map) {\r\n  \t\tthis.remove();\r\n  \t\tthis._map = map;\r\n\r\n  \t\tvar container = this._container = this.onAdd(map),\r\n  \t\t    pos = this.getPosition(),\r\n  \t\t    corner = map._controlCorners[pos];\r\n\r\n  \t\taddClass(container, 'leaflet-control');\r\n\r\n  \t\tif (pos.indexOf('bottom') !== -1) {\r\n  \t\t\tcorner.insertBefore(container, corner.firstChild);\r\n  \t\t} else {\r\n  \t\t\tcorner.appendChild(container);\r\n  \t\t}\r\n\r\n  \t\tthis._map.on('unload', this.remove, this);\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method remove: this\r\n  \t// Removes the control from the map it is currently active on.\r\n  \tremove: function () {\r\n  \t\tif (!this._map) {\r\n  \t\t\treturn this;\r\n  \t\t}\r\n\r\n  \t\tremove(this._container);\r\n\r\n  \t\tif (this.onRemove) {\r\n  \t\t\tthis.onRemove(this._map);\r\n  \t\t}\r\n\r\n  \t\tthis._map.off('unload', this.remove, this);\r\n  \t\tthis._map = null;\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t_refocusOnMap: function (e) {\r\n  \t\t// if map exists and event is not a keyboard event\r\n  \t\tif (this._map && e && e.screenX > 0 && e.screenY > 0) {\r\n  \t\t\tthis._map.getContainer().focus();\r\n  \t\t}\r\n  \t}\r\n  });\r\n\r\n  var control = function (options) {\r\n  \treturn new Control(options);\r\n  };\r\n\r\n  /* @section Extension methods\r\n   * @uninheritable\r\n   *\r\n   * Every control should extend from `L.Control` and (re-)implement the following methods.\r\n   *\r\n   * @method onAdd(map: Map): HTMLElement\r\n   * Should return the container DOM element for the control and add listeners on relevant map events. Called on [`control.addTo(map)`](#control-addTo).\r\n   *\r\n   * @method onRemove(map: Map)\r\n   * Optional method. Should contain all clean up code that removes the listeners previously added in [`onAdd`](#control-onadd). Called on [`control.remove()`](#control-remove).\r\n   */\r\n\r\n  /* @namespace Map\r\n   * @section Methods for Layers and Controls\r\n   */\r\n  Map.include({\r\n  \t// @method addControl(control: Control): this\r\n  \t// Adds the given control to the map\r\n  \taddControl: function (control) {\r\n  \t\tcontrol.addTo(this);\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method removeControl(control: Control): this\r\n  \t// Removes the given control from the map\r\n  \tremoveControl: function (control) {\r\n  \t\tcontrol.remove();\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t_initControlPos: function () {\r\n  \t\tvar corners = this._controlCorners = {},\r\n  \t\t    l = 'leaflet-',\r\n  \t\t    container = this._controlContainer =\r\n  \t\t            create$1('div', l + 'control-container', this._container);\r\n\r\n  \t\tfunction createCorner(vSide, hSide) {\r\n  \t\t\tvar className = l + vSide + ' ' + l + hSide;\r\n\r\n  \t\t\tcorners[vSide + hSide] = create$1('div', className, container);\r\n  \t\t}\r\n\r\n  \t\tcreateCorner('top', 'left');\r\n  \t\tcreateCorner('top', 'right');\r\n  \t\tcreateCorner('bottom', 'left');\r\n  \t\tcreateCorner('bottom', 'right');\r\n  \t},\r\n\r\n  \t_clearControlPos: function () {\r\n  \t\tfor (var i in this._controlCorners) {\r\n  \t\t\tremove(this._controlCorners[i]);\r\n  \t\t}\r\n  \t\tremove(this._controlContainer);\r\n  \t\tdelete this._controlCorners;\r\n  \t\tdelete this._controlContainer;\r\n  \t}\r\n  });\n\n  /*\r\n   * @class Control.Layers\r\n   * @aka L.Control.Layers\r\n   * @inherits Control\r\n   *\r\n   * The layers control gives users the ability to switch between different base layers and switch overlays on/off (check out the [detailed example](https://leafletjs.com/examples/layers-control/)). Extends `Control`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var baseLayers = {\r\n   * \t\"Mapbox\": mapbox,\r\n   * \t\"OpenStreetMap\": osm\r\n   * };\r\n   *\r\n   * var overlays = {\r\n   * \t\"Marker\": marker,\r\n   * \t\"Roads\": roadsLayer\r\n   * };\r\n   *\r\n   * L.control.layers(baseLayers, overlays).addTo(map);\r\n   * ```\r\n   *\r\n   * The `baseLayers` and `overlays` parameters are object literals with layer names as keys and `Layer` objects as values:\r\n   *\r\n   * ```js\r\n   * {\r\n   *     \"<someName1>\": layer1,\r\n   *     \"<someName2>\": layer2\r\n   * }\r\n   * ```\r\n   *\r\n   * The layer names can contain HTML, which allows you to add additional styling to the items:\r\n   *\r\n   * ```js\r\n   * {\"<img src='my-layer-icon' /> <span class='my-layer-item'>My Layer</span>\": myLayer}\r\n   * ```\r\n   */\r\n\r\n  var Layers = Control.extend({\r\n  \t// @section\r\n  \t// @aka Control.Layers options\r\n  \toptions: {\r\n  \t\t// @option collapsed: Boolean = true\r\n  \t\t// If `true`, the control will be collapsed into an icon and expanded on mouse hover, touch, or keyboard activation.\r\n  \t\tcollapsed: true,\r\n  \t\tposition: 'topright',\r\n\r\n  \t\t// @option autoZIndex: Boolean = true\r\n  \t\t// If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.\r\n  \t\tautoZIndex: true,\r\n\r\n  \t\t// @option hideSingleBase: Boolean = false\r\n  \t\t// If `true`, the base layers in the control will be hidden when there is only one.\r\n  \t\thideSingleBase: false,\r\n\r\n  \t\t// @option sortLayers: Boolean = false\r\n  \t\t// Whether to sort the layers. When `false`, layers will keep the order\r\n  \t\t// in which they were added to the control.\r\n  \t\tsortLayers: false,\r\n\r\n  \t\t// @option sortFunction: Function = *\r\n  \t\t// A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)\r\n  \t\t// that will be used for sorting the layers, when `sortLayers` is `true`.\r\n  \t\t// The function receives both the `L.Layer` instances and their names, as in\r\n  \t\t// `sortFunction(layerA, layerB, nameA, nameB)`.\r\n  \t\t// By default, it sorts layers alphabetically by their name.\r\n  \t\tsortFunction: function (layerA, layerB, nameA, nameB) {\r\n  \t\t\treturn nameA < nameB ? -1 : (nameB < nameA ? 1 : 0);\r\n  \t\t}\r\n  \t},\r\n\r\n  \tinitialize: function (baseLayers, overlays, options) {\r\n  \t\tsetOptions(this, options);\r\n\r\n  \t\tthis._layerControlInputs = [];\r\n  \t\tthis._layers = [];\r\n  \t\tthis._lastZIndex = 0;\r\n  \t\tthis._handlingClick = false;\r\n\r\n  \t\tfor (var i in baseLayers) {\r\n  \t\t\tthis._addLayer(baseLayers[i], i);\r\n  \t\t}\r\n\r\n  \t\tfor (i in overlays) {\r\n  \t\t\tthis._addLayer(overlays[i], i, true);\r\n  \t\t}\r\n  \t},\r\n\r\n  \tonAdd: function (map) {\r\n  \t\tthis._initLayout();\r\n  \t\tthis._update();\r\n\r\n  \t\tthis._map = map;\r\n  \t\tmap.on('zoomend', this._checkDisabledLayers, this);\r\n\r\n  \t\tfor (var i = 0; i < this._layers.length; i++) {\r\n  \t\t\tthis._layers[i].layer.on('add remove', this._onLayerChange, this);\r\n  \t\t}\r\n\r\n  \t\treturn this._container;\r\n  \t},\r\n\r\n  \taddTo: function (map) {\r\n  \t\tControl.prototype.addTo.call(this, map);\r\n  \t\t// Trigger expand after Layers Control has been inserted into DOM so that is now has an actual height.\r\n  \t\treturn this._expandIfNotCollapsed();\r\n  \t},\r\n\r\n  \tonRemove: function () {\r\n  \t\tthis._map.off('zoomend', this._checkDisabledLayers, this);\r\n\r\n  \t\tfor (var i = 0; i < this._layers.length; i++) {\r\n  \t\t\tthis._layers[i].layer.off('add remove', this._onLayerChange, this);\r\n  \t\t}\r\n  \t},\r\n\r\n  \t// @method addBaseLayer(layer: Layer, name: String): this\r\n  \t// Adds a base layer (radio button entry) with the given name to the control.\r\n  \taddBaseLayer: function (layer, name) {\r\n  \t\tthis._addLayer(layer, name);\r\n  \t\treturn (this._map) ? this._update() : this;\r\n  \t},\r\n\r\n  \t// @method addOverlay(layer: Layer, name: String): this\r\n  \t// Adds an overlay (checkbox entry) with the given name to the control.\r\n  \taddOverlay: function (layer, name) {\r\n  \t\tthis._addLayer(layer, name, true);\r\n  \t\treturn (this._map) ? this._update() : this;\r\n  \t},\r\n\r\n  \t// @method removeLayer(layer: Layer): this\r\n  \t// Remove the given layer from the control.\r\n  \tremoveLayer: function (layer) {\r\n  \t\tlayer.off('add remove', this._onLayerChange, this);\r\n\r\n  \t\tvar obj = this._getLayer(stamp(layer));\r\n  \t\tif (obj) {\r\n  \t\t\tthis._layers.splice(this._layers.indexOf(obj), 1);\r\n  \t\t}\r\n  \t\treturn (this._map) ? this._update() : this;\r\n  \t},\r\n\r\n  \t// @method expand(): this\r\n  \t// Expand the control container if collapsed.\r\n  \texpand: function () {\r\n  \t\taddClass(this._container, 'leaflet-control-layers-expanded');\r\n  \t\tthis._section.style.height = null;\r\n  \t\tvar acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);\r\n  \t\tif (acceptableHeight < this._section.clientHeight) {\r\n  \t\t\taddClass(this._section, 'leaflet-control-layers-scrollbar');\r\n  \t\t\tthis._section.style.height = acceptableHeight + 'px';\r\n  \t\t} else {\r\n  \t\t\tremoveClass(this._section, 'leaflet-control-layers-scrollbar');\r\n  \t\t}\r\n  \t\tthis._checkDisabledLayers();\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method collapse(): this\r\n  \t// Collapse the control container if expanded.\r\n  \tcollapse: function () {\r\n  \t\tremoveClass(this._container, 'leaflet-control-layers-expanded');\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t_initLayout: function () {\r\n  \t\tvar className = 'leaflet-control-layers',\r\n  \t\t    container = this._container = create$1('div', className),\r\n  \t\t    collapsed = this.options.collapsed;\r\n\r\n  \t\t// makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released\r\n  \t\tcontainer.setAttribute('aria-haspopup', true);\r\n\r\n  \t\tdisableClickPropagation(container);\r\n  \t\tdisableScrollPropagation(container);\r\n\r\n  \t\tvar section = this._section = create$1('section', className + '-list');\r\n\r\n  \t\tif (collapsed) {\r\n  \t\t\tthis._map.on('click', this.collapse, this);\r\n\r\n  \t\t\ton(container, {\r\n  \t\t\t\tmouseenter: this._expandSafely,\r\n  \t\t\t\tmouseleave: this.collapse\r\n  \t\t\t}, this);\r\n  \t\t}\r\n\r\n  \t\tvar link = this._layersLink = create$1('a', className + '-toggle', container);\r\n  \t\tlink.href = '#';\r\n  \t\tlink.title = 'Layers';\r\n  \t\tlink.setAttribute('role', 'button');\r\n\r\n  \t\ton(link, {\r\n  \t\t\tkeydown: function (e) {\r\n  \t\t\t\tif (e.keyCode === 13) {\r\n  \t\t\t\t\tthis._expandSafely();\r\n  \t\t\t\t}\r\n  \t\t\t},\r\n  \t\t\t// Certain screen readers intercept the key event and instead send a click event\r\n  \t\t\tclick: function (e) {\r\n  \t\t\t\tpreventDefault(e);\r\n  \t\t\t\tthis._expandSafely();\r\n  \t\t\t}\r\n  \t\t}, this);\r\n\r\n  \t\tif (!collapsed) {\r\n  \t\t\tthis.expand();\r\n  \t\t}\r\n\r\n  \t\tthis._baseLayersList = create$1('div', className + '-base', section);\r\n  \t\tthis._separator = create$1('div', className + '-separator', section);\r\n  \t\tthis._overlaysList = create$1('div', className + '-overlays', section);\r\n\r\n  \t\tcontainer.appendChild(section);\r\n  \t},\r\n\r\n  \t_getLayer: function (id) {\r\n  \t\tfor (var i = 0; i < this._layers.length; i++) {\r\n\r\n  \t\t\tif (this._layers[i] && stamp(this._layers[i].layer) === id) {\r\n  \t\t\t\treturn this._layers[i];\r\n  \t\t\t}\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_addLayer: function (layer, name, overlay) {\r\n  \t\tif (this._map) {\r\n  \t\t\tlayer.on('add remove', this._onLayerChange, this);\r\n  \t\t}\r\n\r\n  \t\tthis._layers.push({\r\n  \t\t\tlayer: layer,\r\n  \t\t\tname: name,\r\n  \t\t\toverlay: overlay\r\n  \t\t});\r\n\r\n  \t\tif (this.options.sortLayers) {\r\n  \t\t\tthis._layers.sort(bind(function (a, b) {\r\n  \t\t\t\treturn this.options.sortFunction(a.layer, b.layer, a.name, b.name);\r\n  \t\t\t}, this));\r\n  \t\t}\r\n\r\n  \t\tif (this.options.autoZIndex && layer.setZIndex) {\r\n  \t\t\tthis._lastZIndex++;\r\n  \t\t\tlayer.setZIndex(this._lastZIndex);\r\n  \t\t}\r\n\r\n  \t\tthis._expandIfNotCollapsed();\r\n  \t},\r\n\r\n  \t_update: function () {\r\n  \t\tif (!this._container) { return this; }\r\n\r\n  \t\tempty(this._baseLayersList);\r\n  \t\tempty(this._overlaysList);\r\n\r\n  \t\tthis._layerControlInputs = [];\r\n  \t\tvar baseLayersPresent, overlaysPresent, i, obj, baseLayersCount = 0;\r\n\r\n  \t\tfor (i = 0; i < this._layers.length; i++) {\r\n  \t\t\tobj = this._layers[i];\r\n  \t\t\tthis._addItem(obj);\r\n  \t\t\toverlaysPresent = overlaysPresent || obj.overlay;\r\n  \t\t\tbaseLayersPresent = baseLayersPresent || !obj.overlay;\r\n  \t\t\tbaseLayersCount += !obj.overlay ? 1 : 0;\r\n  \t\t}\r\n\r\n  \t\t// Hide base layers section if there's only one layer.\r\n  \t\tif (this.options.hideSingleBase) {\r\n  \t\t\tbaseLayersPresent = baseLayersPresent && baseLayersCount > 1;\r\n  \t\t\tthis._baseLayersList.style.display = baseLayersPresent ? '' : 'none';\r\n  \t\t}\r\n\r\n  \t\tthis._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t_onLayerChange: function (e) {\r\n  \t\tif (!this._handlingClick) {\r\n  \t\t\tthis._update();\r\n  \t\t}\r\n\r\n  \t\tvar obj = this._getLayer(stamp(e.target));\r\n\r\n  \t\t// @namespace Map\r\n  \t\t// @section Layer events\r\n  \t\t// @event baselayerchange: LayersControlEvent\r\n  \t\t// Fired when the base layer is changed through the [layers control](#control-layers).\r\n  \t\t// @event overlayadd: LayersControlEvent\r\n  \t\t// Fired when an overlay is selected through the [layers control](#control-layers).\r\n  \t\t// @event overlayremove: LayersControlEvent\r\n  \t\t// Fired when an overlay is deselected through the [layers control](#control-layers).\r\n  \t\t// @namespace Control.Layers\r\n  \t\tvar type = obj.overlay ?\r\n  \t\t\t(e.type === 'add' ? 'overlayadd' : 'overlayremove') :\r\n  \t\t\t(e.type === 'add' ? 'baselayerchange' : null);\r\n\r\n  \t\tif (type) {\r\n  \t\t\tthis._map.fire(type, obj);\r\n  \t\t}\r\n  \t},\r\n\r\n  \t// IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see https://stackoverflow.com/a/119079)\r\n  \t_createRadioElement: function (name, checked) {\r\n\r\n  \t\tvar radioHtml = '<input type=\"radio\" class=\"leaflet-control-layers-selector\" name=\"' +\r\n  \t\t\t\tname + '\"' + (checked ? ' checked=\"checked\"' : '') + '/>';\r\n\r\n  \t\tvar radioFragment = document.createElement('div');\r\n  \t\tradioFragment.innerHTML = radioHtml;\r\n\r\n  \t\treturn radioFragment.firstChild;\r\n  \t},\r\n\r\n  \t_addItem: function (obj) {\r\n  \t\tvar label = document.createElement('label'),\r\n  \t\t    checked = this._map.hasLayer(obj.layer),\r\n  \t\t    input;\r\n\r\n  \t\tif (obj.overlay) {\r\n  \t\t\tinput = document.createElement('input');\r\n  \t\t\tinput.type = 'checkbox';\r\n  \t\t\tinput.className = 'leaflet-control-layers-selector';\r\n  \t\t\tinput.defaultChecked = checked;\r\n  \t\t} else {\r\n  \t\t\tinput = this._createRadioElement('leaflet-base-layers_' + stamp(this), checked);\r\n  \t\t}\r\n\r\n  \t\tthis._layerControlInputs.push(input);\r\n  \t\tinput.layerId = stamp(obj.layer);\r\n\r\n  \t\ton(input, 'click', this._onInputClick, this);\r\n\r\n  \t\tvar name = document.createElement('span');\r\n  \t\tname.innerHTML = ' ' + obj.name;\r\n\r\n  \t\t// Helps from preventing layer control flicker when checkboxes are disabled\r\n  \t\t// https://github.com/Leaflet/Leaflet/issues/2771\r\n  \t\tvar holder = document.createElement('span');\r\n\r\n  \t\tlabel.appendChild(holder);\r\n  \t\tholder.appendChild(input);\r\n  \t\tholder.appendChild(name);\r\n\r\n  \t\tvar container = obj.overlay ? this._overlaysList : this._baseLayersList;\r\n  \t\tcontainer.appendChild(label);\r\n\r\n  \t\tthis._checkDisabledLayers();\r\n  \t\treturn label;\r\n  \t},\r\n\r\n  \t_onInputClick: function () {\r\n  \t\tvar inputs = this._layerControlInputs,\r\n  \t\t    input, layer;\r\n  \t\tvar addedLayers = [],\r\n  \t\t    removedLayers = [];\r\n\r\n  \t\tthis._handlingClick = true;\r\n\r\n  \t\tfor (var i = inputs.length - 1; i >= 0; i--) {\r\n  \t\t\tinput = inputs[i];\r\n  \t\t\tlayer = this._getLayer(input.layerId).layer;\r\n\r\n  \t\t\tif (input.checked) {\r\n  \t\t\t\taddedLayers.push(layer);\r\n  \t\t\t} else if (!input.checked) {\r\n  \t\t\t\tremovedLayers.push(layer);\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\t// Bugfix issue 2318: Should remove all old layers before readding new ones\r\n  \t\tfor (i = 0; i < removedLayers.length; i++) {\r\n  \t\t\tif (this._map.hasLayer(removedLayers[i])) {\r\n  \t\t\t\tthis._map.removeLayer(removedLayers[i]);\r\n  \t\t\t}\r\n  \t\t}\r\n  \t\tfor (i = 0; i < addedLayers.length; i++) {\r\n  \t\t\tif (!this._map.hasLayer(addedLayers[i])) {\r\n  \t\t\t\tthis._map.addLayer(addedLayers[i]);\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\tthis._handlingClick = false;\r\n\r\n  \t\tthis._refocusOnMap();\r\n  \t},\r\n\r\n  \t_checkDisabledLayers: function () {\r\n  \t\tvar inputs = this._layerControlInputs,\r\n  \t\t    input,\r\n  \t\t    layer,\r\n  \t\t    zoom = this._map.getZoom();\r\n\r\n  \t\tfor (var i = inputs.length - 1; i >= 0; i--) {\r\n  \t\t\tinput = inputs[i];\r\n  \t\t\tlayer = this._getLayer(input.layerId).layer;\r\n  \t\t\tinput.disabled = (layer.options.minZoom !== undefined && zoom < layer.options.minZoom) ||\r\n  \t\t\t                 (layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom);\r\n\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_expandIfNotCollapsed: function () {\r\n  \t\tif (this._map && !this.options.collapsed) {\r\n  \t\t\tthis.expand();\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t_expandSafely: function () {\r\n  \t\tvar section = this._section;\r\n  \t\ton(section, 'click', preventDefault);\r\n  \t\tthis.expand();\r\n  \t\tsetTimeout(function () {\r\n  \t\t\toff(section, 'click', preventDefault);\r\n  \t\t});\r\n  \t}\r\n\r\n  });\r\n\r\n\r\n  // @factory L.control.layers(baselayers?: Object, overlays?: Object, options?: Control.Layers options)\r\n  // Creates a layers control with the given layers. Base layers will be switched with radio buttons, while overlays will be switched with checkboxes. Note that all base layers should be passed in the base layers object, but only one should be added to the map during map instantiation.\r\n  var layers = function (baseLayers, overlays, options) {\r\n  \treturn new Layers(baseLayers, overlays, options);\r\n  };\n\n  /*\r\n   * @class Control.Zoom\r\n   * @aka L.Control.Zoom\r\n   * @inherits Control\r\n   *\r\n   * A basic zoom control with two buttons (zoom in and zoom out). It is put on the map by default unless you set its [`zoomControl` option](#map-zoomcontrol) to `false`. Extends `Control`.\r\n   */\r\n\r\n  var Zoom = Control.extend({\r\n  \t// @section\r\n  \t// @aka Control.Zoom options\r\n  \toptions: {\r\n  \t\tposition: 'topleft',\r\n\r\n  \t\t// @option zoomInText: String = '<span aria-hidden=\"true\">+</span>'\r\n  \t\t// The text set on the 'zoom in' button.\r\n  \t\tzoomInText: '<span aria-hidden=\"true\">+</span>',\r\n\r\n  \t\t// @option zoomInTitle: String = 'Zoom in'\r\n  \t\t// The title set on the 'zoom in' button.\r\n  \t\tzoomInTitle: 'Zoom in',\r\n\r\n  \t\t// @option zoomOutText: String = '<span aria-hidden=\"true\">&#x2212;</span>'\r\n  \t\t// The text set on the 'zoom out' button.\r\n  \t\tzoomOutText: '<span aria-hidden=\"true\">&#x2212;</span>',\r\n\r\n  \t\t// @option zoomOutTitle: String = 'Zoom out'\r\n  \t\t// The title set on the 'zoom out' button.\r\n  \t\tzoomOutTitle: 'Zoom out'\r\n  \t},\r\n\r\n  \tonAdd: function (map) {\r\n  \t\tvar zoomName = 'leaflet-control-zoom',\r\n  \t\t    container = create$1('div', zoomName + ' leaflet-bar'),\r\n  \t\t    options = this.options;\r\n\r\n  \t\tthis._zoomInButton  = this._createButton(options.zoomInText, options.zoomInTitle,\r\n  \t\t        zoomName + '-in',  container, this._zoomIn);\r\n  \t\tthis._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle,\r\n  \t\t        zoomName + '-out', container, this._zoomOut);\r\n\r\n  \t\tthis._updateDisabled();\r\n  \t\tmap.on('zoomend zoomlevelschange', this._updateDisabled, this);\r\n\r\n  \t\treturn container;\r\n  \t},\r\n\r\n  \tonRemove: function (map) {\r\n  \t\tmap.off('zoomend zoomlevelschange', this._updateDisabled, this);\r\n  \t},\r\n\r\n  \tdisable: function () {\r\n  \t\tthis._disabled = true;\r\n  \t\tthis._updateDisabled();\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \tenable: function () {\r\n  \t\tthis._disabled = false;\r\n  \t\tthis._updateDisabled();\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t_zoomIn: function (e) {\r\n  \t\tif (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {\r\n  \t\t\tthis._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_zoomOut: function (e) {\r\n  \t\tif (!this._disabled && this._map._zoom > this._map.getMinZoom()) {\r\n  \t\t\tthis._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_createButton: function (html, title, className, container, fn) {\r\n  \t\tvar link = create$1('a', className, container);\r\n  \t\tlink.innerHTML = html;\r\n  \t\tlink.href = '#';\r\n  \t\tlink.title = title;\r\n\r\n  \t\t/*\r\n  \t\t * Will force screen readers like VoiceOver to read this as \"Zoom in - button\"\r\n  \t\t */\r\n  \t\tlink.setAttribute('role', 'button');\r\n  \t\tlink.setAttribute('aria-label', title);\r\n\r\n  \t\tdisableClickPropagation(link);\r\n  \t\ton(link, 'click', stop);\r\n  \t\ton(link, 'click', fn, this);\r\n  \t\ton(link, 'click', this._refocusOnMap, this);\r\n\r\n  \t\treturn link;\r\n  \t},\r\n\r\n  \t_updateDisabled: function () {\r\n  \t\tvar map = this._map,\r\n  \t\t    className = 'leaflet-disabled';\r\n\r\n  \t\tremoveClass(this._zoomInButton, className);\r\n  \t\tremoveClass(this._zoomOutButton, className);\r\n  \t\tthis._zoomInButton.setAttribute('aria-disabled', 'false');\r\n  \t\tthis._zoomOutButton.setAttribute('aria-disabled', 'false');\r\n\r\n  \t\tif (this._disabled || map._zoom === map.getMinZoom()) {\r\n  \t\t\taddClass(this._zoomOutButton, className);\r\n  \t\t\tthis._zoomOutButton.setAttribute('aria-disabled', 'true');\r\n  \t\t}\r\n  \t\tif (this._disabled || map._zoom === map.getMaxZoom()) {\r\n  \t\t\taddClass(this._zoomInButton, className);\r\n  \t\t\tthis._zoomInButton.setAttribute('aria-disabled', 'true');\r\n  \t\t}\r\n  \t}\r\n  });\r\n\r\n  // @namespace Map\r\n  // @section Control options\r\n  // @option zoomControl: Boolean = true\r\n  // Whether a [zoom control](#control-zoom) is added to the map by default.\r\n  Map.mergeOptions({\r\n  \tzoomControl: true\r\n  });\r\n\r\n  Map.addInitHook(function () {\r\n  \tif (this.options.zoomControl) {\r\n  \t\t// @section Controls\r\n  \t\t// @property zoomControl: Control.Zoom\r\n  \t\t// The default zoom control (only available if the\r\n  \t\t// [`zoomControl` option](#map-zoomcontrol) was `true` when creating the map).\r\n  \t\tthis.zoomControl = new Zoom();\r\n  \t\tthis.addControl(this.zoomControl);\r\n  \t}\r\n  });\r\n\r\n  // @namespace Control.Zoom\r\n  // @factory L.control.zoom(options: Control.Zoom options)\r\n  // Creates a zoom control\r\n  var zoom = function (options) {\r\n  \treturn new Zoom(options);\r\n  };\n\n  /*\n   * @class Control.Scale\n   * @aka L.Control.Scale\n   * @inherits Control\n   *\n   * A simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems. Extends `Control`.\n   *\n   * @example\n   *\n   * ```js\n   * L.control.scale().addTo(map);\n   * ```\n   */\n\n  var Scale = Control.extend({\n  \t// @section\n  \t// @aka Control.Scale options\n  \toptions: {\n  \t\tposition: 'bottomleft',\n\n  \t\t// @option maxWidth: Number = 100\n  \t\t// Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).\n  \t\tmaxWidth: 100,\n\n  \t\t// @option metric: Boolean = True\n  \t\t// Whether to show the metric scale line (m/km).\n  \t\tmetric: true,\n\n  \t\t// @option imperial: Boolean = True\n  \t\t// Whether to show the imperial scale line (mi/ft).\n  \t\timperial: true\n\n  \t\t// @option updateWhenIdle: Boolean = false\n  \t\t// If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).\n  \t},\n\n  \tonAdd: function (map) {\n  \t\tvar className = 'leaflet-control-scale',\n  \t\t    container = create$1('div', className),\n  \t\t    options = this.options;\n\n  \t\tthis._addScales(options, className + '-line', container);\n\n  \t\tmap.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n  \t\tmap.whenReady(this._update, this);\n\n  \t\treturn container;\n  \t},\n\n  \tonRemove: function (map) {\n  \t\tmap.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n  \t},\n\n  \t_addScales: function (options, className, container) {\n  \t\tif (options.metric) {\n  \t\t\tthis._mScale = create$1('div', className, container);\n  \t\t}\n  \t\tif (options.imperial) {\n  \t\t\tthis._iScale = create$1('div', className, container);\n  \t\t}\n  \t},\n\n  \t_update: function () {\n  \t\tvar map = this._map,\n  \t\t    y = map.getSize().y / 2;\n\n  \t\tvar maxMeters = map.distance(\n  \t\t\tmap.containerPointToLatLng([0, y]),\n  \t\t\tmap.containerPointToLatLng([this.options.maxWidth, y]));\n\n  \t\tthis._updateScales(maxMeters);\n  \t},\n\n  \t_updateScales: function (maxMeters) {\n  \t\tif (this.options.metric && maxMeters) {\n  \t\t\tthis._updateMetric(maxMeters);\n  \t\t}\n  \t\tif (this.options.imperial && maxMeters) {\n  \t\t\tthis._updateImperial(maxMeters);\n  \t\t}\n  \t},\n\n  \t_updateMetric: function (maxMeters) {\n  \t\tvar meters = this._getRoundNum(maxMeters),\n  \t\t    label = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';\n\n  \t\tthis._updateScale(this._mScale, label, meters / maxMeters);\n  \t},\n\n  \t_updateImperial: function (maxMeters) {\n  \t\tvar maxFeet = maxMeters * 3.2808399,\n  \t\t    maxMiles, miles, feet;\n\n  \t\tif (maxFeet > 5280) {\n  \t\t\tmaxMiles = maxFeet / 5280;\n  \t\t\tmiles = this._getRoundNum(maxMiles);\n  \t\t\tthis._updateScale(this._iScale, miles + ' mi', miles / maxMiles);\n\n  \t\t} else {\n  \t\t\tfeet = this._getRoundNum(maxFeet);\n  \t\t\tthis._updateScale(this._iScale, feet + ' ft', feet / maxFeet);\n  \t\t}\n  \t},\n\n  \t_updateScale: function (scale, text, ratio) {\n  \t\tscale.style.width = Math.round(this.options.maxWidth * ratio) + 'px';\n  \t\tscale.innerHTML = text;\n  \t},\n\n  \t_getRoundNum: function (num) {\n  \t\tvar pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),\n  \t\t    d = num / pow10;\n\n  \t\td = d >= 10 ? 10 :\n  \t\t    d >= 5 ? 5 :\n  \t\t    d >= 3 ? 3 :\n  \t\t    d >= 2 ? 2 : 1;\n\n  \t\treturn pow10 * d;\n  \t}\n  });\n\n\n  // @factory L.control.scale(options?: Control.Scale options)\n  // Creates an scale control with the given options.\n  var scale = function (options) {\n  \treturn new Scale(options);\n  };\n\n  var ukrainianFlag = '<svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" width=\"12\" height=\"8\" viewBox=\"0 0 12 8\" class=\"leaflet-attribution-flag\"><path fill=\"#4C7BE1\" d=\"M0 0h12v4H0z\"/><path fill=\"#FFD500\" d=\"M0 4h12v3H0z\"/><path fill=\"#E0BC00\" d=\"M0 7h12v1H0z\"/></svg>';\r\n\r\n\r\n  /*\r\n   * @class Control.Attribution\r\n   * @aka L.Control.Attribution\r\n   * @inherits Control\r\n   *\r\n   * The attribution control allows you to display attribution data in a small text box on a map. It is put on the map by default unless you set its [`attributionControl` option](#map-attributioncontrol) to `false`, and it fetches attribution texts from layers with the [`getAttribution` method](#layer-getattribution) automatically. Extends Control.\r\n   */\r\n\r\n  var Attribution = Control.extend({\r\n  \t// @section\r\n  \t// @aka Control.Attribution options\r\n  \toptions: {\r\n  \t\tposition: 'bottomright',\r\n\r\n  \t\t// @option prefix: String|false = 'Leaflet'\r\n  \t\t// The HTML text shown before the attributions. Pass `false` to disable.\r\n  \t\tprefix: '<a href=\"https://leafletjs.com\" title=\"A JavaScript library for interactive maps\">' + (Browser.inlineSvg ? ukrainianFlag + ' ' : '') + 'Leaflet</a>'\r\n  \t},\r\n\r\n  \tinitialize: function (options) {\r\n  \t\tsetOptions(this, options);\r\n\r\n  \t\tthis._attributions = {};\r\n  \t},\r\n\r\n  \tonAdd: function (map) {\r\n  \t\tmap.attributionControl = this;\r\n  \t\tthis._container = create$1('div', 'leaflet-control-attribution');\r\n  \t\tdisableClickPropagation(this._container);\r\n\r\n  \t\t// TODO ugly, refactor\r\n  \t\tfor (var i in map._layers) {\r\n  \t\t\tif (map._layers[i].getAttribution) {\r\n  \t\t\t\tthis.addAttribution(map._layers[i].getAttribution());\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\tthis._update();\r\n\r\n  \t\tmap.on('layeradd', this._addAttribution, this);\r\n\r\n  \t\treturn this._container;\r\n  \t},\r\n\r\n  \tonRemove: function (map) {\r\n  \t\tmap.off('layeradd', this._addAttribution, this);\r\n  \t},\r\n\r\n  \t_addAttribution: function (ev) {\r\n  \t\tif (ev.layer.getAttribution) {\r\n  \t\t\tthis.addAttribution(ev.layer.getAttribution());\r\n  \t\t\tev.layer.once('remove', function () {\r\n  \t\t\t\tthis.removeAttribution(ev.layer.getAttribution());\r\n  \t\t\t}, this);\r\n  \t\t}\r\n  \t},\r\n\r\n  \t// @method setPrefix(prefix: String|false): this\r\n  \t// The HTML text shown before the attributions. Pass `false` to disable.\r\n  \tsetPrefix: function (prefix) {\r\n  \t\tthis.options.prefix = prefix;\r\n  \t\tthis._update();\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method addAttribution(text: String): this\r\n  \t// Adds an attribution text (e.g. `'&copy; OpenStreetMap contributors'`).\r\n  \taddAttribution: function (text) {\r\n  \t\tif (!text) { return this; }\r\n\r\n  \t\tif (!this._attributions[text]) {\r\n  \t\t\tthis._attributions[text] = 0;\r\n  \t\t}\r\n  \t\tthis._attributions[text]++;\r\n\r\n  \t\tthis._update();\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method removeAttribution(text: String): this\r\n  \t// Removes an attribution text.\r\n  \tremoveAttribution: function (text) {\r\n  \t\tif (!text) { return this; }\r\n\r\n  \t\tif (this._attributions[text]) {\r\n  \t\t\tthis._attributions[text]--;\r\n  \t\t\tthis._update();\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t_update: function () {\r\n  \t\tif (!this._map) { return; }\r\n\r\n  \t\tvar attribs = [];\r\n\r\n  \t\tfor (var i in this._attributions) {\r\n  \t\t\tif (this._attributions[i]) {\r\n  \t\t\t\tattribs.push(i);\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\tvar prefixAndAttribs = [];\r\n\r\n  \t\tif (this.options.prefix) {\r\n  \t\t\tprefixAndAttribs.push(this.options.prefix);\r\n  \t\t}\r\n  \t\tif (attribs.length) {\r\n  \t\t\tprefixAndAttribs.push(attribs.join(', '));\r\n  \t\t}\r\n\r\n  \t\tthis._container.innerHTML = prefixAndAttribs.join(' <span aria-hidden=\"true\">|</span> ');\r\n  \t}\r\n  });\r\n\r\n  // @namespace Map\r\n  // @section Control options\r\n  // @option attributionControl: Boolean = true\r\n  // Whether a [attribution control](#control-attribution) is added to the map by default.\r\n  Map.mergeOptions({\r\n  \tattributionControl: true\r\n  });\r\n\r\n  Map.addInitHook(function () {\r\n  \tif (this.options.attributionControl) {\r\n  \t\tnew Attribution().addTo(this);\r\n  \t}\r\n  });\r\n\r\n  // @namespace Control.Attribution\r\n  // @factory L.control.attribution(options: Control.Attribution options)\r\n  // Creates an attribution control.\r\n  var attribution = function (options) {\r\n  \treturn new Attribution(options);\r\n  };\n\n  Control.Layers = Layers;\n  Control.Zoom = Zoom;\n  Control.Scale = Scale;\n  Control.Attribution = Attribution;\n\n  control.layers = layers;\n  control.zoom = zoom;\n  control.scale = scale;\n  control.attribution = attribution;\n\n  /*\n  \tL.Handler is a base class for handler classes that are used internally to inject\n  \tinteraction features like dragging to classes like Map and Marker.\n  */\n\n  // @class Handler\n  // @aka L.Handler\n  // Abstract class for map interaction handlers\n\n  var Handler = Class.extend({\n  \tinitialize: function (map) {\n  \t\tthis._map = map;\n  \t},\n\n  \t// @method enable(): this\n  \t// Enables the handler\n  \tenable: function () {\n  \t\tif (this._enabled) { return this; }\n\n  \t\tthis._enabled = true;\n  \t\tthis.addHooks();\n  \t\treturn this;\n  \t},\n\n  \t// @method disable(): this\n  \t// Disables the handler\n  \tdisable: function () {\n  \t\tif (!this._enabled) { return this; }\n\n  \t\tthis._enabled = false;\n  \t\tthis.removeHooks();\n  \t\treturn this;\n  \t},\n\n  \t// @method enabled(): Boolean\n  \t// Returns `true` if the handler is enabled\n  \tenabled: function () {\n  \t\treturn !!this._enabled;\n  \t}\n\n  \t// @section Extension methods\n  \t// Classes inheriting from `Handler` must implement the two following methods:\n  \t// @method addHooks()\n  \t// Called when the handler is enabled, should add event hooks.\n  \t// @method removeHooks()\n  \t// Called when the handler is disabled, should remove the event hooks added previously.\n  });\n\n  // @section There is static function which can be called without instantiating L.Handler:\n  // @function addTo(map: Map, name: String): this\n  // Adds a new Handler to the given map with the given name.\n  Handler.addTo = function (map, name) {\n  \tmap.addHandler(name, this);\n  \treturn this;\n  };\n\n  var Mixin = {Events: Events};\n\n  /*\r\n   * @class Draggable\r\n   * @aka L.Draggable\r\n   * @inherits Evented\r\n   *\r\n   * A class for making DOM elements draggable (including touch support).\r\n   * Used internally for map and marker dragging. Only works for elements\r\n   * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).\r\n   *\r\n   * @example\r\n   * ```js\r\n   * var draggable = new L.Draggable(elementToDrag);\r\n   * draggable.enable();\r\n   * ```\r\n   */\r\n\r\n  var START = Browser.touch ? 'touchstart mousedown' : 'mousedown';\r\n\r\n  var Draggable = Evented.extend({\r\n\r\n  \toptions: {\r\n  \t\t// @section\r\n  \t\t// @aka Draggable options\r\n  \t\t// @option clickTolerance: Number = 3\r\n  \t\t// The max number of pixels a user can shift the mouse pointer during a click\r\n  \t\t// for it to be considered a valid click (as opposed to a mouse drag).\r\n  \t\tclickTolerance: 3\r\n  \t},\r\n\r\n  \t// @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)\r\n  \t// Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).\r\n  \tinitialize: function (element, dragStartTarget, preventOutline, options) {\r\n  \t\tsetOptions(this, options);\r\n\r\n  \t\tthis._element = element;\r\n  \t\tthis._dragStartTarget = dragStartTarget || element;\r\n  \t\tthis._preventOutline = preventOutline;\r\n  \t},\r\n\r\n  \t// @method enable()\r\n  \t// Enables the dragging ability\r\n  \tenable: function () {\r\n  \t\tif (this._enabled) { return; }\r\n\r\n  \t\ton(this._dragStartTarget, START, this._onDown, this);\r\n\r\n  \t\tthis._enabled = true;\r\n  \t},\r\n\r\n  \t// @method disable()\r\n  \t// Disables the dragging ability\r\n  \tdisable: function () {\r\n  \t\tif (!this._enabled) { return; }\r\n\r\n  \t\t// If we're currently dragging this draggable,\r\n  \t\t// disabling it counts as first ending the drag.\r\n  \t\tif (Draggable._dragging === this) {\r\n  \t\t\tthis.finishDrag(true);\r\n  \t\t}\r\n\r\n  \t\toff(this._dragStartTarget, START, this._onDown, this);\r\n\r\n  \t\tthis._enabled = false;\r\n  \t\tthis._moved = false;\r\n  \t},\r\n\r\n  \t_onDown: function (e) {\r\n  \t\t// Ignore the event if disabled; this happens in IE11\r\n  \t\t// under some circumstances, see #3666.\r\n  \t\tif (!this._enabled) { return; }\r\n\r\n  \t\tthis._moved = false;\r\n\r\n  \t\tif (hasClass(this._element, 'leaflet-zoom-anim')) { return; }\r\n\r\n  \t\tif (e.touches && e.touches.length !== 1) {\r\n  \t\t\t// Finish dragging to avoid conflict with touchZoom\r\n  \t\t\tif (Draggable._dragging === this) {\r\n  \t\t\t\tthis.finishDrag();\r\n  \t\t\t}\r\n  \t\t\treturn;\r\n  \t\t}\r\n\r\n  \t\tif (Draggable._dragging || e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches)) { return; }\r\n  \t\tDraggable._dragging = this;  // Prevent dragging multiple objects at once.\r\n\r\n  \t\tif (this._preventOutline) {\r\n  \t\t\tpreventOutline(this._element);\r\n  \t\t}\r\n\r\n  \t\tdisableImageDrag();\r\n  \t\tdisableTextSelection();\r\n\r\n  \t\tif (this._moving) { return; }\r\n\r\n  \t\t// @event down: Event\r\n  \t\t// Fired when a drag is about to start.\r\n  \t\tthis.fire('down');\r\n\r\n  \t\tvar first = e.touches ? e.touches[0] : e,\r\n  \t\t    sizedParent = getSizedParentNode(this._element);\r\n\r\n  \t\tthis._startPoint = new Point(first.clientX, first.clientY);\r\n  \t\tthis._startPos = getPosition(this._element);\r\n\r\n  \t\t// Cache the scale, so that we can continuously compensate for it during drag (_onMove).\r\n  \t\tthis._parentScale = getScale(sizedParent);\r\n\r\n  \t\tvar mouseevent = e.type === 'mousedown';\r\n  \t\ton(document, mouseevent ? 'mousemove' : 'touchmove', this._onMove, this);\r\n  \t\ton(document, mouseevent ? 'mouseup' : 'touchend touchcancel', this._onUp, this);\r\n  \t},\r\n\r\n  \t_onMove: function (e) {\r\n  \t\t// Ignore the event if disabled; this happens in IE11\r\n  \t\t// under some circumstances, see #3666.\r\n  \t\tif (!this._enabled) { return; }\r\n\r\n  \t\tif (e.touches && e.touches.length > 1) {\r\n  \t\t\tthis._moved = true;\r\n  \t\t\treturn;\r\n  \t\t}\r\n\r\n  \t\tvar first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),\r\n  \t\t    offset = new Point(first.clientX, first.clientY)._subtract(this._startPoint);\r\n\r\n  \t\tif (!offset.x && !offset.y) { return; }\r\n  \t\tif (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) { return; }\r\n\r\n  \t\t// We assume that the parent container's position, border and scale do not change for the duration of the drag.\r\n  \t\t// Therefore there is no need to account for the position and border (they are eliminated by the subtraction)\r\n  \t\t// and we can use the cached value for the scale.\r\n  \t\toffset.x /= this._parentScale.x;\r\n  \t\toffset.y /= this._parentScale.y;\r\n\r\n  \t\tpreventDefault(e);\r\n\r\n  \t\tif (!this._moved) {\r\n  \t\t\t// @event dragstart: Event\r\n  \t\t\t// Fired when a drag starts\r\n  \t\t\tthis.fire('dragstart');\r\n\r\n  \t\t\tthis._moved = true;\r\n\r\n  \t\t\taddClass(document.body, 'leaflet-dragging');\r\n\r\n  \t\t\tthis._lastTarget = e.target || e.srcElement;\r\n  \t\t\t// IE and Edge do not give the <use> element, so fetch it\r\n  \t\t\t// if necessary\r\n  \t\t\tif (window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance) {\r\n  \t\t\t\tthis._lastTarget = this._lastTarget.correspondingUseElement;\r\n  \t\t\t}\r\n  \t\t\taddClass(this._lastTarget, 'leaflet-drag-target');\r\n  \t\t}\r\n\r\n  \t\tthis._newPos = this._startPos.add(offset);\r\n  \t\tthis._moving = true;\r\n\r\n  \t\tthis._lastEvent = e;\r\n  \t\tthis._updatePosition();\r\n  \t},\r\n\r\n  \t_updatePosition: function () {\r\n  \t\tvar e = {originalEvent: this._lastEvent};\r\n\r\n  \t\t// @event predrag: Event\r\n  \t\t// Fired continuously during dragging *before* each corresponding\r\n  \t\t// update of the element's position.\r\n  \t\tthis.fire('predrag', e);\r\n  \t\tsetPosition(this._element, this._newPos);\r\n\r\n  \t\t// @event drag: Event\r\n  \t\t// Fired continuously during dragging.\r\n  \t\tthis.fire('drag', e);\r\n  \t},\r\n\r\n  \t_onUp: function () {\r\n  \t\t// Ignore the event if disabled; this happens in IE11\r\n  \t\t// under some circumstances, see #3666.\r\n  \t\tif (!this._enabled) { return; }\r\n  \t\tthis.finishDrag();\r\n  \t},\r\n\r\n  \tfinishDrag: function (noInertia) {\r\n  \t\tremoveClass(document.body, 'leaflet-dragging');\r\n\r\n  \t\tif (this._lastTarget) {\r\n  \t\t\tremoveClass(this._lastTarget, 'leaflet-drag-target');\r\n  \t\t\tthis._lastTarget = null;\r\n  \t\t}\r\n\r\n  \t\toff(document, 'mousemove touchmove', this._onMove, this);\r\n  \t\toff(document, 'mouseup touchend touchcancel', this._onUp, this);\r\n\r\n  \t\tenableImageDrag();\r\n  \t\tenableTextSelection();\r\n\r\n  \t\tif (this._moved && this._moving) {\r\n\r\n  \t\t\t// @event dragend: DragEndEvent\r\n  \t\t\t// Fired when the drag ends.\r\n  \t\t\tthis.fire('dragend', {\r\n  \t\t\t\tnoInertia: noInertia,\r\n  \t\t\t\tdistance: this._newPos.distanceTo(this._startPos)\r\n  \t\t\t});\r\n  \t\t}\r\n\r\n  \t\tthis._moving = false;\r\n  \t\tDraggable._dragging = false;\r\n  \t}\r\n\r\n  });\n\n  /*\r\n   * @namespace LineUtil\r\n   *\r\n   * Various utility functions for polyline points processing, used by Leaflet internally to make polylines lightning-fast.\r\n   */\r\n\r\n  // Simplify polyline with vertex reduction and Douglas-Peucker simplification.\r\n  // Improves rendering performance dramatically by lessening the number of points to draw.\r\n\r\n  // @function simplify(points: Point[], tolerance: Number): Point[]\r\n  // Dramatically reduces the number of points in a polyline while retaining\r\n  // its shape and returns a new array of simplified points, using the\r\n  // [Ramer-Douglas-Peucker algorithm](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm).\r\n  // Used for a huge performance boost when processing/displaying Leaflet polylines for\r\n  // each zoom level and also reducing visual noise. tolerance affects the amount of\r\n  // simplification (lesser value means higher quality but slower and with more points).\r\n  // Also released as a separated micro-library [Simplify.js](https://mourner.github.io/simplify-js/).\r\n  function simplify(points, tolerance) {\r\n  \tif (!tolerance || !points.length) {\r\n  \t\treturn points.slice();\r\n  \t}\r\n\r\n  \tvar sqTolerance = tolerance * tolerance;\r\n\r\n  \t    // stage 1: vertex reduction\r\n  \t    points = _reducePoints(points, sqTolerance);\r\n\r\n  \t    // stage 2: Douglas-Peucker simplification\r\n  \t    points = _simplifyDP(points, sqTolerance);\r\n\r\n  \treturn points;\r\n  }\r\n\r\n  // @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number\r\n  // Returns the distance between point `p` and segment `p1` to `p2`.\r\n  function pointToSegmentDistance(p, p1, p2) {\r\n  \treturn Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));\r\n  }\r\n\r\n  // @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number\r\n  // Returns the closest point from a point `p` on a segment `p1` to `p2`.\r\n  function closestPointOnSegment(p, p1, p2) {\r\n  \treturn _sqClosestPointOnSegment(p, p1, p2);\r\n  }\r\n\r\n  // Ramer-Douglas-Peucker simplification, see https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm\r\n  function _simplifyDP(points, sqTolerance) {\r\n\r\n  \tvar len = points.length,\r\n  \t    ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,\r\n  \t    markers = new ArrayConstructor(len);\r\n\r\n  \t    markers[0] = markers[len - 1] = 1;\r\n\r\n  \t_simplifyDPStep(points, markers, sqTolerance, 0, len - 1);\r\n\r\n  \tvar i,\r\n  \t    newPoints = [];\r\n\r\n  \tfor (i = 0; i < len; i++) {\r\n  \t\tif (markers[i]) {\r\n  \t\t\tnewPoints.push(points[i]);\r\n  \t\t}\r\n  \t}\r\n\r\n  \treturn newPoints;\r\n  }\r\n\r\n  function _simplifyDPStep(points, markers, sqTolerance, first, last) {\r\n\r\n  \tvar maxSqDist = 0,\r\n  \tindex, i, sqDist;\r\n\r\n  \tfor (i = first + 1; i <= last - 1; i++) {\r\n  \t\tsqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);\r\n\r\n  \t\tif (sqDist > maxSqDist) {\r\n  \t\t\tindex = i;\r\n  \t\t\tmaxSqDist = sqDist;\r\n  \t\t}\r\n  \t}\r\n\r\n  \tif (maxSqDist > sqTolerance) {\r\n  \t\tmarkers[index] = 1;\r\n\r\n  \t\t_simplifyDPStep(points, markers, sqTolerance, first, index);\r\n  \t\t_simplifyDPStep(points, markers, sqTolerance, index, last);\r\n  \t}\r\n  }\r\n\r\n  // reduce points that are too close to each other to a single point\r\n  function _reducePoints(points, sqTolerance) {\r\n  \tvar reducedPoints = [points[0]];\r\n\r\n  \tfor (var i = 1, prev = 0, len = points.length; i < len; i++) {\r\n  \t\tif (_sqDist(points[i], points[prev]) > sqTolerance) {\r\n  \t\t\treducedPoints.push(points[i]);\r\n  \t\t\tprev = i;\r\n  \t\t}\r\n  \t}\r\n  \tif (prev < len - 1) {\r\n  \t\treducedPoints.push(points[len - 1]);\r\n  \t}\r\n  \treturn reducedPoints;\r\n  }\r\n\r\n  var _lastCode;\r\n\r\n  // @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean\r\n  // Clips the segment a to b by rectangular bounds with the\r\n  // [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)\r\n  // (modifying the segment points directly!). Used by Leaflet to only show polyline\r\n  // points that are on the screen or near, increasing performance.\r\n  function clipSegment(a, b, bounds, useLastCode, round) {\r\n  \tvar codeA = useLastCode ? _lastCode : _getBitCode(a, bounds),\r\n  \t    codeB = _getBitCode(b, bounds),\r\n\r\n  \t    codeOut, p, newCode;\r\n\r\n  \t    // save 2nd code to avoid calculating it on the next segment\r\n  \t    _lastCode = codeB;\r\n\r\n  \twhile (true) {\r\n  \t\t// if a,b is inside the clip window (trivial accept)\r\n  \t\tif (!(codeA | codeB)) {\r\n  \t\t\treturn [a, b];\r\n  \t\t}\r\n\r\n  \t\t// if a,b is outside the clip window (trivial reject)\r\n  \t\tif (codeA & codeB) {\r\n  \t\t\treturn false;\r\n  \t\t}\r\n\r\n  \t\t// other cases\r\n  \t\tcodeOut = codeA || codeB;\r\n  \t\tp = _getEdgeIntersection(a, b, codeOut, bounds, round);\r\n  \t\tnewCode = _getBitCode(p, bounds);\r\n\r\n  \t\tif (codeOut === codeA) {\r\n  \t\t\ta = p;\r\n  \t\t\tcodeA = newCode;\r\n  \t\t} else {\r\n  \t\t\tb = p;\r\n  \t\t\tcodeB = newCode;\r\n  \t\t}\r\n  \t}\r\n  }\r\n\r\n  function _getEdgeIntersection(a, b, code, bounds, round) {\r\n  \tvar dx = b.x - a.x,\r\n  \t    dy = b.y - a.y,\r\n  \t    min = bounds.min,\r\n  \t    max = bounds.max,\r\n  \t    x, y;\r\n\r\n  \tif (code & 8) { // top\r\n  \t\tx = a.x + dx * (max.y - a.y) / dy;\r\n  \t\ty = max.y;\r\n\r\n  \t} else if (code & 4) { // bottom\r\n  \t\tx = a.x + dx * (min.y - a.y) / dy;\r\n  \t\ty = min.y;\r\n\r\n  \t} else if (code & 2) { // right\r\n  \t\tx = max.x;\r\n  \t\ty = a.y + dy * (max.x - a.x) / dx;\r\n\r\n  \t} else if (code & 1) { // left\r\n  \t\tx = min.x;\r\n  \t\ty = a.y + dy * (min.x - a.x) / dx;\r\n  \t}\r\n\r\n  \treturn new Point(x, y, round);\r\n  }\r\n\r\n  function _getBitCode(p, bounds) {\r\n  \tvar code = 0;\r\n\r\n  \tif (p.x < bounds.min.x) { // left\r\n  \t\tcode |= 1;\r\n  \t} else if (p.x > bounds.max.x) { // right\r\n  \t\tcode |= 2;\r\n  \t}\r\n\r\n  \tif (p.y < bounds.min.y) { // bottom\r\n  \t\tcode |= 4;\r\n  \t} else if (p.y > bounds.max.y) { // top\r\n  \t\tcode |= 8;\r\n  \t}\r\n\r\n  \treturn code;\r\n  }\r\n\r\n  // square distance (to avoid unnecessary Math.sqrt calls)\r\n  function _sqDist(p1, p2) {\r\n  \tvar dx = p2.x - p1.x,\r\n  \t    dy = p2.y - p1.y;\r\n  \treturn dx * dx + dy * dy;\r\n  }\r\n\r\n  // return closest point on segment or distance to that point\r\n  function _sqClosestPointOnSegment(p, p1, p2, sqDist) {\r\n  \tvar x = p1.x,\r\n  \t    y = p1.y,\r\n  \t    dx = p2.x - x,\r\n  \t    dy = p2.y - y,\r\n  \t    dot = dx * dx + dy * dy,\r\n  \t    t;\r\n\r\n  \tif (dot > 0) {\r\n  \t\tt = ((p.x - x) * dx + (p.y - y) * dy) / dot;\r\n\r\n  \t\tif (t > 1) {\r\n  \t\t\tx = p2.x;\r\n  \t\t\ty = p2.y;\r\n  \t\t} else if (t > 0) {\r\n  \t\t\tx += dx * t;\r\n  \t\t\ty += dy * t;\r\n  \t\t}\r\n  \t}\r\n\r\n  \tdx = p.x - x;\r\n  \tdy = p.y - y;\r\n\r\n  \treturn sqDist ? dx * dx + dy * dy : new Point(x, y);\r\n  }\r\n\r\n\r\n  // @function isFlat(latlngs: LatLng[]): Boolean\r\n  // Returns true if `latlngs` is a flat array, false is nested.\r\n  function isFlat(latlngs) {\r\n  \treturn !isArray(latlngs[0]) || (typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined');\r\n  }\r\n\r\n  function _flat(latlngs) {\r\n  \tconsole.warn('Deprecated use of _flat, please use L.LineUtil.isFlat instead.');\r\n  \treturn isFlat(latlngs);\r\n  }\r\n\r\n  /* @function polylineCenter(latlngs: LatLng[], crs: CRS): LatLng\r\n   * Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the passed LatLngs (first ring) from a polyline.\r\n   */\r\n  function polylineCenter(latlngs, crs) {\r\n  \tvar i, halfDist, segDist, dist, p1, p2, ratio, center;\r\n\r\n  \tif (!latlngs || latlngs.length === 0) {\r\n  \t\tthrow new Error('latlngs not passed');\r\n  \t}\r\n\r\n  \tif (!isFlat(latlngs)) {\r\n  \t\tconsole.warn('latlngs are not flat! Only the first ring will be used');\r\n  \t\tlatlngs = latlngs[0];\r\n  \t}\r\n\r\n  \tvar points = [];\r\n  \tfor (var j in latlngs) {\r\n  \t\tpoints.push(crs.project(toLatLng(latlngs[j])));\r\n  \t}\r\n\r\n  \tvar len = points.length;\r\n\r\n  \tfor (i = 0, halfDist = 0; i < len - 1; i++) {\r\n  \t\thalfDist += points[i].distanceTo(points[i + 1]) / 2;\r\n  \t}\r\n\r\n  \t// The line is so small in the current view that all points are on the same pixel.\r\n  \tif (halfDist === 0) {\r\n  \t\tcenter = points[0];\r\n  \t} else {\r\n  \t\tfor (i = 0, dist = 0; i < len - 1; i++) {\r\n  \t\t\tp1 = points[i];\r\n  \t\t\tp2 = points[i + 1];\r\n  \t\t\tsegDist = p1.distanceTo(p2);\r\n  \t\t\tdist += segDist;\r\n\r\n  \t\t\tif (dist > halfDist) {\r\n  \t\t\t\tratio = (dist - halfDist) / segDist;\r\n  \t\t\t\tcenter = [\r\n  \t\t\t\t\tp2.x - ratio * (p2.x - p1.x),\r\n  \t\t\t\t\tp2.y - ratio * (p2.y - p1.y)\r\n  \t\t\t\t];\r\n  \t\t\t\tbreak;\r\n  \t\t\t}\r\n  \t\t}\r\n  \t}\r\n  \treturn crs.unproject(toPoint(center));\r\n  }\n\n  var LineUtil = {\n    __proto__: null,\n    simplify: simplify,\n    pointToSegmentDistance: pointToSegmentDistance,\n    closestPointOnSegment: closestPointOnSegment,\n    clipSegment: clipSegment,\n    _getEdgeIntersection: _getEdgeIntersection,\n    _getBitCode: _getBitCode,\n    _sqClosestPointOnSegment: _sqClosestPointOnSegment,\n    isFlat: isFlat,\n    _flat: _flat,\n    polylineCenter: polylineCenter\n  };\n\n  /*\r\n   * @namespace PolyUtil\r\n   * Various utility functions for polygon geometries.\r\n   */\r\n\r\n  /* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]\r\n   * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).\r\n   * Used by Leaflet to only show polygon points that are on the screen or near, increasing\r\n   * performance. Note that polygon points needs different algorithm for clipping\r\n   * than polyline, so there's a separate method for it.\r\n   */\r\n  function clipPolygon(points, bounds, round) {\r\n  \tvar clippedPoints,\r\n  \t    edges = [1, 4, 2, 8],\r\n  \t    i, j, k,\r\n  \t    a, b,\r\n  \t    len, edge, p;\r\n\r\n  \tfor (i = 0, len = points.length; i < len; i++) {\r\n  \t\tpoints[i]._code = _getBitCode(points[i], bounds);\r\n  \t}\r\n\r\n  \t// for each edge (left, bottom, right, top)\r\n  \tfor (k = 0; k < 4; k++) {\r\n  \t\tedge = edges[k];\r\n  \t\tclippedPoints = [];\r\n\r\n  \t\tfor (i = 0, len = points.length, j = len - 1; i < len; j = i++) {\r\n  \t\t\ta = points[i];\r\n  \t\t\tb = points[j];\r\n\r\n  \t\t\t// if a is inside the clip window\r\n  \t\t\tif (!(a._code & edge)) {\r\n  \t\t\t\t// if b is outside the clip window (a->b goes out of screen)\r\n  \t\t\t\tif (b._code & edge) {\r\n  \t\t\t\t\tp = _getEdgeIntersection(b, a, edge, bounds, round);\r\n  \t\t\t\t\tp._code = _getBitCode(p, bounds);\r\n  \t\t\t\t\tclippedPoints.push(p);\r\n  \t\t\t\t}\r\n  \t\t\t\tclippedPoints.push(a);\r\n\r\n  \t\t\t// else if b is inside the clip window (a->b enters the screen)\r\n  \t\t\t} else if (!(b._code & edge)) {\r\n  \t\t\t\tp = _getEdgeIntersection(b, a, edge, bounds, round);\r\n  \t\t\t\tp._code = _getBitCode(p, bounds);\r\n  \t\t\t\tclippedPoints.push(p);\r\n  \t\t\t}\r\n  \t\t}\r\n  \t\tpoints = clippedPoints;\r\n  \t}\r\n\r\n  \treturn points;\r\n  }\r\n\r\n  /* @function polygonCenter(latlngs: LatLng[] crs: CRS): LatLng\r\n   * Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the passed LatLngs (first ring) from a polygon.\r\n   */\r\n  function polygonCenter(latlngs, crs) {\r\n  \tvar i, j, p1, p2, f, area, x, y, center;\r\n\r\n  \tif (!latlngs || latlngs.length === 0) {\r\n  \t\tthrow new Error('latlngs not passed');\r\n  \t}\r\n\r\n  \tif (!isFlat(latlngs)) {\r\n  \t\tconsole.warn('latlngs are not flat! Only the first ring will be used');\r\n  \t\tlatlngs = latlngs[0];\r\n  \t}\r\n\r\n  \tvar points = [];\r\n  \tfor (var k in latlngs) {\r\n  \t\tpoints.push(crs.project(toLatLng(latlngs[k])));\r\n  \t}\r\n\r\n  \tvar len = points.length;\r\n  \tarea = x = y = 0;\r\n\r\n  \t// polygon centroid algorithm;\r\n  \tfor (i = 0, j = len - 1; i < len; j = i++) {\r\n  \t\tp1 = points[i];\r\n  \t\tp2 = points[j];\r\n\r\n  \t\tf = p1.y * p2.x - p2.y * p1.x;\r\n  \t\tx += (p1.x + p2.x) * f;\r\n  \t\ty += (p1.y + p2.y) * f;\r\n  \t\tarea += f * 3;\r\n  \t}\r\n\r\n  \tif (area === 0) {\r\n  \t\t// Polygon is so small that all points are on same pixel.\r\n  \t\tcenter = points[0];\r\n  \t} else {\r\n  \t\tcenter = [x / area, y / area];\r\n  \t}\r\n  \treturn crs.unproject(toPoint(center));\r\n  }\n\n  var PolyUtil = {\n    __proto__: null,\n    clipPolygon: clipPolygon,\n    polygonCenter: polygonCenter\n  };\n\n  /*\r\n   * @namespace Projection\r\n   * @section\r\n   * Leaflet comes with a set of already defined Projections out of the box:\r\n   *\r\n   * @projection L.Projection.LonLat\r\n   *\r\n   * Equirectangular, or Plate Carree projection  the most simple projection,\r\n   * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as\r\n   * latitude. Also suitable for flat worlds, e.g. game maps. Used by the\r\n   * `EPSG:4326` and `Simple` CRS.\r\n   */\r\n\r\n  var LonLat = {\r\n  \tproject: function (latlng) {\r\n  \t\treturn new Point(latlng.lng, latlng.lat);\r\n  \t},\r\n\r\n  \tunproject: function (point) {\r\n  \t\treturn new LatLng(point.y, point.x);\r\n  \t},\r\n\r\n  \tbounds: new Bounds([-180, -90], [180, 90])\r\n  };\n\n  /*\r\n   * @namespace Projection\r\n   * @projection L.Projection.Mercator\r\n   *\r\n   * Elliptical Mercator projection  more complex than Spherical Mercator. Assumes that Earth is an ellipsoid. Used by the EPSG:3395 CRS.\r\n   */\r\n\r\n  var Mercator = {\r\n  \tR: 6378137,\r\n  \tR_MINOR: 6356752.314245179,\r\n\r\n  \tbounds: new Bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),\r\n\r\n  \tproject: function (latlng) {\r\n  \t\tvar d = Math.PI / 180,\r\n  \t\t    r = this.R,\r\n  \t\t    y = latlng.lat * d,\r\n  \t\t    tmp = this.R_MINOR / r,\r\n  \t\t    e = Math.sqrt(1 - tmp * tmp),\r\n  \t\t    con = e * Math.sin(y);\r\n\r\n  \t\tvar ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);\r\n  \t\ty = -r * Math.log(Math.max(ts, 1E-10));\r\n\r\n  \t\treturn new Point(latlng.lng * d * r, y);\r\n  \t},\r\n\r\n  \tunproject: function (point) {\r\n  \t\tvar d = 180 / Math.PI,\r\n  \t\t    r = this.R,\r\n  \t\t    tmp = this.R_MINOR / r,\r\n  \t\t    e = Math.sqrt(1 - tmp * tmp),\r\n  \t\t    ts = Math.exp(-point.y / r),\r\n  \t\t    phi = Math.PI / 2 - 2 * Math.atan(ts);\r\n\r\n  \t\tfor (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {\r\n  \t\t\tcon = e * Math.sin(phi);\r\n  \t\t\tcon = Math.pow((1 - con) / (1 + con), e / 2);\r\n  \t\t\tdphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;\r\n  \t\t\tphi += dphi;\r\n  \t\t}\r\n\r\n  \t\treturn new LatLng(phi * d, point.x * d / r);\r\n  \t}\r\n  };\n\n  /*\n   * @class Projection\n\n   * An object with methods for projecting geographical coordinates of the world onto\n   * a flat surface (and back). See [Map projection](https://en.wikipedia.org/wiki/Map_projection).\n\n   * @property bounds: Bounds\n   * The bounds (specified in CRS units) where the projection is valid\n\n   * @method project(latlng: LatLng): Point\n   * Projects geographical coordinates into a 2D point.\n   * Only accepts actual `L.LatLng` instances, not arrays.\n\n   * @method unproject(point: Point): LatLng\n   * The inverse of `project`. Projects a 2D point into a geographical location.\n   * Only accepts actual `L.Point` instances, not arrays.\n\n   * Note that the projection instances do not inherit from Leaflet's `Class` object,\n   * and can't be instantiated. Also, new classes can't inherit from them,\n   * and methods can't be added to them with the `include` function.\n\n   */\n\n  var index = {\n    __proto__: null,\n    LonLat: LonLat,\n    Mercator: Mercator,\n    SphericalMercator: SphericalMercator\n  };\n\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.EPSG3395\r\n   *\r\n   * Rarely used by some commercial tile providers. Uses Elliptical Mercator projection.\r\n   */\r\n  var EPSG3395 = extend({}, Earth, {\r\n  \tcode: 'EPSG:3395',\r\n  \tprojection: Mercator,\r\n\r\n  \ttransformation: (function () {\r\n  \t\tvar scale = 0.5 / (Math.PI * Mercator.R);\r\n  \t\treturn toTransformation(scale, 0.5, -scale, 0.5);\r\n  \t}())\r\n  });\n\n  /*\r\n   * @namespace CRS\r\n   * @crs L.CRS.EPSG4326\r\n   *\r\n   * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.\r\n   *\r\n   * Leaflet 1.0.x complies with the [TMS coordinate scheme for EPSG:4326](https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification#global-geodetic),\r\n   * which is a breaking change from 0.7.x behaviour.  If you are using a `TileLayer`\r\n   * with this CRS, ensure that there are two 256x256 pixel tiles covering the\r\n   * whole earth at zoom level zero, and that the tile coordinate origin is (-180,+90),\r\n   * or (-180,-90) for `TileLayer`s with [the `tms` option](#tilelayer-tms) set.\r\n   */\r\n\r\n  var EPSG4326 = extend({}, Earth, {\r\n  \tcode: 'EPSG:4326',\r\n  \tprojection: LonLat,\r\n  \ttransformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)\r\n  });\n\n  /*\n   * @namespace CRS\n   * @crs L.CRS.Simple\n   *\n   * A simple CRS that maps longitude and latitude into `x` and `y` directly.\n   * May be used for maps of flat surfaces (e.g. game maps). Note that the `y`\n   * axis should still be inverted (going from bottom to top). `distance()` returns\n   * simple euclidean distance.\n   */\n\n  var Simple = extend({}, CRS, {\n  \tprojection: LonLat,\n  \ttransformation: toTransformation(1, 0, -1, 0),\n\n  \tscale: function (zoom) {\n  \t\treturn Math.pow(2, zoom);\n  \t},\n\n  \tzoom: function (scale) {\n  \t\treturn Math.log(scale) / Math.LN2;\n  \t},\n\n  \tdistance: function (latlng1, latlng2) {\n  \t\tvar dx = latlng2.lng - latlng1.lng,\n  \t\t    dy = latlng2.lat - latlng1.lat;\n\n  \t\treturn Math.sqrt(dx * dx + dy * dy);\n  \t},\n\n  \tinfinite: true\n  });\n\n  CRS.Earth = Earth;\n  CRS.EPSG3395 = EPSG3395;\n  CRS.EPSG3857 = EPSG3857;\n  CRS.EPSG900913 = EPSG900913;\n  CRS.EPSG4326 = EPSG4326;\n  CRS.Simple = Simple;\n\n  /*\n   * @class Layer\n   * @inherits Evented\n   * @aka L.Layer\n   * @aka ILayer\n   *\n   * A set of methods from the Layer base class that all Leaflet layers use.\n   * Inherits all methods, options and events from `L.Evented`.\n   *\n   * @example\n   *\n   * ```js\n   * var layer = L.marker(latlng).addTo(map);\n   * layer.addTo(map);\n   * layer.remove();\n   * ```\n   *\n   * @event add: Event\n   * Fired after the layer is added to a map\n   *\n   * @event remove: Event\n   * Fired after the layer is removed from a map\n   */\n\n\n  var Layer = Evented.extend({\n\n  \t// Classes extending `L.Layer` will inherit the following options:\n  \toptions: {\n  \t\t// @option pane: String = 'overlayPane'\n  \t\t// By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.\n  \t\tpane: 'overlayPane',\n\n  \t\t// @option attribution: String = null\n  \t\t// String to be shown in the attribution control, e.g. \" OpenStreetMap contributors\". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.\n  \t\tattribution: null,\n\n  \t\tbubblingMouseEvents: true\n  \t},\n\n  \t/* @section\n  \t * Classes extending `L.Layer` will inherit the following methods:\n  \t *\n  \t * @method addTo(map: Map|LayerGroup): this\n  \t * Adds the layer to the given map or layer group.\n  \t */\n  \taddTo: function (map) {\n  \t\tmap.addLayer(this);\n  \t\treturn this;\n  \t},\n\n  \t// @method remove: this\n  \t// Removes the layer from the map it is currently active on.\n  \tremove: function () {\n  \t\treturn this.removeFrom(this._map || this._mapToAdd);\n  \t},\n\n  \t// @method removeFrom(map: Map): this\n  \t// Removes the layer from the given map\n  \t//\n  \t// @alternative\n  \t// @method removeFrom(group: LayerGroup): this\n  \t// Removes the layer from the given `LayerGroup`\n  \tremoveFrom: function (obj) {\n  \t\tif (obj) {\n  \t\t\tobj.removeLayer(this);\n  \t\t}\n  \t\treturn this;\n  \t},\n\n  \t// @method getPane(name? : String): HTMLElement\n  \t// Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.\n  \tgetPane: function (name) {\n  \t\treturn this._map.getPane(name ? (this.options[name] || name) : this.options.pane);\n  \t},\n\n  \taddInteractiveTarget: function (targetEl) {\n  \t\tthis._map._targets[stamp(targetEl)] = this;\n  \t\treturn this;\n  \t},\n\n  \tremoveInteractiveTarget: function (targetEl) {\n  \t\tdelete this._map._targets[stamp(targetEl)];\n  \t\treturn this;\n  \t},\n\n  \t// @method getAttribution: String\n  \t// Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).\n  \tgetAttribution: function () {\n  \t\treturn this.options.attribution;\n  \t},\n\n  \t_layerAdd: function (e) {\n  \t\tvar map = e.target;\n\n  \t\t// check in case layer gets added and then removed before the map is ready\n  \t\tif (!map.hasLayer(this)) { return; }\n\n  \t\tthis._map = map;\n  \t\tthis._zoomAnimated = map._zoomAnimated;\n\n  \t\tif (this.getEvents) {\n  \t\t\tvar events = this.getEvents();\n  \t\t\tmap.on(events, this);\n  \t\t\tthis.once('remove', function () {\n  \t\t\t\tmap.off(events, this);\n  \t\t\t}, this);\n  \t\t}\n\n  \t\tthis.onAdd(map);\n\n  \t\tthis.fire('add');\n  \t\tmap.fire('layeradd', {layer: this});\n  \t}\n  });\n\n  /* @section Extension methods\n   * @uninheritable\n   *\n   * Every layer should extend from `L.Layer` and (re-)implement the following methods.\n   *\n   * @method onAdd(map: Map): this\n   * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on [`map.addLayer(layer)`](#map-addlayer).\n   *\n   * @method onRemove(map: Map): this\n   * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in [`onAdd`](#layer-onadd). Called on [`map.removeLayer(layer)`](#map-removelayer).\n   *\n   * @method getEvents(): Object\n   * This optional method should return an object like `{ viewreset: this._reset }` for [`addEventListener`](#evented-addeventlistener). The event handlers in this object will be automatically added and removed from the map with your layer.\n   *\n   * @method getAttribution(): String\n   * This optional method should return a string containing HTML to be shown on the `Attribution control` whenever the layer is visible.\n   *\n   * @method beforeAdd(map: Map): this\n   * Optional method. Called on [`map.addLayer(layer)`](#map-addlayer), before the layer is added to the map, before events are initialized, without waiting until the map is in a usable state. Use for early initialization only.\n   */\n\n\n  /* @namespace Map\n   * @section Layer events\n   *\n   * @event layeradd: LayerEvent\n   * Fired when a new layer is added to the map.\n   *\n   * @event layerremove: LayerEvent\n   * Fired when some layer is removed from the map\n   *\n   * @section Methods for Layers and Controls\n   */\n  Map.include({\n  \t// @method addLayer(layer: Layer): this\n  \t// Adds the given layer to the map\n  \taddLayer: function (layer) {\n  \t\tif (!layer._layerAdd) {\n  \t\t\tthrow new Error('The provided object is not a Layer.');\n  \t\t}\n\n  \t\tvar id = stamp(layer);\n  \t\tif (this._layers[id]) { return this; }\n  \t\tthis._layers[id] = layer;\n\n  \t\tlayer._mapToAdd = this;\n\n  \t\tif (layer.beforeAdd) {\n  \t\t\tlayer.beforeAdd(this);\n  \t\t}\n\n  \t\tthis.whenReady(layer._layerAdd, layer);\n\n  \t\treturn this;\n  \t},\n\n  \t// @method removeLayer(layer: Layer): this\n  \t// Removes the given layer from the map.\n  \tremoveLayer: function (layer) {\n  \t\tvar id = stamp(layer);\n\n  \t\tif (!this._layers[id]) { return this; }\n\n  \t\tif (this._loaded) {\n  \t\t\tlayer.onRemove(this);\n  \t\t}\n\n  \t\tdelete this._layers[id];\n\n  \t\tif (this._loaded) {\n  \t\t\tthis.fire('layerremove', {layer: layer});\n  \t\t\tlayer.fire('remove');\n  \t\t}\n\n  \t\tlayer._map = layer._mapToAdd = null;\n\n  \t\treturn this;\n  \t},\n\n  \t// @method hasLayer(layer: Layer): Boolean\n  \t// Returns `true` if the given layer is currently added to the map\n  \thasLayer: function (layer) {\n  \t\treturn stamp(layer) in this._layers;\n  \t},\n\n  \t/* @method eachLayer(fn: Function, context?: Object): this\n  \t * Iterates over the layers of the map, optionally specifying context of the iterator function.\n  \t * ```\n  \t * map.eachLayer(function(layer){\n  \t *     layer.bindPopup('Hello');\n  \t * });\n  \t * ```\n  \t */\n  \teachLayer: function (method, context) {\n  \t\tfor (var i in this._layers) {\n  \t\t\tmethod.call(context, this._layers[i]);\n  \t\t}\n  \t\treturn this;\n  \t},\n\n  \t_addLayers: function (layers) {\n  \t\tlayers = layers ? (isArray(layers) ? layers : [layers]) : [];\n\n  \t\tfor (var i = 0, len = layers.length; i < len; i++) {\n  \t\t\tthis.addLayer(layers[i]);\n  \t\t}\n  \t},\n\n  \t_addZoomLimit: function (layer) {\n  \t\tif (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {\n  \t\t\tthis._zoomBoundLayers[stamp(layer)] = layer;\n  \t\t\tthis._updateZoomLevels();\n  \t\t}\n  \t},\n\n  \t_removeZoomLimit: function (layer) {\n  \t\tvar id = stamp(layer);\n\n  \t\tif (this._zoomBoundLayers[id]) {\n  \t\t\tdelete this._zoomBoundLayers[id];\n  \t\t\tthis._updateZoomLevels();\n  \t\t}\n  \t},\n\n  \t_updateZoomLevels: function () {\n  \t\tvar minZoom = Infinity,\n  \t\t    maxZoom = -Infinity,\n  \t\t    oldZoomSpan = this._getZoomSpan();\n\n  \t\tfor (var i in this._zoomBoundLayers) {\n  \t\t\tvar options = this._zoomBoundLayers[i].options;\n\n  \t\t\tminZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);\n  \t\t\tmaxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);\n  \t\t}\n\n  \t\tthis._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;\n  \t\tthis._layersMinZoom = minZoom === Infinity ? undefined : minZoom;\n\n  \t\t// @section Map state change events\n  \t\t// @event zoomlevelschange: Event\n  \t\t// Fired when the number of zoomlevels on the map is changed due\n  \t\t// to adding or removing a layer.\n  \t\tif (oldZoomSpan !== this._getZoomSpan()) {\n  \t\t\tthis.fire('zoomlevelschange');\n  \t\t}\n\n  \t\tif (this.options.maxZoom === undefined && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {\n  \t\t\tthis.setZoom(this._layersMaxZoom);\n  \t\t}\n  \t\tif (this.options.minZoom === undefined && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {\n  \t\t\tthis.setZoom(this._layersMinZoom);\n  \t\t}\n  \t}\n  });\n\n  /*\r\n   * @class LayerGroup\r\n   * @aka L.LayerGroup\r\n   * @inherits Interactive layer\r\n   *\r\n   * Used to group several layers and handle them as one. If you add it to the map,\r\n   * any layers added or removed from the group will be added/removed on the map as\r\n   * well. Extends `Layer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.layerGroup([marker1, marker2])\r\n   * \t.addLayer(polyline)\r\n   * \t.addTo(map);\r\n   * ```\r\n   */\r\n\r\n  var LayerGroup = Layer.extend({\r\n\r\n  \tinitialize: function (layers, options) {\r\n  \t\tsetOptions(this, options);\r\n\r\n  \t\tthis._layers = {};\r\n\r\n  \t\tvar i, len;\r\n\r\n  \t\tif (layers) {\r\n  \t\t\tfor (i = 0, len = layers.length; i < len; i++) {\r\n  \t\t\t\tthis.addLayer(layers[i]);\r\n  \t\t\t}\r\n  \t\t}\r\n  \t},\r\n\r\n  \t// @method addLayer(layer: Layer): this\r\n  \t// Adds the given layer to the group.\r\n  \taddLayer: function (layer) {\r\n  \t\tvar id = this.getLayerId(layer);\r\n\r\n  \t\tthis._layers[id] = layer;\r\n\r\n  \t\tif (this._map) {\r\n  \t\t\tthis._map.addLayer(layer);\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method removeLayer(layer: Layer): this\r\n  \t// Removes the given layer from the group.\r\n  \t// @alternative\r\n  \t// @method removeLayer(id: Number): this\r\n  \t// Removes the layer with the given internal ID from the group.\r\n  \tremoveLayer: function (layer) {\r\n  \t\tvar id = layer in this._layers ? layer : this.getLayerId(layer);\r\n\r\n  \t\tif (this._map && this._layers[id]) {\r\n  \t\t\tthis._map.removeLayer(this._layers[id]);\r\n  \t\t}\r\n\r\n  \t\tdelete this._layers[id];\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method hasLayer(layer: Layer): Boolean\r\n  \t// Returns `true` if the given layer is currently added to the group.\r\n  \t// @alternative\r\n  \t// @method hasLayer(id: Number): Boolean\r\n  \t// Returns `true` if the given internal ID is currently added to the group.\r\n  \thasLayer: function (layer) {\r\n  \t\tvar layerId = typeof layer === 'number' ? layer : this.getLayerId(layer);\r\n  \t\treturn layerId in this._layers;\r\n  \t},\r\n\r\n  \t// @method clearLayers(): this\r\n  \t// Removes all the layers from the group.\r\n  \tclearLayers: function () {\r\n  \t\treturn this.eachLayer(this.removeLayer, this);\r\n  \t},\r\n\r\n  \t// @method invoke(methodName: String, ): this\r\n  \t// Calls `methodName` on every layer contained in this group, passing any\r\n  \t// additional parameters. Has no effect if the layers contained do not\r\n  \t// implement `methodName`.\r\n  \tinvoke: function (methodName) {\r\n  \t\tvar args = Array.prototype.slice.call(arguments, 1),\r\n  \t\t    i, layer;\r\n\r\n  \t\tfor (i in this._layers) {\r\n  \t\t\tlayer = this._layers[i];\r\n\r\n  \t\t\tif (layer[methodName]) {\r\n  \t\t\t\tlayer[methodName].apply(layer, args);\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \tonAdd: function (map) {\r\n  \t\tthis.eachLayer(map.addLayer, map);\r\n  \t},\r\n\r\n  \tonRemove: function (map) {\r\n  \t\tthis.eachLayer(map.removeLayer, map);\r\n  \t},\r\n\r\n  \t// @method eachLayer(fn: Function, context?: Object): this\r\n  \t// Iterates over the layers of the group, optionally specifying context of the iterator function.\r\n  \t// ```js\r\n  \t// group.eachLayer(function (layer) {\r\n  \t// \tlayer.bindPopup('Hello');\r\n  \t// });\r\n  \t// ```\r\n  \teachLayer: function (method, context) {\r\n  \t\tfor (var i in this._layers) {\r\n  \t\t\tmethod.call(context, this._layers[i]);\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method getLayer(id: Number): Layer\r\n  \t// Returns the layer with the given internal ID.\r\n  \tgetLayer: function (id) {\r\n  \t\treturn this._layers[id];\r\n  \t},\r\n\r\n  \t// @method getLayers(): Layer[]\r\n  \t// Returns an array of all the layers added to the group.\r\n  \tgetLayers: function () {\r\n  \t\tvar layers = [];\r\n  \t\tthis.eachLayer(layers.push, layers);\r\n  \t\treturn layers;\r\n  \t},\r\n\r\n  \t// @method setZIndex(zIndex: Number): this\r\n  \t// Calls `setZIndex` on every layer contained in this group, passing the z-index.\r\n  \tsetZIndex: function (zIndex) {\r\n  \t\treturn this.invoke('setZIndex', zIndex);\r\n  \t},\r\n\r\n  \t// @method getLayerId(layer: Layer): Number\r\n  \t// Returns the internal ID for a layer\r\n  \tgetLayerId: function (layer) {\r\n  \t\treturn stamp(layer);\r\n  \t}\r\n  });\r\n\r\n\r\n  // @factory L.layerGroup(layers?: Layer[], options?: Object)\r\n  // Create a layer group, optionally given an initial set of layers and an `options` object.\r\n  var layerGroup = function (layers, options) {\r\n  \treturn new LayerGroup(layers, options);\r\n  };\n\n  /*\r\n   * @class FeatureGroup\r\n   * @aka L.FeatureGroup\r\n   * @inherits LayerGroup\r\n   *\r\n   * Extended `LayerGroup` that makes it easier to do the same thing to all its member layers:\r\n   *  * [`bindPopup`](#layer-bindpopup) binds a popup to all of the layers at once (likewise with [`bindTooltip`](#layer-bindtooltip))\r\n   *  * Events are propagated to the `FeatureGroup`, so if the group has an event\r\n   * handler, it will handle events from any of the layers. This includes mouse events\r\n   * and custom events.\r\n   *  * Has `layeradd` and `layerremove` events\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.featureGroup([marker1, marker2, polyline])\r\n   * \t.bindPopup('Hello world!')\r\n   * \t.on('click', function() { alert('Clicked on a member of the group!'); })\r\n   * \t.addTo(map);\r\n   * ```\r\n   */\r\n\r\n  var FeatureGroup = LayerGroup.extend({\r\n\r\n  \taddLayer: function (layer) {\r\n  \t\tif (this.hasLayer(layer)) {\r\n  \t\t\treturn this;\r\n  \t\t}\r\n\r\n  \t\tlayer.addEventParent(this);\r\n\r\n  \t\tLayerGroup.prototype.addLayer.call(this, layer);\r\n\r\n  \t\t// @event layeradd: LayerEvent\r\n  \t\t// Fired when a layer is added to this `FeatureGroup`\r\n  \t\treturn this.fire('layeradd', {layer: layer});\r\n  \t},\r\n\r\n  \tremoveLayer: function (layer) {\r\n  \t\tif (!this.hasLayer(layer)) {\r\n  \t\t\treturn this;\r\n  \t\t}\r\n  \t\tif (layer in this._layers) {\r\n  \t\t\tlayer = this._layers[layer];\r\n  \t\t}\r\n\r\n  \t\tlayer.removeEventParent(this);\r\n\r\n  \t\tLayerGroup.prototype.removeLayer.call(this, layer);\r\n\r\n  \t\t// @event layerremove: LayerEvent\r\n  \t\t// Fired when a layer is removed from this `FeatureGroup`\r\n  \t\treturn this.fire('layerremove', {layer: layer});\r\n  \t},\r\n\r\n  \t// @method setStyle(style: Path options): this\r\n  \t// Sets the given path options to each layer of the group that has a `setStyle` method.\r\n  \tsetStyle: function (style) {\r\n  \t\treturn this.invoke('setStyle', style);\r\n  \t},\r\n\r\n  \t// @method bringToFront(): this\r\n  \t// Brings the layer group to the top of all other layers\r\n  \tbringToFront: function () {\r\n  \t\treturn this.invoke('bringToFront');\r\n  \t},\r\n\r\n  \t// @method bringToBack(): this\r\n  \t// Brings the layer group to the back of all other layers\r\n  \tbringToBack: function () {\r\n  \t\treturn this.invoke('bringToBack');\r\n  \t},\r\n\r\n  \t// @method getBounds(): LatLngBounds\r\n  \t// Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).\r\n  \tgetBounds: function () {\r\n  \t\tvar bounds = new LatLngBounds();\r\n\r\n  \t\tfor (var id in this._layers) {\r\n  \t\t\tvar layer = this._layers[id];\r\n  \t\t\tbounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());\r\n  \t\t}\r\n  \t\treturn bounds;\r\n  \t}\r\n  });\r\n\r\n  // @factory L.featureGroup(layers?: Layer[], options?: Object)\r\n  // Create a feature group, optionally given an initial set of layers and an `options` object.\r\n  var featureGroup = function (layers, options) {\r\n  \treturn new FeatureGroup(layers, options);\r\n  };\n\n  /*\r\n   * @class Icon\r\n   * @aka L.Icon\r\n   *\r\n   * Represents an icon to provide when creating a marker.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var myIcon = L.icon({\r\n   *     iconUrl: 'my-icon.png',\r\n   *     iconRetinaUrl: 'my-icon@2x.png',\r\n   *     iconSize: [38, 95],\r\n   *     iconAnchor: [22, 94],\r\n   *     popupAnchor: [-3, -76],\r\n   *     shadowUrl: 'my-icon-shadow.png',\r\n   *     shadowRetinaUrl: 'my-icon-shadow@2x.png',\r\n   *     shadowSize: [68, 95],\r\n   *     shadowAnchor: [22, 94]\r\n   * });\r\n   *\r\n   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);\r\n   * ```\r\n   *\r\n   * `L.Icon.Default` extends `L.Icon` and is the blue icon Leaflet uses for markers by default.\r\n   *\r\n   */\r\n\r\n  var Icon = Class.extend({\r\n\r\n  \t/* @section\r\n  \t * @aka Icon options\r\n  \t *\r\n  \t * @option iconUrl: String = null\r\n  \t * **(required)** The URL to the icon image (absolute or relative to your script path).\r\n  \t *\r\n  \t * @option iconRetinaUrl: String = null\r\n  \t * The URL to a retina sized version of the icon image (absolute or relative to your\r\n  \t * script path). Used for Retina screen devices.\r\n  \t *\r\n  \t * @option iconSize: Point = null\r\n  \t * Size of the icon image in pixels.\r\n  \t *\r\n  \t * @option iconAnchor: Point = null\r\n  \t * The coordinates of the \"tip\" of the icon (relative to its top left corner). The icon\r\n  \t * will be aligned so that this point is at the marker's geographical location. Centered\r\n  \t * by default if size is specified, also can be set in CSS with negative margins.\r\n  \t *\r\n  \t * @option popupAnchor: Point = [0, 0]\r\n  \t * The coordinates of the point from which popups will \"open\", relative to the icon anchor.\r\n  \t *\r\n  \t * @option tooltipAnchor: Point = [0, 0]\r\n  \t * The coordinates of the point from which tooltips will \"open\", relative to the icon anchor.\r\n  \t *\r\n  \t * @option shadowUrl: String = null\r\n  \t * The URL to the icon shadow image. If not specified, no shadow image will be created.\r\n  \t *\r\n  \t * @option shadowRetinaUrl: String = null\r\n  \t *\r\n  \t * @option shadowSize: Point = null\r\n  \t * Size of the shadow image in pixels.\r\n  \t *\r\n  \t * @option shadowAnchor: Point = null\r\n  \t * The coordinates of the \"tip\" of the shadow (relative to its top left corner) (the same\r\n  \t * as iconAnchor if not specified).\r\n  \t *\r\n  \t * @option className: String = ''\r\n  \t * A custom class name to assign to both icon and shadow images. Empty by default.\r\n  \t */\r\n\r\n  \toptions: {\r\n  \t\tpopupAnchor: [0, 0],\r\n  \t\ttooltipAnchor: [0, 0],\r\n\r\n  \t\t// @option crossOrigin: Boolean|String = false\r\n  \t\t// Whether the crossOrigin attribute will be added to the tiles.\r\n  \t\t// If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.\r\n  \t\t// Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.\r\n  \t\tcrossOrigin: false\r\n  \t},\r\n\r\n  \tinitialize: function (options) {\r\n  \t\tsetOptions(this, options);\r\n  \t},\r\n\r\n  \t// @method createIcon(oldIcon?: HTMLElement): HTMLElement\r\n  \t// Called internally when the icon has to be shown, returns a `<img>` HTML element\r\n  \t// styled according to the options.\r\n  \tcreateIcon: function (oldIcon) {\r\n  \t\treturn this._createIcon('icon', oldIcon);\r\n  \t},\r\n\r\n  \t// @method createShadow(oldIcon?: HTMLElement): HTMLElement\r\n  \t// As `createIcon`, but for the shadow beneath it.\r\n  \tcreateShadow: function (oldIcon) {\r\n  \t\treturn this._createIcon('shadow', oldIcon);\r\n  \t},\r\n\r\n  \t_createIcon: function (name, oldIcon) {\r\n  \t\tvar src = this._getIconUrl(name);\r\n\r\n  \t\tif (!src) {\r\n  \t\t\tif (name === 'icon') {\r\n  \t\t\t\tthrow new Error('iconUrl not set in Icon options (see the docs).');\r\n  \t\t\t}\r\n  \t\t\treturn null;\r\n  \t\t}\r\n\r\n  \t\tvar img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);\r\n  \t\tthis._setIconStyles(img, name);\r\n\r\n  \t\tif (this.options.crossOrigin || this.options.crossOrigin === '') {\r\n  \t\t\timg.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;\r\n  \t\t}\r\n\r\n  \t\treturn img;\r\n  \t},\r\n\r\n  \t_setIconStyles: function (img, name) {\r\n  \t\tvar options = this.options;\r\n  \t\tvar sizeOption = options[name + 'Size'];\r\n\r\n  \t\tif (typeof sizeOption === 'number') {\r\n  \t\t\tsizeOption = [sizeOption, sizeOption];\r\n  \t\t}\r\n\r\n  \t\tvar size = toPoint(sizeOption),\r\n  \t\t    anchor = toPoint(name === 'shadow' && options.shadowAnchor || options.iconAnchor ||\r\n  \t\t            size && size.divideBy(2, true));\r\n\r\n  \t\timg.className = 'leaflet-marker-' + name + ' ' + (options.className || '');\r\n\r\n  \t\tif (anchor) {\r\n  \t\t\timg.style.marginLeft = (-anchor.x) + 'px';\r\n  \t\t\timg.style.marginTop  = (-anchor.y) + 'px';\r\n  \t\t}\r\n\r\n  \t\tif (size) {\r\n  \t\t\timg.style.width  = size.x + 'px';\r\n  \t\t\timg.style.height = size.y + 'px';\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_createImg: function (src, el) {\r\n  \t\tel = el || document.createElement('img');\r\n  \t\tel.src = src;\r\n  \t\treturn el;\r\n  \t},\r\n\r\n  \t_getIconUrl: function (name) {\r\n  \t\treturn Browser.retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];\r\n  \t}\r\n  });\r\n\r\n\r\n  // @factory L.icon(options: Icon options)\r\n  // Creates an icon instance with the given options.\r\n  function icon(options) {\r\n  \treturn new Icon(options);\r\n  }\n\n  /*\n   * @miniclass Icon.Default (Icon)\n   * @aka L.Icon.Default\n   * @section\n   *\n   * A trivial subclass of `Icon`, represents the icon to use in `Marker`s when\n   * no icon is specified. Points to the blue marker image distributed with Leaflet\n   * releases.\n   *\n   * In order to customize the default icon, just change the properties of `L.Icon.Default.prototype.options`\n   * (which is a set of `Icon options`).\n   *\n   * If you want to _completely_ replace the default icon, override the\n   * `L.Marker.prototype.options.icon` with your own icon instead.\n   */\n\n  var IconDefault = Icon.extend({\n\n  \toptions: {\n  \t\ticonUrl:       'marker-icon.png',\n  \t\ticonRetinaUrl: 'marker-icon-2x.png',\n  \t\tshadowUrl:     'marker-shadow.png',\n  \t\ticonSize:    [25, 41],\n  \t\ticonAnchor:  [12, 41],\n  \t\tpopupAnchor: [1, -34],\n  \t\ttooltipAnchor: [16, -28],\n  \t\tshadowSize:  [41, 41]\n  \t},\n\n  \t_getIconUrl: function (name) {\n  \t\tif (typeof IconDefault.imagePath !== 'string') {\t// Deprecated, backwards-compatibility only\n  \t\t\tIconDefault.imagePath = this._detectIconPath();\n  \t\t}\n\n  \t\t// @option imagePath: String\n  \t\t// `Icon.Default` will try to auto-detect the location of the\n  \t\t// blue icon images. If you are placing these images in a non-standard\n  \t\t// way, set this option to point to the right path.\n  \t\treturn (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);\n  \t},\n\n  \t_stripUrl: function (path) {\t// separate function to use in tests\n  \t\tvar strip = function (str, re, idx) {\n  \t\t\tvar match = re.exec(str);\n  \t\t\treturn match && match[idx];\n  \t\t};\n  \t\tpath = strip(path, /^url\\((['\"])?(.+)\\1\\)$/, 2);\n  \t\treturn path && strip(path, /^(.*)marker-icon\\.png$/, 1);\n  \t},\n\n  \t_detectIconPath: function () {\n  \t\tvar el = create$1('div',  'leaflet-default-icon-path', document.body);\n  \t\tvar path = getStyle(el, 'background-image') ||\n  \t\t           getStyle(el, 'backgroundImage');\t// IE8\n\n  \t\tdocument.body.removeChild(el);\n  \t\tpath = this._stripUrl(path);\n  \t\tif (path) { return path; }\n  \t\tvar link = document.querySelector('link[href$=\"leaflet.css\"]');\n  \t\tif (!link) { return ''; }\n  \t\treturn link.href.substring(0, link.href.length - 'leaflet.css'.length - 1);\n  \t}\n  });\n\n  /*\n   * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.\n   */\n\n\n  /* @namespace Marker\n   * @section Interaction handlers\n   *\n   * Interaction handlers are properties of a marker instance that allow you to control interaction behavior in runtime, enabling or disabling certain features such as dragging (see `Handler` methods). Example:\n   *\n   * ```js\n   * marker.dragging.disable();\n   * ```\n   *\n   * @property dragging: Handler\n   * Marker dragging handler (by both mouse and touch). Only valid when the marker is on the map (Otherwise set [`marker.options.draggable`](#marker-draggable)).\n   */\n\n  var MarkerDrag = Handler.extend({\n  \tinitialize: function (marker) {\n  \t\tthis._marker = marker;\n  \t},\n\n  \taddHooks: function () {\n  \t\tvar icon = this._marker._icon;\n\n  \t\tif (!this._draggable) {\n  \t\t\tthis._draggable = new Draggable(icon, icon, true);\n  \t\t}\n\n  \t\tthis._draggable.on({\n  \t\t\tdragstart: this._onDragStart,\n  \t\t\tpredrag: this._onPreDrag,\n  \t\t\tdrag: this._onDrag,\n  \t\t\tdragend: this._onDragEnd\n  \t\t}, this).enable();\n\n  \t\taddClass(icon, 'leaflet-marker-draggable');\n  \t},\n\n  \tremoveHooks: function () {\n  \t\tthis._draggable.off({\n  \t\t\tdragstart: this._onDragStart,\n  \t\t\tpredrag: this._onPreDrag,\n  \t\t\tdrag: this._onDrag,\n  \t\t\tdragend: this._onDragEnd\n  \t\t}, this).disable();\n\n  \t\tif (this._marker._icon) {\n  \t\t\tremoveClass(this._marker._icon, 'leaflet-marker-draggable');\n  \t\t}\n  \t},\n\n  \tmoved: function () {\n  \t\treturn this._draggable && this._draggable._moved;\n  \t},\n\n  \t_adjustPan: function (e) {\n  \t\tvar marker = this._marker,\n  \t\t    map = marker._map,\n  \t\t    speed = this._marker.options.autoPanSpeed,\n  \t\t    padding = this._marker.options.autoPanPadding,\n  \t\t    iconPos = getPosition(marker._icon),\n  \t\t    bounds = map.getPixelBounds(),\n  \t\t    origin = map.getPixelOrigin();\n\n  \t\tvar panBounds = toBounds(\n  \t\t\tbounds.min._subtract(origin).add(padding),\n  \t\t\tbounds.max._subtract(origin).subtract(padding)\n  \t\t);\n\n  \t\tif (!panBounds.contains(iconPos)) {\n  \t\t\t// Compute incremental movement\n  \t\t\tvar movement = toPoint(\n  \t\t\t\t(Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) -\n  \t\t\t\t(Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x),\n\n  \t\t\t\t(Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) -\n  \t\t\t\t(Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)\n  \t\t\t).multiplyBy(speed);\n\n  \t\t\tmap.panBy(movement, {animate: false});\n\n  \t\t\tthis._draggable._newPos._add(movement);\n  \t\t\tthis._draggable._startPos._add(movement);\n\n  \t\t\tsetPosition(marker._icon, this._draggable._newPos);\n  \t\t\tthis._onDrag(e);\n\n  \t\t\tthis._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));\n  \t\t}\n  \t},\n\n  \t_onDragStart: function () {\n  \t\t// @section Dragging events\n  \t\t// @event dragstart: Event\n  \t\t// Fired when the user starts dragging the marker.\n\n  \t\t// @event movestart: Event\n  \t\t// Fired when the marker starts moving (because of dragging).\n\n  \t\tthis._oldLatLng = this._marker.getLatLng();\n\n  \t\t// When using ES6 imports it could not be set when `Popup` was not imported as well\n  \t\tthis._marker.closePopup && this._marker.closePopup();\n\n  \t\tthis._marker\n  \t\t\t.fire('movestart')\n  \t\t\t.fire('dragstart');\n  \t},\n\n  \t_onPreDrag: function (e) {\n  \t\tif (this._marker.options.autoPan) {\n  \t\t\tcancelAnimFrame(this._panRequest);\n  \t\t\tthis._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));\n  \t\t}\n  \t},\n\n  \t_onDrag: function (e) {\n  \t\tvar marker = this._marker,\n  \t\t    shadow = marker._shadow,\n  \t\t    iconPos = getPosition(marker._icon),\n  \t\t    latlng = marker._map.layerPointToLatLng(iconPos);\n\n  \t\t// update shadow position\n  \t\tif (shadow) {\n  \t\t\tsetPosition(shadow, iconPos);\n  \t\t}\n\n  \t\tmarker._latlng = latlng;\n  \t\te.latlng = latlng;\n  \t\te.oldLatLng = this._oldLatLng;\n\n  \t\t// @event drag: Event\n  \t\t// Fired repeatedly while the user drags the marker.\n  \t\tmarker\n  \t\t    .fire('move', e)\n  \t\t    .fire('drag', e);\n  \t},\n\n  \t_onDragEnd: function (e) {\n  \t\t// @event dragend: DragEndEvent\n  \t\t// Fired when the user stops dragging the marker.\n\n  \t\t cancelAnimFrame(this._panRequest);\n\n  \t\t// @event moveend: Event\n  \t\t// Fired when the marker stops moving (because of dragging).\n  \t\tdelete this._oldLatLng;\n  \t\tthis._marker\n  \t\t    .fire('moveend')\n  \t\t    .fire('dragend', e);\n  \t}\n  });\n\n  /*\r\n   * @class Marker\r\n   * @inherits Interactive layer\r\n   * @aka L.Marker\r\n   * L.Marker is used to display clickable/draggable icons on the map. Extends `Layer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.marker([50.5, 30.5]).addTo(map);\r\n   * ```\r\n   */\r\n\r\n  var Marker = Layer.extend({\r\n\r\n  \t// @section\r\n  \t// @aka Marker options\r\n  \toptions: {\r\n  \t\t// @option icon: Icon = *\r\n  \t\t// Icon instance to use for rendering the marker.\r\n  \t\t// See [Icon documentation](#L.Icon) for details on how to customize the marker icon.\r\n  \t\t// If not specified, a common instance of `L.Icon.Default` is used.\r\n  \t\ticon: new IconDefault(),\r\n\r\n  \t\t// Option inherited from \"Interactive layer\" abstract class\r\n  \t\tinteractive: true,\r\n\r\n  \t\t// @option keyboard: Boolean = true\r\n  \t\t// Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.\r\n  \t\tkeyboard: true,\r\n\r\n  \t\t// @option title: String = ''\r\n  \t\t// Text for the browser tooltip that appear on marker hover (no tooltip by default).\r\n  \t\t// [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).\r\n  \t\ttitle: '',\r\n\r\n  \t\t// @option alt: String = 'Marker'\r\n  \t\t// Text for the `alt` attribute of the icon image.\r\n  \t\t// [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).\r\n  \t\talt: 'Marker',\r\n\r\n  \t\t// @option zIndexOffset: Number = 0\r\n  \t\t// By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).\r\n  \t\tzIndexOffset: 0,\r\n\r\n  \t\t// @option opacity: Number = 1.0\r\n  \t\t// The opacity of the marker.\r\n  \t\topacity: 1,\r\n\r\n  \t\t// @option riseOnHover: Boolean = false\r\n  \t\t// If `true`, the marker will get on top of others when you hover the mouse over it.\r\n  \t\triseOnHover: false,\r\n\r\n  \t\t// @option riseOffset: Number = 250\r\n  \t\t// The z-index offset used for the `riseOnHover` feature.\r\n  \t\triseOffset: 250,\r\n\r\n  \t\t// @option pane: String = 'markerPane'\r\n  \t\t// `Map pane` where the markers icon will be added.\r\n  \t\tpane: 'markerPane',\r\n\r\n  \t\t// @option shadowPane: String = 'shadowPane'\r\n  \t\t// `Map pane` where the markers shadow will be added.\r\n  \t\tshadowPane: 'shadowPane',\r\n\r\n  \t\t// @option bubblingMouseEvents: Boolean = false\r\n  \t\t// When `true`, a mouse event on this marker will trigger the same event on the map\r\n  \t\t// (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).\r\n  \t\tbubblingMouseEvents: false,\r\n\r\n  \t\t// @option autoPanOnFocus: Boolean = true\r\n  \t\t// When `true`, the map will pan whenever the marker is focused (via\r\n  \t\t// e.g. pressing `tab` on the keyboard) to ensure the marker is\r\n  \t\t// visible within the map's bounds\r\n  \t\tautoPanOnFocus: true,\r\n\r\n  \t\t// @section Draggable marker options\r\n  \t\t// @option draggable: Boolean = false\r\n  \t\t// Whether the marker is draggable with mouse/touch or not.\r\n  \t\tdraggable: false,\r\n\r\n  \t\t// @option autoPan: Boolean = false\r\n  \t\t// Whether to pan the map when dragging this marker near its edge or not.\r\n  \t\tautoPan: false,\r\n\r\n  \t\t// @option autoPanPadding: Point = Point(50, 50)\r\n  \t\t// Distance (in pixels to the left/right and to the top/bottom) of the\r\n  \t\t// map edge to start panning the map.\r\n  \t\tautoPanPadding: [50, 50],\r\n\r\n  \t\t// @option autoPanSpeed: Number = 10\r\n  \t\t// Number of pixels the map should pan by.\r\n  \t\tautoPanSpeed: 10\r\n  \t},\r\n\r\n  \t/* @section\r\n  \t *\r\n  \t * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:\r\n  \t */\r\n\r\n  \tinitialize: function (latlng, options) {\r\n  \t\tsetOptions(this, options);\r\n  \t\tthis._latlng = toLatLng(latlng);\r\n  \t},\r\n\r\n  \tonAdd: function (map) {\r\n  \t\tthis._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;\r\n\r\n  \t\tif (this._zoomAnimated) {\r\n  \t\t\tmap.on('zoomanim', this._animateZoom, this);\r\n  \t\t}\r\n\r\n  \t\tthis._initIcon();\r\n  \t\tthis.update();\r\n  \t},\r\n\r\n  \tonRemove: function (map) {\r\n  \t\tif (this.dragging && this.dragging.enabled()) {\r\n  \t\t\tthis.options.draggable = true;\r\n  \t\t\tthis.dragging.removeHooks();\r\n  \t\t}\r\n  \t\tdelete this.dragging;\r\n\r\n  \t\tif (this._zoomAnimated) {\r\n  \t\t\tmap.off('zoomanim', this._animateZoom, this);\r\n  \t\t}\r\n\r\n  \t\tthis._removeIcon();\r\n  \t\tthis._removeShadow();\r\n  \t},\r\n\r\n  \tgetEvents: function () {\r\n  \t\treturn {\r\n  \t\t\tzoom: this.update,\r\n  \t\t\tviewreset: this.update\r\n  \t\t};\r\n  \t},\r\n\r\n  \t// @method getLatLng: LatLng\r\n  \t// Returns the current geographical position of the marker.\r\n  \tgetLatLng: function () {\r\n  \t\treturn this._latlng;\r\n  \t},\r\n\r\n  \t// @method setLatLng(latlng: LatLng): this\r\n  \t// Changes the marker position to the given point.\r\n  \tsetLatLng: function (latlng) {\r\n  \t\tvar oldLatLng = this._latlng;\r\n  \t\tthis._latlng = toLatLng(latlng);\r\n  \t\tthis.update();\r\n\r\n  \t\t// @event move: Event\r\n  \t\t// Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.\r\n  \t\treturn this.fire('move', {oldLatLng: oldLatLng, latlng: this._latlng});\r\n  \t},\r\n\r\n  \t// @method setZIndexOffset(offset: Number): this\r\n  \t// Changes the [zIndex offset](#marker-zindexoffset) of the marker.\r\n  \tsetZIndexOffset: function (offset) {\r\n  \t\tthis.options.zIndexOffset = offset;\r\n  \t\treturn this.update();\r\n  \t},\r\n\r\n  \t// @method getIcon: Icon\r\n  \t// Returns the current icon used by the marker\r\n  \tgetIcon: function () {\r\n  \t\treturn this.options.icon;\r\n  \t},\r\n\r\n  \t// @method setIcon(icon: Icon): this\r\n  \t// Changes the marker icon.\r\n  \tsetIcon: function (icon) {\r\n\r\n  \t\tthis.options.icon = icon;\r\n\r\n  \t\tif (this._map) {\r\n  \t\t\tthis._initIcon();\r\n  \t\t\tthis.update();\r\n  \t\t}\r\n\r\n  \t\tif (this._popup) {\r\n  \t\t\tthis.bindPopup(this._popup, this._popup.options);\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \tgetElement: function () {\r\n  \t\treturn this._icon;\r\n  \t},\r\n\r\n  \tupdate: function () {\r\n\r\n  \t\tif (this._icon && this._map) {\r\n  \t\t\tvar pos = this._map.latLngToLayerPoint(this._latlng).round();\r\n  \t\t\tthis._setPos(pos);\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t_initIcon: function () {\r\n  \t\tvar options = this.options,\r\n  \t\t    classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');\r\n\r\n  \t\tvar icon = options.icon.createIcon(this._icon),\r\n  \t\t    addIcon = false;\r\n\r\n  \t\t// if we're not reusing the icon, remove the old one and init new one\r\n  \t\tif (icon !== this._icon) {\r\n  \t\t\tif (this._icon) {\r\n  \t\t\t\tthis._removeIcon();\r\n  \t\t\t}\r\n  \t\t\taddIcon = true;\r\n\r\n  \t\t\tif (options.title) {\r\n  \t\t\t\ticon.title = options.title;\r\n  \t\t\t}\r\n\r\n  \t\t\tif (icon.tagName === 'IMG') {\r\n  \t\t\t\ticon.alt = options.alt || '';\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\taddClass(icon, classToAdd);\r\n\r\n  \t\tif (options.keyboard) {\r\n  \t\t\ticon.tabIndex = '0';\r\n  \t\t\ticon.setAttribute('role', 'button');\r\n  \t\t}\r\n\r\n  \t\tthis._icon = icon;\r\n\r\n  \t\tif (options.riseOnHover) {\r\n  \t\t\tthis.on({\r\n  \t\t\t\tmouseover: this._bringToFront,\r\n  \t\t\t\tmouseout: this._resetZIndex\r\n  \t\t\t});\r\n  \t\t}\r\n\r\n  \t\tif (this.options.autoPanOnFocus) {\r\n  \t\t\ton(icon, 'focus', this._panOnFocus, this);\r\n  \t\t}\r\n\r\n  \t\tvar newShadow = options.icon.createShadow(this._shadow),\r\n  \t\t    addShadow = false;\r\n\r\n  \t\tif (newShadow !== this._shadow) {\r\n  \t\t\tthis._removeShadow();\r\n  \t\t\taddShadow = true;\r\n  \t\t}\r\n\r\n  \t\tif (newShadow) {\r\n  \t\t\taddClass(newShadow, classToAdd);\r\n  \t\t\tnewShadow.alt = '';\r\n  \t\t}\r\n  \t\tthis._shadow = newShadow;\r\n\r\n\r\n  \t\tif (options.opacity < 1) {\r\n  \t\t\tthis._updateOpacity();\r\n  \t\t}\r\n\r\n\r\n  \t\tif (addIcon) {\r\n  \t\t\tthis.getPane().appendChild(this._icon);\r\n  \t\t}\r\n  \t\tthis._initInteraction();\r\n  \t\tif (newShadow && addShadow) {\r\n  \t\t\tthis.getPane(options.shadowPane).appendChild(this._shadow);\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_removeIcon: function () {\r\n  \t\tif (this.options.riseOnHover) {\r\n  \t\t\tthis.off({\r\n  \t\t\t\tmouseover: this._bringToFront,\r\n  \t\t\t\tmouseout: this._resetZIndex\r\n  \t\t\t});\r\n  \t\t}\r\n\r\n  \t\tif (this.options.autoPanOnFocus) {\r\n  \t\t\toff(this._icon, 'focus', this._panOnFocus, this);\r\n  \t\t}\r\n\r\n  \t\tremove(this._icon);\r\n  \t\tthis.removeInteractiveTarget(this._icon);\r\n\r\n  \t\tthis._icon = null;\r\n  \t},\r\n\r\n  \t_removeShadow: function () {\r\n  \t\tif (this._shadow) {\r\n  \t\t\tremove(this._shadow);\r\n  \t\t}\r\n  \t\tthis._shadow = null;\r\n  \t},\r\n\r\n  \t_setPos: function (pos) {\r\n\r\n  \t\tif (this._icon) {\r\n  \t\t\tsetPosition(this._icon, pos);\r\n  \t\t}\r\n\r\n  \t\tif (this._shadow) {\r\n  \t\t\tsetPosition(this._shadow, pos);\r\n  \t\t}\r\n\r\n  \t\tthis._zIndex = pos.y + this.options.zIndexOffset;\r\n\r\n  \t\tthis._resetZIndex();\r\n  \t},\r\n\r\n  \t_updateZIndex: function (offset) {\r\n  \t\tif (this._icon) {\r\n  \t\t\tthis._icon.style.zIndex = this._zIndex + offset;\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_animateZoom: function (opt) {\r\n  \t\tvar pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();\r\n\r\n  \t\tthis._setPos(pos);\r\n  \t},\r\n\r\n  \t_initInteraction: function () {\r\n\r\n  \t\tif (!this.options.interactive) { return; }\r\n\r\n  \t\taddClass(this._icon, 'leaflet-interactive');\r\n\r\n  \t\tthis.addInteractiveTarget(this._icon);\r\n\r\n  \t\tif (MarkerDrag) {\r\n  \t\t\tvar draggable = this.options.draggable;\r\n  \t\t\tif (this.dragging) {\r\n  \t\t\t\tdraggable = this.dragging.enabled();\r\n  \t\t\t\tthis.dragging.disable();\r\n  \t\t\t}\r\n\r\n  \t\t\tthis.dragging = new MarkerDrag(this);\r\n\r\n  \t\t\tif (draggable) {\r\n  \t\t\t\tthis.dragging.enable();\r\n  \t\t\t}\r\n  \t\t}\r\n  \t},\r\n\r\n  \t// @method setOpacity(opacity: Number): this\r\n  \t// Changes the opacity of the marker.\r\n  \tsetOpacity: function (opacity) {\r\n  \t\tthis.options.opacity = opacity;\r\n  \t\tif (this._map) {\r\n  \t\t\tthis._updateOpacity();\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t_updateOpacity: function () {\r\n  \t\tvar opacity = this.options.opacity;\r\n\r\n  \t\tif (this._icon) {\r\n  \t\t\tsetOpacity(this._icon, opacity);\r\n  \t\t}\r\n\r\n  \t\tif (this._shadow) {\r\n  \t\t\tsetOpacity(this._shadow, opacity);\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_bringToFront: function () {\r\n  \t\tthis._updateZIndex(this.options.riseOffset);\r\n  \t},\r\n\r\n  \t_resetZIndex: function () {\r\n  \t\tthis._updateZIndex(0);\r\n  \t},\r\n\r\n  \t_panOnFocus: function () {\r\n  \t\tvar map = this._map;\r\n  \t\tif (!map) { return; }\r\n\r\n  \t\tvar iconOpts = this.options.icon.options;\r\n  \t\tvar size = iconOpts.iconSize ? toPoint(iconOpts.iconSize) : toPoint(0, 0);\r\n  \t\tvar anchor = iconOpts.iconAnchor ? toPoint(iconOpts.iconAnchor) : toPoint(0, 0);\r\n\r\n  \t\tmap.panInside(this._latlng, {\r\n  \t\t\tpaddingTopLeft: anchor,\r\n  \t\t\tpaddingBottomRight: size.subtract(anchor)\r\n  \t\t});\r\n  \t},\r\n\r\n  \t_getPopupAnchor: function () {\r\n  \t\treturn this.options.icon.options.popupAnchor;\r\n  \t},\r\n\r\n  \t_getTooltipAnchor: function () {\r\n  \t\treturn this.options.icon.options.tooltipAnchor;\r\n  \t}\r\n  });\r\n\r\n\r\n  // factory L.marker(latlng: LatLng, options? : Marker options)\r\n\r\n  // @factory L.marker(latlng: LatLng, options? : Marker options)\r\n  // Instantiates a Marker object given a geographical point and optionally an options object.\r\n  function marker(latlng, options) {\r\n  \treturn new Marker(latlng, options);\r\n  }\n\n  /*\n   * @class Path\n   * @aka L.Path\n   * @inherits Interactive layer\n   *\n   * An abstract class that contains options and constants shared between vector\n   * overlays (Polygon, Polyline, Circle). Do not use it directly. Extends `Layer`.\n   */\n\n  var Path = Layer.extend({\n\n  \t// @section\n  \t// @aka Path options\n  \toptions: {\n  \t\t// @option stroke: Boolean = true\n  \t\t// Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.\n  \t\tstroke: true,\n\n  \t\t// @option color: String = '#3388ff'\n  \t\t// Stroke color\n  \t\tcolor: '#3388ff',\n\n  \t\t// @option weight: Number = 3\n  \t\t// Stroke width in pixels\n  \t\tweight: 3,\n\n  \t\t// @option opacity: Number = 1.0\n  \t\t// Stroke opacity\n  \t\topacity: 1,\n\n  \t\t// @option lineCap: String= 'round'\n  \t\t// A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.\n  \t\tlineCap: 'round',\n\n  \t\t// @option lineJoin: String = 'round'\n  \t\t// A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.\n  \t\tlineJoin: 'round',\n\n  \t\t// @option dashArray: String = null\n  \t\t// A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).\n  \t\tdashArray: null,\n\n  \t\t// @option dashOffset: String = null\n  \t\t// A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).\n  \t\tdashOffset: null,\n\n  \t\t// @option fill: Boolean = depends\n  \t\t// Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.\n  \t\tfill: false,\n\n  \t\t// @option fillColor: String = *\n  \t\t// Fill color. Defaults to the value of the [`color`](#path-color) option\n  \t\tfillColor: null,\n\n  \t\t// @option fillOpacity: Number = 0.2\n  \t\t// Fill opacity.\n  \t\tfillOpacity: 0.2,\n\n  \t\t// @option fillRule: String = 'evenodd'\n  \t\t// A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.\n  \t\tfillRule: 'evenodd',\n\n  \t\t// className: '',\n\n  \t\t// Option inherited from \"Interactive layer\" abstract class\n  \t\tinteractive: true,\n\n  \t\t// @option bubblingMouseEvents: Boolean = true\n  \t\t// When `true`, a mouse event on this path will trigger the same event on the map\n  \t\t// (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).\n  \t\tbubblingMouseEvents: true\n  \t},\n\n  \tbeforeAdd: function (map) {\n  \t\t// Renderer is set here because we need to call renderer.getEvents\n  \t\t// before this.getEvents.\n  \t\tthis._renderer = map.getRenderer(this);\n  \t},\n\n  \tonAdd: function () {\n  \t\tthis._renderer._initPath(this);\n  \t\tthis._reset();\n  \t\tthis._renderer._addPath(this);\n  \t},\n\n  \tonRemove: function () {\n  \t\tthis._renderer._removePath(this);\n  \t},\n\n  \t// @method redraw(): this\n  \t// Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.\n  \tredraw: function () {\n  \t\tif (this._map) {\n  \t\t\tthis._renderer._updatePath(this);\n  \t\t}\n  \t\treturn this;\n  \t},\n\n  \t// @method setStyle(style: Path options): this\n  \t// Changes the appearance of a Path based on the options in the `Path options` object.\n  \tsetStyle: function (style) {\n  \t\tsetOptions(this, style);\n  \t\tif (this._renderer) {\n  \t\t\tthis._renderer._updateStyle(this);\n  \t\t\tif (this.options.stroke && style && Object.prototype.hasOwnProperty.call(style, 'weight')) {\n  \t\t\t\tthis._updateBounds();\n  \t\t\t}\n  \t\t}\n  \t\treturn this;\n  \t},\n\n  \t// @method bringToFront(): this\n  \t// Brings the layer to the top of all path layers.\n  \tbringToFront: function () {\n  \t\tif (this._renderer) {\n  \t\t\tthis._renderer._bringToFront(this);\n  \t\t}\n  \t\treturn this;\n  \t},\n\n  \t// @method bringToBack(): this\n  \t// Brings the layer to the bottom of all path layers.\n  \tbringToBack: function () {\n  \t\tif (this._renderer) {\n  \t\t\tthis._renderer._bringToBack(this);\n  \t\t}\n  \t\treturn this;\n  \t},\n\n  \tgetElement: function () {\n  \t\treturn this._path;\n  \t},\n\n  \t_reset: function () {\n  \t\t// defined in child classes\n  \t\tthis._project();\n  \t\tthis._update();\n  \t},\n\n  \t_clickTolerance: function () {\n  \t\t// used when doing hit detection for Canvas layers\n  \t\treturn (this.options.stroke ? this.options.weight / 2 : 0) +\n  \t\t  (this._renderer.options.tolerance || 0);\n  \t}\n  });\n\n  /*\n   * @class CircleMarker\n   * @aka L.CircleMarker\n   * @inherits Path\n   *\n   * A circle of a fixed size with radius specified in pixels. Extends `Path`.\n   */\n\n  var CircleMarker = Path.extend({\n\n  \t// @section\n  \t// @aka CircleMarker options\n  \toptions: {\n  \t\tfill: true,\n\n  \t\t// @option radius: Number = 10\n  \t\t// Radius of the circle marker, in pixels\n  \t\tradius: 10\n  \t},\n\n  \tinitialize: function (latlng, options) {\n  \t\tsetOptions(this, options);\n  \t\tthis._latlng = toLatLng(latlng);\n  \t\tthis._radius = this.options.radius;\n  \t},\n\n  \t// @method setLatLng(latLng: LatLng): this\n  \t// Sets the position of a circle marker to a new location.\n  \tsetLatLng: function (latlng) {\n  \t\tvar oldLatLng = this._latlng;\n  \t\tthis._latlng = toLatLng(latlng);\n  \t\tthis.redraw();\n\n  \t\t// @event move: Event\n  \t\t// Fired when the marker is moved via [`setLatLng`](#circlemarker-setlatlng). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.\n  \t\treturn this.fire('move', {oldLatLng: oldLatLng, latlng: this._latlng});\n  \t},\n\n  \t// @method getLatLng(): LatLng\n  \t// Returns the current geographical position of the circle marker\n  \tgetLatLng: function () {\n  \t\treturn this._latlng;\n  \t},\n\n  \t// @method setRadius(radius: Number): this\n  \t// Sets the radius of a circle marker. Units are in pixels.\n  \tsetRadius: function (radius) {\n  \t\tthis.options.radius = this._radius = radius;\n  \t\treturn this.redraw();\n  \t},\n\n  \t// @method getRadius(): Number\n  \t// Returns the current radius of the circle\n  \tgetRadius: function () {\n  \t\treturn this._radius;\n  \t},\n\n  \tsetStyle : function (options) {\n  \t\tvar radius = options && options.radius || this._radius;\n  \t\tPath.prototype.setStyle.call(this, options);\n  \t\tthis.setRadius(radius);\n  \t\treturn this;\n  \t},\n\n  \t_project: function () {\n  \t\tthis._point = this._map.latLngToLayerPoint(this._latlng);\n  \t\tthis._updateBounds();\n  \t},\n\n  \t_updateBounds: function () {\n  \t\tvar r = this._radius,\n  \t\t    r2 = this._radiusY || r,\n  \t\t    w = this._clickTolerance(),\n  \t\t    p = [r + w, r2 + w];\n  \t\tthis._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));\n  \t},\n\n  \t_update: function () {\n  \t\tif (this._map) {\n  \t\t\tthis._updatePath();\n  \t\t}\n  \t},\n\n  \t_updatePath: function () {\n  \t\tthis._renderer._updateCircle(this);\n  \t},\n\n  \t_empty: function () {\n  \t\treturn this._radius && !this._renderer._bounds.intersects(this._pxBounds);\n  \t},\n\n  \t// Needed by the `Canvas` renderer for interactivity\n  \t_containsPoint: function (p) {\n  \t\treturn p.distanceTo(this._point) <= this._radius + this._clickTolerance();\n  \t}\n  });\n\n\n  // @factory L.circleMarker(latlng: LatLng, options?: CircleMarker options)\n  // Instantiates a circle marker object given a geographical point, and an optional options object.\n  function circleMarker(latlng, options) {\n  \treturn new CircleMarker(latlng, options);\n  }\n\n  /*\n   * @class Circle\n   * @aka L.Circle\n   * @inherits CircleMarker\n   *\n   * A class for drawing circle overlays on a map. Extends `CircleMarker`.\n   *\n   * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion).\n   *\n   * @example\n   *\n   * ```js\n   * L.circle([50.5, 30.5], {radius: 200}).addTo(map);\n   * ```\n   */\n\n  var Circle = CircleMarker.extend({\n\n  \tinitialize: function (latlng, options, legacyOptions) {\n  \t\tif (typeof options === 'number') {\n  \t\t\t// Backwards compatibility with 0.7.x factory (latlng, radius, options?)\n  \t\t\toptions = extend({}, legacyOptions, {radius: options});\n  \t\t}\n  \t\tsetOptions(this, options);\n  \t\tthis._latlng = toLatLng(latlng);\n\n  \t\tif (isNaN(this.options.radius)) { throw new Error('Circle radius cannot be NaN'); }\n\n  \t\t// @section\n  \t\t// @aka Circle options\n  \t\t// @option radius: Number; Radius of the circle, in meters.\n  \t\tthis._mRadius = this.options.radius;\n  \t},\n\n  \t// @method setRadius(radius: Number): this\n  \t// Sets the radius of a circle. Units are in meters.\n  \tsetRadius: function (radius) {\n  \t\tthis._mRadius = radius;\n  \t\treturn this.redraw();\n  \t},\n\n  \t// @method getRadius(): Number\n  \t// Returns the current radius of a circle. Units are in meters.\n  \tgetRadius: function () {\n  \t\treturn this._mRadius;\n  \t},\n\n  \t// @method getBounds(): LatLngBounds\n  \t// Returns the `LatLngBounds` of the path.\n  \tgetBounds: function () {\n  \t\tvar half = [this._radius, this._radiusY || this._radius];\n\n  \t\treturn new LatLngBounds(\n  \t\t\tthis._map.layerPointToLatLng(this._point.subtract(half)),\n  \t\t\tthis._map.layerPointToLatLng(this._point.add(half)));\n  \t},\n\n  \tsetStyle: Path.prototype.setStyle,\n\n  \t_project: function () {\n\n  \t\tvar lng = this._latlng.lng,\n  \t\t    lat = this._latlng.lat,\n  \t\t    map = this._map,\n  \t\t    crs = map.options.crs;\n\n  \t\tif (crs.distance === Earth.distance) {\n  \t\t\tvar d = Math.PI / 180,\n  \t\t\t    latR = (this._mRadius / Earth.R) / d,\n  \t\t\t    top = map.project([lat + latR, lng]),\n  \t\t\t    bottom = map.project([lat - latR, lng]),\n  \t\t\t    p = top.add(bottom).divideBy(2),\n  \t\t\t    lat2 = map.unproject(p).lat,\n  \t\t\t    lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) /\n  \t\t\t            (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;\n\n  \t\t\tif (isNaN(lngR) || lngR === 0) {\n  \t\t\t\tlngR = latR / Math.cos(Math.PI / 180 * lat); // Fallback for edge case, #2425\n  \t\t\t}\n\n  \t\t\tthis._point = p.subtract(map.getPixelOrigin());\n  \t\t\tthis._radius = isNaN(lngR) ? 0 : p.x - map.project([lat2, lng - lngR]).x;\n  \t\t\tthis._radiusY = p.y - top.y;\n\n  \t\t} else {\n  \t\t\tvar latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));\n\n  \t\t\tthis._point = map.latLngToLayerPoint(this._latlng);\n  \t\t\tthis._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;\n  \t\t}\n\n  \t\tthis._updateBounds();\n  \t}\n  });\n\n  // @factory L.circle(latlng: LatLng, options?: Circle options)\n  // Instantiates a circle object given a geographical point, and an options object\n  // which contains the circle radius.\n  // @alternative\n  // @factory L.circle(latlng: LatLng, radius: Number, options?: Circle options)\n  // Obsolete way of instantiating a circle, for compatibility with 0.7.x code.\n  // Do not use in new applications or plugins.\n  function circle(latlng, options, legacyOptions) {\n  \treturn new Circle(latlng, options, legacyOptions);\n  }\n\n  /*\n   * @class Polyline\n   * @aka L.Polyline\n   * @inherits Path\n   *\n   * A class for drawing polyline overlays on a map. Extends `Path`.\n   *\n   * @example\n   *\n   * ```js\n   * // create a red polyline from an array of LatLng points\n   * var latlngs = [\n   * \t[45.51, -122.68],\n   * \t[37.77, -122.43],\n   * \t[34.04, -118.2]\n   * ];\n   *\n   * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);\n   *\n   * // zoom the map to the polyline\n   * map.fitBounds(polyline.getBounds());\n   * ```\n   *\n   * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:\n   *\n   * ```js\n   * // create a red polyline from an array of arrays of LatLng points\n   * var latlngs = [\n   * \t[[45.51, -122.68],\n   * \t [37.77, -122.43],\n   * \t [34.04, -118.2]],\n   * \t[[40.78, -73.91],\n   * \t [41.83, -87.62],\n   * \t [32.76, -96.72]]\n   * ];\n   * ```\n   */\n\n\n  var Polyline = Path.extend({\n\n  \t// @section\n  \t// @aka Polyline options\n  \toptions: {\n  \t\t// @option smoothFactor: Number = 1.0\n  \t\t// How much to simplify the polyline on each zoom level. More means\n  \t\t// better performance and smoother look, and less means more accurate representation.\n  \t\tsmoothFactor: 1.0,\n\n  \t\t// @option noClip: Boolean = false\n  \t\t// Disable polyline clipping.\n  \t\tnoClip: false\n  \t},\n\n  \tinitialize: function (latlngs, options) {\n  \t\tsetOptions(this, options);\n  \t\tthis._setLatLngs(latlngs);\n  \t},\n\n  \t// @method getLatLngs(): LatLng[]\n  \t// Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.\n  \tgetLatLngs: function () {\n  \t\treturn this._latlngs;\n  \t},\n\n  \t// @method setLatLngs(latlngs: LatLng[]): this\n  \t// Replaces all the points in the polyline with the given array of geographical points.\n  \tsetLatLngs: function (latlngs) {\n  \t\tthis._setLatLngs(latlngs);\n  \t\treturn this.redraw();\n  \t},\n\n  \t// @method isEmpty(): Boolean\n  \t// Returns `true` if the Polyline has no LatLngs.\n  \tisEmpty: function () {\n  \t\treturn !this._latlngs.length;\n  \t},\n\n  \t// @method closestLayerPoint(p: Point): Point\n  \t// Returns the point closest to `p` on the Polyline.\n  \tclosestLayerPoint: function (p) {\n  \t\tvar minDistance = Infinity,\n  \t\t    minPoint = null,\n  \t\t    closest = _sqClosestPointOnSegment,\n  \t\t    p1, p2;\n\n  \t\tfor (var j = 0, jLen = this._parts.length; j < jLen; j++) {\n  \t\t\tvar points = this._parts[j];\n\n  \t\t\tfor (var i = 1, len = points.length; i < len; i++) {\n  \t\t\t\tp1 = points[i - 1];\n  \t\t\t\tp2 = points[i];\n\n  \t\t\t\tvar sqDist = closest(p, p1, p2, true);\n\n  \t\t\t\tif (sqDist < minDistance) {\n  \t\t\t\t\tminDistance = sqDist;\n  \t\t\t\t\tminPoint = closest(p, p1, p2);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\tif (minPoint) {\n  \t\t\tminPoint.distance = Math.sqrt(minDistance);\n  \t\t}\n  \t\treturn minPoint;\n  \t},\n\n  \t// @method getCenter(): LatLng\n  \t// Returns the center ([centroid](https://en.wikipedia.org/wiki/Centroid)) of the polyline.\n  \tgetCenter: function () {\n  \t\t// throws error when not yet added to map as this center calculation requires projected coordinates\n  \t\tif (!this._map) {\n  \t\t\tthrow new Error('Must add layer to map before using getCenter()');\n  \t\t}\n  \t\treturn polylineCenter(this._defaultShape(), this._map.options.crs);\n  \t},\n\n  \t// @method getBounds(): LatLngBounds\n  \t// Returns the `LatLngBounds` of the path.\n  \tgetBounds: function () {\n  \t\treturn this._bounds;\n  \t},\n\n  \t// @method addLatLng(latlng: LatLng, latlngs?: LatLng[]): this\n  \t// Adds a given point to the polyline. By default, adds to the first ring of\n  \t// the polyline in case of a multi-polyline, but can be overridden by passing\n  \t// a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).\n  \taddLatLng: function (latlng, latlngs) {\n  \t\tlatlngs = latlngs || this._defaultShape();\n  \t\tlatlng = toLatLng(latlng);\n  \t\tlatlngs.push(latlng);\n  \t\tthis._bounds.extend(latlng);\n  \t\treturn this.redraw();\n  \t},\n\n  \t_setLatLngs: function (latlngs) {\n  \t\tthis._bounds = new LatLngBounds();\n  \t\tthis._latlngs = this._convertLatLngs(latlngs);\n  \t},\n\n  \t_defaultShape: function () {\n  \t\treturn isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];\n  \t},\n\n  \t// recursively convert latlngs input into actual LatLng instances; calculate bounds along the way\n  \t_convertLatLngs: function (latlngs) {\n  \t\tvar result = [],\n  \t\t    flat = isFlat(latlngs);\n\n  \t\tfor (var i = 0, len = latlngs.length; i < len; i++) {\n  \t\t\tif (flat) {\n  \t\t\t\tresult[i] = toLatLng(latlngs[i]);\n  \t\t\t\tthis._bounds.extend(result[i]);\n  \t\t\t} else {\n  \t\t\t\tresult[i] = this._convertLatLngs(latlngs[i]);\n  \t\t\t}\n  \t\t}\n\n  \t\treturn result;\n  \t},\n\n  \t_project: function () {\n  \t\tvar pxBounds = new Bounds();\n  \t\tthis._rings = [];\n  \t\tthis._projectLatlngs(this._latlngs, this._rings, pxBounds);\n\n  \t\tif (this._bounds.isValid() && pxBounds.isValid()) {\n  \t\t\tthis._rawPxBounds = pxBounds;\n  \t\t\tthis._updateBounds();\n  \t\t}\n  \t},\n\n  \t_updateBounds: function () {\n  \t\tvar w = this._clickTolerance(),\n  \t\t    p = new Point(w, w);\n\n  \t\tif (!this._rawPxBounds) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tthis._pxBounds = new Bounds([\n  \t\t\tthis._rawPxBounds.min.subtract(p),\n  \t\t\tthis._rawPxBounds.max.add(p)\n  \t\t]);\n  \t},\n\n  \t// recursively turns latlngs into a set of rings with projected coordinates\n  \t_projectLatlngs: function (latlngs, result, projectedBounds) {\n  \t\tvar flat = latlngs[0] instanceof LatLng,\n  \t\t    len = latlngs.length,\n  \t\t    i, ring;\n\n  \t\tif (flat) {\n  \t\t\tring = [];\n  \t\t\tfor (i = 0; i < len; i++) {\n  \t\t\t\tring[i] = this._map.latLngToLayerPoint(latlngs[i]);\n  \t\t\t\tprojectedBounds.extend(ring[i]);\n  \t\t\t}\n  \t\t\tresult.push(ring);\n  \t\t} else {\n  \t\t\tfor (i = 0; i < len; i++) {\n  \t\t\t\tthis._projectLatlngs(latlngs[i], result, projectedBounds);\n  \t\t\t}\n  \t\t}\n  \t},\n\n  \t// clip polyline by renderer bounds so that we have less to render for performance\n  \t_clipPoints: function () {\n  \t\tvar bounds = this._renderer._bounds;\n\n  \t\tthis._parts = [];\n  \t\tif (!this._pxBounds || !this._pxBounds.intersects(bounds)) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tif (this.options.noClip) {\n  \t\t\tthis._parts = this._rings;\n  \t\t\treturn;\n  \t\t}\n\n  \t\tvar parts = this._parts,\n  \t\t    i, j, k, len, len2, segment, points;\n\n  \t\tfor (i = 0, k = 0, len = this._rings.length; i < len; i++) {\n  \t\t\tpoints = this._rings[i];\n\n  \t\t\tfor (j = 0, len2 = points.length; j < len2 - 1; j++) {\n  \t\t\t\tsegment = clipSegment(points[j], points[j + 1], bounds, j, true);\n\n  \t\t\t\tif (!segment) { continue; }\n\n  \t\t\t\tparts[k] = parts[k] || [];\n  \t\t\t\tparts[k].push(segment[0]);\n\n  \t\t\t\t// if segment goes out of screen, or it's the last one, it's the end of the line part\n  \t\t\t\tif ((segment[1] !== points[j + 1]) || (j === len2 - 2)) {\n  \t\t\t\t\tparts[k].push(segment[1]);\n  \t\t\t\t\tk++;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n\n  \t// simplify each clipped part of the polyline for performance\n  \t_simplifyPoints: function () {\n  \t\tvar parts = this._parts,\n  \t\t    tolerance = this.options.smoothFactor;\n\n  \t\tfor (var i = 0, len = parts.length; i < len; i++) {\n  \t\t\tparts[i] = simplify(parts[i], tolerance);\n  \t\t}\n  \t},\n\n  \t_update: function () {\n  \t\tif (!this._map) { return; }\n\n  \t\tthis._clipPoints();\n  \t\tthis._simplifyPoints();\n  \t\tthis._updatePath();\n  \t},\n\n  \t_updatePath: function () {\n  \t\tthis._renderer._updatePoly(this);\n  \t},\n\n  \t// Needed by the `Canvas` renderer for interactivity\n  \t_containsPoint: function (p, closed) {\n  \t\tvar i, j, k, len, len2, part,\n  \t\t    w = this._clickTolerance();\n\n  \t\tif (!this._pxBounds || !this._pxBounds.contains(p)) { return false; }\n\n  \t\t// hit detection for polylines\n  \t\tfor (i = 0, len = this._parts.length; i < len; i++) {\n  \t\t\tpart = this._parts[i];\n\n  \t\t\tfor (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\n  \t\t\t\tif (!closed && (j === 0)) { continue; }\n\n  \t\t\t\tif (pointToSegmentDistance(p, part[k], part[j]) <= w) {\n  \t\t\t\t\treturn true;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\treturn false;\n  \t}\n  });\n\n  // @factory L.polyline(latlngs: LatLng[], options?: Polyline options)\n  // Instantiates a polyline object given an array of geographical points and\n  // optionally an options object. You can create a `Polyline` object with\n  // multiple separate lines (`MultiPolyline`) by passing an array of arrays\n  // of geographic points.\n  function polyline(latlngs, options) {\n  \treturn new Polyline(latlngs, options);\n  }\n\n  // Retrocompat. Allow plugins to support Leaflet versions before and after 1.1.\n  Polyline._flat = _flat;\n\n  /*\n   * @class Polygon\n   * @aka L.Polygon\n   * @inherits Polyline\n   *\n   * A class for drawing polygon overlays on a map. Extends `Polyline`.\n   *\n   * Note that points you pass when creating a polygon shouldn't have an additional last point equal to the first one  it's better to filter out such points.\n   *\n   *\n   * @example\n   *\n   * ```js\n   * // create a red polygon from an array of LatLng points\n   * var latlngs = [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]];\n   *\n   * var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map);\n   *\n   * // zoom the map to the polygon\n   * map.fitBounds(polygon.getBounds());\n   * ```\n   *\n   * You can also pass an array of arrays of latlngs, with the first array representing the outer shape and the other arrays representing holes in the outer shape:\n   *\n   * ```js\n   * var latlngs = [\n   *   [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring\n   *   [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole\n   * ];\n   * ```\n   *\n   * Additionally, you can pass a multi-dimensional array to represent a MultiPolygon shape.\n   *\n   * ```js\n   * var latlngs = [\n   *   [ // first polygon\n   *     [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring\n   *     [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole\n   *   ],\n   *   [ // second polygon\n   *     [[41, -111.03],[45, -111.04],[45, -104.05],[41, -104.05]]\n   *   ]\n   * ];\n   * ```\n   */\n\n  var Polygon = Polyline.extend({\n\n  \toptions: {\n  \t\tfill: true\n  \t},\n\n  \tisEmpty: function () {\n  \t\treturn !this._latlngs.length || !this._latlngs[0].length;\n  \t},\n\n  \t// @method getCenter(): LatLng\n  \t// Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the Polygon.\n  \tgetCenter: function () {\n  \t\t// throws error when not yet added to map as this center calculation requires projected coordinates\n  \t\tif (!this._map) {\n  \t\t\tthrow new Error('Must add layer to map before using getCenter()');\n  \t\t}\n  \t\treturn polygonCenter(this._defaultShape(), this._map.options.crs);\n  \t},\n\n  \t_convertLatLngs: function (latlngs) {\n  \t\tvar result = Polyline.prototype._convertLatLngs.call(this, latlngs),\n  \t\t    len = result.length;\n\n  \t\t// remove last point if it equals first one\n  \t\tif (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {\n  \t\t\tresult.pop();\n  \t\t}\n  \t\treturn result;\n  \t},\n\n  \t_setLatLngs: function (latlngs) {\n  \t\tPolyline.prototype._setLatLngs.call(this, latlngs);\n  \t\tif (isFlat(this._latlngs)) {\n  \t\t\tthis._latlngs = [this._latlngs];\n  \t\t}\n  \t},\n\n  \t_defaultShape: function () {\n  \t\treturn isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];\n  \t},\n\n  \t_clipPoints: function () {\n  \t\t// polygons need a different clipping algorithm so we redefine that\n\n  \t\tvar bounds = this._renderer._bounds,\n  \t\t    w = this.options.weight,\n  \t\t    p = new Point(w, w);\n\n  \t\t// increase clip padding by stroke width to avoid stroke on clip edges\n  \t\tbounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));\n\n  \t\tthis._parts = [];\n  \t\tif (!this._pxBounds || !this._pxBounds.intersects(bounds)) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tif (this.options.noClip) {\n  \t\t\tthis._parts = this._rings;\n  \t\t\treturn;\n  \t\t}\n\n  \t\tfor (var i = 0, len = this._rings.length, clipped; i < len; i++) {\n  \t\t\tclipped = clipPolygon(this._rings[i], bounds, true);\n  \t\t\tif (clipped.length) {\n  \t\t\t\tthis._parts.push(clipped);\n  \t\t\t}\n  \t\t}\n  \t},\n\n  \t_updatePath: function () {\n  \t\tthis._renderer._updatePoly(this, true);\n  \t},\n\n  \t// Needed by the `Canvas` renderer for interactivity\n  \t_containsPoint: function (p) {\n  \t\tvar inside = false,\n  \t\t    part, p1, p2, i, j, k, len, len2;\n\n  \t\tif (!this._pxBounds || !this._pxBounds.contains(p)) { return false; }\n\n  \t\t// ray casting algorithm for detecting if point is in polygon\n  \t\tfor (i = 0, len = this._parts.length; i < len; i++) {\n  \t\t\tpart = this._parts[i];\n\n  \t\t\tfor (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\n  \t\t\t\tp1 = part[j];\n  \t\t\t\tp2 = part[k];\n\n  \t\t\t\tif (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {\n  \t\t\t\t\tinside = !inside;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\t// also check if it's on polygon stroke\n  \t\treturn inside || Polyline.prototype._containsPoint.call(this, p, true);\n  \t}\n\n  });\n\n\n  // @factory L.polygon(latlngs: LatLng[], options?: Polyline options)\n  function polygon(latlngs, options) {\n  \treturn new Polygon(latlngs, options);\n  }\n\n  /*\r\n   * @class GeoJSON\r\n   * @aka L.GeoJSON\r\n   * @inherits FeatureGroup\r\n   *\r\n   * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse\r\n   * GeoJSON data and display it on the map. Extends `FeatureGroup`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.geoJSON(data, {\r\n   * \tstyle: function (feature) {\r\n   * \t\treturn {color: feature.properties.color};\r\n   * \t}\r\n   * }).bindPopup(function (layer) {\r\n   * \treturn layer.feature.properties.description;\r\n   * }).addTo(map);\r\n   * ```\r\n   */\r\n\r\n  var GeoJSON = FeatureGroup.extend({\r\n\r\n  \t/* @section\r\n  \t * @aka GeoJSON options\r\n  \t *\r\n  \t * @option pointToLayer: Function = *\r\n  \t * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally\r\n  \t * called when data is added, passing the GeoJSON point feature and its `LatLng`.\r\n  \t * The default is to spawn a default `Marker`:\r\n  \t * ```js\r\n  \t * function(geoJsonPoint, latlng) {\r\n  \t * \treturn L.marker(latlng);\r\n  \t * }\r\n  \t * ```\r\n  \t *\r\n  \t * @option style: Function = *\r\n  \t * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,\r\n  \t * called internally when data is added.\r\n  \t * The default value is to not override any defaults:\r\n  \t * ```js\r\n  \t * function (geoJsonFeature) {\r\n  \t * \treturn {}\r\n  \t * }\r\n  \t * ```\r\n  \t *\r\n  \t * @option onEachFeature: Function = *\r\n  \t * A `Function` that will be called once for each created `Feature`, after it has\r\n  \t * been created and styled. Useful for attaching events and popups to features.\r\n  \t * The default is to do nothing with the newly created layers:\r\n  \t * ```js\r\n  \t * function (feature, layer) {}\r\n  \t * ```\r\n  \t *\r\n  \t * @option filter: Function = *\r\n  \t * A `Function` that will be used to decide whether to include a feature or not.\r\n  \t * The default is to include all features:\r\n  \t * ```js\r\n  \t * function (geoJsonFeature) {\r\n  \t * \treturn true;\r\n  \t * }\r\n  \t * ```\r\n  \t * Note: dynamically changing the `filter` option will have effect only on newly\r\n  \t * added data. It will _not_ re-evaluate already included features.\r\n  \t *\r\n  \t * @option coordsToLatLng: Function = *\r\n  \t * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.\r\n  \t * The default is the `coordsToLatLng` static method.\r\n  \t *\r\n  \t * @option markersInheritOptions: Boolean = false\r\n  \t * Whether default Markers for \"Point\" type Features inherit from group options.\r\n  \t */\r\n\r\n  \tinitialize: function (geojson, options) {\r\n  \t\tsetOptions(this, options);\r\n\r\n  \t\tthis._layers = {};\r\n\r\n  \t\tif (geojson) {\r\n  \t\t\tthis.addData(geojson);\r\n  \t\t}\r\n  \t},\r\n\r\n  \t// @method addData( <GeoJSON> data ): this\r\n  \t// Adds a GeoJSON object to the layer.\r\n  \taddData: function (geojson) {\r\n  \t\tvar features = isArray(geojson) ? geojson : geojson.features,\r\n  \t\t    i, len, feature;\r\n\r\n  \t\tif (features) {\r\n  \t\t\tfor (i = 0, len = features.length; i < len; i++) {\r\n  \t\t\t\t// only add this if geometry or geometries are set and not null\r\n  \t\t\t\tfeature = features[i];\r\n  \t\t\t\tif (feature.geometries || feature.geometry || feature.features || feature.coordinates) {\r\n  \t\t\t\t\tthis.addData(feature);\r\n  \t\t\t\t}\r\n  \t\t\t}\r\n  \t\t\treturn this;\r\n  \t\t}\r\n\r\n  \t\tvar options = this.options;\r\n\r\n  \t\tif (options.filter && !options.filter(geojson)) { return this; }\r\n\r\n  \t\tvar layer = geometryToLayer(geojson, options);\r\n  \t\tif (!layer) {\r\n  \t\t\treturn this;\r\n  \t\t}\r\n  \t\tlayer.feature = asFeature(geojson);\r\n\r\n  \t\tlayer.defaultOptions = layer.options;\r\n  \t\tthis.resetStyle(layer);\r\n\r\n  \t\tif (options.onEachFeature) {\r\n  \t\t\toptions.onEachFeature(geojson, layer);\r\n  \t\t}\r\n\r\n  \t\treturn this.addLayer(layer);\r\n  \t},\r\n\r\n  \t// @method resetStyle( <Path> layer? ): this\r\n  \t// Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.\r\n  \t// If `layer` is omitted, the style of all features in the current layer is reset.\r\n  \tresetStyle: function (layer) {\r\n  \t\tif (layer === undefined) {\r\n  \t\t\treturn this.eachLayer(this.resetStyle, this);\r\n  \t\t}\r\n  \t\t// reset any custom styles\r\n  \t\tlayer.options = extend({}, layer.defaultOptions);\r\n  \t\tthis._setLayerStyle(layer, this.options.style);\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method setStyle( <Function> style ): this\r\n  \t// Changes styles of GeoJSON vector layers with the given style function.\r\n  \tsetStyle: function (style) {\r\n  \t\treturn this.eachLayer(function (layer) {\r\n  \t\t\tthis._setLayerStyle(layer, style);\r\n  \t\t}, this);\r\n  \t},\r\n\r\n  \t_setLayerStyle: function (layer, style) {\r\n  \t\tif (layer.setStyle) {\r\n  \t\t\tif (typeof style === 'function') {\r\n  \t\t\t\tstyle = style(layer.feature);\r\n  \t\t\t}\r\n  \t\t\tlayer.setStyle(style);\r\n  \t\t}\r\n  \t}\r\n  });\r\n\r\n  // @section\r\n  // There are several static functions which can be called without instantiating L.GeoJSON:\r\n\r\n  // @function geometryToLayer(featureData: Object, options?: GeoJSON options): Layer\r\n  // Creates a `Layer` from a given GeoJSON feature. Can use a custom\r\n  // [`pointToLayer`](#geojson-pointtolayer) and/or [`coordsToLatLng`](#geojson-coordstolatlng)\r\n  // functions if provided as options.\r\n  function geometryToLayer(geojson, options) {\r\n\r\n  \tvar geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,\r\n  \t    coords = geometry ? geometry.coordinates : null,\r\n  \t    layers = [],\r\n  \t    pointToLayer = options && options.pointToLayer,\r\n  \t    _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng,\r\n  \t    latlng, latlngs, i, len;\r\n\r\n  \tif (!coords && !geometry) {\r\n  \t\treturn null;\r\n  \t}\r\n\r\n  \tswitch (geometry.type) {\r\n  \tcase 'Point':\r\n  \t\tlatlng = _coordsToLatLng(coords);\r\n  \t\treturn _pointToLayer(pointToLayer, geojson, latlng, options);\r\n\r\n  \tcase 'MultiPoint':\r\n  \t\tfor (i = 0, len = coords.length; i < len; i++) {\r\n  \t\t\tlatlng = _coordsToLatLng(coords[i]);\r\n  \t\t\tlayers.push(_pointToLayer(pointToLayer, geojson, latlng, options));\r\n  \t\t}\r\n  \t\treturn new FeatureGroup(layers);\r\n\r\n  \tcase 'LineString':\r\n  \tcase 'MultiLineString':\r\n  \t\tlatlngs = coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, _coordsToLatLng);\r\n  \t\treturn new Polyline(latlngs, options);\r\n\r\n  \tcase 'Polygon':\r\n  \tcase 'MultiPolygon':\r\n  \t\tlatlngs = coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, _coordsToLatLng);\r\n  \t\treturn new Polygon(latlngs, options);\r\n\r\n  \tcase 'GeometryCollection':\r\n  \t\tfor (i = 0, len = geometry.geometries.length; i < len; i++) {\r\n  \t\t\tvar geoLayer = geometryToLayer({\r\n  \t\t\t\tgeometry: geometry.geometries[i],\r\n  \t\t\t\ttype: 'Feature',\r\n  \t\t\t\tproperties: geojson.properties\r\n  \t\t\t}, options);\r\n\r\n  \t\t\tif (geoLayer) {\r\n  \t\t\t\tlayers.push(geoLayer);\r\n  \t\t\t}\r\n  \t\t}\r\n  \t\treturn new FeatureGroup(layers);\r\n\r\n  \tcase 'FeatureCollection':\r\n  \t\tfor (i = 0, len = geometry.features.length; i < len; i++) {\r\n  \t\t\tvar featureLayer = geometryToLayer(geometry.features[i], options);\r\n\r\n  \t\t\tif (featureLayer) {\r\n  \t\t\t\tlayers.push(featureLayer);\r\n  \t\t\t}\r\n  \t\t}\r\n  \t\treturn new FeatureGroup(layers);\r\n\r\n  \tdefault:\r\n  \t\tthrow new Error('Invalid GeoJSON object.');\r\n  \t}\r\n  }\r\n\r\n  function _pointToLayer(pointToLayerFn, geojson, latlng, options) {\r\n  \treturn pointToLayerFn ?\r\n  \t\tpointToLayerFn(geojson, latlng) :\r\n  \t\tnew Marker(latlng, options && options.markersInheritOptions && options);\r\n  }\r\n\r\n  // @function coordsToLatLng(coords: Array): LatLng\r\n  // Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)\r\n  // or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.\r\n  function coordsToLatLng(coords) {\r\n  \treturn new LatLng(coords[1], coords[0], coords[2]);\r\n  }\r\n\r\n  // @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array\r\n  // Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.\r\n  // `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).\r\n  // Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.\r\n  function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {\r\n  \tvar latlngs = [];\r\n\r\n  \tfor (var i = 0, len = coords.length, latlng; i < len; i++) {\r\n  \t\tlatlng = levelsDeep ?\r\n  \t\t\tcoordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) :\r\n  \t\t\t(_coordsToLatLng || coordsToLatLng)(coords[i]);\r\n\r\n  \t\tlatlngs.push(latlng);\r\n  \t}\r\n\r\n  \treturn latlngs;\r\n  }\r\n\r\n  // @function latLngToCoords(latlng: LatLng, precision?: Number|false): Array\r\n  // Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)\r\n  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function.\r\n  function latLngToCoords(latlng, precision) {\r\n  \tlatlng = toLatLng(latlng);\r\n  \treturn latlng.alt !== undefined ?\r\n  \t\t[formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] :\r\n  \t\t[formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];\r\n  }\r\n\r\n  // @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean, precision?: Number|false): Array\r\n  // Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)\r\n  // `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.\r\n  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function.\r\n  function latLngsToCoords(latlngs, levelsDeep, closed, precision) {\r\n  \tvar coords = [];\r\n\r\n  \tfor (var i = 0, len = latlngs.length; i < len; i++) {\r\n  \t\t// Check for flat arrays required to ensure unbalanced arrays are correctly converted in recursion\r\n  \t\tcoords.push(levelsDeep ?\r\n  \t\t\tlatLngsToCoords(latlngs[i], isFlat(latlngs[i]) ? 0 : levelsDeep - 1, closed, precision) :\r\n  \t\t\tlatLngToCoords(latlngs[i], precision));\r\n  \t}\r\n\r\n  \tif (!levelsDeep && closed) {\r\n  \t\tcoords.push(coords[0].slice());\r\n  \t}\r\n\r\n  \treturn coords;\r\n  }\r\n\r\n  function getFeature(layer, newGeometry) {\r\n  \treturn layer.feature ?\r\n  \t\textend({}, layer.feature, {geometry: newGeometry}) :\r\n  \t\tasFeature(newGeometry);\r\n  }\r\n\r\n  // @function asFeature(geojson: Object): Object\r\n  // Normalize GeoJSON geometries/features into GeoJSON features.\r\n  function asFeature(geojson) {\r\n  \tif (geojson.type === 'Feature' || geojson.type === 'FeatureCollection') {\r\n  \t\treturn geojson;\r\n  \t}\r\n\r\n  \treturn {\r\n  \t\ttype: 'Feature',\r\n  \t\tproperties: {},\r\n  \t\tgeometry: geojson\r\n  \t};\r\n  }\r\n\r\n  var PointToGeoJSON = {\r\n  \ttoGeoJSON: function (precision) {\r\n  \t\treturn getFeature(this, {\r\n  \t\t\ttype: 'Point',\r\n  \t\t\tcoordinates: latLngToCoords(this.getLatLng(), precision)\r\n  \t\t});\r\n  \t}\r\n  };\r\n\r\n  // @namespace Marker\r\n  // @section Other methods\r\n  // @method toGeoJSON(precision?: Number|false): Object\r\n  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.\r\n  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the marker (as a GeoJSON `Point` Feature).\r\n  Marker.include(PointToGeoJSON);\r\n\r\n  // @namespace CircleMarker\r\n  // @method toGeoJSON(precision?: Number|false): Object\r\n  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.\r\n  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the circle marker (as a GeoJSON `Point` Feature).\r\n  Circle.include(PointToGeoJSON);\r\n  CircleMarker.include(PointToGeoJSON);\r\n\r\n\r\n  // @namespace Polyline\r\n  // @method toGeoJSON(precision?: Number|false): Object\r\n  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.\r\n  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the polyline (as a GeoJSON `LineString` or `MultiLineString` Feature).\r\n  Polyline.include({\r\n  \ttoGeoJSON: function (precision) {\r\n  \t\tvar multi = !isFlat(this._latlngs);\r\n\r\n  \t\tvar coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);\r\n\r\n  \t\treturn getFeature(this, {\r\n  \t\t\ttype: (multi ? 'Multi' : '') + 'LineString',\r\n  \t\t\tcoordinates: coords\r\n  \t\t});\r\n  \t}\r\n  });\r\n\r\n  // @namespace Polygon\r\n  // @method toGeoJSON(precision?: Number|false): Object\r\n  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.\r\n  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the polygon (as a GeoJSON `Polygon` or `MultiPolygon` Feature).\r\n  Polygon.include({\r\n  \ttoGeoJSON: function (precision) {\r\n  \t\tvar holes = !isFlat(this._latlngs),\r\n  \t\t    multi = holes && !isFlat(this._latlngs[0]);\r\n\r\n  \t\tvar coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);\r\n\r\n  \t\tif (!holes) {\r\n  \t\t\tcoords = [coords];\r\n  \t\t}\r\n\r\n  \t\treturn getFeature(this, {\r\n  \t\t\ttype: (multi ? 'Multi' : '') + 'Polygon',\r\n  \t\t\tcoordinates: coords\r\n  \t\t});\r\n  \t}\r\n  });\r\n\r\n\r\n  // @namespace LayerGroup\r\n  LayerGroup.include({\r\n  \ttoMultiPoint: function (precision) {\r\n  \t\tvar coords = [];\r\n\r\n  \t\tthis.eachLayer(function (layer) {\r\n  \t\t\tcoords.push(layer.toGeoJSON(precision).geometry.coordinates);\r\n  \t\t});\r\n\r\n  \t\treturn getFeature(this, {\r\n  \t\t\ttype: 'MultiPoint',\r\n  \t\t\tcoordinates: coords\r\n  \t\t});\r\n  \t},\r\n\r\n  \t// @method toGeoJSON(precision?: Number|false): Object\r\n  \t// Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.\r\n  \t// Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).\r\n  \ttoGeoJSON: function (precision) {\r\n\r\n  \t\tvar type = this.feature && this.feature.geometry && this.feature.geometry.type;\r\n\r\n  \t\tif (type === 'MultiPoint') {\r\n  \t\t\treturn this.toMultiPoint(precision);\r\n  \t\t}\r\n\r\n  \t\tvar isGeometryCollection = type === 'GeometryCollection',\r\n  \t\t    jsons = [];\r\n\r\n  \t\tthis.eachLayer(function (layer) {\r\n  \t\t\tif (layer.toGeoJSON) {\r\n  \t\t\t\tvar json = layer.toGeoJSON(precision);\r\n  \t\t\t\tif (isGeometryCollection) {\r\n  \t\t\t\t\tjsons.push(json.geometry);\r\n  \t\t\t\t} else {\r\n  \t\t\t\t\tvar feature = asFeature(json);\r\n  \t\t\t\t\t// Squash nested feature collections\r\n  \t\t\t\t\tif (feature.type === 'FeatureCollection') {\r\n  \t\t\t\t\t\tjsons.push.apply(jsons, feature.features);\r\n  \t\t\t\t\t} else {\r\n  \t\t\t\t\t\tjsons.push(feature);\r\n  \t\t\t\t\t}\r\n  \t\t\t\t}\r\n  \t\t\t}\r\n  \t\t});\r\n\r\n  \t\tif (isGeometryCollection) {\r\n  \t\t\treturn getFeature(this, {\r\n  \t\t\t\tgeometries: jsons,\r\n  \t\t\t\ttype: 'GeometryCollection'\r\n  \t\t\t});\r\n  \t\t}\r\n\r\n  \t\treturn {\r\n  \t\t\ttype: 'FeatureCollection',\r\n  \t\t\tfeatures: jsons\r\n  \t\t};\r\n  \t}\r\n  });\r\n\r\n  // @namespace GeoJSON\r\n  // @factory L.geoJSON(geojson?: Object, options?: GeoJSON options)\r\n  // Creates a GeoJSON layer. Optionally accepts an object in\r\n  // [GeoJSON format](https://tools.ietf.org/html/rfc7946) to display on the map\r\n  // (you can alternatively add it later with `addData` method) and an `options` object.\r\n  function geoJSON(geojson, options) {\r\n  \treturn new GeoJSON(geojson, options);\r\n  }\r\n\r\n  // Backward compatibility.\r\n  var geoJson = geoJSON;\n\n  /*\r\n   * @class ImageOverlay\r\n   * @aka L.ImageOverlay\r\n   * @inherits Interactive layer\r\n   *\r\n   * Used to load and display a single image over specific bounds of the map. Extends `Layer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var imageUrl = 'https://maps.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',\r\n   * \timageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];\r\n   * L.imageOverlay(imageUrl, imageBounds).addTo(map);\r\n   * ```\r\n   */\r\n\r\n  var ImageOverlay = Layer.extend({\r\n\r\n  \t// @section\r\n  \t// @aka ImageOverlay options\r\n  \toptions: {\r\n  \t\t// @option opacity: Number = 1.0\r\n  \t\t// The opacity of the image overlay.\r\n  \t\topacity: 1,\r\n\r\n  \t\t// @option alt: String = ''\r\n  \t\t// Text for the `alt` attribute of the image (useful for accessibility).\r\n  \t\talt: '',\r\n\r\n  \t\t// @option interactive: Boolean = false\r\n  \t\t// If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.\r\n  \t\tinteractive: false,\r\n\r\n  \t\t// @option crossOrigin: Boolean|String = false\r\n  \t\t// Whether the crossOrigin attribute will be added to the image.\r\n  \t\t// If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.\r\n  \t\t// Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.\r\n  \t\tcrossOrigin: false,\r\n\r\n  \t\t// @option errorOverlayUrl: String = ''\r\n  \t\t// URL to the overlay image to show in place of the overlay that failed to load.\r\n  \t\terrorOverlayUrl: '',\r\n\r\n  \t\t// @option zIndex: Number = 1\r\n  \t\t// The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.\r\n  \t\tzIndex: 1,\r\n\r\n  \t\t// @option className: String = ''\r\n  \t\t// A custom class name to assign to the image. Empty by default.\r\n  \t\tclassName: ''\r\n  \t},\r\n\r\n  \tinitialize: function (url, bounds, options) { // (String, LatLngBounds, Object)\r\n  \t\tthis._url = url;\r\n  \t\tthis._bounds = toLatLngBounds(bounds);\r\n\r\n  \t\tsetOptions(this, options);\r\n  \t},\r\n\r\n  \tonAdd: function () {\r\n  \t\tif (!this._image) {\r\n  \t\t\tthis._initImage();\r\n\r\n  \t\t\tif (this.options.opacity < 1) {\r\n  \t\t\t\tthis._updateOpacity();\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\tif (this.options.interactive) {\r\n  \t\t\taddClass(this._image, 'leaflet-interactive');\r\n  \t\t\tthis.addInteractiveTarget(this._image);\r\n  \t\t}\r\n\r\n  \t\tthis.getPane().appendChild(this._image);\r\n  \t\tthis._reset();\r\n  \t},\r\n\r\n  \tonRemove: function () {\r\n  \t\tremove(this._image);\r\n  \t\tif (this.options.interactive) {\r\n  \t\t\tthis.removeInteractiveTarget(this._image);\r\n  \t\t}\r\n  \t},\r\n\r\n  \t// @method setOpacity(opacity: Number): this\r\n  \t// Sets the opacity of the overlay.\r\n  \tsetOpacity: function (opacity) {\r\n  \t\tthis.options.opacity = opacity;\r\n\r\n  \t\tif (this._image) {\r\n  \t\t\tthis._updateOpacity();\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \tsetStyle: function (styleOpts) {\r\n  \t\tif (styleOpts.opacity) {\r\n  \t\t\tthis.setOpacity(styleOpts.opacity);\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method bringToFront(): this\r\n  \t// Brings the layer to the top of all overlays.\r\n  \tbringToFront: function () {\r\n  \t\tif (this._map) {\r\n  \t\t\ttoFront(this._image);\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method bringToBack(): this\r\n  \t// Brings the layer to the bottom of all overlays.\r\n  \tbringToBack: function () {\r\n  \t\tif (this._map) {\r\n  \t\t\ttoBack(this._image);\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method setUrl(url: String): this\r\n  \t// Changes the URL of the image.\r\n  \tsetUrl: function (url) {\r\n  \t\tthis._url = url;\r\n\r\n  \t\tif (this._image) {\r\n  \t\t\tthis._image.src = url;\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method setBounds(bounds: LatLngBounds): this\r\n  \t// Update the bounds that this ImageOverlay covers\r\n  \tsetBounds: function (bounds) {\r\n  \t\tthis._bounds = toLatLngBounds(bounds);\r\n\r\n  \t\tif (this._map) {\r\n  \t\t\tthis._reset();\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \tgetEvents: function () {\r\n  \t\tvar events = {\r\n  \t\t\tzoom: this._reset,\r\n  \t\t\tviewreset: this._reset\r\n  \t\t};\r\n\r\n  \t\tif (this._zoomAnimated) {\r\n  \t\t\tevents.zoomanim = this._animateZoom;\r\n  \t\t}\r\n\r\n  \t\treturn events;\r\n  \t},\r\n\r\n  \t// @method setZIndex(value: Number): this\r\n  \t// Changes the [zIndex](#imageoverlay-zindex) of the image overlay.\r\n  \tsetZIndex: function (value) {\r\n  \t\tthis.options.zIndex = value;\r\n  \t\tthis._updateZIndex();\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method getBounds(): LatLngBounds\r\n  \t// Get the bounds that this ImageOverlay covers\r\n  \tgetBounds: function () {\r\n  \t\treturn this._bounds;\r\n  \t},\r\n\r\n  \t// @method getElement(): HTMLElement\r\n  \t// Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)\r\n  \t// used by this overlay.\r\n  \tgetElement: function () {\r\n  \t\treturn this._image;\r\n  \t},\r\n\r\n  \t_initImage: function () {\r\n  \t\tvar wasElementSupplied = this._url.tagName === 'IMG';\r\n  \t\tvar img = this._image = wasElementSupplied ? this._url : create$1('img');\r\n\r\n  \t\taddClass(img, 'leaflet-image-layer');\r\n  \t\tif (this._zoomAnimated) { addClass(img, 'leaflet-zoom-animated'); }\r\n  \t\tif (this.options.className) { addClass(img, this.options.className); }\r\n\r\n  \t\timg.onselectstart = falseFn;\r\n  \t\timg.onmousemove = falseFn;\r\n\r\n  \t\t// @event load: Event\r\n  \t\t// Fired when the ImageOverlay layer has loaded its image\r\n  \t\timg.onload = bind(this.fire, this, 'load');\r\n  \t\timg.onerror = bind(this._overlayOnError, this, 'error');\r\n\r\n  \t\tif (this.options.crossOrigin || this.options.crossOrigin === '') {\r\n  \t\t\timg.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;\r\n  \t\t}\r\n\r\n  \t\tif (this.options.zIndex) {\r\n  \t\t\tthis._updateZIndex();\r\n  \t\t}\r\n\r\n  \t\tif (wasElementSupplied) {\r\n  \t\t\tthis._url = img.src;\r\n  \t\t\treturn;\r\n  \t\t}\r\n\r\n  \t\timg.src = this._url;\r\n  \t\timg.alt = this.options.alt;\r\n  \t},\r\n\r\n  \t_animateZoom: function (e) {\r\n  \t\tvar scale = this._map.getZoomScale(e.zoom),\r\n  \t\t    offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;\r\n\r\n  \t\tsetTransform(this._image, offset, scale);\r\n  \t},\r\n\r\n  \t_reset: function () {\r\n  \t\tvar image = this._image,\r\n  \t\t    bounds = new Bounds(\r\n  \t\t        this._map.latLngToLayerPoint(this._bounds.getNorthWest()),\r\n  \t\t        this._map.latLngToLayerPoint(this._bounds.getSouthEast())),\r\n  \t\t    size = bounds.getSize();\r\n\r\n  \t\tsetPosition(image, bounds.min);\r\n\r\n  \t\timage.style.width  = size.x + 'px';\r\n  \t\timage.style.height = size.y + 'px';\r\n  \t},\r\n\r\n  \t_updateOpacity: function () {\r\n  \t\tsetOpacity(this._image, this.options.opacity);\r\n  \t},\r\n\r\n  \t_updateZIndex: function () {\r\n  \t\tif (this._image && this.options.zIndex !== undefined && this.options.zIndex !== null) {\r\n  \t\t\tthis._image.style.zIndex = this.options.zIndex;\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_overlayOnError: function () {\r\n  \t\t// @event error: Event\r\n  \t\t// Fired when the ImageOverlay layer fails to load its image\r\n  \t\tthis.fire('error');\r\n\r\n  \t\tvar errorUrl = this.options.errorOverlayUrl;\r\n  \t\tif (errorUrl && this._url !== errorUrl) {\r\n  \t\t\tthis._url = errorUrl;\r\n  \t\t\tthis._image.src = errorUrl;\r\n  \t\t}\r\n  \t},\r\n\r\n  \t// @method getCenter(): LatLng\r\n  \t// Returns the center of the ImageOverlay.\r\n  \tgetCenter: function () {\r\n  \t\treturn this._bounds.getCenter();\r\n  \t}\r\n  });\r\n\r\n  // @factory L.imageOverlay(imageUrl: String, bounds: LatLngBounds, options?: ImageOverlay options)\r\n  // Instantiates an image overlay object given the URL of the image and the\r\n  // geographical bounds it is tied to.\r\n  var imageOverlay = function (url, bounds, options) {\r\n  \treturn new ImageOverlay(url, bounds, options);\r\n  };\n\n  /*\r\n   * @class VideoOverlay\r\n   * @aka L.VideoOverlay\r\n   * @inherits ImageOverlay\r\n   *\r\n   * Used to load and display a video player over specific bounds of the map. Extends `ImageOverlay`.\r\n   *\r\n   * A video overlay uses the [`<video>`](https://developer.mozilla.org/docs/Web/HTML/Element/video)\r\n   * HTML5 element.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var videoUrl = 'https://www.mapbox.com/bites/00188/patricia_nasa.webm',\r\n   * \tvideoBounds = [[ 32, -130], [ 13, -100]];\r\n   * L.videoOverlay(videoUrl, videoBounds ).addTo(map);\r\n   * ```\r\n   */\r\n\r\n  var VideoOverlay = ImageOverlay.extend({\r\n\r\n  \t// @section\r\n  \t// @aka VideoOverlay options\r\n  \toptions: {\r\n  \t\t// @option autoplay: Boolean = true\r\n  \t\t// Whether the video starts playing automatically when loaded.\r\n  \t\t// On some browsers autoplay will only work with `muted: true`\r\n  \t\tautoplay: true,\r\n\r\n  \t\t// @option loop: Boolean = true\r\n  \t\t// Whether the video will loop back to the beginning when played.\r\n  \t\tloop: true,\r\n\r\n  \t\t// @option keepAspectRatio: Boolean = true\r\n  \t\t// Whether the video will save aspect ratio after the projection.\r\n  \t\t// Relevant for supported browsers. See [browser compatibility](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit)\r\n  \t\tkeepAspectRatio: true,\r\n\r\n  \t\t// @option muted: Boolean = false\r\n  \t\t// Whether the video starts on mute when loaded.\r\n  \t\tmuted: false,\r\n\r\n  \t\t// @option playsInline: Boolean = true\r\n  \t\t// Mobile browsers will play the video right where it is instead of open it up in fullscreen mode.\r\n  \t\tplaysInline: true\r\n  \t},\r\n\r\n  \t_initImage: function () {\r\n  \t\tvar wasElementSupplied = this._url.tagName === 'VIDEO';\r\n  \t\tvar vid = this._image = wasElementSupplied ? this._url : create$1('video');\r\n\r\n  \t\taddClass(vid, 'leaflet-image-layer');\r\n  \t\tif (this._zoomAnimated) { addClass(vid, 'leaflet-zoom-animated'); }\r\n  \t\tif (this.options.className) { addClass(vid, this.options.className); }\r\n\r\n  \t\tvid.onselectstart = falseFn;\r\n  \t\tvid.onmousemove = falseFn;\r\n\r\n  \t\t// @event load: Event\r\n  \t\t// Fired when the video has finished loading the first frame\r\n  \t\tvid.onloadeddata = bind(this.fire, this, 'load');\r\n\r\n  \t\tif (wasElementSupplied) {\r\n  \t\t\tvar sourceElements = vid.getElementsByTagName('source');\r\n  \t\t\tvar sources = [];\r\n  \t\t\tfor (var j = 0; j < sourceElements.length; j++) {\r\n  \t\t\t\tsources.push(sourceElements[j].src);\r\n  \t\t\t}\r\n\r\n  \t\t\tthis._url = (sourceElements.length > 0) ? sources : [vid.src];\r\n  \t\t\treturn;\r\n  \t\t}\r\n\r\n  \t\tif (!isArray(this._url)) { this._url = [this._url]; }\r\n\r\n  \t\tif (!this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(vid.style, 'objectFit')) {\r\n  \t\t\tvid.style['objectFit'] = 'fill';\r\n  \t\t}\r\n  \t\tvid.autoplay = !!this.options.autoplay;\r\n  \t\tvid.loop = !!this.options.loop;\r\n  \t\tvid.muted = !!this.options.muted;\r\n  \t\tvid.playsInline = !!this.options.playsInline;\r\n  \t\tfor (var i = 0; i < this._url.length; i++) {\r\n  \t\t\tvar source = create$1('source');\r\n  \t\t\tsource.src = this._url[i];\r\n  \t\t\tvid.appendChild(source);\r\n  \t\t}\r\n  \t}\r\n\r\n  \t// @method getElement(): HTMLVideoElement\r\n  \t// Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)\r\n  \t// used by this overlay.\r\n  });\r\n\r\n\r\n  // @factory L.videoOverlay(video: String|Array|HTMLVideoElement, bounds: LatLngBounds, options?: VideoOverlay options)\r\n  // Instantiates an image overlay object given the URL of the video (or array of URLs, or even a video element) and the\r\n  // geographical bounds it is tied to.\r\n\r\n  function videoOverlay(video, bounds, options) {\r\n  \treturn new VideoOverlay(video, bounds, options);\r\n  }\n\n  /*\n   * @class SVGOverlay\n   * @aka L.SVGOverlay\n   * @inherits ImageOverlay\n   *\n   * Used to load, display and provide DOM access to an SVG file over specific bounds of the map. Extends `ImageOverlay`.\n   *\n   * An SVG overlay uses the [`<svg>`](https://developer.mozilla.org/docs/Web/SVG/Element/svg) element.\n   *\n   * @example\n   *\n   * ```js\n   * var svgElement = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n   * svgElement.setAttribute('xmlns', \"http://www.w3.org/2000/svg\");\n   * svgElement.setAttribute('viewBox', \"0 0 200 200\");\n   * svgElement.innerHTML = '<rect width=\"200\" height=\"200\"/><rect x=\"75\" y=\"23\" width=\"50\" height=\"50\" style=\"fill:red\"/><rect x=\"75\" y=\"123\" width=\"50\" height=\"50\" style=\"fill:#0013ff\"/>';\n   * var svgElementBounds = [ [ 32, -130 ], [ 13, -100 ] ];\n   * L.svgOverlay(svgElement, svgElementBounds).addTo(map);\n   * ```\n   */\n\n  var SVGOverlay = ImageOverlay.extend({\n  \t_initImage: function () {\n  \t\tvar el = this._image = this._url;\n\n  \t\taddClass(el, 'leaflet-image-layer');\n  \t\tif (this._zoomAnimated) { addClass(el, 'leaflet-zoom-animated'); }\n  \t\tif (this.options.className) { addClass(el, this.options.className); }\n\n  \t\tel.onselectstart = falseFn;\n  \t\tel.onmousemove = falseFn;\n  \t}\n\n  \t// @method getElement(): SVGElement\n  \t// Returns the instance of [`SVGElement`](https://developer.mozilla.org/docs/Web/API/SVGElement)\n  \t// used by this overlay.\n  });\n\n\n  // @factory L.svgOverlay(svg: String|SVGElement, bounds: LatLngBounds, options?: SVGOverlay options)\n  // Instantiates an image overlay object given an SVG element and the geographical bounds it is tied to.\n  // A viewBox attribute is required on the SVG element to zoom in and out properly.\n\n  function svgOverlay(el, bounds, options) {\n  \treturn new SVGOverlay(el, bounds, options);\n  }\n\n  /*\r\n   * @class DivOverlay\r\n   * @inherits Interactive layer\r\n   * @aka L.DivOverlay\r\n   * Base model for L.Popup and L.Tooltip. Inherit from it for custom overlays like plugins.\r\n   */\r\n\r\n  // @namespace DivOverlay\r\n  var DivOverlay = Layer.extend({\r\n\r\n  \t// @section\r\n  \t// @aka DivOverlay options\r\n  \toptions: {\r\n  \t\t// @option interactive: Boolean = false\r\n  \t\t// If true, the popup/tooltip will listen to the mouse events.\r\n  \t\tinteractive: false,\r\n\r\n  \t\t// @option offset: Point = Point(0, 0)\r\n  \t\t// The offset of the overlay position.\r\n  \t\toffset: [0, 0],\r\n\r\n  \t\t// @option className: String = ''\r\n  \t\t// A custom CSS class name to assign to the overlay.\r\n  \t\tclassName: '',\r\n\r\n  \t\t// @option pane: String = undefined\r\n  \t\t// `Map pane` where the overlay will be added.\r\n  \t\tpane: undefined,\r\n\r\n  \t\t// @option content: String|HTMLElement|Function = ''\r\n  \t\t// Sets the HTML content of the overlay while initializing. If a function is passed the source layer will be\r\n  \t\t// passed to the function. The function should return a `String` or `HTMLElement` to be used in the overlay.\r\n  \t\tcontent: ''\r\n  \t},\r\n\r\n  \tinitialize: function (options, source) {\r\n  \t\tif (options && (options instanceof LatLng || isArray(options))) {\r\n  \t\t\tthis._latlng = toLatLng(options);\r\n  \t\t\tsetOptions(this, source);\r\n  \t\t} else {\r\n  \t\t\tsetOptions(this, options);\r\n  \t\t\tthis._source = source;\r\n  \t\t}\r\n  \t\tif (this.options.content) {\r\n  \t\t\tthis._content = this.options.content;\r\n  \t\t}\r\n  \t},\r\n\r\n  \t// @method openOn(map: Map): this\r\n  \t// Adds the overlay to the map.\r\n  \t// Alternative to `map.openPopup(popup)`/`.openTooltip(tooltip)`.\r\n  \topenOn: function (map) {\r\n  \t\tmap = arguments.length ? map : this._source._map; // experimental, not the part of public api\r\n  \t\tif (!map.hasLayer(this)) {\r\n  \t\t\tmap.addLayer(this);\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method close(): this\r\n  \t// Closes the overlay.\r\n  \t// Alternative to `map.closePopup(popup)`/`.closeTooltip(tooltip)`\r\n  \t// and `layer.closePopup()`/`.closeTooltip()`.\r\n  \tclose: function () {\r\n  \t\tif (this._map) {\r\n  \t\t\tthis._map.removeLayer(this);\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method toggle(layer?: Layer): this\r\n  \t// Opens or closes the overlay bound to layer depending on its current state.\r\n  \t// Argument may be omitted only for overlay bound to layer.\r\n  \t// Alternative to `layer.togglePopup()`/`.toggleTooltip()`.\r\n  \ttoggle: function (layer) {\r\n  \t\tif (this._map) {\r\n  \t\t\tthis.close();\r\n  \t\t} else {\r\n  \t\t\tif (arguments.length) {\r\n  \t\t\t\tthis._source = layer;\r\n  \t\t\t} else {\r\n  \t\t\t\tlayer = this._source;\r\n  \t\t\t}\r\n  \t\t\tthis._prepareOpen();\r\n\r\n  \t\t\t// open the overlay on the map\r\n  \t\t\tthis.openOn(layer._map);\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \tonAdd: function (map) {\r\n  \t\tthis._zoomAnimated = map._zoomAnimated;\r\n\r\n  \t\tif (!this._container) {\r\n  \t\t\tthis._initLayout();\r\n  \t\t}\r\n\r\n  \t\tif (map._fadeAnimated) {\r\n  \t\t\tsetOpacity(this._container, 0);\r\n  \t\t}\r\n\r\n  \t\tclearTimeout(this._removeTimeout);\r\n  \t\tthis.getPane().appendChild(this._container);\r\n  \t\tthis.update();\r\n\r\n  \t\tif (map._fadeAnimated) {\r\n  \t\t\tsetOpacity(this._container, 1);\r\n  \t\t}\r\n\r\n  \t\tthis.bringToFront();\r\n\r\n  \t\tif (this.options.interactive) {\r\n  \t\t\taddClass(this._container, 'leaflet-interactive');\r\n  \t\t\tthis.addInteractiveTarget(this._container);\r\n  \t\t}\r\n  \t},\r\n\r\n  \tonRemove: function (map) {\r\n  \t\tif (map._fadeAnimated) {\r\n  \t\t\tsetOpacity(this._container, 0);\r\n  \t\t\tthis._removeTimeout = setTimeout(bind(remove, undefined, this._container), 200);\r\n  \t\t} else {\r\n  \t\t\tremove(this._container);\r\n  \t\t}\r\n\r\n  \t\tif (this.options.interactive) {\r\n  \t\t\tremoveClass(this._container, 'leaflet-interactive');\r\n  \t\t\tthis.removeInteractiveTarget(this._container);\r\n  \t\t}\r\n  \t},\r\n\r\n  \t// @namespace DivOverlay\r\n  \t// @method getLatLng: LatLng\r\n  \t// Returns the geographical point of the overlay.\r\n  \tgetLatLng: function () {\r\n  \t\treturn this._latlng;\r\n  \t},\r\n\r\n  \t// @method setLatLng(latlng: LatLng): this\r\n  \t// Sets the geographical point where the overlay will open.\r\n  \tsetLatLng: function (latlng) {\r\n  \t\tthis._latlng = toLatLng(latlng);\r\n  \t\tif (this._map) {\r\n  \t\t\tthis._updatePosition();\r\n  \t\t\tthis._adjustPan();\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method getContent: String|HTMLElement\r\n  \t// Returns the content of the overlay.\r\n  \tgetContent: function () {\r\n  \t\treturn this._content;\r\n  \t},\r\n\r\n  \t// @method setContent(htmlContent: String|HTMLElement|Function): this\r\n  \t// Sets the HTML content of the overlay. If a function is passed the source layer will be passed to the function.\r\n  \t// The function should return a `String` or `HTMLElement` to be used in the overlay.\r\n  \tsetContent: function (content) {\r\n  \t\tthis._content = content;\r\n  \t\tthis.update();\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method getElement: String|HTMLElement\r\n  \t// Returns the HTML container of the overlay.\r\n  \tgetElement: function () {\r\n  \t\treturn this._container;\r\n  \t},\r\n\r\n  \t// @method update: null\r\n  \t// Updates the overlay content, layout and position. Useful for updating the overlay after something inside changed, e.g. image loaded.\r\n  \tupdate: function () {\r\n  \t\tif (!this._map) { return; }\r\n\r\n  \t\tthis._container.style.visibility = 'hidden';\r\n\r\n  \t\tthis._updateContent();\r\n  \t\tthis._updateLayout();\r\n  \t\tthis._updatePosition();\r\n\r\n  \t\tthis._container.style.visibility = '';\r\n\r\n  \t\tthis._adjustPan();\r\n  \t},\r\n\r\n  \tgetEvents: function () {\r\n  \t\tvar events = {\r\n  \t\t\tzoom: this._updatePosition,\r\n  \t\t\tviewreset: this._updatePosition\r\n  \t\t};\r\n\r\n  \t\tif (this._zoomAnimated) {\r\n  \t\t\tevents.zoomanim = this._animateZoom;\r\n  \t\t}\r\n  \t\treturn events;\r\n  \t},\r\n\r\n  \t// @method isOpen: Boolean\r\n  \t// Returns `true` when the overlay is visible on the map.\r\n  \tisOpen: function () {\r\n  \t\treturn !!this._map && this._map.hasLayer(this);\r\n  \t},\r\n\r\n  \t// @method bringToFront: this\r\n  \t// Brings this overlay in front of other overlays (in the same map pane).\r\n  \tbringToFront: function () {\r\n  \t\tif (this._map) {\r\n  \t\t\ttoFront(this._container);\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method bringToBack: this\r\n  \t// Brings this overlay to the back of other overlays (in the same map pane).\r\n  \tbringToBack: function () {\r\n  \t\tif (this._map) {\r\n  \t\t\ttoBack(this._container);\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// prepare bound overlay to open: update latlng pos / content source (for FeatureGroup)\r\n  \t_prepareOpen: function (latlng) {\r\n  \t\tvar source = this._source;\r\n  \t\tif (!source._map) { return false; }\r\n\r\n  \t\tif (source instanceof FeatureGroup) {\r\n  \t\t\tsource = null;\r\n  \t\t\tvar layers = this._source._layers;\r\n  \t\t\tfor (var id in layers) {\r\n  \t\t\t\tif (layers[id]._map) {\r\n  \t\t\t\t\tsource = layers[id];\r\n  \t\t\t\t\tbreak;\r\n  \t\t\t\t}\r\n  \t\t\t}\r\n  \t\t\tif (!source) { return false; } // Unable to get source layer.\r\n\r\n  \t\t\t// set overlay source to this layer\r\n  \t\t\tthis._source = source;\r\n  \t\t}\r\n\r\n  \t\tif (!latlng) {\r\n  \t\t\tif (source.getCenter) {\r\n  \t\t\t\tlatlng = source.getCenter();\r\n  \t\t\t} else if (source.getLatLng) {\r\n  \t\t\t\tlatlng = source.getLatLng();\r\n  \t\t\t} else if (source.getBounds) {\r\n  \t\t\t\tlatlng = source.getBounds().getCenter();\r\n  \t\t\t} else {\r\n  \t\t\t\tthrow new Error('Unable to get source layer LatLng.');\r\n  \t\t\t}\r\n  \t\t}\r\n  \t\tthis.setLatLng(latlng);\r\n\r\n  \t\tif (this._map) {\r\n  \t\t\t// update the overlay (content, layout, etc...)\r\n  \t\t\tthis.update();\r\n  \t\t}\r\n\r\n  \t\treturn true;\r\n  \t},\r\n\r\n  \t_updateContent: function () {\r\n  \t\tif (!this._content) { return; }\r\n\r\n  \t\tvar node = this._contentNode;\r\n  \t\tvar content = (typeof this._content === 'function') ? this._content(this._source || this) : this._content;\r\n\r\n  \t\tif (typeof content === 'string') {\r\n  \t\t\tnode.innerHTML = content;\r\n  \t\t} else {\r\n  \t\t\twhile (node.hasChildNodes()) {\r\n  \t\t\t\tnode.removeChild(node.firstChild);\r\n  \t\t\t}\r\n  \t\t\tnode.appendChild(content);\r\n  \t\t}\r\n\r\n  \t\t// @namespace DivOverlay\r\n  \t\t// @section DivOverlay events\r\n  \t\t// @event contentupdate: Event\r\n  \t\t// Fired when the content of the overlay is updated\r\n  \t\tthis.fire('contentupdate');\r\n  \t},\r\n\r\n  \t_updatePosition: function () {\r\n  \t\tif (!this._map) { return; }\r\n\r\n  \t\tvar pos = this._map.latLngToLayerPoint(this._latlng),\r\n  \t\t    offset = toPoint(this.options.offset),\r\n  \t\t    anchor = this._getAnchor();\r\n\r\n  \t\tif (this._zoomAnimated) {\r\n  \t\t\tsetPosition(this._container, pos.add(anchor));\r\n  \t\t} else {\r\n  \t\t\toffset = offset.add(pos).add(anchor);\r\n  \t\t}\r\n\r\n  \t\tvar bottom = this._containerBottom = -offset.y,\r\n  \t\t    left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;\r\n\r\n  \t\t// bottom position the overlay in case the height of the overlay changes (images loading etc)\r\n  \t\tthis._container.style.bottom = bottom + 'px';\r\n  \t\tthis._container.style.left = left + 'px';\r\n  \t},\r\n\r\n  \t_getAnchor: function () {\r\n  \t\treturn [0, 0];\r\n  \t}\r\n\r\n  });\r\n\r\n  Map.include({\r\n  \t_initOverlay: function (OverlayClass, content, latlng, options) {\r\n  \t\tvar overlay = content;\r\n  \t\tif (!(overlay instanceof OverlayClass)) {\r\n  \t\t\toverlay = new OverlayClass(options).setContent(content);\r\n  \t\t}\r\n  \t\tif (latlng) {\r\n  \t\t\toverlay.setLatLng(latlng);\r\n  \t\t}\r\n  \t\treturn overlay;\r\n  \t}\r\n  });\r\n\r\n\r\n  Layer.include({\r\n  \t_initOverlay: function (OverlayClass, old, content, options) {\r\n  \t\tvar overlay = content;\r\n  \t\tif (overlay instanceof OverlayClass) {\r\n  \t\t\tsetOptions(overlay, options);\r\n  \t\t\toverlay._source = this;\r\n  \t\t} else {\r\n  \t\t\toverlay = (old && !options) ? old : new OverlayClass(options, this);\r\n  \t\t\toverlay.setContent(content);\r\n  \t\t}\r\n  \t\treturn overlay;\r\n  \t}\r\n  });\n\n  /*\r\n   * @class Popup\r\n   * @inherits DivOverlay\r\n   * @aka L.Popup\r\n   * Used to open popups in certain places of the map. Use [Map.openPopup](#map-openpopup) to\r\n   * open popups while making sure that only one popup is open at one time\r\n   * (recommended for usability), or use [Map.addLayer](#map-addlayer) to open as many as you want.\r\n   *\r\n   * @example\r\n   *\r\n   * If you want to just bind a popup to marker click and then open it, it's really easy:\r\n   *\r\n   * ```js\r\n   * marker.bindPopup(popupContent).openPopup();\r\n   * ```\r\n   * Path overlays like polylines also have a `bindPopup` method.\r\n   *\r\n   * A popup can be also standalone:\r\n   *\r\n   * ```js\r\n   * var popup = L.popup()\r\n   * \t.setLatLng(latlng)\r\n   * \t.setContent('<p>Hello world!<br />This is a nice popup.</p>')\r\n   * \t.openOn(map);\r\n   * ```\r\n   * or\r\n   * ```js\r\n   * var popup = L.popup(latlng, {content: '<p>Hello world!<br />This is a nice popup.</p>')\r\n   * \t.openOn(map);\r\n   * ```\r\n   */\r\n\r\n\r\n  // @namespace Popup\r\n  var Popup = DivOverlay.extend({\r\n\r\n  \t// @section\r\n  \t// @aka Popup options\r\n  \toptions: {\r\n  \t\t// @option pane: String = 'popupPane'\r\n  \t\t// `Map pane` where the popup will be added.\r\n  \t\tpane: 'popupPane',\r\n\r\n  \t\t// @option offset: Point = Point(0, 7)\r\n  \t\t// The offset of the popup position.\r\n  \t\toffset: [0, 7],\r\n\r\n  \t\t// @option maxWidth: Number = 300\r\n  \t\t// Max width of the popup, in pixels.\r\n  \t\tmaxWidth: 300,\r\n\r\n  \t\t// @option minWidth: Number = 50\r\n  \t\t// Min width of the popup, in pixels.\r\n  \t\tminWidth: 50,\r\n\r\n  \t\t// @option maxHeight: Number = null\r\n  \t\t// If set, creates a scrollable container of the given height\r\n  \t\t// inside a popup if its content exceeds it.\r\n  \t\t// The scrollable container can be styled using the\r\n  \t\t// `leaflet-popup-scrolled` CSS class selector.\r\n  \t\tmaxHeight: null,\r\n\r\n  \t\t// @option autoPan: Boolean = true\r\n  \t\t// Set it to `false` if you don't want the map to do panning animation\r\n  \t\t// to fit the opened popup.\r\n  \t\tautoPan: true,\r\n\r\n  \t\t// @option autoPanPaddingTopLeft: Point = null\r\n  \t\t// The margin between the popup and the top left corner of the map\r\n  \t\t// view after autopanning was performed.\r\n  \t\tautoPanPaddingTopLeft: null,\r\n\r\n  \t\t// @option autoPanPaddingBottomRight: Point = null\r\n  \t\t// The margin between the popup and the bottom right corner of the map\r\n  \t\t// view after autopanning was performed.\r\n  \t\tautoPanPaddingBottomRight: null,\r\n\r\n  \t\t// @option autoPanPadding: Point = Point(5, 5)\r\n  \t\t// Equivalent of setting both top left and bottom right autopan padding to the same value.\r\n  \t\tautoPanPadding: [5, 5],\r\n\r\n  \t\t// @option keepInView: Boolean = false\r\n  \t\t// Set it to `true` if you want to prevent users from panning the popup\r\n  \t\t// off of the screen while it is open.\r\n  \t\tkeepInView: false,\r\n\r\n  \t\t// @option closeButton: Boolean = true\r\n  \t\t// Controls the presence of a close button in the popup.\r\n  \t\tcloseButton: true,\r\n\r\n  \t\t// @option autoClose: Boolean = true\r\n  \t\t// Set it to `false` if you want to override the default behavior of\r\n  \t\t// the popup closing when another popup is opened.\r\n  \t\tautoClose: true,\r\n\r\n  \t\t// @option closeOnEscapeKey: Boolean = true\r\n  \t\t// Set it to `false` if you want to override the default behavior of\r\n  \t\t// the ESC key for closing of the popup.\r\n  \t\tcloseOnEscapeKey: true,\r\n\r\n  \t\t// @option closeOnClick: Boolean = *\r\n  \t\t// Set it if you want to override the default behavior of the popup closing when user clicks\r\n  \t\t// on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.\r\n\r\n  \t\t// @option className: String = ''\r\n  \t\t// A custom CSS class name to assign to the popup.\r\n  \t\tclassName: ''\r\n  \t},\r\n\r\n  \t// @namespace Popup\r\n  \t// @method openOn(map: Map): this\r\n  \t// Alternative to `map.openPopup(popup)`.\r\n  \t// Adds the popup to the map and closes the previous one.\r\n  \topenOn: function (map) {\r\n  \t\tmap = arguments.length ? map : this._source._map; // experimental, not the part of public api\r\n\r\n  \t\tif (!map.hasLayer(this) && map._popup && map._popup.options.autoClose) {\r\n  \t\t\tmap.removeLayer(map._popup);\r\n  \t\t}\r\n  \t\tmap._popup = this;\r\n\r\n  \t\treturn DivOverlay.prototype.openOn.call(this, map);\r\n  \t},\r\n\r\n  \tonAdd: function (map) {\r\n  \t\tDivOverlay.prototype.onAdd.call(this, map);\r\n\r\n  \t\t// @namespace Map\r\n  \t\t// @section Popup events\r\n  \t\t// @event popupopen: PopupEvent\r\n  \t\t// Fired when a popup is opened in the map\r\n  \t\tmap.fire('popupopen', {popup: this});\r\n\r\n  \t\tif (this._source) {\r\n  \t\t\t// @namespace Layer\r\n  \t\t\t// @section Popup events\r\n  \t\t\t// @event popupopen: PopupEvent\r\n  \t\t\t// Fired when a popup bound to this layer is opened\r\n  \t\t\tthis._source.fire('popupopen', {popup: this}, true);\r\n  \t\t\t// For non-path layers, we toggle the popup when clicking\r\n  \t\t\t// again the layer, so prevent the map to reopen it.\r\n  \t\t\tif (!(this._source instanceof Path)) {\r\n  \t\t\t\tthis._source.on('preclick', stopPropagation);\r\n  \t\t\t}\r\n  \t\t}\r\n  \t},\r\n\r\n  \tonRemove: function (map) {\r\n  \t\tDivOverlay.prototype.onRemove.call(this, map);\r\n\r\n  \t\t// @namespace Map\r\n  \t\t// @section Popup events\r\n  \t\t// @event popupclose: PopupEvent\r\n  \t\t// Fired when a popup in the map is closed\r\n  \t\tmap.fire('popupclose', {popup: this});\r\n\r\n  \t\tif (this._source) {\r\n  \t\t\t// @namespace Layer\r\n  \t\t\t// @section Popup events\r\n  \t\t\t// @event popupclose: PopupEvent\r\n  \t\t\t// Fired when a popup bound to this layer is closed\r\n  \t\t\tthis._source.fire('popupclose', {popup: this}, true);\r\n  \t\t\tif (!(this._source instanceof Path)) {\r\n  \t\t\t\tthis._source.off('preclick', stopPropagation);\r\n  \t\t\t}\r\n  \t\t}\r\n  \t},\r\n\r\n  \tgetEvents: function () {\r\n  \t\tvar events = DivOverlay.prototype.getEvents.call(this);\r\n\r\n  \t\tif (this.options.closeOnClick !== undefined ? this.options.closeOnClick : this._map.options.closePopupOnClick) {\r\n  \t\t\tevents.preclick = this.close;\r\n  \t\t}\r\n\r\n  \t\tif (this.options.keepInView) {\r\n  \t\t\tevents.moveend = this._adjustPan;\r\n  \t\t}\r\n\r\n  \t\treturn events;\r\n  \t},\r\n\r\n  \t_initLayout: function () {\r\n  \t\tvar prefix = 'leaflet-popup',\r\n  \t\t    container = this._container = create$1('div',\r\n  \t\t\tprefix + ' ' + (this.options.className || '') +\r\n  \t\t\t' leaflet-zoom-animated');\r\n\r\n  \t\tvar wrapper = this._wrapper = create$1('div', prefix + '-content-wrapper', container);\r\n  \t\tthis._contentNode = create$1('div', prefix + '-content', wrapper);\r\n\r\n  \t\tdisableClickPropagation(container);\r\n  \t\tdisableScrollPropagation(this._contentNode);\r\n  \t\ton(container, 'contextmenu', stopPropagation);\r\n\r\n  \t\tthis._tipContainer = create$1('div', prefix + '-tip-container', container);\r\n  \t\tthis._tip = create$1('div', prefix + '-tip', this._tipContainer);\r\n\r\n  \t\tif (this.options.closeButton) {\r\n  \t\t\tvar closeButton = this._closeButton = create$1('a', prefix + '-close-button', container);\r\n  \t\t\tcloseButton.setAttribute('role', 'button'); // overrides the implicit role=link of <a> elements #7399\r\n  \t\t\tcloseButton.setAttribute('aria-label', 'Close popup');\r\n  \t\t\tcloseButton.href = '#close';\r\n  \t\t\tcloseButton.innerHTML = '<span aria-hidden=\"true\">&#215;</span>';\r\n\r\n  \t\t\ton(closeButton, 'click', function (ev) {\r\n  \t\t\t\tpreventDefault(ev);\r\n  \t\t\t\tthis.close();\r\n  \t\t\t}, this);\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_updateLayout: function () {\r\n  \t\tvar container = this._contentNode,\r\n  \t\t    style = container.style;\r\n\r\n  \t\tstyle.width = '';\r\n  \t\tstyle.whiteSpace = 'nowrap';\r\n\r\n  \t\tvar width = container.offsetWidth;\r\n  \t\twidth = Math.min(width, this.options.maxWidth);\r\n  \t\twidth = Math.max(width, this.options.minWidth);\r\n\r\n  \t\tstyle.width = (width + 1) + 'px';\r\n  \t\tstyle.whiteSpace = '';\r\n\r\n  \t\tstyle.height = '';\r\n\r\n  \t\tvar height = container.offsetHeight,\r\n  \t\t    maxHeight = this.options.maxHeight,\r\n  \t\t    scrolledClass = 'leaflet-popup-scrolled';\r\n\r\n  \t\tif (maxHeight && height > maxHeight) {\r\n  \t\t\tstyle.height = maxHeight + 'px';\r\n  \t\t\taddClass(container, scrolledClass);\r\n  \t\t} else {\r\n  \t\t\tremoveClass(container, scrolledClass);\r\n  \t\t}\r\n\r\n  \t\tthis._containerWidth = this._container.offsetWidth;\r\n  \t},\r\n\r\n  \t_animateZoom: function (e) {\r\n  \t\tvar pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center),\r\n  \t\t    anchor = this._getAnchor();\r\n  \t\tsetPosition(this._container, pos.add(anchor));\r\n  \t},\r\n\r\n  \t_adjustPan: function () {\r\n  \t\tif (!this.options.autoPan) { return; }\r\n  \t\tif (this._map._panAnim) { this._map._panAnim.stop(); }\r\n\r\n  \t\t// We can endlessly recurse if keepInView is set and the view resets.\r\n  \t\t// Let's guard against that by exiting early if we're responding to our own autopan.\r\n  \t\tif (this._autopanning) {\r\n  \t\t\tthis._autopanning = false;\r\n  \t\t\treturn;\r\n  \t\t}\r\n\r\n  \t\tvar map = this._map,\r\n  \t\t    marginBottom = parseInt(getStyle(this._container, 'marginBottom'), 10) || 0,\r\n  \t\t    containerHeight = this._container.offsetHeight + marginBottom,\r\n  \t\t    containerWidth = this._containerWidth,\r\n  \t\t    layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);\r\n\r\n  \t\tlayerPos._add(getPosition(this._container));\r\n\r\n  \t\tvar containerPos = map.layerPointToContainerPoint(layerPos),\r\n  \t\t    padding = toPoint(this.options.autoPanPadding),\r\n  \t\t    paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding),\r\n  \t\t    paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding),\r\n  \t\t    size = map.getSize(),\r\n  \t\t    dx = 0,\r\n  \t\t    dy = 0;\r\n\r\n  \t\tif (containerPos.x + containerWidth + paddingBR.x > size.x) { // right\r\n  \t\t\tdx = containerPos.x + containerWidth - size.x + paddingBR.x;\r\n  \t\t}\r\n  \t\tif (containerPos.x - dx - paddingTL.x < 0) { // left\r\n  \t\t\tdx = containerPos.x - paddingTL.x;\r\n  \t\t}\r\n  \t\tif (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom\r\n  \t\t\tdy = containerPos.y + containerHeight - size.y + paddingBR.y;\r\n  \t\t}\r\n  \t\tif (containerPos.y - dy - paddingTL.y < 0) { // top\r\n  \t\t\tdy = containerPos.y - paddingTL.y;\r\n  \t\t}\r\n\r\n  \t\t// @namespace Map\r\n  \t\t// @section Popup events\r\n  \t\t// @event autopanstart: Event\r\n  \t\t// Fired when the map starts autopanning when opening a popup.\r\n  \t\tif (dx || dy) {\r\n  \t\t\t// Track that we're autopanning, as this function will be re-ran on moveend\r\n  \t\t\tif (this.options.keepInView) {\r\n  \t\t\t\tthis._autopanning = true;\r\n  \t\t\t}\r\n\r\n  \t\t\tmap\r\n  \t\t\t    .fire('autopanstart')\r\n  \t\t\t    .panBy([dx, dy]);\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_getAnchor: function () {\r\n  \t\t// Where should we anchor the popup on the source layer?\r\n  \t\treturn toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);\r\n  \t}\r\n\r\n  });\r\n\r\n  // @namespace Popup\r\n  // @factory L.popup(options?: Popup options, source?: Layer)\r\n  // Instantiates a `Popup` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the popup with a reference to the Layer to which it refers.\r\n  // @alternative\r\n  // @factory L.popup(latlng: LatLng, options?: Popup options)\r\n  // Instantiates a `Popup` object given `latlng` where the popup will open and an optional `options` object that describes its appearance and location.\r\n  var popup = function (options, source) {\r\n  \treturn new Popup(options, source);\r\n  };\r\n\r\n\r\n  /* @namespace Map\r\n   * @section Interaction Options\r\n   * @option closePopupOnClick: Boolean = true\r\n   * Set it to `false` if you don't want popups to close when user clicks the map.\r\n   */\r\n  Map.mergeOptions({\r\n  \tclosePopupOnClick: true\r\n  });\r\n\r\n\r\n  // @namespace Map\r\n  // @section Methods for Layers and Controls\r\n  Map.include({\r\n  \t// @method openPopup(popup: Popup): this\r\n  \t// Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).\r\n  \t// @alternative\r\n  \t// @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this\r\n  \t// Creates a popup with the specified content and options and opens it in the given point on a map.\r\n  \topenPopup: function (popup, latlng, options) {\r\n  \t\tthis._initOverlay(Popup, popup, latlng, options)\r\n  \t\t  .openOn(this);\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method closePopup(popup?: Popup): this\r\n  \t// Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).\r\n  \tclosePopup: function (popup) {\r\n  \t\tpopup = arguments.length ? popup : this._popup;\r\n  \t\tif (popup) {\r\n  \t\t\tpopup.close();\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t}\r\n  });\r\n\r\n  /*\r\n   * @namespace Layer\r\n   * @section Popup methods example\r\n   *\r\n   * All layers share a set of methods convenient for binding popups to it.\r\n   *\r\n   * ```js\r\n   * var layer = L.Polygon(latlngs).bindPopup('Hi There!').addTo(map);\r\n   * layer.openPopup();\r\n   * layer.closePopup();\r\n   * ```\r\n   *\r\n   * Popups will also be automatically opened when the layer is clicked on and closed when the layer is removed from the map or another popup is opened.\r\n   */\r\n\r\n  // @section Popup methods\r\n  Layer.include({\r\n\r\n  \t// @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this\r\n  \t// Binds a popup to the layer with the passed `content` and sets up the\r\n  \t// necessary event listeners. If a `Function` is passed it will receive\r\n  \t// the layer as the first argument and should return a `String` or `HTMLElement`.\r\n  \tbindPopup: function (content, options) {\r\n  \t\tthis._popup = this._initOverlay(Popup, this._popup, content, options);\r\n  \t\tif (!this._popupHandlersAdded) {\r\n  \t\t\tthis.on({\r\n  \t\t\t\tclick: this._openPopup,\r\n  \t\t\t\tkeypress: this._onKeyPress,\r\n  \t\t\t\tremove: this.closePopup,\r\n  \t\t\t\tmove: this._movePopup\r\n  \t\t\t});\r\n  \t\t\tthis._popupHandlersAdded = true;\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method unbindPopup(): this\r\n  \t// Removes the popup previously bound with `bindPopup`.\r\n  \tunbindPopup: function () {\r\n  \t\tif (this._popup) {\r\n  \t\t\tthis.off({\r\n  \t\t\t\tclick: this._openPopup,\r\n  \t\t\t\tkeypress: this._onKeyPress,\r\n  \t\t\t\tremove: this.closePopup,\r\n  \t\t\t\tmove: this._movePopup\r\n  \t\t\t});\r\n  \t\t\tthis._popupHandlersAdded = false;\r\n  \t\t\tthis._popup = null;\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method openPopup(latlng?: LatLng): this\r\n  \t// Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.\r\n  \topenPopup: function (latlng) {\r\n  \t\tif (this._popup) {\r\n  \t\t\tif (!(this instanceof FeatureGroup)) {\r\n  \t\t\t\tthis._popup._source = this;\r\n  \t\t\t}\r\n  \t\t\tif (this._popup._prepareOpen(latlng || this._latlng)) {\r\n  \t\t\t\t// open the popup on the map\r\n  \t\t\t\tthis._popup.openOn(this._map);\r\n  \t\t\t}\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method closePopup(): this\r\n  \t// Closes the popup bound to this layer if it is open.\r\n  \tclosePopup: function () {\r\n  \t\tif (this._popup) {\r\n  \t\t\tthis._popup.close();\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method togglePopup(): this\r\n  \t// Opens or closes the popup bound to this layer depending on its current state.\r\n  \ttogglePopup: function () {\r\n  \t\tif (this._popup) {\r\n  \t\t\tthis._popup.toggle(this);\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method isPopupOpen(): boolean\r\n  \t// Returns `true` if the popup bound to this layer is currently open.\r\n  \tisPopupOpen: function () {\r\n  \t\treturn (this._popup ? this._popup.isOpen() : false);\r\n  \t},\r\n\r\n  \t// @method setPopupContent(content: String|HTMLElement|Popup): this\r\n  \t// Sets the content of the popup bound to this layer.\r\n  \tsetPopupContent: function (content) {\r\n  \t\tif (this._popup) {\r\n  \t\t\tthis._popup.setContent(content);\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method getPopup(): Popup\r\n  \t// Returns the popup bound to this layer.\r\n  \tgetPopup: function () {\r\n  \t\treturn this._popup;\r\n  \t},\r\n\r\n  \t_openPopup: function (e) {\r\n  \t\tif (!this._popup || !this._map) {\r\n  \t\t\treturn;\r\n  \t\t}\r\n  \t\t// prevent map click\r\n  \t\tstop(e);\r\n\r\n  \t\tvar target = e.layer || e.target;\r\n  \t\tif (this._popup._source === target && !(target instanceof Path)) {\r\n  \t\t\t// treat it like a marker and figure out\r\n  \t\t\t// if we should toggle it open/closed\r\n  \t\t\tif (this._map.hasLayer(this._popup)) {\r\n  \t\t\t\tthis.closePopup();\r\n  \t\t\t} else {\r\n  \t\t\t\tthis.openPopup(e.latlng);\r\n  \t\t\t}\r\n  \t\t\treturn;\r\n  \t\t}\r\n  \t\tthis._popup._source = target;\r\n  \t\tthis.openPopup(e.latlng);\r\n  \t},\r\n\r\n  \t_movePopup: function (e) {\r\n  \t\tthis._popup.setLatLng(e.latlng);\r\n  \t},\r\n\r\n  \t_onKeyPress: function (e) {\r\n  \t\tif (e.originalEvent.keyCode === 13) {\r\n  \t\t\tthis._openPopup(e);\r\n  \t\t}\r\n  \t}\r\n  });\n\n  /*\n   * @class Tooltip\n   * @inherits DivOverlay\n   * @aka L.Tooltip\n   * Used to display small texts on top of map layers.\n   *\n   * @example\n   * If you want to just bind a tooltip to marker:\n   *\n   * ```js\n   * marker.bindTooltip(\"my tooltip text\").openTooltip();\n   * ```\n   * Path overlays like polylines also have a `bindTooltip` method.\n   *\n   * A tooltip can be also standalone:\n   *\n   * ```js\n   * var tooltip = L.tooltip()\n   * \t.setLatLng(latlng)\n   * \t.setContent('Hello world!<br />This is a nice tooltip.')\n   * \t.addTo(map);\n   * ```\n   * or\n   * ```js\n   * var tooltip = L.tooltip(latlng, {content: 'Hello world!<br />This is a nice tooltip.'})\n   * \t.addTo(map);\n   * ```\n   *\n   *\n   * Note about tooltip offset. Leaflet takes two options in consideration\n   * for computing tooltip offsetting:\n   * - the `offset` Tooltip option: it defaults to [0, 0], and it's specific to one tooltip.\n   *   Add a positive x offset to move the tooltip to the right, and a positive y offset to\n   *   move it to the bottom. Negatives will move to the left and top.\n   * - the `tooltipAnchor` Icon option: this will only be considered for Marker. You\n   *   should adapt this value if you use a custom icon.\n   */\n\n\n  // @namespace Tooltip\n  var Tooltip = DivOverlay.extend({\n\n  \t// @section\n  \t// @aka Tooltip options\n  \toptions: {\n  \t\t// @option pane: String = 'tooltipPane'\n  \t\t// `Map pane` where the tooltip will be added.\n  \t\tpane: 'tooltipPane',\n\n  \t\t// @option offset: Point = Point(0, 0)\n  \t\t// Optional offset of the tooltip position.\n  \t\toffset: [0, 0],\n\n  \t\t// @option direction: String = 'auto'\n  \t\t// Direction where to open the tooltip. Possible values are: `right`, `left`,\n  \t\t// `top`, `bottom`, `center`, `auto`.\n  \t\t// `auto` will dynamically switch between `right` and `left` according to the tooltip\n  \t\t// position on the map.\n  \t\tdirection: 'auto',\n\n  \t\t// @option permanent: Boolean = false\n  \t\t// Whether to open the tooltip permanently or only on mouseover.\n  \t\tpermanent: false,\n\n  \t\t// @option sticky: Boolean = false\n  \t\t// If true, the tooltip will follow the mouse instead of being fixed at the feature center.\n  \t\tsticky: false,\n\n  \t\t// @option opacity: Number = 0.9\n  \t\t// Tooltip container opacity.\n  \t\topacity: 0.9\n  \t},\n\n  \tonAdd: function (map) {\n  \t\tDivOverlay.prototype.onAdd.call(this, map);\n  \t\tthis.setOpacity(this.options.opacity);\n\n  \t\t// @namespace Map\n  \t\t// @section Tooltip events\n  \t\t// @event tooltipopen: TooltipEvent\n  \t\t// Fired when a tooltip is opened in the map.\n  \t\tmap.fire('tooltipopen', {tooltip: this});\n\n  \t\tif (this._source) {\n  \t\t\tthis.addEventParent(this._source);\n\n  \t\t\t// @namespace Layer\n  \t\t\t// @section Tooltip events\n  \t\t\t// @event tooltipopen: TooltipEvent\n  \t\t\t// Fired when a tooltip bound to this layer is opened.\n  \t\t\tthis._source.fire('tooltipopen', {tooltip: this}, true);\n  \t\t}\n  \t},\n\n  \tonRemove: function (map) {\n  \t\tDivOverlay.prototype.onRemove.call(this, map);\n\n  \t\t// @namespace Map\n  \t\t// @section Tooltip events\n  \t\t// @event tooltipclose: TooltipEvent\n  \t\t// Fired when a tooltip in the map is closed.\n  \t\tmap.fire('tooltipclose', {tooltip: this});\n\n  \t\tif (this._source) {\n  \t\t\tthis.removeEventParent(this._source);\n\n  \t\t\t// @namespace Layer\n  \t\t\t// @section Tooltip events\n  \t\t\t// @event tooltipclose: TooltipEvent\n  \t\t\t// Fired when a tooltip bound to this layer is closed.\n  \t\t\tthis._source.fire('tooltipclose', {tooltip: this}, true);\n  \t\t}\n  \t},\n\n  \tgetEvents: function () {\n  \t\tvar events = DivOverlay.prototype.getEvents.call(this);\n\n  \t\tif (!this.options.permanent) {\n  \t\t\tevents.preclick = this.close;\n  \t\t}\n\n  \t\treturn events;\n  \t},\n\n  \t_initLayout: function () {\n  \t\tvar prefix = 'leaflet-tooltip',\n  \t\t    className = prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');\n\n  \t\tthis._contentNode = this._container = create$1('div', className);\n\n  \t\tthis._container.setAttribute('role', 'tooltip');\n  \t\tthis._container.setAttribute('id', 'leaflet-tooltip-' + stamp(this));\n  \t},\n\n  \t_updateLayout: function () {},\n\n  \t_adjustPan: function () {},\n\n  \t_setPosition: function (pos) {\n  \t\tvar subX, subY,\n  \t\t    map = this._map,\n  \t\t    container = this._container,\n  \t\t    centerPoint = map.latLngToContainerPoint(map.getCenter()),\n  \t\t    tooltipPoint = map.layerPointToContainerPoint(pos),\n  \t\t    direction = this.options.direction,\n  \t\t    tooltipWidth = container.offsetWidth,\n  \t\t    tooltipHeight = container.offsetHeight,\n  \t\t    offset = toPoint(this.options.offset),\n  \t\t    anchor = this._getAnchor();\n\n  \t\tif (direction === 'top') {\n  \t\t\tsubX = tooltipWidth / 2;\n  \t\t\tsubY = tooltipHeight;\n  \t\t} else if (direction === 'bottom') {\n  \t\t\tsubX = tooltipWidth / 2;\n  \t\t\tsubY = 0;\n  \t\t} else if (direction === 'center') {\n  \t\t\tsubX = tooltipWidth / 2;\n  \t\t\tsubY = tooltipHeight / 2;\n  \t\t} else if (direction === 'right') {\n  \t\t\tsubX = 0;\n  \t\t\tsubY = tooltipHeight / 2;\n  \t\t} else if (direction === 'left') {\n  \t\t\tsubX = tooltipWidth;\n  \t\t\tsubY = tooltipHeight / 2;\n  \t\t} else if (tooltipPoint.x < centerPoint.x) {\n  \t\t\tdirection = 'right';\n  \t\t\tsubX = 0;\n  \t\t\tsubY = tooltipHeight / 2;\n  \t\t} else {\n  \t\t\tdirection = 'left';\n  \t\t\tsubX = tooltipWidth + (offset.x + anchor.x) * 2;\n  \t\t\tsubY = tooltipHeight / 2;\n  \t\t}\n\n  \t\tpos = pos.subtract(toPoint(subX, subY, true)).add(offset).add(anchor);\n\n  \t\tremoveClass(container, 'leaflet-tooltip-right');\n  \t\tremoveClass(container, 'leaflet-tooltip-left');\n  \t\tremoveClass(container, 'leaflet-tooltip-top');\n  \t\tremoveClass(container, 'leaflet-tooltip-bottom');\n  \t\taddClass(container, 'leaflet-tooltip-' + direction);\n  \t\tsetPosition(container, pos);\n  \t},\n\n  \t_updatePosition: function () {\n  \t\tvar pos = this._map.latLngToLayerPoint(this._latlng);\n  \t\tthis._setPosition(pos);\n  \t},\n\n  \tsetOpacity: function (opacity) {\n  \t\tthis.options.opacity = opacity;\n\n  \t\tif (this._container) {\n  \t\t\tsetOpacity(this._container, opacity);\n  \t\t}\n  \t},\n\n  \t_animateZoom: function (e) {\n  \t\tvar pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);\n  \t\tthis._setPosition(pos);\n  \t},\n\n  \t_getAnchor: function () {\n  \t\t// Where should we anchor the tooltip on the source layer?\n  \t\treturn toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);\n  \t}\n\n  });\n\n  // @namespace Tooltip\n  // @factory L.tooltip(options?: Tooltip options, source?: Layer)\n  // Instantiates a `Tooltip` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the tooltip with a reference to the Layer to which it refers.\n  // @alternative\n  // @factory L.tooltip(latlng: LatLng, options?: Tooltip options)\n  // Instantiates a `Tooltip` object given `latlng` where the tooltip will open and an optional `options` object that describes its appearance and location.\n  var tooltip = function (options, source) {\n  \treturn new Tooltip(options, source);\n  };\n\n  // @namespace Map\n  // @section Methods for Layers and Controls\n  Map.include({\n\n  \t// @method openTooltip(tooltip: Tooltip): this\n  \t// Opens the specified tooltip.\n  \t// @alternative\n  \t// @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this\n  \t// Creates a tooltip with the specified content and options and open it.\n  \topenTooltip: function (tooltip, latlng, options) {\n  \t\tthis._initOverlay(Tooltip, tooltip, latlng, options)\n  \t\t  .openOn(this);\n\n  \t\treturn this;\n  \t},\n\n  \t// @method closeTooltip(tooltip: Tooltip): this\n  \t// Closes the tooltip given as parameter.\n  \tcloseTooltip: function (tooltip) {\n  \t\ttooltip.close();\n  \t\treturn this;\n  \t}\n\n  });\n\n  /*\n   * @namespace Layer\n   * @section Tooltip methods example\n   *\n   * All layers share a set of methods convenient for binding tooltips to it.\n   *\n   * ```js\n   * var layer = L.Polygon(latlngs).bindTooltip('Hi There!').addTo(map);\n   * layer.openTooltip();\n   * layer.closeTooltip();\n   * ```\n   */\n\n  // @section Tooltip methods\n  Layer.include({\n\n  \t// @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this\n  \t// Binds a tooltip to the layer with the passed `content` and sets up the\n  \t// necessary event listeners. If a `Function` is passed it will receive\n  \t// the layer as the first argument and should return a `String` or `HTMLElement`.\n  \tbindTooltip: function (content, options) {\n\n  \t\tif (this._tooltip && this.isTooltipOpen()) {\n  \t\t\tthis.unbindTooltip();\n  \t\t}\n\n  \t\tthis._tooltip = this._initOverlay(Tooltip, this._tooltip, content, options);\n  \t\tthis._initTooltipInteractions();\n\n  \t\tif (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {\n  \t\t\tthis.openTooltip();\n  \t\t}\n\n  \t\treturn this;\n  \t},\n\n  \t// @method unbindTooltip(): this\n  \t// Removes the tooltip previously bound with `bindTooltip`.\n  \tunbindTooltip: function () {\n  \t\tif (this._tooltip) {\n  \t\t\tthis._initTooltipInteractions(true);\n  \t\t\tthis.closeTooltip();\n  \t\t\tthis._tooltip = null;\n  \t\t}\n  \t\treturn this;\n  \t},\n\n  \t_initTooltipInteractions: function (remove) {\n  \t\tif (!remove && this._tooltipHandlersAdded) { return; }\n  \t\tvar onOff = remove ? 'off' : 'on',\n  \t\t    events = {\n  \t\t\tremove: this.closeTooltip,\n  \t\t\tmove: this._moveTooltip\n  \t\t    };\n  \t\tif (!this._tooltip.options.permanent) {\n  \t\t\tevents.mouseover = this._openTooltip;\n  \t\t\tevents.mouseout = this.closeTooltip;\n  \t\t\tevents.click = this._openTooltip;\n  \t\t\tif (this._map) {\n  \t\t\t\tthis._addFocusListeners();\n  \t\t\t} else {\n  \t\t\t\tevents.add = this._addFocusListeners;\n  \t\t\t}\n  \t\t} else {\n  \t\t\tevents.add = this._openTooltip;\n  \t\t}\n  \t\tif (this._tooltip.options.sticky) {\n  \t\t\tevents.mousemove = this._moveTooltip;\n  \t\t}\n  \t\tthis[onOff](events);\n  \t\tthis._tooltipHandlersAdded = !remove;\n  \t},\n\n  \t// @method openTooltip(latlng?: LatLng): this\n  \t// Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.\n  \topenTooltip: function (latlng) {\n  \t\tif (this._tooltip) {\n  \t\t\tif (!(this instanceof FeatureGroup)) {\n  \t\t\t\tthis._tooltip._source = this;\n  \t\t\t}\n  \t\t\tif (this._tooltip._prepareOpen(latlng)) {\n  \t\t\t\t// open the tooltip on the map\n  \t\t\t\tthis._tooltip.openOn(this._map);\n\n  \t\t\t\tif (this.getElement) {\n  \t\t\t\t\tthis._setAriaDescribedByOnLayer(this);\n  \t\t\t\t} else if (this.eachLayer) {\n  \t\t\t\t\tthis.eachLayer(this._setAriaDescribedByOnLayer, this);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\treturn this;\n  \t},\n\n  \t// @method closeTooltip(): this\n  \t// Closes the tooltip bound to this layer if it is open.\n  \tcloseTooltip: function () {\n  \t\tif (this._tooltip) {\n  \t\t\treturn this._tooltip.close();\n  \t\t}\n  \t},\n\n  \t// @method toggleTooltip(): this\n  \t// Opens or closes the tooltip bound to this layer depending on its current state.\n  \ttoggleTooltip: function () {\n  \t\tif (this._tooltip) {\n  \t\t\tthis._tooltip.toggle(this);\n  \t\t}\n  \t\treturn this;\n  \t},\n\n  \t// @method isTooltipOpen(): boolean\n  \t// Returns `true` if the tooltip bound to this layer is currently open.\n  \tisTooltipOpen: function () {\n  \t\treturn this._tooltip.isOpen();\n  \t},\n\n  \t// @method setTooltipContent(content: String|HTMLElement|Tooltip): this\n  \t// Sets the content of the tooltip bound to this layer.\n  \tsetTooltipContent: function (content) {\n  \t\tif (this._tooltip) {\n  \t\t\tthis._tooltip.setContent(content);\n  \t\t}\n  \t\treturn this;\n  \t},\n\n  \t// @method getTooltip(): Tooltip\n  \t// Returns the tooltip bound to this layer.\n  \tgetTooltip: function () {\n  \t\treturn this._tooltip;\n  \t},\n\n  \t_addFocusListeners: function () {\n  \t\tif (this.getElement) {\n  \t\t\tthis._addFocusListenersOnLayer(this);\n  \t\t} else if (this.eachLayer) {\n  \t\t\tthis.eachLayer(this._addFocusListenersOnLayer, this);\n  \t\t}\n  \t},\n\n  \t_addFocusListenersOnLayer: function (layer) {\n  \t\tvar el = layer.getElement();\n  \t\tif (el) {\n  \t\t\ton(el, 'focus', function () {\n  \t\t\t\tthis._tooltip._source = layer;\n  \t\t\t\tthis.openTooltip();\n  \t\t\t}, this);\n  \t\t\ton(el, 'blur', this.closeTooltip, this);\n  \t\t}\n  \t},\n\n  \t_setAriaDescribedByOnLayer: function (layer) {\n  \t\tvar el = layer.getElement();\n  \t\tif (el) {\n  \t\t\tel.setAttribute('aria-describedby', this._tooltip._container.id);\n  \t\t}\n  \t},\n\n\n  \t_openTooltip: function (e) {\n  \t\tif (!this._tooltip || !this._map || (this._map.dragging && this._map.dragging.moving())) {\n  \t\t\treturn;\n  \t\t}\n  \t\tthis._tooltip._source = e.layer || e.target;\n\n  \t\tthis.openTooltip(this._tooltip.options.sticky ? e.latlng : undefined);\n  \t},\n\n  \t_moveTooltip: function (e) {\n  \t\tvar latlng = e.latlng, containerPoint, layerPoint;\n  \t\tif (this._tooltip.options.sticky && e.originalEvent) {\n  \t\t\tcontainerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);\n  \t\t\tlayerPoint = this._map.containerPointToLayerPoint(containerPoint);\n  \t\t\tlatlng = this._map.layerPointToLatLng(layerPoint);\n  \t\t}\n  \t\tthis._tooltip.setLatLng(latlng);\n  \t}\n  });\n\n  /*\n   * @class DivIcon\n   * @aka L.DivIcon\n   * @inherits Icon\n   *\n   * Represents a lightweight icon for markers that uses a simple `<div>`\n   * element instead of an image. Inherits from `Icon` but ignores the `iconUrl` and shadow options.\n   *\n   * @example\n   * ```js\n   * var myIcon = L.divIcon({className: 'my-div-icon'});\n   * // you can set .my-div-icon styles in CSS\n   *\n   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);\n   * ```\n   *\n   * By default, it has a 'leaflet-div-icon' CSS class and is styled as a little white square with a shadow.\n   */\n\n  var DivIcon = Icon.extend({\n  \toptions: {\n  \t\t// @section\n  \t\t// @aka DivIcon options\n  \t\ticonSize: [12, 12], // also can be set through CSS\n\n  \t\t// iconAnchor: (Point),\n  \t\t// popupAnchor: (Point),\n\n  \t\t// @option html: String|HTMLElement = ''\n  \t\t// Custom HTML code to put inside the div element, empty by default. Alternatively,\n  \t\t// an instance of `HTMLElement`.\n  \t\thtml: false,\n\n  \t\t// @option bgPos: Point = [0, 0]\n  \t\t// Optional relative position of the background, in pixels\n  \t\tbgPos: null,\n\n  \t\tclassName: 'leaflet-div-icon'\n  \t},\n\n  \tcreateIcon: function (oldIcon) {\n  \t\tvar div = (oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'),\n  \t\t    options = this.options;\n\n  \t\tif (options.html instanceof Element) {\n  \t\t\tempty(div);\n  \t\t\tdiv.appendChild(options.html);\n  \t\t} else {\n  \t\t\tdiv.innerHTML = options.html !== false ? options.html : '';\n  \t\t}\n\n  \t\tif (options.bgPos) {\n  \t\t\tvar bgPos = toPoint(options.bgPos);\n  \t\t\tdiv.style.backgroundPosition = (-bgPos.x) + 'px ' + (-bgPos.y) + 'px';\n  \t\t}\n  \t\tthis._setIconStyles(div, 'icon');\n\n  \t\treturn div;\n  \t},\n\n  \tcreateShadow: function () {\n  \t\treturn null;\n  \t}\n  });\n\n  // @factory L.divIcon(options: DivIcon options)\n  // Creates a `DivIcon` instance with the given options.\n  function divIcon(options) {\n  \treturn new DivIcon(options);\n  }\n\n  Icon.Default = IconDefault;\n\n  /*\n   * @class GridLayer\n   * @inherits Layer\n   * @aka L.GridLayer\n   *\n   * Generic class for handling a tiled grid of HTML elements. This is the base class for all tile layers and replaces `TileLayer.Canvas`.\n   * GridLayer can be extended to create a tiled grid of HTML elements like `<canvas>`, `<img>` or `<div>`. GridLayer will handle creating and animating these DOM elements for you.\n   *\n   *\n   * @section Synchronous usage\n   * @example\n   *\n   * To create a custom layer, extend GridLayer and implement the `createTile()` method, which will be passed a `Point` object with the `x`, `y`, and `z` (zoom level) coordinates to draw your tile.\n   *\n   * ```js\n   * var CanvasLayer = L.GridLayer.extend({\n   *     createTile: function(coords){\n   *         // create a <canvas> element for drawing\n   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');\n   *\n   *         // setup tile width and height according to the options\n   *         var size = this.getTileSize();\n   *         tile.width = size.x;\n   *         tile.height = size.y;\n   *\n   *         // get a canvas context and draw something on it using coords.x, coords.y and coords.z\n   *         var ctx = tile.getContext('2d');\n   *\n   *         // return the tile so it can be rendered on screen\n   *         return tile;\n   *     }\n   * });\n   * ```\n   *\n   * @section Asynchronous usage\n   * @example\n   *\n   * Tile creation can also be asynchronous, this is useful when using a third-party drawing library. Once the tile is finished drawing it can be passed to the `done()` callback.\n   *\n   * ```js\n   * var CanvasLayer = L.GridLayer.extend({\n   *     createTile: function(coords, done){\n   *         var error;\n   *\n   *         // create a <canvas> element for drawing\n   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');\n   *\n   *         // setup tile width and height according to the options\n   *         var size = this.getTileSize();\n   *         tile.width = size.x;\n   *         tile.height = size.y;\n   *\n   *         // draw something asynchronously and pass the tile to the done() callback\n   *         setTimeout(function() {\n   *             done(error, tile);\n   *         }, 1000);\n   *\n   *         return tile;\n   *     }\n   * });\n   * ```\n   *\n   * @section\n   */\n\n\n  var GridLayer = Layer.extend({\n\n  \t// @section\n  \t// @aka GridLayer options\n  \toptions: {\n  \t\t// @option tileSize: Number|Point = 256\n  \t\t// Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.\n  \t\ttileSize: 256,\n\n  \t\t// @option opacity: Number = 1.0\n  \t\t// Opacity of the tiles. Can be used in the `createTile()` function.\n  \t\topacity: 1,\n\n  \t\t// @option updateWhenIdle: Boolean = (depends)\n  \t\t// Load new tiles only when panning ends.\n  \t\t// `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.\n  \t\t// `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the\n  \t\t// [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.\n  \t\tupdateWhenIdle: Browser.mobile,\n\n  \t\t// @option updateWhenZooming: Boolean = true\n  \t\t// By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.\n  \t\tupdateWhenZooming: true,\n\n  \t\t// @option updateInterval: Number = 200\n  \t\t// Tiles will not update more than once every `updateInterval` milliseconds when panning.\n  \t\tupdateInterval: 200,\n\n  \t\t// @option zIndex: Number = 1\n  \t\t// The explicit zIndex of the tile layer.\n  \t\tzIndex: 1,\n\n  \t\t// @option bounds: LatLngBounds = undefined\n  \t\t// If set, tiles will only be loaded inside the set `LatLngBounds`.\n  \t\tbounds: null,\n\n  \t\t// @option minZoom: Number = 0\n  \t\t// The minimum zoom level down to which this layer will be displayed (inclusive).\n  \t\tminZoom: 0,\n\n  \t\t// @option maxZoom: Number = undefined\n  \t\t// The maximum zoom level up to which this layer will be displayed (inclusive).\n  \t\tmaxZoom: undefined,\n\n  \t\t// @option maxNativeZoom: Number = undefined\n  \t\t// Maximum zoom number the tile source has available. If it is specified,\n  \t\t// the tiles on all zoom levels higher than `maxNativeZoom` will be loaded\n  \t\t// from `maxNativeZoom` level and auto-scaled.\n  \t\tmaxNativeZoom: undefined,\n\n  \t\t// @option minNativeZoom: Number = undefined\n  \t\t// Minimum zoom number the tile source has available. If it is specified,\n  \t\t// the tiles on all zoom levels lower than `minNativeZoom` will be loaded\n  \t\t// from `minNativeZoom` level and auto-scaled.\n  \t\tminNativeZoom: undefined,\n\n  \t\t// @option noWrap: Boolean = false\n  \t\t// Whether the layer is wrapped around the antimeridian. If `true`, the\n  \t\t// GridLayer will only be displayed once at low zoom levels. Has no\n  \t\t// effect when the [map CRS](#map-crs) doesn't wrap around. Can be used\n  \t\t// in combination with [`bounds`](#gridlayer-bounds) to prevent requesting\n  \t\t// tiles outside the CRS limits.\n  \t\tnoWrap: false,\n\n  \t\t// @option pane: String = 'tilePane'\n  \t\t// `Map pane` where the grid layer will be added.\n  \t\tpane: 'tilePane',\n\n  \t\t// @option className: String = ''\n  \t\t// A custom class name to assign to the tile layer. Empty by default.\n  \t\tclassName: '',\n\n  \t\t// @option keepBuffer: Number = 2\n  \t\t// When panning the map, keep this many rows and columns of tiles before unloading them.\n  \t\tkeepBuffer: 2\n  \t},\n\n  \tinitialize: function (options) {\n  \t\tsetOptions(this, options);\n  \t},\n\n  \tonAdd: function () {\n  \t\tthis._initContainer();\n\n  \t\tthis._levels = {};\n  \t\tthis._tiles = {};\n\n  \t\tthis._resetView(); // implicit _update() call\n  \t},\n\n  \tbeforeAdd: function (map) {\n  \t\tmap._addZoomLimit(this);\n  \t},\n\n  \tonRemove: function (map) {\n  \t\tthis._removeAllTiles();\n  \t\tremove(this._container);\n  \t\tmap._removeZoomLimit(this);\n  \t\tthis._container = null;\n  \t\tthis._tileZoom = undefined;\n  \t},\n\n  \t// @method bringToFront: this\n  \t// Brings the tile layer to the top of all tile layers.\n  \tbringToFront: function () {\n  \t\tif (this._map) {\n  \t\t\ttoFront(this._container);\n  \t\t\tthis._setAutoZIndex(Math.max);\n  \t\t}\n  \t\treturn this;\n  \t},\n\n  \t// @method bringToBack: this\n  \t// Brings the tile layer to the bottom of all tile layers.\n  \tbringToBack: function () {\n  \t\tif (this._map) {\n  \t\t\ttoBack(this._container);\n  \t\t\tthis._setAutoZIndex(Math.min);\n  \t\t}\n  \t\treturn this;\n  \t},\n\n  \t// @method getContainer: HTMLElement\n  \t// Returns the HTML element that contains the tiles for this layer.\n  \tgetContainer: function () {\n  \t\treturn this._container;\n  \t},\n\n  \t// @method setOpacity(opacity: Number): this\n  \t// Changes the [opacity](#gridlayer-opacity) of the grid layer.\n  \tsetOpacity: function (opacity) {\n  \t\tthis.options.opacity = opacity;\n  \t\tthis._updateOpacity();\n  \t\treturn this;\n  \t},\n\n  \t// @method setZIndex(zIndex: Number): this\n  \t// Changes the [zIndex](#gridlayer-zindex) of the grid layer.\n  \tsetZIndex: function (zIndex) {\n  \t\tthis.options.zIndex = zIndex;\n  \t\tthis._updateZIndex();\n\n  \t\treturn this;\n  \t},\n\n  \t// @method isLoading: Boolean\n  \t// Returns `true` if any tile in the grid layer has not finished loading.\n  \tisLoading: function () {\n  \t\treturn this._loading;\n  \t},\n\n  \t// @method redraw: this\n  \t// Causes the layer to clear all the tiles and request them again.\n  \tredraw: function () {\n  \t\tif (this._map) {\n  \t\t\tthis._removeAllTiles();\n  \t\t\tvar tileZoom = this._clampZoom(this._map.getZoom());\n  \t\t\tif (tileZoom !== this._tileZoom) {\n  \t\t\t\tthis._tileZoom = tileZoom;\n  \t\t\t\tthis._updateLevels();\n  \t\t\t}\n  \t\t\tthis._update();\n  \t\t}\n  \t\treturn this;\n  \t},\n\n  \tgetEvents: function () {\n  \t\tvar events = {\n  \t\t\tviewprereset: this._invalidateAll,\n  \t\t\tviewreset: this._resetView,\n  \t\t\tzoom: this._resetView,\n  \t\t\tmoveend: this._onMoveEnd\n  \t\t};\n\n  \t\tif (!this.options.updateWhenIdle) {\n  \t\t\t// update tiles on move, but not more often than once per given interval\n  \t\t\tif (!this._onMove) {\n  \t\t\t\tthis._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);\n  \t\t\t}\n\n  \t\t\tevents.move = this._onMove;\n  \t\t}\n\n  \t\tif (this._zoomAnimated) {\n  \t\t\tevents.zoomanim = this._animateZoom;\n  \t\t}\n\n  \t\treturn events;\n  \t},\n\n  \t// @section Extension methods\n  \t// Layers extending `GridLayer` shall reimplement the following method.\n  \t// @method createTile(coords: Object, done?: Function): HTMLElement\n  \t// Called only internally, must be overridden by classes extending `GridLayer`.\n  \t// Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback\n  \t// is specified, it must be called when the tile has finished loading and drawing.\n  \tcreateTile: function () {\n  \t\treturn document.createElement('div');\n  \t},\n\n  \t// @section\n  \t// @method getTileSize: Point\n  \t// Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.\n  \tgetTileSize: function () {\n  \t\tvar s = this.options.tileSize;\n  \t\treturn s instanceof Point ? s : new Point(s, s);\n  \t},\n\n  \t_updateZIndex: function () {\n  \t\tif (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {\n  \t\t\tthis._container.style.zIndex = this.options.zIndex;\n  \t\t}\n  \t},\n\n  \t_setAutoZIndex: function (compare) {\n  \t\t// go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)\n\n  \t\tvar layers = this.getPane().children,\n  \t\t    edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min\n\n  \t\tfor (var i = 0, len = layers.length, zIndex; i < len; i++) {\n\n  \t\t\tzIndex = layers[i].style.zIndex;\n\n  \t\t\tif (layers[i] !== this._container && zIndex) {\n  \t\t\t\tedgeZIndex = compare(edgeZIndex, +zIndex);\n  \t\t\t}\n  \t\t}\n\n  \t\tif (isFinite(edgeZIndex)) {\n  \t\t\tthis.options.zIndex = edgeZIndex + compare(-1, 1);\n  \t\t\tthis._updateZIndex();\n  \t\t}\n  \t},\n\n  \t_updateOpacity: function () {\n  \t\tif (!this._map) { return; }\n\n  \t\t// IE doesn't inherit filter opacity properly, so we're forced to set it on tiles\n  \t\tif (Browser.ielt9) { return; }\n\n  \t\tsetOpacity(this._container, this.options.opacity);\n\n  \t\tvar now = +new Date(),\n  \t\t    nextFrame = false,\n  \t\t    willPrune = false;\n\n  \t\tfor (var key in this._tiles) {\n  \t\t\tvar tile = this._tiles[key];\n  \t\t\tif (!tile.current || !tile.loaded) { continue; }\n\n  \t\t\tvar fade = Math.min(1, (now - tile.loaded) / 200);\n\n  \t\t\tsetOpacity(tile.el, fade);\n  \t\t\tif (fade < 1) {\n  \t\t\t\tnextFrame = true;\n  \t\t\t} else {\n  \t\t\t\tif (tile.active) {\n  \t\t\t\t\twillPrune = true;\n  \t\t\t\t} else {\n  \t\t\t\t\tthis._onOpaqueTile(tile);\n  \t\t\t\t}\n  \t\t\t\ttile.active = true;\n  \t\t\t}\n  \t\t}\n\n  \t\tif (willPrune && !this._noPrune) { this._pruneTiles(); }\n\n  \t\tif (nextFrame) {\n  \t\t\tcancelAnimFrame(this._fadeFrame);\n  \t\t\tthis._fadeFrame = requestAnimFrame(this._updateOpacity, this);\n  \t\t}\n  \t},\n\n  \t_onOpaqueTile: falseFn,\n\n  \t_initContainer: function () {\n  \t\tif (this._container) { return; }\n\n  \t\tthis._container = create$1('div', 'leaflet-layer ' + (this.options.className || ''));\n  \t\tthis._updateZIndex();\n\n  \t\tif (this.options.opacity < 1) {\n  \t\t\tthis._updateOpacity();\n  \t\t}\n\n  \t\tthis.getPane().appendChild(this._container);\n  \t},\n\n  \t_updateLevels: function () {\n\n  \t\tvar zoom = this._tileZoom,\n  \t\t    maxZoom = this.options.maxZoom;\n\n  \t\tif (zoom === undefined) { return undefined; }\n\n  \t\tfor (var z in this._levels) {\n  \t\t\tz = Number(z);\n  \t\t\tif (this._levels[z].el.children.length || z === zoom) {\n  \t\t\t\tthis._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);\n  \t\t\t\tthis._onUpdateLevel(z);\n  \t\t\t} else {\n  \t\t\t\tremove(this._levels[z].el);\n  \t\t\t\tthis._removeTilesAtZoom(z);\n  \t\t\t\tthis._onRemoveLevel(z);\n  \t\t\t\tdelete this._levels[z];\n  \t\t\t}\n  \t\t}\n\n  \t\tvar level = this._levels[zoom],\n  \t\t    map = this._map;\n\n  \t\tif (!level) {\n  \t\t\tlevel = this._levels[zoom] = {};\n\n  \t\t\tlevel.el = create$1('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);\n  \t\t\tlevel.el.style.zIndex = maxZoom;\n\n  \t\t\tlevel.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();\n  \t\t\tlevel.zoom = zoom;\n\n  \t\t\tthis._setZoomTransform(level, map.getCenter(), map.getZoom());\n\n  \t\t\t// force the browser to consider the newly added element for transition\n  \t\t\tfalseFn(level.el.offsetWidth);\n\n  \t\t\tthis._onCreateLevel(level);\n  \t\t}\n\n  \t\tthis._level = level;\n\n  \t\treturn level;\n  \t},\n\n  \t_onUpdateLevel: falseFn,\n\n  \t_onRemoveLevel: falseFn,\n\n  \t_onCreateLevel: falseFn,\n\n  \t_pruneTiles: function () {\n  \t\tif (!this._map) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tvar key, tile;\n\n  \t\tvar zoom = this._map.getZoom();\n  \t\tif (zoom > this.options.maxZoom ||\n  \t\t\tzoom < this.options.minZoom) {\n  \t\t\tthis._removeAllTiles();\n  \t\t\treturn;\n  \t\t}\n\n  \t\tfor (key in this._tiles) {\n  \t\t\ttile = this._tiles[key];\n  \t\t\ttile.retain = tile.current;\n  \t\t}\n\n  \t\tfor (key in this._tiles) {\n  \t\t\ttile = this._tiles[key];\n  \t\t\tif (tile.current && !tile.active) {\n  \t\t\t\tvar coords = tile.coords;\n  \t\t\t\tif (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {\n  \t\t\t\t\tthis._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\tfor (key in this._tiles) {\n  \t\t\tif (!this._tiles[key].retain) {\n  \t\t\t\tthis._removeTile(key);\n  \t\t\t}\n  \t\t}\n  \t},\n\n  \t_removeTilesAtZoom: function (zoom) {\n  \t\tfor (var key in this._tiles) {\n  \t\t\tif (this._tiles[key].coords.z !== zoom) {\n  \t\t\t\tcontinue;\n  \t\t\t}\n  \t\t\tthis._removeTile(key);\n  \t\t}\n  \t},\n\n  \t_removeAllTiles: function () {\n  \t\tfor (var key in this._tiles) {\n  \t\t\tthis._removeTile(key);\n  \t\t}\n  \t},\n\n  \t_invalidateAll: function () {\n  \t\tfor (var z in this._levels) {\n  \t\t\tremove(this._levels[z].el);\n  \t\t\tthis._onRemoveLevel(Number(z));\n  \t\t\tdelete this._levels[z];\n  \t\t}\n  \t\tthis._removeAllTiles();\n\n  \t\tthis._tileZoom = undefined;\n  \t},\n\n  \t_retainParent: function (x, y, z, minZoom) {\n  \t\tvar x2 = Math.floor(x / 2),\n  \t\t    y2 = Math.floor(y / 2),\n  \t\t    z2 = z - 1,\n  \t\t    coords2 = new Point(+x2, +y2);\n  \t\tcoords2.z = +z2;\n\n  \t\tvar key = this._tileCoordsToKey(coords2),\n  \t\t    tile = this._tiles[key];\n\n  \t\tif (tile && tile.active) {\n  \t\t\ttile.retain = true;\n  \t\t\treturn true;\n\n  \t\t} else if (tile && tile.loaded) {\n  \t\t\ttile.retain = true;\n  \t\t}\n\n  \t\tif (z2 > minZoom) {\n  \t\t\treturn this._retainParent(x2, y2, z2, minZoom);\n  \t\t}\n\n  \t\treturn false;\n  \t},\n\n  \t_retainChildren: function (x, y, z, maxZoom) {\n\n  \t\tfor (var i = 2 * x; i < 2 * x + 2; i++) {\n  \t\t\tfor (var j = 2 * y; j < 2 * y + 2; j++) {\n\n  \t\t\t\tvar coords = new Point(i, j);\n  \t\t\t\tcoords.z = z + 1;\n\n  \t\t\t\tvar key = this._tileCoordsToKey(coords),\n  \t\t\t\t    tile = this._tiles[key];\n\n  \t\t\t\tif (tile && tile.active) {\n  \t\t\t\t\ttile.retain = true;\n  \t\t\t\t\tcontinue;\n\n  \t\t\t\t} else if (tile && tile.loaded) {\n  \t\t\t\t\ttile.retain = true;\n  \t\t\t\t}\n\n  \t\t\t\tif (z + 1 < maxZoom) {\n  \t\t\t\t\tthis._retainChildren(i, j, z + 1, maxZoom);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n\n  \t_resetView: function (e) {\n  \t\tvar animating = e && (e.pinch || e.flyTo);\n  \t\tthis._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);\n  \t},\n\n  \t_animateZoom: function (e) {\n  \t\tthis._setView(e.center, e.zoom, true, e.noUpdate);\n  \t},\n\n  \t_clampZoom: function (zoom) {\n  \t\tvar options = this.options;\n\n  \t\tif (undefined !== options.minNativeZoom && zoom < options.minNativeZoom) {\n  \t\t\treturn options.minNativeZoom;\n  \t\t}\n\n  \t\tif (undefined !== options.maxNativeZoom && options.maxNativeZoom < zoom) {\n  \t\t\treturn options.maxNativeZoom;\n  \t\t}\n\n  \t\treturn zoom;\n  \t},\n\n  \t_setView: function (center, zoom, noPrune, noUpdate) {\n  \t\tvar tileZoom = Math.round(zoom);\n  \t\tif ((this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom) ||\n  \t\t    (this.options.minZoom !== undefined && tileZoom < this.options.minZoom)) {\n  \t\t\ttileZoom = undefined;\n  \t\t} else {\n  \t\t\ttileZoom = this._clampZoom(tileZoom);\n  \t\t}\n\n  \t\tvar tileZoomChanged = this.options.updateWhenZooming && (tileZoom !== this._tileZoom);\n\n  \t\tif (!noUpdate || tileZoomChanged) {\n\n  \t\t\tthis._tileZoom = tileZoom;\n\n  \t\t\tif (this._abortLoading) {\n  \t\t\t\tthis._abortLoading();\n  \t\t\t}\n\n  \t\t\tthis._updateLevels();\n  \t\t\tthis._resetGrid();\n\n  \t\t\tif (tileZoom !== undefined) {\n  \t\t\t\tthis._update(center);\n  \t\t\t}\n\n  \t\t\tif (!noPrune) {\n  \t\t\t\tthis._pruneTiles();\n  \t\t\t}\n\n  \t\t\t// Flag to prevent _updateOpacity from pruning tiles during\n  \t\t\t// a zoom anim or a pinch gesture\n  \t\t\tthis._noPrune = !!noPrune;\n  \t\t}\n\n  \t\tthis._setZoomTransforms(center, zoom);\n  \t},\n\n  \t_setZoomTransforms: function (center, zoom) {\n  \t\tfor (var i in this._levels) {\n  \t\t\tthis._setZoomTransform(this._levels[i], center, zoom);\n  \t\t}\n  \t},\n\n  \t_setZoomTransform: function (level, center, zoom) {\n  \t\tvar scale = this._map.getZoomScale(zoom, level.zoom),\n  \t\t    translate = level.origin.multiplyBy(scale)\n  \t\t        .subtract(this._map._getNewPixelOrigin(center, zoom)).round();\n\n  \t\tif (Browser.any3d) {\n  \t\t\tsetTransform(level.el, translate, scale);\n  \t\t} else {\n  \t\t\tsetPosition(level.el, translate);\n  \t\t}\n  \t},\n\n  \t_resetGrid: function () {\n  \t\tvar map = this._map,\n  \t\t    crs = map.options.crs,\n  \t\t    tileSize = this._tileSize = this.getTileSize(),\n  \t\t    tileZoom = this._tileZoom;\n\n  \t\tvar bounds = this._map.getPixelWorldBounds(this._tileZoom);\n  \t\tif (bounds) {\n  \t\t\tthis._globalTileRange = this._pxBoundsToTileRange(bounds);\n  \t\t}\n\n  \t\tthis._wrapX = crs.wrapLng && !this.options.noWrap && [\n  \t\t\tMath.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x),\n  \t\t\tMath.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)\n  \t\t];\n  \t\tthis._wrapY = crs.wrapLat && !this.options.noWrap && [\n  \t\t\tMath.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x),\n  \t\t\tMath.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)\n  \t\t];\n  \t},\n\n  \t_onMoveEnd: function () {\n  \t\tif (!this._map || this._map._animatingZoom) { return; }\n\n  \t\tthis._update();\n  \t},\n\n  \t_getTiledPixelBounds: function (center) {\n  \t\tvar map = this._map,\n  \t\t    mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(),\n  \t\t    scale = map.getZoomScale(mapZoom, this._tileZoom),\n  \t\t    pixelCenter = map.project(center, this._tileZoom).floor(),\n  \t\t    halfSize = map.getSize().divideBy(scale * 2);\n\n  \t\treturn new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));\n  \t},\n\n  \t// Private method to load tiles in the grid's active zoom level according to map bounds\n  \t_update: function (center) {\n  \t\tvar map = this._map;\n  \t\tif (!map) { return; }\n  \t\tvar zoom = this._clampZoom(map.getZoom());\n\n  \t\tif (center === undefined) { center = map.getCenter(); }\n  \t\tif (this._tileZoom === undefined) { return; }\t// if out of minzoom/maxzoom\n\n  \t\tvar pixelBounds = this._getTiledPixelBounds(center),\n  \t\t    tileRange = this._pxBoundsToTileRange(pixelBounds),\n  \t\t    tileCenter = tileRange.getCenter(),\n  \t\t    queue = [],\n  \t\t    margin = this.options.keepBuffer,\n  \t\t    noPruneRange = new Bounds(tileRange.getBottomLeft().subtract([margin, -margin]),\n  \t\t                              tileRange.getTopRight().add([margin, -margin]));\n\n  \t\t// Sanity check: panic if the tile range contains Infinity somewhere.\n  \t\tif (!(isFinite(tileRange.min.x) &&\n  \t\t      isFinite(tileRange.min.y) &&\n  \t\t      isFinite(tileRange.max.x) &&\n  \t\t      isFinite(tileRange.max.y))) { throw new Error('Attempted to load an infinite number of tiles'); }\n\n  \t\tfor (var key in this._tiles) {\n  \t\t\tvar c = this._tiles[key].coords;\n  \t\t\tif (c.z !== this._tileZoom || !noPruneRange.contains(new Point(c.x, c.y))) {\n  \t\t\t\tthis._tiles[key].current = false;\n  \t\t\t}\n  \t\t}\n\n  \t\t// _update just loads more tiles. If the tile zoom level differs too much\n  \t\t// from the map's, let _setView reset levels and prune old tiles.\n  \t\tif (Math.abs(zoom - this._tileZoom) > 1) { this._setView(center, zoom); return; }\n\n  \t\t// create a queue of coordinates to load tiles from\n  \t\tfor (var j = tileRange.min.y; j <= tileRange.max.y; j++) {\n  \t\t\tfor (var i = tileRange.min.x; i <= tileRange.max.x; i++) {\n  \t\t\t\tvar coords = new Point(i, j);\n  \t\t\t\tcoords.z = this._tileZoom;\n\n  \t\t\t\tif (!this._isValidTile(coords)) { continue; }\n\n  \t\t\t\tvar tile = this._tiles[this._tileCoordsToKey(coords)];\n  \t\t\t\tif (tile) {\n  \t\t\t\t\ttile.current = true;\n  \t\t\t\t} else {\n  \t\t\t\t\tqueue.push(coords);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\t// sort tile queue to load tiles in order of their distance to center\n  \t\tqueue.sort(function (a, b) {\n  \t\t\treturn a.distanceTo(tileCenter) - b.distanceTo(tileCenter);\n  \t\t});\n\n  \t\tif (queue.length !== 0) {\n  \t\t\t// if it's the first batch of tiles to load\n  \t\t\tif (!this._loading) {\n  \t\t\t\tthis._loading = true;\n  \t\t\t\t// @event loading: Event\n  \t\t\t\t// Fired when the grid layer starts loading tiles.\n  \t\t\t\tthis.fire('loading');\n  \t\t\t}\n\n  \t\t\t// create DOM fragment to append tiles in one batch\n  \t\t\tvar fragment = document.createDocumentFragment();\n\n  \t\t\tfor (i = 0; i < queue.length; i++) {\n  \t\t\t\tthis._addTile(queue[i], fragment);\n  \t\t\t}\n\n  \t\t\tthis._level.el.appendChild(fragment);\n  \t\t}\n  \t},\n\n  \t_isValidTile: function (coords) {\n  \t\tvar crs = this._map.options.crs;\n\n  \t\tif (!crs.infinite) {\n  \t\t\t// don't load tile if it's out of bounds and not wrapped\n  \t\t\tvar bounds = this._globalTileRange;\n  \t\t\tif ((!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x)) ||\n  \t\t\t    (!crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y))) { return false; }\n  \t\t}\n\n  \t\tif (!this.options.bounds) { return true; }\n\n  \t\t// don't load tile if it doesn't intersect the bounds in options\n  \t\tvar tileBounds = this._tileCoordsToBounds(coords);\n  \t\treturn toLatLngBounds(this.options.bounds).overlaps(tileBounds);\n  \t},\n\n  \t_keyToBounds: function (key) {\n  \t\treturn this._tileCoordsToBounds(this._keyToTileCoords(key));\n  \t},\n\n  \t_tileCoordsToNwSe: function (coords) {\n  \t\tvar map = this._map,\n  \t\t    tileSize = this.getTileSize(),\n  \t\t    nwPoint = coords.scaleBy(tileSize),\n  \t\t    sePoint = nwPoint.add(tileSize),\n  \t\t    nw = map.unproject(nwPoint, coords.z),\n  \t\t    se = map.unproject(sePoint, coords.z);\n  \t\treturn [nw, se];\n  \t},\n\n  \t// converts tile coordinates to its geographical bounds\n  \t_tileCoordsToBounds: function (coords) {\n  \t\tvar bp = this._tileCoordsToNwSe(coords),\n  \t\t    bounds = new LatLngBounds(bp[0], bp[1]);\n\n  \t\tif (!this.options.noWrap) {\n  \t\t\tbounds = this._map.wrapLatLngBounds(bounds);\n  \t\t}\n  \t\treturn bounds;\n  \t},\n  \t// converts tile coordinates to key for the tile cache\n  \t_tileCoordsToKey: function (coords) {\n  \t\treturn coords.x + ':' + coords.y + ':' + coords.z;\n  \t},\n\n  \t// converts tile cache key to coordinates\n  \t_keyToTileCoords: function (key) {\n  \t\tvar k = key.split(':'),\n  \t\t    coords = new Point(+k[0], +k[1]);\n  \t\tcoords.z = +k[2];\n  \t\treturn coords;\n  \t},\n\n  \t_removeTile: function (key) {\n  \t\tvar tile = this._tiles[key];\n  \t\tif (!tile) { return; }\n\n  \t\tremove(tile.el);\n\n  \t\tdelete this._tiles[key];\n\n  \t\t// @event tileunload: TileEvent\n  \t\t// Fired when a tile is removed (e.g. when a tile goes off the screen).\n  \t\tthis.fire('tileunload', {\n  \t\t\ttile: tile.el,\n  \t\t\tcoords: this._keyToTileCoords(key)\n  \t\t});\n  \t},\n\n  \t_initTile: function (tile) {\n  \t\taddClass(tile, 'leaflet-tile');\n\n  \t\tvar tileSize = this.getTileSize();\n  \t\ttile.style.width = tileSize.x + 'px';\n  \t\ttile.style.height = tileSize.y + 'px';\n\n  \t\ttile.onselectstart = falseFn;\n  \t\ttile.onmousemove = falseFn;\n\n  \t\t// update opacity on tiles in IE7-8 because of filter inheritance problems\n  \t\tif (Browser.ielt9 && this.options.opacity < 1) {\n  \t\t\tsetOpacity(tile, this.options.opacity);\n  \t\t}\n  \t},\n\n  \t_addTile: function (coords, container) {\n  \t\tvar tilePos = this._getTilePos(coords),\n  \t\t    key = this._tileCoordsToKey(coords);\n\n  \t\tvar tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));\n\n  \t\tthis._initTile(tile);\n\n  \t\t// if createTile is defined with a second argument (\"done\" callback),\n  \t\t// we know that tile is async and will be ready later; otherwise\n  \t\tif (this.createTile.length < 2) {\n  \t\t\t// mark tile as ready, but delay one frame for opacity animation to happen\n  \t\t\trequestAnimFrame(bind(this._tileReady, this, coords, null, tile));\n  \t\t}\n\n  \t\tsetPosition(tile, tilePos);\n\n  \t\t// save tile in cache\n  \t\tthis._tiles[key] = {\n  \t\t\tel: tile,\n  \t\t\tcoords: coords,\n  \t\t\tcurrent: true\n  \t\t};\n\n  \t\tcontainer.appendChild(tile);\n  \t\t// @event tileloadstart: TileEvent\n  \t\t// Fired when a tile is requested and starts loading.\n  \t\tthis.fire('tileloadstart', {\n  \t\t\ttile: tile,\n  \t\t\tcoords: coords\n  \t\t});\n  \t},\n\n  \t_tileReady: function (coords, err, tile) {\n  \t\tif (err) {\n  \t\t\t// @event tileerror: TileErrorEvent\n  \t\t\t// Fired when there is an error loading a tile.\n  \t\t\tthis.fire('tileerror', {\n  \t\t\t\terror: err,\n  \t\t\t\ttile: tile,\n  \t\t\t\tcoords: coords\n  \t\t\t});\n  \t\t}\n\n  \t\tvar key = this._tileCoordsToKey(coords);\n\n  \t\ttile = this._tiles[key];\n  \t\tif (!tile) { return; }\n\n  \t\ttile.loaded = +new Date();\n  \t\tif (this._map._fadeAnimated) {\n  \t\t\tsetOpacity(tile.el, 0);\n  \t\t\tcancelAnimFrame(this._fadeFrame);\n  \t\t\tthis._fadeFrame = requestAnimFrame(this._updateOpacity, this);\n  \t\t} else {\n  \t\t\ttile.active = true;\n  \t\t\tthis._pruneTiles();\n  \t\t}\n\n  \t\tif (!err) {\n  \t\t\taddClass(tile.el, 'leaflet-tile-loaded');\n\n  \t\t\t// @event tileload: TileEvent\n  \t\t\t// Fired when a tile loads.\n  \t\t\tthis.fire('tileload', {\n  \t\t\t\ttile: tile.el,\n  \t\t\t\tcoords: coords\n  \t\t\t});\n  \t\t}\n\n  \t\tif (this._noTilesToLoad()) {\n  \t\t\tthis._loading = false;\n  \t\t\t// @event load: Event\n  \t\t\t// Fired when the grid layer loaded all visible tiles.\n  \t\t\tthis.fire('load');\n\n  \t\t\tif (Browser.ielt9 || !this._map._fadeAnimated) {\n  \t\t\t\trequestAnimFrame(this._pruneTiles, this);\n  \t\t\t} else {\n  \t\t\t\t// Wait a bit more than 0.2 secs (the duration of the tile fade-in)\n  \t\t\t\t// to trigger a pruning.\n  \t\t\t\tsetTimeout(bind(this._pruneTiles, this), 250);\n  \t\t\t}\n  \t\t}\n  \t},\n\n  \t_getTilePos: function (coords) {\n  \t\treturn coords.scaleBy(this.getTileSize()).subtract(this._level.origin);\n  \t},\n\n  \t_wrapCoords: function (coords) {\n  \t\tvar newCoords = new Point(\n  \t\t\tthis._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x,\n  \t\t\tthis._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y);\n  \t\tnewCoords.z = coords.z;\n  \t\treturn newCoords;\n  \t},\n\n  \t_pxBoundsToTileRange: function (bounds) {\n  \t\tvar tileSize = this.getTileSize();\n  \t\treturn new Bounds(\n  \t\t\tbounds.min.unscaleBy(tileSize).floor(),\n  \t\t\tbounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));\n  \t},\n\n  \t_noTilesToLoad: function () {\n  \t\tfor (var key in this._tiles) {\n  \t\t\tif (!this._tiles[key].loaded) { return false; }\n  \t\t}\n  \t\treturn true;\n  \t}\n  });\n\n  // @factory L.gridLayer(options?: GridLayer options)\n  // Creates a new instance of GridLayer with the supplied options.\n  function gridLayer(options) {\n  \treturn new GridLayer(options);\n  }\n\n  /*\r\n   * @class TileLayer\r\n   * @inherits GridLayer\r\n   * @aka L.TileLayer\r\n   * Used to load and display tile layers on the map. Note that most tile servers require attribution, which you can set under `Layer`. Extends `GridLayer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar', attribution: '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors'}).addTo(map);\n   * ```\r\n   *\r\n   * @section URL template\r\n   * @example\r\n   *\r\n   * A string of the following form:\r\n   *\r\n   * ```\r\n   * 'https://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'\r\n   * ```\r\n   *\r\n   * `{s}` means one of the available subdomains (used sequentially to help with browser parallel requests per domain limitation; subdomain values are specified in options; `a`, `b` or `c` by default, can be omitted), `{z}`  zoom level, `{x}` and `{y}`  tile coordinates. `{r}` can be used to add \"&commat;2x\" to the URL to load retina tiles.\r\n   *\r\n   * You can use custom keys in the template, which will be [evaluated](#util-template) from TileLayer options, like this:\r\n   *\r\n   * ```\r\n   * L.tileLayer('https://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});\r\n   * ```\r\n   */\r\n\r\n\r\n  var TileLayer = GridLayer.extend({\r\n\r\n  \t// @section\r\n  \t// @aka TileLayer options\r\n  \toptions: {\r\n  \t\t// @option minZoom: Number = 0\r\n  \t\t// The minimum zoom level down to which this layer will be displayed (inclusive).\r\n  \t\tminZoom: 0,\r\n\r\n  \t\t// @option maxZoom: Number = 18\r\n  \t\t// The maximum zoom level up to which this layer will be displayed (inclusive).\r\n  \t\tmaxZoom: 18,\r\n\r\n  \t\t// @option subdomains: String|String[] = 'abc'\r\n  \t\t// Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.\r\n  \t\tsubdomains: 'abc',\r\n\r\n  \t\t// @option errorTileUrl: String = ''\r\n  \t\t// URL to the tile image to show in place of the tile that failed to load.\r\n  \t\terrorTileUrl: '',\r\n\r\n  \t\t// @option zoomOffset: Number = 0\r\n  \t\t// The zoom number used in tile URLs will be offset with this value.\r\n  \t\tzoomOffset: 0,\r\n\r\n  \t\t// @option tms: Boolean = false\r\n  \t\t// If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).\r\n  \t\ttms: false,\r\n\r\n  \t\t// @option zoomReverse: Boolean = false\r\n  \t\t// If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)\r\n  \t\tzoomReverse: false,\r\n\r\n  \t\t// @option detectRetina: Boolean = false\r\n  \t\t// If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.\r\n  \t\tdetectRetina: false,\r\n\r\n  \t\t// @option crossOrigin: Boolean|String = false\r\n  \t\t// Whether the crossOrigin attribute will be added to the tiles.\r\n  \t\t// If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.\r\n  \t\t// Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.\r\n  \t\tcrossOrigin: false,\r\n\r\n  \t\t// @option referrerPolicy: Boolean|String = false\r\n  \t\t// Whether the referrerPolicy attribute will be added to the tiles.\r\n  \t\t// If a String is provided, all tiles will have their referrerPolicy attribute set to the String provided.\r\n  \t\t// This may be needed if your map's rendering context has a strict default but your tile provider expects a valid referrer\r\n  \t\t// (e.g. to validate an API token).\r\n  \t\t// Refer to [HTMLImageElement.referrerPolicy](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/referrerPolicy) for valid String values.\r\n  \t\treferrerPolicy: false\r\n  \t},\r\n\r\n  \tinitialize: function (url, options) {\r\n\r\n  \t\tthis._url = url;\r\n\r\n  \t\toptions = setOptions(this, options);\r\n\r\n  \t\t// detecting retina displays, adjusting tileSize and zoom levels\r\n  \t\tif (options.detectRetina && Browser.retina && options.maxZoom > 0) {\r\n\r\n  \t\t\toptions.tileSize = Math.floor(options.tileSize / 2);\r\n\r\n  \t\t\tif (!options.zoomReverse) {\r\n  \t\t\t\toptions.zoomOffset++;\r\n  \t\t\t\toptions.maxZoom = Math.max(options.minZoom, options.maxZoom - 1);\r\n  \t\t\t} else {\r\n  \t\t\t\toptions.zoomOffset--;\r\n  \t\t\t\toptions.minZoom = Math.min(options.maxZoom, options.minZoom + 1);\r\n  \t\t\t}\r\n\r\n  \t\t\toptions.minZoom = Math.max(0, options.minZoom);\r\n  \t\t} else if (!options.zoomReverse) {\r\n  \t\t\t// make sure maxZoom is gte minZoom\r\n  \t\t\toptions.maxZoom = Math.max(options.minZoom, options.maxZoom);\r\n  \t\t} else {\r\n  \t\t\t// make sure minZoom is lte maxZoom\r\n  \t\t\toptions.minZoom = Math.min(options.maxZoom, options.minZoom);\r\n  \t\t}\r\n\r\n  \t\tif (typeof options.subdomains === 'string') {\r\n  \t\t\toptions.subdomains = options.subdomains.split('');\r\n  \t\t}\r\n\r\n  \t\tthis.on('tileunload', this._onTileRemove);\r\n  \t},\r\n\r\n  \t// @method setUrl(url: String, noRedraw?: Boolean): this\r\n  \t// Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).\r\n  \t// If the URL does not change, the layer will not be redrawn unless\r\n  \t// the noRedraw parameter is set to false.\r\n  \tsetUrl: function (url, noRedraw) {\r\n  \t\tif (this._url === url && noRedraw === undefined) {\r\n  \t\t\tnoRedraw = true;\r\n  \t\t}\r\n\r\n  \t\tthis._url = url;\r\n\r\n  \t\tif (!noRedraw) {\r\n  \t\t\tthis.redraw();\r\n  \t\t}\r\n  \t\treturn this;\r\n  \t},\r\n\r\n  \t// @method createTile(coords: Object, done?: Function): HTMLElement\r\n  \t// Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)\r\n  \t// to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`\r\n  \t// callback is called when the tile has been loaded.\r\n  \tcreateTile: function (coords, done) {\r\n  \t\tvar tile = document.createElement('img');\r\n\r\n  \t\ton(tile, 'load', bind(this._tileOnLoad, this, done, tile));\r\n  \t\ton(tile, 'error', bind(this._tileOnError, this, done, tile));\r\n\r\n  \t\tif (this.options.crossOrigin || this.options.crossOrigin === '') {\r\n  \t\t\ttile.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;\r\n  \t\t}\r\n\r\n  \t\t// for this new option we follow the documented behavior\r\n  \t\t// more closely by only setting the property when string\r\n  \t\tif (typeof this.options.referrerPolicy === 'string') {\r\n  \t\t\ttile.referrerPolicy = this.options.referrerPolicy;\r\n  \t\t}\r\n\r\n  \t\t// The alt attribute is set to the empty string,\r\n  \t\t// allowing screen readers to ignore the decorative image tiles.\r\n  \t\t// https://www.w3.org/WAI/tutorials/images/decorative/\r\n  \t\t// https://www.w3.org/TR/html-aria/#el-img-empty-alt\r\n  \t\ttile.alt = '';\r\n\r\n  \t\ttile.src = this.getTileUrl(coords);\r\n\r\n  \t\treturn tile;\r\n  \t},\r\n\r\n  \t// @section Extension methods\r\n  \t// @uninheritable\r\n  \t// Layers extending `TileLayer` might reimplement the following method.\r\n  \t// @method getTileUrl(coords: Object): String\r\n  \t// Called only internally, returns the URL for a tile given its coordinates.\r\n  \t// Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.\r\n  \tgetTileUrl: function (coords) {\r\n  \t\tvar data = {\r\n  \t\t\tr: Browser.retina ? '@2x' : '',\r\n  \t\t\ts: this._getSubdomain(coords),\r\n  \t\t\tx: coords.x,\r\n  \t\t\ty: coords.y,\r\n  \t\t\tz: this._getZoomForUrl()\r\n  \t\t};\r\n  \t\tif (this._map && !this._map.options.crs.infinite) {\r\n  \t\t\tvar invertedY = this._globalTileRange.max.y - coords.y;\r\n  \t\t\tif (this.options.tms) {\r\n  \t\t\t\tdata['y'] = invertedY;\r\n  \t\t\t}\r\n  \t\t\tdata['-y'] = invertedY;\r\n  \t\t}\r\n\r\n  \t\treturn template(this._url, extend(data, this.options));\r\n  \t},\r\n\r\n  \t_tileOnLoad: function (done, tile) {\r\n  \t\t// For https://github.com/Leaflet/Leaflet/issues/3332\r\n  \t\tif (Browser.ielt9) {\r\n  \t\t\tsetTimeout(bind(done, this, null, tile), 0);\r\n  \t\t} else {\r\n  \t\t\tdone(null, tile);\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_tileOnError: function (done, tile, e) {\r\n  \t\tvar errorUrl = this.options.errorTileUrl;\r\n  \t\tif (errorUrl && tile.getAttribute('src') !== errorUrl) {\r\n  \t\t\ttile.src = errorUrl;\r\n  \t\t}\r\n  \t\tdone(e, tile);\r\n  \t},\r\n\r\n  \t_onTileRemove: function (e) {\r\n  \t\te.tile.onload = null;\r\n  \t},\r\n\r\n  \t_getZoomForUrl: function () {\r\n  \t\tvar zoom = this._tileZoom,\r\n  \t\tmaxZoom = this.options.maxZoom,\r\n  \t\tzoomReverse = this.options.zoomReverse,\r\n  \t\tzoomOffset = this.options.zoomOffset;\r\n\r\n  \t\tif (zoomReverse) {\r\n  \t\t\tzoom = maxZoom - zoom;\r\n  \t\t}\r\n\r\n  \t\treturn zoom + zoomOffset;\r\n  \t},\r\n\r\n  \t_getSubdomain: function (tilePoint) {\r\n  \t\tvar index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;\r\n  \t\treturn this.options.subdomains[index];\r\n  \t},\r\n\r\n  \t// stops loading all tiles in the background layer\r\n  \t_abortLoading: function () {\r\n  \t\tvar i, tile;\r\n  \t\tfor (i in this._tiles) {\r\n  \t\t\tif (this._tiles[i].coords.z !== this._tileZoom) {\r\n  \t\t\t\ttile = this._tiles[i].el;\r\n\r\n  \t\t\t\ttile.onload = falseFn;\r\n  \t\t\t\ttile.onerror = falseFn;\r\n\r\n  \t\t\t\tif (!tile.complete) {\r\n  \t\t\t\t\ttile.src = emptyImageUrl;\r\n  \t\t\t\t\tvar coords = this._tiles[i].coords;\r\n  \t\t\t\t\tremove(tile);\r\n  \t\t\t\t\tdelete this._tiles[i];\r\n  \t\t\t\t\t// @event tileabort: TileEvent\r\n  \t\t\t\t\t// Fired when a tile was loading but is now not wanted.\r\n  \t\t\t\t\tthis.fire('tileabort', {\r\n  \t\t\t\t\t\ttile: tile,\r\n  \t\t\t\t\t\tcoords: coords\r\n  \t\t\t\t\t});\r\n  \t\t\t\t}\r\n  \t\t\t}\r\n  \t\t}\r\n  \t},\r\n\r\n  \t_removeTile: function (key) {\r\n  \t\tvar tile = this._tiles[key];\r\n  \t\tif (!tile) { return; }\r\n\r\n  \t\t// Cancels any pending http requests associated with the tile\r\n  \t\ttile.el.setAttribute('src', emptyImageUrl);\r\n\r\n  \t\treturn GridLayer.prototype._removeTile.call(this, key);\r\n  \t},\r\n\r\n  \t_tileReady: function (coords, err, tile) {\r\n  \t\tif (!this._map || (tile && tile.getAttribute('src') === emptyImageUrl)) {\r\n  \t\t\treturn;\r\n  \t\t}\r\n\r\n  \t\treturn GridLayer.prototype._tileReady.call(this, coords, err, tile);\r\n  \t}\r\n  });\r\n\r\n\r\n  // @factory L.tilelayer(urlTemplate: String, options?: TileLayer options)\r\n  // Instantiates a tile layer object given a `URL template` and optionally an options object.\r\n\r\n  function tileLayer(url, options) {\r\n  \treturn new TileLayer(url, options);\r\n  }\n\n  /*\r\n   * @class TileLayer.WMS\r\n   * @inherits TileLayer\r\n   * @aka L.TileLayer.WMS\r\n   * Used to display [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services as tile layers on the map. Extends `TileLayer`.\r\n   *\r\n   * @example\r\n   *\r\n   * ```js\r\n   * var nexrad = L.tileLayer.wms(\"http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi\", {\r\n   * \tlayers: 'nexrad-n0r-900913',\r\n   * \tformat: 'image/png',\r\n   * \ttransparent: true,\r\n   * \tattribution: \"Weather data  2012 IEM Nexrad\"\r\n   * });\r\n   * ```\r\n   */\r\n\r\n  var TileLayerWMS = TileLayer.extend({\r\n\r\n  \t// @section\r\n  \t// @aka TileLayer.WMS options\r\n  \t// If any custom options not documented here are used, they will be sent to the\r\n  \t// WMS server as extra parameters in each request URL. This can be useful for\r\n  \t// [non-standard vendor WMS parameters](https://docs.geoserver.org/stable/en/user/services/wms/vendor.html).\r\n  \tdefaultWmsParams: {\r\n  \t\tservice: 'WMS',\r\n  \t\trequest: 'GetMap',\r\n\r\n  \t\t// @option layers: String = ''\r\n  \t\t// **(required)** Comma-separated list of WMS layers to show.\r\n  \t\tlayers: '',\r\n\r\n  \t\t// @option styles: String = ''\r\n  \t\t// Comma-separated list of WMS styles.\r\n  \t\tstyles: '',\r\n\r\n  \t\t// @option format: String = 'image/jpeg'\r\n  \t\t// WMS image format (use `'image/png'` for layers with transparency).\r\n  \t\tformat: 'image/jpeg',\r\n\r\n  \t\t// @option transparent: Boolean = false\r\n  \t\t// If `true`, the WMS service will return images with transparency.\r\n  \t\ttransparent: false,\r\n\r\n  \t\t// @option version: String = '1.1.1'\r\n  \t\t// Version of the WMS service to use\r\n  \t\tversion: '1.1.1'\r\n  \t},\r\n\r\n  \toptions: {\r\n  \t\t// @option crs: CRS = null\r\n  \t\t// Coordinate Reference System to use for the WMS requests, defaults to\r\n  \t\t// map CRS. Don't change this if you're not sure what it means.\r\n  \t\tcrs: null,\r\n\r\n  \t\t// @option uppercase: Boolean = false\r\n  \t\t// If `true`, WMS request parameter keys will be uppercase.\r\n  \t\tuppercase: false\r\n  \t},\r\n\r\n  \tinitialize: function (url, options) {\r\n\r\n  \t\tthis._url = url;\r\n\r\n  \t\tvar wmsParams = extend({}, this.defaultWmsParams);\r\n\r\n  \t\t// all keys that are not TileLayer options go to WMS params\r\n  \t\tfor (var i in options) {\r\n  \t\t\tif (!(i in this.options)) {\r\n  \t\t\t\twmsParams[i] = options[i];\r\n  \t\t\t}\r\n  \t\t}\r\n\r\n  \t\toptions = setOptions(this, options);\r\n\r\n  \t\tvar realRetina = options.detectRetina && Browser.retina ? 2 : 1;\r\n  \t\tvar tileSize = this.getTileSize();\r\n  \t\twmsParams.width = tileSize.x * realRetina;\r\n  \t\twmsParams.height = tileSize.y * realRetina;\r\n\r\n  \t\tthis.wmsParams = wmsParams;\r\n  \t},\r\n\r\n  \tonAdd: function (map) {\r\n\r\n  \t\tthis._crs = this.options.crs || map.options.crs;\r\n  \t\tthis._wmsVersion = parseFloat(this.wmsParams.version);\r\n\r\n  \t\tvar projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';\r\n  \t\tthis.wmsParams[projectionKey] = this._crs.code;\r\n\r\n  \t\tTileLayer.prototype.onAdd.call(this, map);\r\n  \t},\r\n\r\n  \tgetTileUrl: function (coords) {\r\n\r\n  \t\tvar tileBounds = this._tileCoordsToNwSe(coords),\r\n  \t\t    crs = this._crs,\r\n  \t\t    bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])),\r\n  \t\t    min = bounds.min,\r\n  \t\t    max = bounds.max,\r\n  \t\t    bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ?\r\n  \t\t    [min.y, min.x, max.y, max.x] :\r\n  \t\t    [min.x, min.y, max.x, max.y]).join(','),\r\n  \t\t    url = TileLayer.prototype.getTileUrl.call(this, coords);\r\n  \t\treturn url +\r\n  \t\t\tgetParamString(this.wmsParams, url, this.options.uppercase) +\r\n  \t\t\t(this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;\r\n  \t},\r\n\r\n  \t// @method setParams(params: Object, noRedraw?: Boolean): this\r\n  \t// Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).\r\n  \tsetParams: function (params, noRedraw) {\r\n\r\n  \t\textend(this.wmsParams, params);\r\n\r\n  \t\tif (!noRedraw) {\r\n  \t\t\tthis.redraw();\r\n  \t\t}\r\n\r\n  \t\treturn this;\r\n  \t}\r\n  });\r\n\r\n\r\n  // @factory L.tileLayer.wms(baseUrl: String, options: TileLayer.WMS options)\r\n  // Instantiates a WMS tile layer object given a base URL of the WMS service and a WMS parameters/options object.\r\n  function tileLayerWMS(url, options) {\r\n  \treturn new TileLayerWMS(url, options);\r\n  }\n\n  TileLayer.WMS = TileLayerWMS;\n  tileLayer.wms = tileLayerWMS;\n\n  /*\n   * @class Renderer\n   * @inherits Layer\n   * @aka L.Renderer\n   *\n   * Base class for vector renderer implementations (`SVG`, `Canvas`). Handles the\n   * DOM container of the renderer, its bounds, and its zoom animation.\n   *\n   * A `Renderer` works as an implicit layer group for all `Path`s - the renderer\n   * itself can be added or removed to the map. All paths use a renderer, which can\n   * be implicit (the map will decide the type of renderer and use it automatically)\n   * or explicit (using the [`renderer`](#path-renderer) option of the path).\n   *\n   * Do not use this class directly, use `SVG` and `Canvas` instead.\n   *\n   * @event update: Event\n   * Fired when the renderer updates its bounds, center and zoom, for example when\n   * its map has moved\n   */\n\n  var Renderer = Layer.extend({\n\n  \t// @section\n  \t// @aka Renderer options\n  \toptions: {\n  \t\t// @option padding: Number = 0.1\n  \t\t// How much to extend the clip area around the map view (relative to its size)\n  \t\t// e.g. 0.1 would be 10% of map view in each direction\n  \t\tpadding: 0.1\n  \t},\n\n  \tinitialize: function (options) {\n  \t\tsetOptions(this, options);\n  \t\tstamp(this);\n  \t\tthis._layers = this._layers || {};\n  \t},\n\n  \tonAdd: function () {\n  \t\tif (!this._container) {\n  \t\t\tthis._initContainer(); // defined by renderer implementations\n\n  \t\t\tif (this._zoomAnimated) {\n  \t\t\t\taddClass(this._container, 'leaflet-zoom-animated');\n  \t\t\t}\n  \t\t}\n\n  \t\tthis.getPane().appendChild(this._container);\n  \t\tthis._update();\n  \t\tthis.on('update', this._updatePaths, this);\n  \t},\n\n  \tonRemove: function () {\n  \t\tthis.off('update', this._updatePaths, this);\n  \t\tthis._destroyContainer();\n  \t},\n\n  \tgetEvents: function () {\n  \t\tvar events = {\n  \t\t\tviewreset: this._reset,\n  \t\t\tzoom: this._onZoom,\n  \t\t\tmoveend: this._update,\n  \t\t\tzoomend: this._onZoomEnd\n  \t\t};\n  \t\tif (this._zoomAnimated) {\n  \t\t\tevents.zoomanim = this._onAnimZoom;\n  \t\t}\n  \t\treturn events;\n  \t},\n\n  \t_onAnimZoom: function (ev) {\n  \t\tthis._updateTransform(ev.center, ev.zoom);\n  \t},\n\n  \t_onZoom: function () {\n  \t\tthis._updateTransform(this._map.getCenter(), this._map.getZoom());\n  \t},\n\n  \t_updateTransform: function (center, zoom) {\n  \t\tvar scale = this._map.getZoomScale(zoom, this._zoom),\n  \t\t    viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding),\n  \t\t    currentCenterPoint = this._map.project(this._center, zoom),\n\n  \t\t    topLeftOffset = viewHalf.multiplyBy(-scale).add(currentCenterPoint)\n  \t\t\t\t  .subtract(this._map._getNewPixelOrigin(center, zoom));\n\n  \t\tif (Browser.any3d) {\n  \t\t\tsetTransform(this._container, topLeftOffset, scale);\n  \t\t} else {\n  \t\t\tsetPosition(this._container, topLeftOffset);\n  \t\t}\n  \t},\n\n  \t_reset: function () {\n  \t\tthis._update();\n  \t\tthis._updateTransform(this._center, this._zoom);\n\n  \t\tfor (var id in this._layers) {\n  \t\t\tthis._layers[id]._reset();\n  \t\t}\n  \t},\n\n  \t_onZoomEnd: function () {\n  \t\tfor (var id in this._layers) {\n  \t\t\tthis._layers[id]._project();\n  \t\t}\n  \t},\n\n  \t_updatePaths: function () {\n  \t\tfor (var id in this._layers) {\n  \t\t\tthis._layers[id]._update();\n  \t\t}\n  \t},\n\n  \t_update: function () {\n  \t\t// Update pixel bounds of renderer container (for positioning/sizing/clipping later)\n  \t\t// Subclasses are responsible of firing the 'update' event.\n  \t\tvar p = this.options.padding,\n  \t\t    size = this._map.getSize(),\n  \t\t    min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();\n\n  \t\tthis._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());\n\n  \t\tthis._center = this._map.getCenter();\n  \t\tthis._zoom = this._map.getZoom();\n  \t}\n  });\n\n  /*\n   * @class Canvas\n   * @inherits Renderer\n   * @aka L.Canvas\n   *\n   * Allows vector layers to be displayed with [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).\n   * Inherits `Renderer`.\n   *\n   * Due to [technical limitations](https://caniuse.com/canvas), Canvas is not\n   * available in all web browsers, notably IE8, and overlapping geometries might\n   * not display properly in some edge cases.\n   *\n   * @example\n   *\n   * Use Canvas by default for all paths in the map:\n   *\n   * ```js\n   * var map = L.map('map', {\n   * \trenderer: L.canvas()\n   * });\n   * ```\n   *\n   * Use a Canvas renderer with extra padding for specific vector geometries:\n   *\n   * ```js\n   * var map = L.map('map');\n   * var myRenderer = L.canvas({ padding: 0.5 });\n   * var line = L.polyline( coordinates, { renderer: myRenderer } );\n   * var circle = L.circle( center, { renderer: myRenderer } );\n   * ```\n   */\n\n  var Canvas = Renderer.extend({\n\n  \t// @section\n  \t// @aka Canvas options\n  \toptions: {\n  \t\t// @option tolerance: Number = 0\n  \t\t// How much to extend the click tolerance around a path/object on the map.\n  \t\ttolerance: 0\n  \t},\n\n  \tgetEvents: function () {\n  \t\tvar events = Renderer.prototype.getEvents.call(this);\n  \t\tevents.viewprereset = this._onViewPreReset;\n  \t\treturn events;\n  \t},\n\n  \t_onViewPreReset: function () {\n  \t\t// Set a flag so that a viewprereset+moveend+viewreset only updates&redraws once\n  \t\tthis._postponeUpdatePaths = true;\n  \t},\n\n  \tonAdd: function () {\n  \t\tRenderer.prototype.onAdd.call(this);\n\n  \t\t// Redraw vectors since canvas is cleared upon removal,\n  \t\t// in case of removing the renderer itself from the map.\n  \t\tthis._draw();\n  \t},\n\n  \t_initContainer: function () {\n  \t\tvar container = this._container = document.createElement('canvas');\n\n  \t\ton(container, 'mousemove', this._onMouseMove, this);\n  \t\ton(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this);\n  \t\ton(container, 'mouseout', this._handleMouseOut, this);\n  \t\tcontainer['_leaflet_disable_events'] = true;\n\n  \t\tthis._ctx = container.getContext('2d');\n  \t},\n\n  \t_destroyContainer: function () {\n  \t\tcancelAnimFrame(this._redrawRequest);\n  \t\tdelete this._ctx;\n  \t\tremove(this._container);\n  \t\toff(this._container);\n  \t\tdelete this._container;\n  \t},\n\n  \t_updatePaths: function () {\n  \t\tif (this._postponeUpdatePaths) { return; }\n\n  \t\tvar layer;\n  \t\tthis._redrawBounds = null;\n  \t\tfor (var id in this._layers) {\n  \t\t\tlayer = this._layers[id];\n  \t\t\tlayer._update();\n  \t\t}\n  \t\tthis._redraw();\n  \t},\n\n  \t_update: function () {\n  \t\tif (this._map._animatingZoom && this._bounds) { return; }\n\n  \t\tRenderer.prototype._update.call(this);\n\n  \t\tvar b = this._bounds,\n  \t\t    container = this._container,\n  \t\t    size = b.getSize(),\n  \t\t    m = Browser.retina ? 2 : 1;\n\n  \t\tsetPosition(container, b.min);\n\n  \t\t// set canvas size (also clearing it); use double size on retina\n  \t\tcontainer.width = m * size.x;\n  \t\tcontainer.height = m * size.y;\n  \t\tcontainer.style.width = size.x + 'px';\n  \t\tcontainer.style.height = size.y + 'px';\n\n  \t\tif (Browser.retina) {\n  \t\t\tthis._ctx.scale(2, 2);\n  \t\t}\n\n  \t\t// translate so we use the same path coordinates after canvas element moves\n  \t\tthis._ctx.translate(-b.min.x, -b.min.y);\n\n  \t\t// Tell paths to redraw themselves\n  \t\tthis.fire('update');\n  \t},\n\n  \t_reset: function () {\n  \t\tRenderer.prototype._reset.call(this);\n\n  \t\tif (this._postponeUpdatePaths) {\n  \t\t\tthis._postponeUpdatePaths = false;\n  \t\t\tthis._updatePaths();\n  \t\t}\n  \t},\n\n  \t_initPath: function (layer) {\n  \t\tthis._updateDashArray(layer);\n  \t\tthis._layers[stamp(layer)] = layer;\n\n  \t\tvar order = layer._order = {\n  \t\t\tlayer: layer,\n  \t\t\tprev: this._drawLast,\n  \t\t\tnext: null\n  \t\t};\n  \t\tif (this._drawLast) { this._drawLast.next = order; }\n  \t\tthis._drawLast = order;\n  \t\tthis._drawFirst = this._drawFirst || this._drawLast;\n  \t},\n\n  \t_addPath: function (layer) {\n  \t\tthis._requestRedraw(layer);\n  \t},\n\n  \t_removePath: function (layer) {\n  \t\tvar order = layer._order;\n  \t\tvar next = order.next;\n  \t\tvar prev = order.prev;\n\n  \t\tif (next) {\n  \t\t\tnext.prev = prev;\n  \t\t} else {\n  \t\t\tthis._drawLast = prev;\n  \t\t}\n  \t\tif (prev) {\n  \t\t\tprev.next = next;\n  \t\t} else {\n  \t\t\tthis._drawFirst = next;\n  \t\t}\n\n  \t\tdelete layer._order;\n\n  \t\tdelete this._layers[stamp(layer)];\n\n  \t\tthis._requestRedraw(layer);\n  \t},\n\n  \t_updatePath: function (layer) {\n  \t\t// Redraw the union of the layer's old pixel\n  \t\t// bounds and the new pixel bounds.\n  \t\tthis._extendRedrawBounds(layer);\n  \t\tlayer._project();\n  \t\tlayer._update();\n  \t\t// The redraw will extend the redraw bounds\n  \t\t// with the new pixel bounds.\n  \t\tthis._requestRedraw(layer);\n  \t},\n\n  \t_updateStyle: function (layer) {\n  \t\tthis._updateDashArray(layer);\n  \t\tthis._requestRedraw(layer);\n  \t},\n\n  \t_updateDashArray: function (layer) {\n  \t\tif (typeof layer.options.dashArray === 'string') {\n  \t\t\tvar parts = layer.options.dashArray.split(/[, ]+/),\n  \t\t\t    dashArray = [],\n  \t\t\t    dashValue,\n  \t\t\t    i;\n  \t\t\tfor (i = 0; i < parts.length; i++) {\n  \t\t\t\tdashValue = Number(parts[i]);\n  \t\t\t\t// Ignore dash array containing invalid lengths\n  \t\t\t\tif (isNaN(dashValue)) { return; }\n  \t\t\t\tdashArray.push(dashValue);\n  \t\t\t}\n  \t\t\tlayer.options._dashArray = dashArray;\n  \t\t} else {\n  \t\t\tlayer.options._dashArray = layer.options.dashArray;\n  \t\t}\n  \t},\n\n  \t_requestRedraw: function (layer) {\n  \t\tif (!this._map) { return; }\n\n  \t\tthis._extendRedrawBounds(layer);\n  \t\tthis._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);\n  \t},\n\n  \t_extendRedrawBounds: function (layer) {\n  \t\tif (layer._pxBounds) {\n  \t\t\tvar padding = (layer.options.weight || 0) + 1;\n  \t\t\tthis._redrawBounds = this._redrawBounds || new Bounds();\n  \t\t\tthis._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));\n  \t\t\tthis._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));\n  \t\t}\n  \t},\n\n  \t_redraw: function () {\n  \t\tthis._redrawRequest = null;\n\n  \t\tif (this._redrawBounds) {\n  \t\t\tthis._redrawBounds.min._floor();\n  \t\t\tthis._redrawBounds.max._ceil();\n  \t\t}\n\n  \t\tthis._clear(); // clear layers in redraw bounds\n  \t\tthis._draw(); // draw layers\n\n  \t\tthis._redrawBounds = null;\n  \t},\n\n  \t_clear: function () {\n  \t\tvar bounds = this._redrawBounds;\n  \t\tif (bounds) {\n  \t\t\tvar size = bounds.getSize();\n  \t\t\tthis._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);\n  \t\t} else {\n  \t\t\tthis._ctx.save();\n  \t\t\tthis._ctx.setTransform(1, 0, 0, 1, 0, 0);\n  \t\t\tthis._ctx.clearRect(0, 0, this._container.width, this._container.height);\n  \t\t\tthis._ctx.restore();\n  \t\t}\n  \t},\n\n  \t_draw: function () {\n  \t\tvar layer, bounds = this._redrawBounds;\n  \t\tthis._ctx.save();\n  \t\tif (bounds) {\n  \t\t\tvar size = bounds.getSize();\n  \t\t\tthis._ctx.beginPath();\n  \t\t\tthis._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);\n  \t\t\tthis._ctx.clip();\n  \t\t}\n\n  \t\tthis._drawing = true;\n\n  \t\tfor (var order = this._drawFirst; order; order = order.next) {\n  \t\t\tlayer = order.layer;\n  \t\t\tif (!bounds || (layer._pxBounds && layer._pxBounds.intersects(bounds))) {\n  \t\t\t\tlayer._updatePath();\n  \t\t\t}\n  \t\t}\n\n  \t\tthis._drawing = false;\n\n  \t\tthis._ctx.restore();  // Restore state before clipping.\n  \t},\n\n  \t_updatePoly: function (layer, closed) {\n  \t\tif (!this._drawing) { return; }\n\n  \t\tvar i, j, len2, p,\n  \t\t    parts = layer._parts,\n  \t\t    len = parts.length,\n  \t\t    ctx = this._ctx;\n\n  \t\tif (!len) { return; }\n\n  \t\tctx.beginPath();\n\n  \t\tfor (i = 0; i < len; i++) {\n  \t\t\tfor (j = 0, len2 = parts[i].length; j < len2; j++) {\n  \t\t\t\tp = parts[i][j];\n  \t\t\t\tctx[j ? 'lineTo' : 'moveTo'](p.x, p.y);\n  \t\t\t}\n  \t\t\tif (closed) {\n  \t\t\t\tctx.closePath();\n  \t\t\t}\n  \t\t}\n\n  \t\tthis._fillStroke(ctx, layer);\n\n  \t\t// TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature\n  \t},\n\n  \t_updateCircle: function (layer) {\n\n  \t\tif (!this._drawing || layer._empty()) { return; }\n\n  \t\tvar p = layer._point,\n  \t\t    ctx = this._ctx,\n  \t\t    r = Math.max(Math.round(layer._radius), 1),\n  \t\t    s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;\n\n  \t\tif (s !== 1) {\n  \t\t\tctx.save();\n  \t\t\tctx.scale(1, s);\n  \t\t}\n\n  \t\tctx.beginPath();\n  \t\tctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);\n\n  \t\tif (s !== 1) {\n  \t\t\tctx.restore();\n  \t\t}\n\n  \t\tthis._fillStroke(ctx, layer);\n  \t},\n\n  \t_fillStroke: function (ctx, layer) {\n  \t\tvar options = layer.options;\n\n  \t\tif (options.fill) {\n  \t\t\tctx.globalAlpha = options.fillOpacity;\n  \t\t\tctx.fillStyle = options.fillColor || options.color;\n  \t\t\tctx.fill(options.fillRule || 'evenodd');\n  \t\t}\n\n  \t\tif (options.stroke && options.weight !== 0) {\n  \t\t\tif (ctx.setLineDash) {\n  \t\t\t\tctx.setLineDash(layer.options && layer.options._dashArray || []);\n  \t\t\t}\n  \t\t\tctx.globalAlpha = options.opacity;\n  \t\t\tctx.lineWidth = options.weight;\n  \t\t\tctx.strokeStyle = options.color;\n  \t\t\tctx.lineCap = options.lineCap;\n  \t\t\tctx.lineJoin = options.lineJoin;\n  \t\t\tctx.stroke();\n  \t\t}\n  \t},\n\n  \t// Canvas obviously doesn't have mouse events for individual drawn objects,\n  \t// so we emulate that by calculating what's under the mouse on mousemove/click manually\n\n  \t_onClick: function (e) {\n  \t\tvar point = this._map.mouseEventToLayerPoint(e), layer, clickedLayer;\n\n  \t\tfor (var order = this._drawFirst; order; order = order.next) {\n  \t\t\tlayer = order.layer;\n  \t\t\tif (layer.options.interactive && layer._containsPoint(point)) {\n  \t\t\t\tif (!(e.type === 'click' || e.type === 'preclick') || !this._map._draggableMoved(layer)) {\n  \t\t\t\t\tclickedLayer = layer;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\tthis._fireEvent(clickedLayer ? [clickedLayer] : false, e);\n  \t},\n\n  \t_onMouseMove: function (e) {\n  \t\tif (!this._map || this._map.dragging.moving() || this._map._animatingZoom) { return; }\n\n  \t\tvar point = this._map.mouseEventToLayerPoint(e);\n  \t\tthis._handleMouseHover(e, point);\n  \t},\n\n\n  \t_handleMouseOut: function (e) {\n  \t\tvar layer = this._hoveredLayer;\n  \t\tif (layer) {\n  \t\t\t// if we're leaving the layer, fire mouseout\n  \t\t\tremoveClass(this._container, 'leaflet-interactive');\n  \t\t\tthis._fireEvent([layer], e, 'mouseout');\n  \t\t\tthis._hoveredLayer = null;\n  \t\t\tthis._mouseHoverThrottled = false;\n  \t\t}\n  \t},\n\n  \t_handleMouseHover: function (e, point) {\n  \t\tif (this._mouseHoverThrottled) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tvar layer, candidateHoveredLayer;\n\n  \t\tfor (var order = this._drawFirst; order; order = order.next) {\n  \t\t\tlayer = order.layer;\n  \t\t\tif (layer.options.interactive && layer._containsPoint(point)) {\n  \t\t\t\tcandidateHoveredLayer = layer;\n  \t\t\t}\n  \t\t}\n\n  \t\tif (candidateHoveredLayer !== this._hoveredLayer) {\n  \t\t\tthis._handleMouseOut(e);\n\n  \t\t\tif (candidateHoveredLayer) {\n  \t\t\t\taddClass(this._container, 'leaflet-interactive'); // change cursor\n  \t\t\t\tthis._fireEvent([candidateHoveredLayer], e, 'mouseover');\n  \t\t\t\tthis._hoveredLayer = candidateHoveredLayer;\n  \t\t\t}\n  \t\t}\n\n  \t\tthis._fireEvent(this._hoveredLayer ? [this._hoveredLayer] : false, e);\n\n  \t\tthis._mouseHoverThrottled = true;\n  \t\tsetTimeout(bind(function () {\n  \t\t\tthis._mouseHoverThrottled = false;\n  \t\t}, this), 32);\n  \t},\n\n  \t_fireEvent: function (layers, e, type) {\n  \t\tthis._map._fireDOMEvent(e, type || e.type, layers);\n  \t},\n\n  \t_bringToFront: function (layer) {\n  \t\tvar order = layer._order;\n\n  \t\tif (!order) { return; }\n\n  \t\tvar next = order.next;\n  \t\tvar prev = order.prev;\n\n  \t\tif (next) {\n  \t\t\tnext.prev = prev;\n  \t\t} else {\n  \t\t\t// Already last\n  \t\t\treturn;\n  \t\t}\n  \t\tif (prev) {\n  \t\t\tprev.next = next;\n  \t\t} else if (next) {\n  \t\t\t// Update first entry unless this is the\n  \t\t\t// single entry\n  \t\t\tthis._drawFirst = next;\n  \t\t}\n\n  \t\torder.prev = this._drawLast;\n  \t\tthis._drawLast.next = order;\n\n  \t\torder.next = null;\n  \t\tthis._drawLast = order;\n\n  \t\tthis._requestRedraw(layer);\n  \t},\n\n  \t_bringToBack: function (layer) {\n  \t\tvar order = layer._order;\n\n  \t\tif (!order) { return; }\n\n  \t\tvar next = order.next;\n  \t\tvar prev = order.prev;\n\n  \t\tif (prev) {\n  \t\t\tprev.next = next;\n  \t\t} else {\n  \t\t\t// Already first\n  \t\t\treturn;\n  \t\t}\n  \t\tif (next) {\n  \t\t\tnext.prev = prev;\n  \t\t} else if (prev) {\n  \t\t\t// Update last entry unless this is the\n  \t\t\t// single entry\n  \t\t\tthis._drawLast = prev;\n  \t\t}\n\n  \t\torder.prev = null;\n\n  \t\torder.next = this._drawFirst;\n  \t\tthis._drawFirst.prev = order;\n  \t\tthis._drawFirst = order;\n\n  \t\tthis._requestRedraw(layer);\n  \t}\n  });\n\n  // @factory L.canvas(options?: Renderer options)\n  // Creates a Canvas renderer with the given options.\n  function canvas(options) {\n  \treturn Browser.canvas ? new Canvas(options) : null;\n  }\n\n  /*\n   * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!\n   */\n\n\n  var vmlCreate = (function () {\n  \ttry {\n  \t\tdocument.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');\n  \t\treturn function (name) {\n  \t\t\treturn document.createElement('<lvml:' + name + ' class=\"lvml\">');\n  \t\t};\n  \t} catch (e) {\n  \t\t// Do not return fn from catch block so `e` can be garbage collected\n  \t\t// See https://github.com/Leaflet/Leaflet/pull/7279\n  \t}\n  \treturn function (name) {\n  \t\treturn document.createElement('<' + name + ' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"lvml\">');\n  \t};\n  })();\n\n\n  /*\n   * @class SVG\n   *\n   *\n   * VML was deprecated in 2012, which means VML functionality exists only for backwards compatibility\n   * with old versions of Internet Explorer.\n   */\n\n  // mixin to redefine some SVG methods to handle VML syntax which is similar but with some differences\n  var vmlMixin = {\n\n  \t_initContainer: function () {\n  \t\tthis._container = create$1('div', 'leaflet-vml-container');\n  \t},\n\n  \t_update: function () {\n  \t\tif (this._map._animatingZoom) { return; }\n  \t\tRenderer.prototype._update.call(this);\n  \t\tthis.fire('update');\n  \t},\n\n  \t_initPath: function (layer) {\n  \t\tvar container = layer._container = vmlCreate('shape');\n\n  \t\taddClass(container, 'leaflet-vml-shape ' + (this.options.className || ''));\n\n  \t\tcontainer.coordsize = '1 1';\n\n  \t\tlayer._path = vmlCreate('path');\n  \t\tcontainer.appendChild(layer._path);\n\n  \t\tthis._updateStyle(layer);\n  \t\tthis._layers[stamp(layer)] = layer;\n  \t},\n\n  \t_addPath: function (layer) {\n  \t\tvar container = layer._container;\n  \t\tthis._container.appendChild(container);\n\n  \t\tif (layer.options.interactive) {\n  \t\t\tlayer.addInteractiveTarget(container);\n  \t\t}\n  \t},\n\n  \t_removePath: function (layer) {\n  \t\tvar container = layer._container;\n  \t\tremove(container);\n  \t\tlayer.removeInteractiveTarget(container);\n  \t\tdelete this._layers[stamp(layer)];\n  \t},\n\n  \t_updateStyle: function (layer) {\n  \t\tvar stroke = layer._stroke,\n  \t\t    fill = layer._fill,\n  \t\t    options = layer.options,\n  \t\t    container = layer._container;\n\n  \t\tcontainer.stroked = !!options.stroke;\n  \t\tcontainer.filled = !!options.fill;\n\n  \t\tif (options.stroke) {\n  \t\t\tif (!stroke) {\n  \t\t\t\tstroke = layer._stroke = vmlCreate('stroke');\n  \t\t\t}\n  \t\t\tcontainer.appendChild(stroke);\n  \t\t\tstroke.weight = options.weight + 'px';\n  \t\t\tstroke.color = options.color;\n  \t\t\tstroke.opacity = options.opacity;\n\n  \t\t\tif (options.dashArray) {\n  \t\t\t\tstroke.dashStyle = isArray(options.dashArray) ?\n  \t\t\t\t    options.dashArray.join(' ') :\n  \t\t\t\t    options.dashArray.replace(/( *, *)/g, ' ');\n  \t\t\t} else {\n  \t\t\t\tstroke.dashStyle = '';\n  \t\t\t}\n  \t\t\tstroke.endcap = options.lineCap.replace('butt', 'flat');\n  \t\t\tstroke.joinstyle = options.lineJoin;\n\n  \t\t} else if (stroke) {\n  \t\t\tcontainer.removeChild(stroke);\n  \t\t\tlayer._stroke = null;\n  \t\t}\n\n  \t\tif (options.fill) {\n  \t\t\tif (!fill) {\n  \t\t\t\tfill = layer._fill = vmlCreate('fill');\n  \t\t\t}\n  \t\t\tcontainer.appendChild(fill);\n  \t\t\tfill.color = options.fillColor || options.color;\n  \t\t\tfill.opacity = options.fillOpacity;\n\n  \t\t} else if (fill) {\n  \t\t\tcontainer.removeChild(fill);\n  \t\t\tlayer._fill = null;\n  \t\t}\n  \t},\n\n  \t_updateCircle: function (layer) {\n  \t\tvar p = layer._point.round(),\n  \t\t    r = Math.round(layer._radius),\n  \t\t    r2 = Math.round(layer._radiusY || r);\n\n  \t\tthis._setPath(layer, layer._empty() ? 'M0 0' :\n  \t\t\t'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r2 + ' 0,' + (65535 * 360));\n  \t},\n\n  \t_setPath: function (layer, path) {\n  \t\tlayer._path.v = path;\n  \t},\n\n  \t_bringToFront: function (layer) {\n  \t\ttoFront(layer._container);\n  \t},\n\n  \t_bringToBack: function (layer) {\n  \t\ttoBack(layer._container);\n  \t}\n  };\n\n  var create = Browser.vml ? vmlCreate : svgCreate;\n\n  /*\n   * @class SVG\n   * @inherits Renderer\n   * @aka L.SVG\n   *\n   * Allows vector layers to be displayed with [SVG](https://developer.mozilla.org/docs/Web/SVG).\n   * Inherits `Renderer`.\n   *\n   * Due to [technical limitations](https://caniuse.com/svg), SVG is not\n   * available in all web browsers, notably Android 2.x and 3.x.\n   *\n   * Although SVG is not available on IE7 and IE8, these browsers support\n   * [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language)\n   * (a now deprecated technology), and the SVG renderer will fall back to VML in\n   * this case.\n   *\n   * @example\n   *\n   * Use SVG by default for all paths in the map:\n   *\n   * ```js\n   * var map = L.map('map', {\n   * \trenderer: L.svg()\n   * });\n   * ```\n   *\n   * Use a SVG renderer with extra padding for specific vector geometries:\n   *\n   * ```js\n   * var map = L.map('map');\n   * var myRenderer = L.svg({ padding: 0.5 });\n   * var line = L.polyline( coordinates, { renderer: myRenderer } );\n   * var circle = L.circle( center, { renderer: myRenderer } );\n   * ```\n   */\n\n  var SVG = Renderer.extend({\n\n  \t_initContainer: function () {\n  \t\tthis._container = create('svg');\n\n  \t\t// makes it possible to click through svg root; we'll reset it back in individual paths\n  \t\tthis._container.setAttribute('pointer-events', 'none');\n\n  \t\tthis._rootGroup = create('g');\n  \t\tthis._container.appendChild(this._rootGroup);\n  \t},\n\n  \t_destroyContainer: function () {\n  \t\tremove(this._container);\n  \t\toff(this._container);\n  \t\tdelete this._container;\n  \t\tdelete this._rootGroup;\n  \t\tdelete this._svgSize;\n  \t},\n\n  \t_update: function () {\n  \t\tif (this._map._animatingZoom && this._bounds) { return; }\n\n  \t\tRenderer.prototype._update.call(this);\n\n  \t\tvar b = this._bounds,\n  \t\t    size = b.getSize(),\n  \t\t    container = this._container;\n\n  \t\t// set size of svg-container if changed\n  \t\tif (!this._svgSize || !this._svgSize.equals(size)) {\n  \t\t\tthis._svgSize = size;\n  \t\t\tcontainer.setAttribute('width', size.x);\n  \t\t\tcontainer.setAttribute('height', size.y);\n  \t\t}\n\n  \t\t// movement: update container viewBox so that we don't have to change coordinates of individual layers\n  \t\tsetPosition(container, b.min);\n  \t\tcontainer.setAttribute('viewBox', [b.min.x, b.min.y, size.x, size.y].join(' '));\n\n  \t\tthis.fire('update');\n  \t},\n\n  \t// methods below are called by vector layers implementations\n\n  \t_initPath: function (layer) {\n  \t\tvar path = layer._path = create('path');\n\n  \t\t// @namespace Path\n  \t\t// @option className: String = null\n  \t\t// Custom class name set on an element. Only for SVG renderer.\n  \t\tif (layer.options.className) {\n  \t\t\taddClass(path, layer.options.className);\n  \t\t}\n\n  \t\tif (layer.options.interactive) {\n  \t\t\taddClass(path, 'leaflet-interactive');\n  \t\t}\n\n  \t\tthis._updateStyle(layer);\n  \t\tthis._layers[stamp(layer)] = layer;\n  \t},\n\n  \t_addPath: function (layer) {\n  \t\tif (!this._rootGroup) { this._initContainer(); }\n  \t\tthis._rootGroup.appendChild(layer._path);\n  \t\tlayer.addInteractiveTarget(layer._path);\n  \t},\n\n  \t_removePath: function (layer) {\n  \t\tremove(layer._path);\n  \t\tlayer.removeInteractiveTarget(layer._path);\n  \t\tdelete this._layers[stamp(layer)];\n  \t},\n\n  \t_updatePath: function (layer) {\n  \t\tlayer._project();\n  \t\tlayer._update();\n  \t},\n\n  \t_updateStyle: function (layer) {\n  \t\tvar path = layer._path,\n  \t\t    options = layer.options;\n\n  \t\tif (!path) { return; }\n\n  \t\tif (options.stroke) {\n  \t\t\tpath.setAttribute('stroke', options.color);\n  \t\t\tpath.setAttribute('stroke-opacity', options.opacity);\n  \t\t\tpath.setAttribute('stroke-width', options.weight);\n  \t\t\tpath.setAttribute('stroke-linecap', options.lineCap);\n  \t\t\tpath.setAttribute('stroke-linejoin', options.lineJoin);\n\n  \t\t\tif (options.dashArray) {\n  \t\t\t\tpath.setAttribute('stroke-dasharray', options.dashArray);\n  \t\t\t} else {\n  \t\t\t\tpath.removeAttribute('stroke-dasharray');\n  \t\t\t}\n\n  \t\t\tif (options.dashOffset) {\n  \t\t\t\tpath.setAttribute('stroke-dashoffset', options.dashOffset);\n  \t\t\t} else {\n  \t\t\t\tpath.removeAttribute('stroke-dashoffset');\n  \t\t\t}\n  \t\t} else {\n  \t\t\tpath.setAttribute('stroke', 'none');\n  \t\t}\n\n  \t\tif (options.fill) {\n  \t\t\tpath.setAttribute('fill', options.fillColor || options.color);\n  \t\t\tpath.setAttribute('fill-opacity', options.fillOpacity);\n  \t\t\tpath.setAttribute('fill-rule', options.fillRule || 'evenodd');\n  \t\t} else {\n  \t\t\tpath.setAttribute('fill', 'none');\n  \t\t}\n  \t},\n\n  \t_updatePoly: function (layer, closed) {\n  \t\tthis._setPath(layer, pointsToPath(layer._parts, closed));\n  \t},\n\n  \t_updateCircle: function (layer) {\n  \t\tvar p = layer._point,\n  \t\t    r = Math.max(Math.round(layer._radius), 1),\n  \t\t    r2 = Math.max(Math.round(layer._radiusY), 1) || r,\n  \t\t    arc = 'a' + r + ',' + r2 + ' 0 1,0 ';\n\n  \t\t// drawing a circle with two half-arcs\n  \t\tvar d = layer._empty() ? 'M0 0' :\n  \t\t\t'M' + (p.x - r) + ',' + p.y +\n  \t\t\tarc + (r * 2) + ',0 ' +\n  \t\t\tarc + (-r * 2) + ',0 ';\n\n  \t\tthis._setPath(layer, d);\n  \t},\n\n  \t_setPath: function (layer, path) {\n  \t\tlayer._path.setAttribute('d', path);\n  \t},\n\n  \t// SVG does not have the concept of zIndex so we resort to changing the DOM order of elements\n  \t_bringToFront: function (layer) {\n  \t\ttoFront(layer._path);\n  \t},\n\n  \t_bringToBack: function (layer) {\n  \t\ttoBack(layer._path);\n  \t}\n  });\n\n  if (Browser.vml) {\n  \tSVG.include(vmlMixin);\n  }\n\n  // @namespace SVG\n  // @factory L.svg(options?: Renderer options)\n  // Creates a SVG renderer with the given options.\n  function svg(options) {\n  \treturn Browser.svg || Browser.vml ? new SVG(options) : null;\n  }\n\n  Map.include({\n  \t// @namespace Map; @method getRenderer(layer: Path): Renderer\n  \t// Returns the instance of `Renderer` that should be used to render the given\n  \t// `Path`. It will ensure that the `renderer` options of the map and paths\n  \t// are respected, and that the renderers do exist on the map.\n  \tgetRenderer: function (layer) {\n  \t\t// @namespace Path; @option renderer: Renderer\n  \t\t// Use this specific instance of `Renderer` for this path. Takes\n  \t\t// precedence over the map's [default renderer](#map-renderer).\n  \t\tvar renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;\n\n  \t\tif (!renderer) {\n  \t\t\trenderer = this._renderer = this._createRenderer();\n  \t\t}\n\n  \t\tif (!this.hasLayer(renderer)) {\n  \t\t\tthis.addLayer(renderer);\n  \t\t}\n  \t\treturn renderer;\n  \t},\n\n  \t_getPaneRenderer: function (name) {\n  \t\tif (name === 'overlayPane' || name === undefined) {\n  \t\t\treturn false;\n  \t\t}\n\n  \t\tvar renderer = this._paneRenderers[name];\n  \t\tif (renderer === undefined) {\n  \t\t\trenderer = this._createRenderer({pane: name});\n  \t\t\tthis._paneRenderers[name] = renderer;\n  \t\t}\n  \t\treturn renderer;\n  \t},\n\n  \t_createRenderer: function (options) {\n  \t\t// @namespace Map; @option preferCanvas: Boolean = false\n  \t\t// Whether `Path`s should be rendered on a `Canvas` renderer.\n  \t\t// By default, all `Path`s are rendered in a `SVG` renderer.\n  \t\treturn (this.options.preferCanvas && canvas(options)) || svg(options);\n  \t}\n  });\n\n  /*\n   * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.\n   */\n\n  /*\n   * @class Rectangle\n   * @aka L.Rectangle\n   * @inherits Polygon\n   *\n   * A class for drawing rectangle overlays on a map. Extends `Polygon`.\n   *\n   * @example\n   *\n   * ```js\n   * // define rectangle geographical bounds\n   * var bounds = [[54.559322, -5.767822], [56.1210604, -3.021240]];\n   *\n   * // create an orange rectangle\n   * L.rectangle(bounds, {color: \"#ff7800\", weight: 1}).addTo(map);\n   *\n   * // zoom the map to the rectangle bounds\n   * map.fitBounds(bounds);\n   * ```\n   *\n   */\n\n\n  var Rectangle = Polygon.extend({\n  \tinitialize: function (latLngBounds, options) {\n  \t\tPolygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);\n  \t},\n\n  \t// @method setBounds(latLngBounds: LatLngBounds): this\n  \t// Redraws the rectangle with the passed bounds.\n  \tsetBounds: function (latLngBounds) {\n  \t\treturn this.setLatLngs(this._boundsToLatLngs(latLngBounds));\n  \t},\n\n  \t_boundsToLatLngs: function (latLngBounds) {\n  \t\tlatLngBounds = toLatLngBounds(latLngBounds);\n  \t\treturn [\n  \t\t\tlatLngBounds.getSouthWest(),\n  \t\t\tlatLngBounds.getNorthWest(),\n  \t\t\tlatLngBounds.getNorthEast(),\n  \t\t\tlatLngBounds.getSouthEast()\n  \t\t];\n  \t}\n  });\n\n\n  // @factory L.rectangle(latLngBounds: LatLngBounds, options?: Polyline options)\n  function rectangle(latLngBounds, options) {\n  \treturn new Rectangle(latLngBounds, options);\n  }\n\n  SVG.create = create;\n  SVG.pointsToPath = pointsToPath;\n\n  GeoJSON.geometryToLayer = geometryToLayer;\n  GeoJSON.coordsToLatLng = coordsToLatLng;\n  GeoJSON.coordsToLatLngs = coordsToLatLngs;\n  GeoJSON.latLngToCoords = latLngToCoords;\n  GeoJSON.latLngsToCoords = latLngsToCoords;\n  GeoJSON.getFeature = getFeature;\n  GeoJSON.asFeature = asFeature;\n\n  /*\n   * L.Handler.BoxZoom is used to add shift-drag zoom interaction to the map\n   * (zoom to a selected bounding box), enabled by default.\n   */\n\n  // @namespace Map\n  // @section Interaction Options\n  Map.mergeOptions({\n  \t// @option boxZoom: Boolean = true\n  \t// Whether the map can be zoomed to a rectangular area specified by\n  \t// dragging the mouse while pressing the shift key.\n  \tboxZoom: true\n  });\n\n  var BoxZoom = Handler.extend({\n  \tinitialize: function (map) {\n  \t\tthis._map = map;\n  \t\tthis._container = map._container;\n  \t\tthis._pane = map._panes.overlayPane;\n  \t\tthis._resetStateTimeout = 0;\n  \t\tmap.on('unload', this._destroy, this);\n  \t},\n\n  \taddHooks: function () {\n  \t\ton(this._container, 'mousedown', this._onMouseDown, this);\n  \t},\n\n  \tremoveHooks: function () {\n  \t\toff(this._container, 'mousedown', this._onMouseDown, this);\n  \t},\n\n  \tmoved: function () {\n  \t\treturn this._moved;\n  \t},\n\n  \t_destroy: function () {\n  \t\tremove(this._pane);\n  \t\tdelete this._pane;\n  \t},\n\n  \t_resetState: function () {\n  \t\tthis._resetStateTimeout = 0;\n  \t\tthis._moved = false;\n  \t},\n\n  \t_clearDeferredResetState: function () {\n  \t\tif (this._resetStateTimeout !== 0) {\n  \t\t\tclearTimeout(this._resetStateTimeout);\n  \t\t\tthis._resetStateTimeout = 0;\n  \t\t}\n  \t},\n\n  \t_onMouseDown: function (e) {\n  \t\tif (!e.shiftKey || ((e.which !== 1) && (e.button !== 1))) { return false; }\n\n  \t\t// Clear the deferred resetState if it hasn't executed yet, otherwise it\n  \t\t// will interrupt the interaction and orphan a box element in the container.\n  \t\tthis._clearDeferredResetState();\n  \t\tthis._resetState();\n\n  \t\tdisableTextSelection();\n  \t\tdisableImageDrag();\n\n  \t\tthis._startPoint = this._map.mouseEventToContainerPoint(e);\n\n  \t\ton(document, {\n  \t\t\tcontextmenu: stop,\n  \t\t\tmousemove: this._onMouseMove,\n  \t\t\tmouseup: this._onMouseUp,\n  \t\t\tkeydown: this._onKeyDown\n  \t\t}, this);\n  \t},\n\n  \t_onMouseMove: function (e) {\n  \t\tif (!this._moved) {\n  \t\t\tthis._moved = true;\n\n  \t\t\tthis._box = create$1('div', 'leaflet-zoom-box', this._container);\n  \t\t\taddClass(this._container, 'leaflet-crosshair');\n\n  \t\t\tthis._map.fire('boxzoomstart');\n  \t\t}\n\n  \t\tthis._point = this._map.mouseEventToContainerPoint(e);\n\n  \t\tvar bounds = new Bounds(this._point, this._startPoint),\n  \t\t    size = bounds.getSize();\n\n  \t\tsetPosition(this._box, bounds.min);\n\n  \t\tthis._box.style.width  = size.x + 'px';\n  \t\tthis._box.style.height = size.y + 'px';\n  \t},\n\n  \t_finish: function () {\n  \t\tif (this._moved) {\n  \t\t\tremove(this._box);\n  \t\t\tremoveClass(this._container, 'leaflet-crosshair');\n  \t\t}\n\n  \t\tenableTextSelection();\n  \t\tenableImageDrag();\n\n  \t\toff(document, {\n  \t\t\tcontextmenu: stop,\n  \t\t\tmousemove: this._onMouseMove,\n  \t\t\tmouseup: this._onMouseUp,\n  \t\t\tkeydown: this._onKeyDown\n  \t\t}, this);\n  \t},\n\n  \t_onMouseUp: function (e) {\n  \t\tif ((e.which !== 1) && (e.button !== 1)) { return; }\n\n  \t\tthis._finish();\n\n  \t\tif (!this._moved) { return; }\n  \t\t// Postpone to next JS tick so internal click event handling\n  \t\t// still see it as \"moved\".\n  \t\tthis._clearDeferredResetState();\n  \t\tthis._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);\n\n  \t\tvar bounds = new LatLngBounds(\n  \t\t        this._map.containerPointToLatLng(this._startPoint),\n  \t\t        this._map.containerPointToLatLng(this._point));\n\n  \t\tthis._map\n  \t\t\t.fitBounds(bounds)\n  \t\t\t.fire('boxzoomend', {boxZoomBounds: bounds});\n  \t},\n\n  \t_onKeyDown: function (e) {\n  \t\tif (e.keyCode === 27) {\n  \t\t\tthis._finish();\n  \t\t\tthis._clearDeferredResetState();\n  \t\t\tthis._resetState();\n  \t\t}\n  \t}\n  });\n\n  // @section Handlers\n  // @property boxZoom: Handler\n  // Box (shift-drag with mouse) zoom handler.\n  Map.addInitHook('addHandler', 'boxZoom', BoxZoom);\n\n  /*\n   * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.\n   */\n\n  // @namespace Map\n  // @section Interaction Options\n\n  Map.mergeOptions({\n  \t// @option doubleClickZoom: Boolean|String = true\n  \t// Whether the map can be zoomed in by double clicking on it and\n  \t// zoomed out by double clicking while holding shift. If passed\n  \t// `'center'`, double-click zoom will zoom to the center of the\n  \t//  view regardless of where the mouse was.\n  \tdoubleClickZoom: true\n  });\n\n  var DoubleClickZoom = Handler.extend({\n  \taddHooks: function () {\n  \t\tthis._map.on('dblclick', this._onDoubleClick, this);\n  \t},\n\n  \tremoveHooks: function () {\n  \t\tthis._map.off('dblclick', this._onDoubleClick, this);\n  \t},\n\n  \t_onDoubleClick: function (e) {\n  \t\tvar map = this._map,\n  \t\t    oldZoom = map.getZoom(),\n  \t\t    delta = map.options.zoomDelta,\n  \t\t    zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;\n\n  \t\tif (map.options.doubleClickZoom === 'center') {\n  \t\t\tmap.setZoom(zoom);\n  \t\t} else {\n  \t\t\tmap.setZoomAround(e.containerPoint, zoom);\n  \t\t}\n  \t}\n  });\n\n  // @section Handlers\n  //\n  // Map properties include interaction handlers that allow you to control\n  // interaction behavior in runtime, enabling or disabling certain features such\n  // as dragging or touch zoom (see `Handler` methods). For example:\n  //\n  // ```js\n  // map.doubleClickZoom.disable();\n  // ```\n  //\n  // @property doubleClickZoom: Handler\n  // Double click zoom handler.\n  Map.addInitHook('addHandler', 'doubleClickZoom', DoubleClickZoom);\n\n  /*\n   * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.\n   */\n\n  // @namespace Map\n  // @section Interaction Options\n  Map.mergeOptions({\n  \t// @option dragging: Boolean = true\n  \t// Whether the map is draggable with mouse/touch or not.\n  \tdragging: true,\n\n  \t// @section Panning Inertia Options\n  \t// @option inertia: Boolean = *\n  \t// If enabled, panning of the map will have an inertia effect where\n  \t// the map builds momentum while dragging and continues moving in\n  \t// the same direction for some time. Feels especially nice on touch\n  \t// devices. Enabled by default.\n  \tinertia: true,\n\n  \t// @option inertiaDeceleration: Number = 3000\n  \t// The rate with which the inertial movement slows down, in pixels/second.\n  \tinertiaDeceleration: 3400, // px/s^2\n\n  \t// @option inertiaMaxSpeed: Number = Infinity\n  \t// Max speed of the inertial movement, in pixels/second.\n  \tinertiaMaxSpeed: Infinity, // px/s\n\n  \t// @option easeLinearity: Number = 0.2\n  \teaseLinearity: 0.2,\n\n  \t// TODO refactor, move to CRS\n  \t// @option worldCopyJump: Boolean = false\n  \t// With this option enabled, the map tracks when you pan to another \"copy\"\n  \t// of the world and seamlessly jumps to the original one so that all overlays\n  \t// like markers and vector layers are still visible.\n  \tworldCopyJump: false,\n\n  \t// @option maxBoundsViscosity: Number = 0.0\n  \t// If `maxBounds` is set, this option will control how solid the bounds\n  \t// are when dragging the map around. The default value of `0.0` allows the\n  \t// user to drag outside the bounds at normal speed, higher values will\n  \t// slow down map dragging outside bounds, and `1.0` makes the bounds fully\n  \t// solid, preventing the user from dragging outside the bounds.\n  \tmaxBoundsViscosity: 0.0\n  });\n\n  var Drag = Handler.extend({\n  \taddHooks: function () {\n  \t\tif (!this._draggable) {\n  \t\t\tvar map = this._map;\n\n  \t\t\tthis._draggable = new Draggable(map._mapPane, map._container);\n\n  \t\t\tthis._draggable.on({\n  \t\t\t\tdragstart: this._onDragStart,\n  \t\t\t\tdrag: this._onDrag,\n  \t\t\t\tdragend: this._onDragEnd\n  \t\t\t}, this);\n\n  \t\t\tthis._draggable.on('predrag', this._onPreDragLimit, this);\n  \t\t\tif (map.options.worldCopyJump) {\n  \t\t\t\tthis._draggable.on('predrag', this._onPreDragWrap, this);\n  \t\t\t\tmap.on('zoomend', this._onZoomEnd, this);\n\n  \t\t\t\tmap.whenReady(this._onZoomEnd, this);\n  \t\t\t}\n  \t\t}\n  \t\taddClass(this._map._container, 'leaflet-grab leaflet-touch-drag');\n  \t\tthis._draggable.enable();\n  \t\tthis._positions = [];\n  \t\tthis._times = [];\n  \t},\n\n  \tremoveHooks: function () {\n  \t\tremoveClass(this._map._container, 'leaflet-grab');\n  \t\tremoveClass(this._map._container, 'leaflet-touch-drag');\n  \t\tthis._draggable.disable();\n  \t},\n\n  \tmoved: function () {\n  \t\treturn this._draggable && this._draggable._moved;\n  \t},\n\n  \tmoving: function () {\n  \t\treturn this._draggable && this._draggable._moving;\n  \t},\n\n  \t_onDragStart: function () {\n  \t\tvar map = this._map;\n\n  \t\tmap._stop();\n  \t\tif (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {\n  \t\t\tvar bounds = toLatLngBounds(this._map.options.maxBounds);\n\n  \t\t\tthis._offsetLimit = toBounds(\n  \t\t\t\tthis._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1),\n  \t\t\t\tthis._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1)\n  \t\t\t\t\t.add(this._map.getSize()));\n\n  \t\t\tthis._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));\n  \t\t} else {\n  \t\t\tthis._offsetLimit = null;\n  \t\t}\n\n  \t\tmap\n  \t\t    .fire('movestart')\n  \t\t    .fire('dragstart');\n\n  \t\tif (map.options.inertia) {\n  \t\t\tthis._positions = [];\n  \t\t\tthis._times = [];\n  \t\t}\n  \t},\n\n  \t_onDrag: function (e) {\n  \t\tif (this._map.options.inertia) {\n  \t\t\tvar time = this._lastTime = +new Date(),\n  \t\t\t    pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;\n\n  \t\t\tthis._positions.push(pos);\n  \t\t\tthis._times.push(time);\n\n  \t\t\tthis._prunePositions(time);\n  \t\t}\n\n  \t\tthis._map\n  \t\t    .fire('move', e)\n  \t\t    .fire('drag', e);\n  \t},\n\n  \t_prunePositions: function (time) {\n  \t\twhile (this._positions.length > 1 && time - this._times[0] > 50) {\n  \t\t\tthis._positions.shift();\n  \t\t\tthis._times.shift();\n  \t\t}\n  \t},\n\n  \t_onZoomEnd: function () {\n  \t\tvar pxCenter = this._map.getSize().divideBy(2),\n  \t\t    pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);\n\n  \t\tthis._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;\n  \t\tthis._worldWidth = this._map.getPixelWorldBounds().getSize().x;\n  \t},\n\n  \t_viscousLimit: function (value, threshold) {\n  \t\treturn value - (value - threshold) * this._viscosity;\n  \t},\n\n  \t_onPreDragLimit: function () {\n  \t\tif (!this._viscosity || !this._offsetLimit) { return; }\n\n  \t\tvar offset = this._draggable._newPos.subtract(this._draggable._startPos);\n\n  \t\tvar limit = this._offsetLimit;\n  \t\tif (offset.x < limit.min.x) { offset.x = this._viscousLimit(offset.x, limit.min.x); }\n  \t\tif (offset.y < limit.min.y) { offset.y = this._viscousLimit(offset.y, limit.min.y); }\n  \t\tif (offset.x > limit.max.x) { offset.x = this._viscousLimit(offset.x, limit.max.x); }\n  \t\tif (offset.y > limit.max.y) { offset.y = this._viscousLimit(offset.y, limit.max.y); }\n\n  \t\tthis._draggable._newPos = this._draggable._startPos.add(offset);\n  \t},\n\n  \t_onPreDragWrap: function () {\n  \t\t// TODO refactor to be able to adjust map pane position after zoom\n  \t\tvar worldWidth = this._worldWidth,\n  \t\t    halfWidth = Math.round(worldWidth / 2),\n  \t\t    dx = this._initialWorldOffset,\n  \t\t    x = this._draggable._newPos.x,\n  \t\t    newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,\n  \t\t    newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,\n  \t\t    newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;\n\n  \t\tthis._draggable._absPos = this._draggable._newPos.clone();\n  \t\tthis._draggable._newPos.x = newX;\n  \t},\n\n  \t_onDragEnd: function (e) {\n  \t\tvar map = this._map,\n  \t\t    options = map.options,\n\n  \t\t    noInertia = !options.inertia || e.noInertia || this._times.length < 2;\n\n  \t\tmap.fire('dragend', e);\n\n  \t\tif (noInertia) {\n  \t\t\tmap.fire('moveend');\n\n  \t\t} else {\n  \t\t\tthis._prunePositions(+new Date());\n\n  \t\t\tvar direction = this._lastPos.subtract(this._positions[0]),\n  \t\t\t    duration = (this._lastTime - this._times[0]) / 1000,\n  \t\t\t    ease = options.easeLinearity,\n\n  \t\t\t    speedVector = direction.multiplyBy(ease / duration),\n  \t\t\t    speed = speedVector.distanceTo([0, 0]),\n\n  \t\t\t    limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),\n  \t\t\t    limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),\n\n  \t\t\t    decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),\n  \t\t\t    offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();\n\n  \t\t\tif (!offset.x && !offset.y) {\n  \t\t\t\tmap.fire('moveend');\n\n  \t\t\t} else {\n  \t\t\t\toffset = map._limitOffset(offset, map.options.maxBounds);\n\n  \t\t\t\trequestAnimFrame(function () {\n  \t\t\t\t\tmap.panBy(offset, {\n  \t\t\t\t\t\tduration: decelerationDuration,\n  \t\t\t\t\t\teaseLinearity: ease,\n  \t\t\t\t\t\tnoMoveStart: true,\n  \t\t\t\t\t\tanimate: true\n  \t\t\t\t\t});\n  \t\t\t\t});\n  \t\t\t}\n  \t\t}\n  \t}\n  });\n\n  // @section Handlers\n  // @property dragging: Handler\n  // Map dragging handler (by both mouse and touch).\n  Map.addInitHook('addHandler', 'dragging', Drag);\n\n  /*\n   * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.\n   */\n\n  // @namespace Map\n  // @section Keyboard Navigation Options\n  Map.mergeOptions({\n  \t// @option keyboard: Boolean = true\n  \t// Makes the map focusable and allows users to navigate the map with keyboard\n  \t// arrows and `+`/`-` keys.\n  \tkeyboard: true,\n\n  \t// @option keyboardPanDelta: Number = 80\n  \t// Amount of pixels to pan when pressing an arrow key.\n  \tkeyboardPanDelta: 80\n  });\n\n  var Keyboard = Handler.extend({\n\n  \tkeyCodes: {\n  \t\tleft:    [37],\n  \t\tright:   [39],\n  \t\tdown:    [40],\n  \t\tup:      [38],\n  \t\tzoomIn:  [187, 107, 61, 171],\n  \t\tzoomOut: [189, 109, 54, 173]\n  \t},\n\n  \tinitialize: function (map) {\n  \t\tthis._map = map;\n\n  \t\tthis._setPanDelta(map.options.keyboardPanDelta);\n  \t\tthis._setZoomDelta(map.options.zoomDelta);\n  \t},\n\n  \taddHooks: function () {\n  \t\tvar container = this._map._container;\n\n  \t\t// make the container focusable by tabbing\n  \t\tif (container.tabIndex <= 0) {\n  \t\t\tcontainer.tabIndex = '0';\n  \t\t}\n\n  \t\ton(container, {\n  \t\t\tfocus: this._onFocus,\n  \t\t\tblur: this._onBlur,\n  \t\t\tmousedown: this._onMouseDown\n  \t\t}, this);\n\n  \t\tthis._map.on({\n  \t\t\tfocus: this._addHooks,\n  \t\t\tblur: this._removeHooks\n  \t\t}, this);\n  \t},\n\n  \tremoveHooks: function () {\n  \t\tthis._removeHooks();\n\n  \t\toff(this._map._container, {\n  \t\t\tfocus: this._onFocus,\n  \t\t\tblur: this._onBlur,\n  \t\t\tmousedown: this._onMouseDown\n  \t\t}, this);\n\n  \t\tthis._map.off({\n  \t\t\tfocus: this._addHooks,\n  \t\t\tblur: this._removeHooks\n  \t\t}, this);\n  \t},\n\n  \t_onMouseDown: function () {\n  \t\tif (this._focused) { return; }\n\n  \t\tvar body = document.body,\n  \t\t    docEl = document.documentElement,\n  \t\t    top = body.scrollTop || docEl.scrollTop,\n  \t\t    left = body.scrollLeft || docEl.scrollLeft;\n\n  \t\tthis._map._container.focus();\n\n  \t\twindow.scrollTo(left, top);\n  \t},\n\n  \t_onFocus: function () {\n  \t\tthis._focused = true;\n  \t\tthis._map.fire('focus');\n  \t},\n\n  \t_onBlur: function () {\n  \t\tthis._focused = false;\n  \t\tthis._map.fire('blur');\n  \t},\n\n  \t_setPanDelta: function (panDelta) {\n  \t\tvar keys = this._panKeys = {},\n  \t\t    codes = this.keyCodes,\n  \t\t    i, len;\n\n  \t\tfor (i = 0, len = codes.left.length; i < len; i++) {\n  \t\t\tkeys[codes.left[i]] = [-1 * panDelta, 0];\n  \t\t}\n  \t\tfor (i = 0, len = codes.right.length; i < len; i++) {\n  \t\t\tkeys[codes.right[i]] = [panDelta, 0];\n  \t\t}\n  \t\tfor (i = 0, len = codes.down.length; i < len; i++) {\n  \t\t\tkeys[codes.down[i]] = [0, panDelta];\n  \t\t}\n  \t\tfor (i = 0, len = codes.up.length; i < len; i++) {\n  \t\t\tkeys[codes.up[i]] = [0, -1 * panDelta];\n  \t\t}\n  \t},\n\n  \t_setZoomDelta: function (zoomDelta) {\n  \t\tvar keys = this._zoomKeys = {},\n  \t\t    codes = this.keyCodes,\n  \t\t    i, len;\n\n  \t\tfor (i = 0, len = codes.zoomIn.length; i < len; i++) {\n  \t\t\tkeys[codes.zoomIn[i]] = zoomDelta;\n  \t\t}\n  \t\tfor (i = 0, len = codes.zoomOut.length; i < len; i++) {\n  \t\t\tkeys[codes.zoomOut[i]] = -zoomDelta;\n  \t\t}\n  \t},\n\n  \t_addHooks: function () {\n  \t\ton(document, 'keydown', this._onKeyDown, this);\n  \t},\n\n  \t_removeHooks: function () {\n  \t\toff(document, 'keydown', this._onKeyDown, this);\n  \t},\n\n  \t_onKeyDown: function (e) {\n  \t\tif (e.altKey || e.ctrlKey || e.metaKey) { return; }\n\n  \t\tvar key = e.keyCode,\n  \t\t    map = this._map,\n  \t\t    offset;\n\n  \t\tif (key in this._panKeys) {\n  \t\t\tif (!map._panAnim || !map._panAnim._inProgress) {\n  \t\t\t\toffset = this._panKeys[key];\n  \t\t\t\tif (e.shiftKey) {\n  \t\t\t\t\toffset = toPoint(offset).multiplyBy(3);\n  \t\t\t\t}\n\n  \t\t\t\tif (map.options.maxBounds) {\n  \t\t\t\t\toffset = map._limitOffset(toPoint(offset), map.options.maxBounds);\n  \t\t\t\t}\n\n  \t\t\t\tif (map.options.worldCopyJump) {\n  \t\t\t\t\tvar newLatLng = map.wrapLatLng(map.unproject(map.project(map.getCenter()).add(offset)));\n  \t\t\t\t\tmap.panTo(newLatLng);\n  \t\t\t\t} else {\n  \t\t\t\t\tmap.panBy(offset);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t} else if (key in this._zoomKeys) {\n  \t\t\tmap.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);\n\n  \t\t} else if (key === 27 && map._popup && map._popup.options.closeOnEscapeKey) {\n  \t\t\tmap.closePopup();\n\n  \t\t} else {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tstop(e);\n  \t}\n  });\n\n  // @section Handlers\n  // @section Handlers\n  // @property keyboard: Handler\n  // Keyboard navigation handler.\n  Map.addInitHook('addHandler', 'keyboard', Keyboard);\n\n  /*\n   * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.\n   */\n\n  // @namespace Map\n  // @section Interaction Options\n  Map.mergeOptions({\n  \t// @section Mouse wheel options\n  \t// @option scrollWheelZoom: Boolean|String = true\n  \t// Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,\n  \t// it will zoom to the center of the view regardless of where the mouse was.\n  \tscrollWheelZoom: true,\n\n  \t// @option wheelDebounceTime: Number = 40\n  \t// Limits the rate at which a wheel can fire (in milliseconds). By default\n  \t// user can't zoom via wheel more often than once per 40 ms.\n  \twheelDebounceTime: 40,\n\n  \t// @option wheelPxPerZoomLevel: Number = 60\n  \t// How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))\n  \t// mean a change of one full zoom level. Smaller values will make wheel-zooming\n  \t// faster (and vice versa).\n  \twheelPxPerZoomLevel: 60\n  });\n\n  var ScrollWheelZoom = Handler.extend({\n  \taddHooks: function () {\n  \t\ton(this._map._container, 'wheel', this._onWheelScroll, this);\n\n  \t\tthis._delta = 0;\n  \t},\n\n  \tremoveHooks: function () {\n  \t\toff(this._map._container, 'wheel', this._onWheelScroll, this);\n  \t},\n\n  \t_onWheelScroll: function (e) {\n  \t\tvar delta = getWheelDelta(e);\n\n  \t\tvar debounce = this._map.options.wheelDebounceTime;\n\n  \t\tthis._delta += delta;\n  \t\tthis._lastMousePos = this._map.mouseEventToContainerPoint(e);\n\n  \t\tif (!this._startTime) {\n  \t\t\tthis._startTime = +new Date();\n  \t\t}\n\n  \t\tvar left = Math.max(debounce - (+new Date() - this._startTime), 0);\n\n  \t\tclearTimeout(this._timer);\n  \t\tthis._timer = setTimeout(bind(this._performZoom, this), left);\n\n  \t\tstop(e);\n  \t},\n\n  \t_performZoom: function () {\n  \t\tvar map = this._map,\n  \t\t    zoom = map.getZoom(),\n  \t\t    snap = this._map.options.zoomSnap || 0;\n\n  \t\tmap._stop(); // stop panning and fly animations if any\n\n  \t\t// map the delta with a sigmoid function to -4..4 range leaning on -1..1\n  \t\tvar d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4),\n  \t\t    d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2,\n  \t\t    d4 = snap ? Math.ceil(d3 / snap) * snap : d3,\n  \t\t    delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;\n\n  \t\tthis._delta = 0;\n  \t\tthis._startTime = null;\n\n  \t\tif (!delta) { return; }\n\n  \t\tif (map.options.scrollWheelZoom === 'center') {\n  \t\t\tmap.setZoom(zoom + delta);\n  \t\t} else {\n  \t\t\tmap.setZoomAround(this._lastMousePos, zoom + delta);\n  \t\t}\n  \t}\n  });\n\n  // @section Handlers\n  // @property scrollWheelZoom: Handler\n  // Scroll wheel zoom handler.\n  Map.addInitHook('addHandler', 'scrollWheelZoom', ScrollWheelZoom);\n\n  /*\n   * L.Map.TapHold is used to simulate `contextmenu` event on long hold,\n   * which otherwise is not fired by mobile Safari.\n   */\n\n  var tapHoldDelay = 600;\n\n  // @namespace Map\n  // @section Interaction Options\n  Map.mergeOptions({\n  \t// @section Touch interaction options\n  \t// @option tapHold: Boolean\n  \t// Enables simulation of `contextmenu` event, default is `true` for mobile Safari.\n  \ttapHold: Browser.touchNative && Browser.safari && Browser.mobile,\n\n  \t// @option tapTolerance: Number = 15\n  \t// The max number of pixels a user can shift his finger during touch\n  \t// for it to be considered a valid tap.\n  \ttapTolerance: 15\n  });\n\n  var TapHold = Handler.extend({\n  \taddHooks: function () {\n  \t\ton(this._map._container, 'touchstart', this._onDown, this);\n  \t},\n\n  \tremoveHooks: function () {\n  \t\toff(this._map._container, 'touchstart', this._onDown, this);\n  \t},\n\n  \t_onDown: function (e) {\n  \t\tclearTimeout(this._holdTimeout);\n  \t\tif (e.touches.length !== 1) { return; }\n\n  \t\tvar first = e.touches[0];\n  \t\tthis._startPos = this._newPos = new Point(first.clientX, first.clientY);\n\n  \t\tthis._holdTimeout = setTimeout(bind(function () {\n  \t\t\tthis._cancel();\n  \t\t\tif (!this._isTapValid()) { return; }\n\n  \t\t\t// prevent simulated mouse events https://w3c.github.io/touch-events/#mouse-events\n  \t\t\ton(document, 'touchend', preventDefault);\n  \t\t\ton(document, 'touchend touchcancel', this._cancelClickPrevent);\n  \t\t\tthis._simulateEvent('contextmenu', first);\n  \t\t}, this), tapHoldDelay);\n\n  \t\ton(document, 'touchend touchcancel contextmenu', this._cancel, this);\n  \t\ton(document, 'touchmove', this._onMove, this);\n  \t},\n\n  \t_cancelClickPrevent: function cancelClickPrevent() {\n  \t\toff(document, 'touchend', preventDefault);\n  \t\toff(document, 'touchend touchcancel', cancelClickPrevent);\n  \t},\n\n  \t_cancel: function () {\n  \t\tclearTimeout(this._holdTimeout);\n  \t\toff(document, 'touchend touchcancel contextmenu', this._cancel, this);\n  \t\toff(document, 'touchmove', this._onMove, this);\n  \t},\n\n  \t_onMove: function (e) {\n  \t\tvar first = e.touches[0];\n  \t\tthis._newPos = new Point(first.clientX, first.clientY);\n  \t},\n\n  \t_isTapValid: function () {\n  \t\treturn this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;\n  \t},\n\n  \t_simulateEvent: function (type, e) {\n  \t\tvar simulatedEvent = new MouseEvent(type, {\n  \t\t\tbubbles: true,\n  \t\t\tcancelable: true,\n  \t\t\tview: window,\n  \t\t\t// detail: 1,\n  \t\t\tscreenX: e.screenX,\n  \t\t\tscreenY: e.screenY,\n  \t\t\tclientX: e.clientX,\n  \t\t\tclientY: e.clientY,\n  \t\t\t// button: 2,\n  \t\t\t// buttons: 2\n  \t\t});\n\n  \t\tsimulatedEvent._simulated = true;\n\n  \t\te.target.dispatchEvent(simulatedEvent);\n  \t}\n  });\n\n  // @section Handlers\n  // @property tapHold: Handler\n  // Long tap handler to simulate `contextmenu` event (useful in mobile Safari).\n  Map.addInitHook('addHandler', 'tapHold', TapHold);\n\n  /*\n   * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.\n   */\n\n  // @namespace Map\n  // @section Interaction Options\n  Map.mergeOptions({\n  \t// @section Touch interaction options\n  \t// @option touchZoom: Boolean|String = *\n  \t// Whether the map can be zoomed by touch-dragging with two fingers. If\n  \t// passed `'center'`, it will zoom to the center of the view regardless of\n  \t// where the touch events (fingers) were. Enabled for touch-capable web\n  \t// browsers.\n  \ttouchZoom: Browser.touch,\n\n  \t// @option bounceAtZoomLimits: Boolean = true\n  \t// Set it to false if you don't want the map to zoom beyond min/max zoom\n  \t// and then bounce back when pinch-zooming.\n  \tbounceAtZoomLimits: true\n  });\n\n  var TouchZoom = Handler.extend({\n  \taddHooks: function () {\n  \t\taddClass(this._map._container, 'leaflet-touch-zoom');\n  \t\ton(this._map._container, 'touchstart', this._onTouchStart, this);\n  \t},\n\n  \tremoveHooks: function () {\n  \t\tremoveClass(this._map._container, 'leaflet-touch-zoom');\n  \t\toff(this._map._container, 'touchstart', this._onTouchStart, this);\n  \t},\n\n  \t_onTouchStart: function (e) {\n  \t\tvar map = this._map;\n  \t\tif (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) { return; }\n\n  \t\tvar p1 = map.mouseEventToContainerPoint(e.touches[0]),\n  \t\t    p2 = map.mouseEventToContainerPoint(e.touches[1]);\n\n  \t\tthis._centerPoint = map.getSize()._divideBy(2);\n  \t\tthis._startLatLng = map.containerPointToLatLng(this._centerPoint);\n  \t\tif (map.options.touchZoom !== 'center') {\n  \t\t\tthis._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));\n  \t\t}\n\n  \t\tthis._startDist = p1.distanceTo(p2);\n  \t\tthis._startZoom = map.getZoom();\n\n  \t\tthis._moved = false;\n  \t\tthis._zooming = true;\n\n  \t\tmap._stop();\n\n  \t\ton(document, 'touchmove', this._onTouchMove, this);\n  \t\ton(document, 'touchend touchcancel', this._onTouchEnd, this);\n\n  \t\tpreventDefault(e);\n  \t},\n\n  \t_onTouchMove: function (e) {\n  \t\tif (!e.touches || e.touches.length !== 2 || !this._zooming) { return; }\n\n  \t\tvar map = this._map,\n  \t\t    p1 = map.mouseEventToContainerPoint(e.touches[0]),\n  \t\t    p2 = map.mouseEventToContainerPoint(e.touches[1]),\n  \t\t    scale = p1.distanceTo(p2) / this._startDist;\n\n  \t\tthis._zoom = map.getScaleZoom(scale, this._startZoom);\n\n  \t\tif (!map.options.bounceAtZoomLimits && (\n  \t\t\t(this._zoom < map.getMinZoom() && scale < 1) ||\n  \t\t\t(this._zoom > map.getMaxZoom() && scale > 1))) {\n  \t\t\tthis._zoom = map._limitZoom(this._zoom);\n  \t\t}\n\n  \t\tif (map.options.touchZoom === 'center') {\n  \t\t\tthis._center = this._startLatLng;\n  \t\t\tif (scale === 1) { return; }\n  \t\t} else {\n  \t\t\t// Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng\n  \t\t\tvar delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);\n  \t\t\tif (scale === 1 && delta.x === 0 && delta.y === 0) { return; }\n  \t\t\tthis._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);\n  \t\t}\n\n  \t\tif (!this._moved) {\n  \t\t\tmap._moveStart(true, false);\n  \t\t\tthis._moved = true;\n  \t\t}\n\n  \t\tcancelAnimFrame(this._animRequest);\n\n  \t\tvar moveFn = bind(map._move, map, this._center, this._zoom, {pinch: true, round: false}, undefined);\n  \t\tthis._animRequest = requestAnimFrame(moveFn, this, true);\n\n  \t\tpreventDefault(e);\n  \t},\n\n  \t_onTouchEnd: function () {\n  \t\tif (!this._moved || !this._zooming) {\n  \t\t\tthis._zooming = false;\n  \t\t\treturn;\n  \t\t}\n\n  \t\tthis._zooming = false;\n  \t\tcancelAnimFrame(this._animRequest);\n\n  \t\toff(document, 'touchmove', this._onTouchMove, this);\n  \t\toff(document, 'touchend touchcancel', this._onTouchEnd, this);\n\n  \t\t// Pinch updates GridLayers' levels only when zoomSnap is off, so zoomSnap becomes noUpdate.\n  \t\tif (this._map.options.zoomAnimation) {\n  \t\t\tthis._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);\n  \t\t} else {\n  \t\t\tthis._map._resetView(this._center, this._map._limitZoom(this._zoom));\n  \t\t}\n  \t}\n  });\n\n  // @section Handlers\n  // @property touchZoom: Handler\n  // Touch zoom handler.\n  Map.addInitHook('addHandler', 'touchZoom', TouchZoom);\n\n  Map.BoxZoom = BoxZoom;\n  Map.DoubleClickZoom = DoubleClickZoom;\n  Map.Drag = Drag;\n  Map.Keyboard = Keyboard;\n  Map.ScrollWheelZoom = ScrollWheelZoom;\n  Map.TapHold = TapHold;\n  Map.TouchZoom = TouchZoom;\n\n  exports.Bounds = Bounds;\n  exports.Browser = Browser;\n  exports.CRS = CRS;\n  exports.Canvas = Canvas;\n  exports.Circle = Circle;\n  exports.CircleMarker = CircleMarker;\n  exports.Class = Class;\n  exports.Control = Control;\n  exports.DivIcon = DivIcon;\n  exports.DivOverlay = DivOverlay;\n  exports.DomEvent = DomEvent;\n  exports.DomUtil = DomUtil;\n  exports.Draggable = Draggable;\n  exports.Evented = Evented;\n  exports.FeatureGroup = FeatureGroup;\n  exports.GeoJSON = GeoJSON;\n  exports.GridLayer = GridLayer;\n  exports.Handler = Handler;\n  exports.Icon = Icon;\n  exports.ImageOverlay = ImageOverlay;\n  exports.LatLng = LatLng;\n  exports.LatLngBounds = LatLngBounds;\n  exports.Layer = Layer;\n  exports.LayerGroup = LayerGroup;\n  exports.LineUtil = LineUtil;\n  exports.Map = Map;\n  exports.Marker = Marker;\n  exports.Mixin = Mixin;\n  exports.Path = Path;\n  exports.Point = Point;\n  exports.PolyUtil = PolyUtil;\n  exports.Polygon = Polygon;\n  exports.Polyline = Polyline;\n  exports.Popup = Popup;\n  exports.PosAnimation = PosAnimation;\n  exports.Projection = index;\n  exports.Rectangle = Rectangle;\n  exports.Renderer = Renderer;\n  exports.SVG = SVG;\n  exports.SVGOverlay = SVGOverlay;\n  exports.TileLayer = TileLayer;\n  exports.Tooltip = Tooltip;\n  exports.Transformation = Transformation;\n  exports.Util = Util;\n  exports.VideoOverlay = VideoOverlay;\n  exports.bind = bind;\n  exports.bounds = toBounds;\n  exports.canvas = canvas;\n  exports.circle = circle;\n  exports.circleMarker = circleMarker;\n  exports.control = control;\n  exports.divIcon = divIcon;\n  exports.extend = extend;\n  exports.featureGroup = featureGroup;\n  exports.geoJSON = geoJSON;\n  exports.geoJson = geoJson;\n  exports.gridLayer = gridLayer;\n  exports.icon = icon;\n  exports.imageOverlay = imageOverlay;\n  exports.latLng = toLatLng;\n  exports.latLngBounds = toLatLngBounds;\n  exports.layerGroup = layerGroup;\n  exports.map = createMap;\n  exports.marker = marker;\n  exports.point = toPoint;\n  exports.polygon = polygon;\n  exports.polyline = polyline;\n  exports.popup = popup;\n  exports.rectangle = rectangle;\n  exports.setOptions = setOptions;\n  exports.stamp = stamp;\n  exports.svg = svg;\n  exports.svgOverlay = svgOverlay;\n  exports.tileLayer = tileLayer;\n  exports.tooltip = tooltip;\n  exports.transformation = toTransformation;\n  exports.version = version;\n  exports.videoOverlay = videoOverlay;\n\n  var oldL = window.L;\n  exports.noConflict = function() {\n  \twindow.L = oldL;\n  \treturn this;\n  }\n  // Always export us to window global (see #2364)\n  window.L = exports;\n\n}));\n//# sourceMappingURL=leaflet-src.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2xlYWZsZXQtc3JjLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRSxLQUE0RDtBQUM5RCxFQUFFLENBQ3dHO0FBQzFHLENBQUMsOEJBQThCOztBQUUvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxtQkFBbUI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixlQUFlO0FBQ3RDO0FBQ0E7QUFDQSxnRkFBZ0YsRUFBRSxHQUFHLEVBQUU7QUFDdkYsOEJBQThCLG1CQUFtQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCx1Q0FBdUM7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFNBQVM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMscUJBQXFCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QyxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakMsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMseUJBQXlCLE9BQU8sc0NBQXNDO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLEdBQUc7O0FBRUgscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsU0FBUztBQUM1Qzs7QUFFQSxzQ0FBc0MsVUFBVTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRixzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnRUFBZ0U7O0FBRWhFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsOEJBQThCO0FBQ2hFLGlDQUFpQyw2QkFBNkI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHVDQUF1QztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHVDQUF1QztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sTUFBTTtBQUNOLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxzRkFBc0YsZ0JBQWdCO0FBQ3RHO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyw2QkFBNkI7QUFDbEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsWUFBWTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIseUJBQXlCO0FBQ3RELDRCQUE0QixxREFBcUQ7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsY0FBYztBQUMvRCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsY0FBYztBQUN4RCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2Qyw2Q0FBNkMsYUFBYTtBQUMxRCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qix1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxZQUFZO0FBQ3BCO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssc0JBQXNCLGVBQWU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLG1FQUFtRSxZQUFZO0FBQy9FO0FBQ0EsUUFBUSxjQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sK0JBQStCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxQkFBcUIsc0JBQXNCLElBQUk7QUFDekUsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIscUJBQXFCLDBCQUEwQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQSx1R0FBdUc7QUFDdkc7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGFBQWE7QUFDbEQsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUY7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwQkFBMEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0JBQXdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0dBQW9HO0FBQ3BHLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsaUZBQWlGO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixlQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsU0FBUztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxLQUFLLHFCQUFxQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxLQUFLLHFCQUFxQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxLQUFLLHFCQUFxQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLEtBQUssK0JBQStCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLEtBQUssK0JBQStCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixhQUFhO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwwQkFBMEIsYUFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxTQUFTO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGlDQUFpQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTs7QUFFQTtBQUNBLDBCQUEwQixZQUFZO0FBQ3RDO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsd0JBQXdCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLCtCQUErQixhQUFhO0FBQzVDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDZDQUE2QztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGFBQWE7QUFDL0MsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxhQUFhO0FBQ2xELElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsZUFBZTs7QUFFekM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDJDQUEyQztBQUN6RSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsMkNBQTJDO0FBQ3pFLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsWUFBWTtBQUN6QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0IsZ0JBQWdCO0FBQzFEO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRDtBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGFBQWE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDQUErQyxVQUFVO0FBQ3pEOztBQUVBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSixzRUFBc0U7QUFDdEU7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlEQUFpRCxTQUFTO0FBQzFEOztBQUVBLHVDQUF1QyxjQUFjO0FBQ3JEOztBQUVBLHNCQUFzQjs7QUFFdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMERBQTBEOztBQUUxRDtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EOztBQUVBLG1EQUFtRCxVQUFVO0FBQzdELGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxhQUFhO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVEQUF1RCxTQUFTO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBEQUEwRDs7QUFFMUQ7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDs7QUFFQSxtREFBbUQsVUFBVTtBQUM3RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFNBQVM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsU0FBUztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFNBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFNBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQkFBa0Isc0JBQXNCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJCQUEyQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixZQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxZQUFZO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFlBQVk7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxxREFBcUQ7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsY0FBYzs7QUFFM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxjQUFjO0FBQ3JEO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGNBQWM7O0FBRTVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSixnQ0FBZ0M7O0FBRWhDLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix5QkFBeUI7QUFDdEQ7QUFDQTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2QixJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0Esb0RBQW9EOztBQUVwRCxpREFBaUQsU0FBUzs7QUFFMUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBLHlCQUF5Qjs7QUFFekI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7O0FBRUE7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7O0FBRUEsd0JBQXdCLGVBQWU7QUFDdkMseUJBQXlCLGVBQWU7O0FBRXhDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUEsZ0NBQWdDO0FBQ2hDLHdDQUF3QyxVQUFVOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0MsNkJBQTZCOztBQUU1RTtBQUNBLGtDQUFrQyxzQkFBc0I7QUFDeEQsbUNBQW1DLHNCQUFzQjtBQUN6RDtBQUNBOztBQUVBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GOztBQUVBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTs7QUFFQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsTUFBTSxJQUFJLElBQUksaUNBQWlDLGtGQUFrRjtBQUM3TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFLHdCQUF3QixFQUFFLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRTtBQUN0RDtBQUNBO0FBQ0EsT0FBTyxFQUFFLHlIQUF5SCwyQ0FBMkMsK0NBQStDLEVBQUUsa0JBQWtCLEVBQUUsUUFBUSxFQUFFLHdCQUF3QixFQUFFLDhCQUE4QjtBQUNwVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixFQUFFLGlCQUFpQixJQUFJLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLFFBQVEsV0FBVztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxjQUFjO0FBQy9DLDJDQUEyQyx1QkFBdUI7QUFDbEUsc0NBQXNDLHVCQUF1QjtBQUM3RDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLG9EQUFvRDs7QUFFcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQixrQkFBa0I7O0FBRWxCO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDBCQUEwQjtBQUMxQixJQUFJOztBQUVKO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7O0FBRWhCOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCLHlDQUF5QyxVQUFVO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjs7QUFFQSw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0EsaUZBQWlGOztBQUVqRjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQSxrQkFBa0I7O0FBRWxCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQSxrQkFBa0I7O0FBRWxCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsY0FBYztBQUM1QywyQ0FBMkMsdUJBQXVCO0FBQ2xFLHNDQUFzQyx1QkFBdUI7QUFDN0Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG9EQUFvRDtBQUNwRDs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0Esb0RBQW9EOztBQUVwRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDLFdBQVc7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNEJBQTRCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLGdFQUFnRTs7QUFFaEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7O0FBRUo7QUFDQSwrQ0FBK0M7O0FBRS9DOztBQUVBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQixzQkFBc0I7QUFDaEQsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0Esa0RBQWtEOztBQUVsRDs7QUFFQTtBQUNBLGtDQUFrQztBQUNsQyxrQ0FBa0M7QUFDbEMsa0NBQWtDO0FBQ2xDLGtDQUFrQzs7QUFFbEM7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTs7QUFFSjtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLGlDQUFpQztBQUNqQztBQUNBOztBQUVBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7O0FBRUEsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0EsOENBQThDOztBQUU5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBLE1BQU07QUFDTjs7QUFFQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsdUZBQXVGOztBQUV2RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0Esa0VBQWtFOztBQUVsRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsTUFBTTtBQUNOO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpRUFBaUUsMEJBQTBCO0FBQzNGOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvZGlzdC9sZWFmbGV0LXNyYy5qcz9hZjZhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIEBwcmVzZXJ2ZVxuICogTGVhZmxldCAxLjkuMywgYSBKUyBsaWJyYXJ5IGZvciBpbnRlcmFjdGl2ZSBtYXBzLiBodHRwczovL2xlYWZsZXRqcy5jb21cbiAqIChjKSAyMDEwLTIwMjIgVmxhZGltaXIgQWdhZm9ua2luLCAoYykgMjAxMC0yMDExIENsb3VkTWFkZVxuICovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwubGVhZmxldCA9IHt9KSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciB2ZXJzaW9uID0gXCIxLjkuM1wiO1xuXG4gIC8qXHJcbiAgICogQG5hbWVzcGFjZSBVdGlsXHJcbiAgICpcclxuICAgKiBWYXJpb3VzIHV0aWxpdHkgZnVuY3Rpb25zLCB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseS5cclxuICAgKi9cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGV4dGVuZChkZXN0OiBPYmplY3QsIHNyYz86IE9iamVjdCk6IE9iamVjdFxyXG4gIC8vIE1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiB0aGUgYHNyY2Agb2JqZWN0IChvciBtdWx0aXBsZSBvYmplY3RzKSBpbnRvIGBkZXN0YCBvYmplY3QgYW5kIHJldHVybnMgdGhlIGxhdHRlci4gSGFzIGFuIGBMLmV4dGVuZGAgc2hvcnRjdXQuXHJcbiAgZnVuY3Rpb24gZXh0ZW5kKGRlc3QpIHtcclxuICBcdHZhciBpLCBqLCBsZW4sIHNyYztcclxuXHJcbiAgXHRmb3IgKGogPSAxLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcclxuICBcdFx0c3JjID0gYXJndW1lbnRzW2pdO1xyXG4gIFx0XHRmb3IgKGkgaW4gc3JjKSB7XHJcbiAgXHRcdFx0ZGVzdFtpXSA9IHNyY1tpXTtcclxuICBcdFx0fVxyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIGRlc3Q7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gY3JlYXRlKHByb3RvOiBPYmplY3QsIHByb3BlcnRpZXM/OiBPYmplY3QpOiBPYmplY3RcclxuICAvLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbT2JqZWN0LmNyZWF0ZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2NyZWF0ZSlcclxuICB2YXIgY3JlYXRlJDIgPSBPYmplY3QuY3JlYXRlIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgXHRmdW5jdGlvbiBGKCkge31cclxuICBcdHJldHVybiBmdW5jdGlvbiAocHJvdG8pIHtcclxuICBcdFx0Ri5wcm90b3R5cGUgPSBwcm90bztcclxuICBcdFx0cmV0dXJuIG5ldyBGKCk7XHJcbiAgXHR9O1xyXG4gIH0pKCk7XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBiaW5kKGZuOiBGdW5jdGlvbiwg4oCmKTogRnVuY3Rpb25cclxuICAvLyBSZXR1cm5zIGEgbmV3IGZ1bmN0aW9uIGJvdW5kIHRvIHRoZSBhcmd1bWVudHMgcGFzc2VkLCBsaWtlIFtGdW5jdGlvbi5wcm90b3R5cGUuYmluZF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vYmluZCkuXHJcbiAgLy8gSGFzIGEgYEwuYmluZCgpYCBzaG9ydGN1dC5cclxuICBmdW5jdGlvbiBiaW5kKGZuLCBvYmopIHtcclxuICBcdHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcclxuXHJcbiAgXHRpZiAoZm4uYmluZCkge1xyXG4gIFx0XHRyZXR1cm4gZm4uYmluZC5hcHBseShmbiwgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcclxuICBcdH1cclxuXHJcbiAgXHR2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcclxuXHJcbiAgXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gZm4uYXBwbHkob2JqLCBhcmdzLmxlbmd0aCA/IGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkgOiBhcmd1bWVudHMpO1xyXG4gIFx0fTtcclxuICB9XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBsYXN0SWQ6IE51bWJlclxyXG4gIC8vIExhc3QgdW5pcXVlIElEIHVzZWQgYnkgW2BzdGFtcCgpYF0oI3V0aWwtc3RhbXApXHJcbiAgdmFyIGxhc3RJZCA9IDA7XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBzdGFtcChvYmo6IE9iamVjdCk6IE51bWJlclxyXG4gIC8vIFJldHVybnMgdGhlIHVuaXF1ZSBJRCBvZiBhbiBvYmplY3QsIGFzc2lnbmluZyBpdCBvbmUgaWYgaXQgZG9lc24ndCBoYXZlIGl0LlxyXG4gIGZ1bmN0aW9uIHN0YW1wKG9iaikge1xyXG4gIFx0aWYgKCEoJ19sZWFmbGV0X2lkJyBpbiBvYmopKSB7XHJcbiAgXHRcdG9ialsnX2xlYWZsZXRfaWQnXSA9ICsrbGFzdElkO1xyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIG9iai5fbGVhZmxldF9pZDtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiB0aHJvdHRsZShmbjogRnVuY3Rpb24sIHRpbWU6IE51bWJlciwgY29udGV4dDogT2JqZWN0KTogRnVuY3Rpb25cclxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggZXhlY3V0ZXMgZnVuY3Rpb24gYGZuYCB3aXRoIHRoZSBnaXZlbiBzY29wZSBgY29udGV4dGBcclxuICAvLyAoc28gdGhhdCB0aGUgYHRoaXNgIGtleXdvcmQgcmVmZXJzIHRvIGBjb250ZXh0YCBpbnNpZGUgYGZuYCdzIGNvZGUpLiBUaGUgZnVuY3Rpb25cclxuICAvLyBgZm5gIHdpbGwgYmUgY2FsbGVkIG5vIG1vcmUgdGhhbiBvbmUgdGltZSBwZXIgZ2l2ZW4gYW1vdW50IG9mIGB0aW1lYC4gVGhlIGFyZ3VtZW50c1xyXG4gIC8vIHJlY2VpdmVkIGJ5IHRoZSBib3VuZCBmdW5jdGlvbiB3aWxsIGJlIGFueSBhcmd1bWVudHMgcGFzc2VkIHdoZW4gYmluZGluZyB0aGVcclxuICAvLyBmdW5jdGlvbiwgZm9sbG93ZWQgYnkgYW55IGFyZ3VtZW50cyBwYXNzZWQgd2hlbiBpbnZva2luZyB0aGUgYm91bmQgZnVuY3Rpb24uXHJcbiAgLy8gSGFzIGFuIGBMLnRocm90dGxlYCBzaG9ydGN1dC5cclxuICBmdW5jdGlvbiB0aHJvdHRsZShmbiwgdGltZSwgY29udGV4dCkge1xyXG4gIFx0dmFyIGxvY2ssIGFyZ3MsIHdyYXBwZXJGbiwgbGF0ZXI7XHJcblxyXG4gIFx0bGF0ZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdC8vIHJlc2V0IGxvY2sgYW5kIGNhbGwgaWYgcXVldWVkXHJcbiAgXHRcdGxvY2sgPSBmYWxzZTtcclxuICBcdFx0aWYgKGFyZ3MpIHtcclxuICBcdFx0XHR3cmFwcGVyRm4uYXBwbHkoY29udGV4dCwgYXJncyk7XHJcbiAgXHRcdFx0YXJncyA9IGZhbHNlO1xyXG4gIFx0XHR9XHJcbiAgXHR9O1xyXG5cclxuICBcdHdyYXBwZXJGbiA9IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKGxvY2spIHtcclxuICBcdFx0XHQvLyBjYWxsZWQgdG9vIHNvb24sIHF1ZXVlIHRvIGNhbGwgbGF0ZXJcclxuICBcdFx0XHRhcmdzID0gYXJndW1lbnRzO1xyXG5cclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHQvLyBjYWxsIGFuZCBsb2NrIHVudGlsIGxhdGVyXHJcbiAgXHRcdFx0Zm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcclxuICBcdFx0XHRzZXRUaW1lb3V0KGxhdGVyLCB0aW1lKTtcclxuICBcdFx0XHRsb2NrID0gdHJ1ZTtcclxuICBcdFx0fVxyXG4gIFx0fTtcclxuXHJcbiAgXHRyZXR1cm4gd3JhcHBlckZuO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHdyYXBOdW0obnVtOiBOdW1iZXIsIHJhbmdlOiBOdW1iZXJbXSwgaW5jbHVkZU1heD86IEJvb2xlYW4pOiBOdW1iZXJcclxuICAvLyBSZXR1cm5zIHRoZSBudW1iZXIgYG51bWAgbW9kdWxvIGByYW5nZWAgaW4gc3VjaCBhIHdheSBzbyBpdCBsaWVzIHdpdGhpblxyXG4gIC8vIGByYW5nZVswXWAgYW5kIGByYW5nZVsxXWAuIFRoZSByZXR1cm5lZCB2YWx1ZSB3aWxsIGJlIGFsd2F5cyBzbWFsbGVyIHRoYW5cclxuICAvLyBgcmFuZ2VbMV1gIHVubGVzcyBgaW5jbHVkZU1heGAgaXMgc2V0IHRvIGB0cnVlYC5cclxuICBmdW5jdGlvbiB3cmFwTnVtKHgsIHJhbmdlLCBpbmNsdWRlTWF4KSB7XHJcbiAgXHR2YXIgbWF4ID0gcmFuZ2VbMV0sXHJcbiAgXHQgICAgbWluID0gcmFuZ2VbMF0sXHJcbiAgXHQgICAgZCA9IG1heCAtIG1pbjtcclxuICBcdHJldHVybiB4ID09PSBtYXggJiYgaW5jbHVkZU1heCA/IHggOiAoKHggLSBtaW4pICUgZCArIGQpICUgZCArIG1pbjtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBmYWxzZUZuKCk6IEZ1bmN0aW9uXHJcbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGFsd2F5cyByZXR1cm5zIGBmYWxzZWAuXHJcbiAgZnVuY3Rpb24gZmFsc2VGbigpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBmb3JtYXROdW0obnVtOiBOdW1iZXIsIHByZWNpc2lvbj86IE51bWJlcnxmYWxzZSk6IE51bWJlclxyXG4gIC8vIFJldHVybnMgdGhlIG51bWJlciBgbnVtYCByb3VuZGVkIHdpdGggc3BlY2lmaWVkIGBwcmVjaXNpb25gLlxyXG4gIC8vIFRoZSBkZWZhdWx0IGBwcmVjaXNpb25gIHZhbHVlIGlzIDYgZGVjaW1hbCBwbGFjZXMuXHJcbiAgLy8gYGZhbHNlYCBjYW4gYmUgcGFzc2VkIHRvIHNraXAgYW55IHByb2Nlc3NpbmcgKGNhbiBiZSB1c2VmdWwgdG8gYXZvaWQgcm91bmQtb2ZmIGVycm9ycykuXHJcbiAgZnVuY3Rpb24gZm9ybWF0TnVtKG51bSwgcHJlY2lzaW9uKSB7XHJcbiAgXHRpZiAocHJlY2lzaW9uID09PSBmYWxzZSkgeyByZXR1cm4gbnVtOyB9XHJcbiAgXHR2YXIgcG93ID0gTWF0aC5wb3coMTAsIHByZWNpc2lvbiA9PT0gdW5kZWZpbmVkID8gNiA6IHByZWNpc2lvbik7XHJcbiAgXHRyZXR1cm4gTWF0aC5yb3VuZChudW0gKiBwb3cpIC8gcG93O1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHRyaW0oc3RyOiBTdHJpbmcpOiBTdHJpbmdcclxuICAvLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbU3RyaW5nLnByb3RvdHlwZS50cmltXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvVHJpbSlcclxuICBmdW5jdGlvbiB0cmltKHN0cikge1xyXG4gIFx0cmV0dXJuIHN0ci50cmltID8gc3RyLnRyaW0oKSA6IHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gc3BsaXRXb3JkcyhzdHI6IFN0cmluZyk6IFN0cmluZ1tdXHJcbiAgLy8gVHJpbXMgYW5kIHNwbGl0cyB0aGUgc3RyaW5nIG9uIHdoaXRlc3BhY2UgYW5kIHJldHVybnMgdGhlIGFycmF5IG9mIHBhcnRzLlxyXG4gIGZ1bmN0aW9uIHNwbGl0V29yZHMoc3RyKSB7XHJcbiAgXHRyZXR1cm4gdHJpbShzdHIpLnNwbGl0KC9cXHMrLyk7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gc2V0T3B0aW9ucyhvYmo6IE9iamVjdCwgb3B0aW9uczogT2JqZWN0KTogT2JqZWN0XHJcbiAgLy8gTWVyZ2VzIHRoZSBnaXZlbiBwcm9wZXJ0aWVzIHRvIHRoZSBgb3B0aW9uc2Agb2YgdGhlIGBvYmpgIG9iamVjdCwgcmV0dXJuaW5nIHRoZSByZXN1bHRpbmcgb3B0aW9ucy4gU2VlIGBDbGFzcyBvcHRpb25zYC4gSGFzIGFuIGBMLnNldE9wdGlvbnNgIHNob3J0Y3V0LlxyXG4gIGZ1bmN0aW9uIHNldE9wdGlvbnMob2JqLCBvcHRpb25zKSB7XHJcbiAgXHRpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosICdvcHRpb25zJykpIHtcclxuICBcdFx0b2JqLm9wdGlvbnMgPSBvYmoub3B0aW9ucyA/IGNyZWF0ZSQyKG9iai5vcHRpb25zKSA6IHt9O1xyXG4gIFx0fVxyXG4gIFx0Zm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XHJcbiAgXHRcdG9iai5vcHRpb25zW2ldID0gb3B0aW9uc1tpXTtcclxuICBcdH1cclxuICBcdHJldHVybiBvYmoub3B0aW9ucztcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBnZXRQYXJhbVN0cmluZyhvYmo6IE9iamVjdCwgZXhpc3RpbmdVcmw/OiBTdHJpbmcsIHVwcGVyY2FzZT86IEJvb2xlYW4pOiBTdHJpbmdcclxuICAvLyBDb252ZXJ0cyBhbiBvYmplY3QgaW50byBhIHBhcmFtZXRlciBVUkwgc3RyaW5nLCBlLmcuIGB7YTogXCJmb29cIiwgYjogXCJiYXJcIn1gXHJcbiAgLy8gdHJhbnNsYXRlcyB0byBgJz9hPWZvbyZiPWJhcidgLiBJZiBgZXhpc3RpbmdVcmxgIGlzIHNldCwgdGhlIHBhcmFtZXRlcnMgd2lsbFxyXG4gIC8vIGJlIGFwcGVuZGVkIGF0IHRoZSBlbmQuIElmIGB1cHBlcmNhc2VgIGlzIGB0cnVlYCwgdGhlIHBhcmFtZXRlciBuYW1lcyB3aWxsXHJcbiAgLy8gYmUgdXBwZXJjYXNlZCAoZS5nLiBgJz9BPWZvbyZCPWJhcidgKVxyXG4gIGZ1bmN0aW9uIGdldFBhcmFtU3RyaW5nKG9iaiwgZXhpc3RpbmdVcmwsIHVwcGVyY2FzZSkge1xyXG4gIFx0dmFyIHBhcmFtcyA9IFtdO1xyXG4gIFx0Zm9yICh2YXIgaSBpbiBvYmopIHtcclxuICBcdFx0cGFyYW1zLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KHVwcGVyY2FzZSA/IGkudG9VcHBlckNhc2UoKSA6IGkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9ialtpXSkpO1xyXG4gIFx0fVxyXG4gIFx0cmV0dXJuICgoIWV4aXN0aW5nVXJsIHx8IGV4aXN0aW5nVXJsLmluZGV4T2YoJz8nKSA9PT0gLTEpID8gJz8nIDogJyYnKSArIHBhcmFtcy5qb2luKCcmJyk7XHJcbiAgfVxyXG5cclxuICB2YXIgdGVtcGxhdGVSZSA9IC9cXHsgKihbXFx3XyAtXSspICpcXH0vZztcclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHRlbXBsYXRlKHN0cjogU3RyaW5nLCBkYXRhOiBPYmplY3QpOiBTdHJpbmdcclxuICAvLyBTaW1wbGUgdGVtcGxhdGluZyBmYWNpbGl0eSwgYWNjZXB0cyBhIHRlbXBsYXRlIHN0cmluZyBvZiB0aGUgZm9ybSBgJ0hlbGxvIHthfSwge2J9J2BcclxuICAvLyBhbmQgYSBkYXRhIG9iamVjdCBsaWtlIGB7YTogJ2ZvbycsIGI6ICdiYXInfWAsIHJldHVybnMgZXZhbHVhdGVkIHN0cmluZ1xyXG4gIC8vIGAoJ0hlbGxvIGZvbywgYmFyJylgLiBZb3UgY2FuIGFsc28gc3BlY2lmeSBmdW5jdGlvbnMgaW5zdGVhZCBvZiBzdHJpbmdzIGZvclxyXG4gIC8vIGRhdGEgdmFsdWVzIOKAlCB0aGV5IHdpbGwgYmUgZXZhbHVhdGVkIHBhc3NpbmcgYGRhdGFgIGFzIGFuIGFyZ3VtZW50LlxyXG4gIGZ1bmN0aW9uIHRlbXBsYXRlKHN0ciwgZGF0YSkge1xyXG4gIFx0cmV0dXJuIHN0ci5yZXBsYWNlKHRlbXBsYXRlUmUsIGZ1bmN0aW9uIChzdHIsIGtleSkge1xyXG4gIFx0XHR2YXIgdmFsdWUgPSBkYXRhW2tleV07XHJcblxyXG4gIFx0XHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcignTm8gdmFsdWUgcHJvdmlkZWQgZm9yIHZhcmlhYmxlICcgKyBzdHIpO1xyXG5cclxuICBcdFx0fSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcclxuICBcdFx0XHR2YWx1ZSA9IHZhbHVlKGRhdGEpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB2YWx1ZTtcclxuICBcdH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGlzQXJyYXkob2JqKTogQm9vbGVhblxyXG4gIC8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtBcnJheS5pc0FycmF5XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pc0FycmF5KVxyXG4gIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAob2JqKSB7XHJcbiAgXHRyZXR1cm4gKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nKTtcclxuICB9O1xyXG5cclxuICAvLyBAZnVuY3Rpb24gaW5kZXhPZihhcnJheTogQXJyYXksIGVsOiBPYmplY3QpOiBOdW1iZXJcclxuICAvLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbQXJyYXkucHJvdG90eXBlLmluZGV4T2ZdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2luZGV4T2YpXHJcbiAgZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgZWwpIHtcclxuICBcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICBcdFx0aWYgKGFycmF5W2ldID09PSBlbCkgeyByZXR1cm4gaTsgfVxyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIC0xO1xyXG4gIH1cclxuXHJcbiAgLy8gQHByb3BlcnR5IGVtcHR5SW1hZ2VVcmw6IFN0cmluZ1xyXG4gIC8vIERhdGEgVVJJIHN0cmluZyBjb250YWluaW5nIGEgYmFzZTY0LWVuY29kZWQgZW1wdHkgR0lGIGltYWdlLlxyXG4gIC8vIFVzZWQgYXMgYSBoYWNrIHRvIGZyZWUgbWVtb3J5IGZyb20gdW51c2VkIGltYWdlcyBvbiBXZWJLaXQtcG93ZXJlZFxyXG4gIC8vIG1vYmlsZSBkZXZpY2VzIChieSBzZXR0aW5nIGltYWdlIGBzcmNgIHRvIHRoaXMgc3RyaW5nKS5cclxuICB2YXIgZW1wdHlJbWFnZVVybCA9ICdkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUFEL0FDd0FBQUFBQVFBQkFBQUNBRHM9JztcclxuXHJcbiAgLy8gaW5zcGlyZWQgYnkgaHR0cHM6Ly9wYXVsaXJpc2guY29tLzIwMTEvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1hbmltYXRpbmcvXHJcblxyXG4gIGZ1bmN0aW9uIGdldFByZWZpeGVkKG5hbWUpIHtcclxuICBcdHJldHVybiB3aW5kb3dbJ3dlYmtpdCcgKyBuYW1lXSB8fCB3aW5kb3dbJ21veicgKyBuYW1lXSB8fCB3aW5kb3dbJ21zJyArIG5hbWVdO1xyXG4gIH1cclxuXHJcbiAgdmFyIGxhc3RUaW1lID0gMDtcclxuXHJcbiAgLy8gZmFsbGJhY2sgZm9yIElFIDctOFxyXG4gIGZ1bmN0aW9uIHRpbWVvdXREZWZlcihmbikge1xyXG4gIFx0dmFyIHRpbWUgPSArbmV3IERhdGUoKSxcclxuICBcdCAgICB0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYgLSAodGltZSAtIGxhc3RUaW1lKSk7XHJcblxyXG4gIFx0bGFzdFRpbWUgPSB0aW1lICsgdGltZVRvQ2FsbDtcclxuICBcdHJldHVybiB3aW5kb3cuc2V0VGltZW91dChmbiwgdGltZVRvQ2FsbCk7XHJcbiAgfVxyXG5cclxuICB2YXIgcmVxdWVzdEZuID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBnZXRQcmVmaXhlZCgnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJykgfHwgdGltZW91dERlZmVyO1xyXG4gIHZhciBjYW5jZWxGbiA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fCBnZXRQcmVmaXhlZCgnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnKSB8fFxyXG4gIFx0XHRnZXRQcmVmaXhlZCgnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJykgfHwgZnVuY3Rpb24gKGlkKSB7IHdpbmRvdy5jbGVhclRpbWVvdXQoaWQpOyB9O1xyXG5cclxuICAvLyBAZnVuY3Rpb24gcmVxdWVzdEFuaW1GcmFtZShmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QsIGltbWVkaWF0ZT86IEJvb2xlYW4pOiBOdW1iZXJcclxuICAvLyBTY2hlZHVsZXMgYGZuYCB0byBiZSBleGVjdXRlZCB3aGVuIHRoZSBicm93c2VyIHJlcGFpbnRzLiBgZm5gIGlzIGJvdW5kIHRvXHJcbiAgLy8gYGNvbnRleHRgIGlmIGdpdmVuLiBXaGVuIGBpbW1lZGlhdGVgIGlzIHNldCwgYGZuYCBpcyBjYWxsZWQgaW1tZWRpYXRlbHkgaWZcclxuICAvLyB0aGUgYnJvd3NlciBkb2Vzbid0IGhhdmUgbmF0aXZlIHN1cHBvcnQgZm9yXHJcbiAgLy8gW2B3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL3dpbmRvdy9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpLFxyXG4gIC8vIG90aGVyd2lzZSBpdCdzIGRlbGF5ZWQuIFJldHVybnMgYSByZXF1ZXN0IElEIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2FuY2VsIHRoZSByZXF1ZXN0LlxyXG4gIGZ1bmN0aW9uIHJlcXVlc3RBbmltRnJhbWUoZm4sIGNvbnRleHQsIGltbWVkaWF0ZSkge1xyXG4gIFx0aWYgKGltbWVkaWF0ZSAmJiByZXF1ZXN0Rm4gPT09IHRpbWVvdXREZWZlcikge1xyXG4gIFx0XHRmbi5jYWxsKGNvbnRleHQpO1xyXG4gIFx0fSBlbHNlIHtcclxuICBcdFx0cmV0dXJuIHJlcXVlc3RGbi5jYWxsKHdpbmRvdywgYmluZChmbiwgY29udGV4dCkpO1xyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGNhbmNlbEFuaW1GcmFtZShpZDogTnVtYmVyKTogdW5kZWZpbmVkXHJcbiAgLy8gQ2FuY2VscyBhIHByZXZpb3VzIGByZXF1ZXN0QW5pbUZyYW1lYC4gU2VlIGFsc28gW3dpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL3dpbmRvdy9jYW5jZWxBbmltYXRpb25GcmFtZSkuXHJcbiAgZnVuY3Rpb24gY2FuY2VsQW5pbUZyYW1lKGlkKSB7XHJcbiAgXHRpZiAoaWQpIHtcclxuICBcdFx0Y2FuY2VsRm4uY2FsbCh3aW5kb3csIGlkKTtcclxuICBcdH1cclxuICB9XG5cbiAgdmFyIFV0aWwgPSB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGV4dGVuZDogZXh0ZW5kLFxuICAgIGNyZWF0ZTogY3JlYXRlJDIsXG4gICAgYmluZDogYmluZCxcbiAgICBnZXQgbGFzdElkICgpIHsgcmV0dXJuIGxhc3RJZDsgfSxcbiAgICBzdGFtcDogc3RhbXAsXG4gICAgdGhyb3R0bGU6IHRocm90dGxlLFxuICAgIHdyYXBOdW06IHdyYXBOdW0sXG4gICAgZmFsc2VGbjogZmFsc2VGbixcbiAgICBmb3JtYXROdW06IGZvcm1hdE51bSxcbiAgICB0cmltOiB0cmltLFxuICAgIHNwbGl0V29yZHM6IHNwbGl0V29yZHMsXG4gICAgc2V0T3B0aW9uczogc2V0T3B0aW9ucyxcbiAgICBnZXRQYXJhbVN0cmluZzogZ2V0UGFyYW1TdHJpbmcsXG4gICAgdGVtcGxhdGU6IHRlbXBsYXRlLFxuICAgIGlzQXJyYXk6IGlzQXJyYXksXG4gICAgaW5kZXhPZjogaW5kZXhPZixcbiAgICBlbXB0eUltYWdlVXJsOiBlbXB0eUltYWdlVXJsLFxuICAgIHJlcXVlc3RGbjogcmVxdWVzdEZuLFxuICAgIGNhbmNlbEZuOiBjYW5jZWxGbixcbiAgICByZXF1ZXN0QW5pbUZyYW1lOiByZXF1ZXN0QW5pbUZyYW1lLFxuICAgIGNhbmNlbEFuaW1GcmFtZTogY2FuY2VsQW5pbUZyYW1lXG4gIH07XG5cbiAgLy8gQGNsYXNzIENsYXNzXHJcbiAgLy8gQGFrYSBMLkNsYXNzXHJcblxyXG4gIC8vIEBzZWN0aW9uXHJcbiAgLy8gQHVuaW5oZXJpdGFibGVcclxuXHJcbiAgLy8gVGhhbmtzIHRvIEpvaG4gUmVzaWcgYW5kIERlYW4gRWR3YXJkcyBmb3IgaW5zcGlyYXRpb24hXHJcblxyXG4gIGZ1bmN0aW9uIENsYXNzKCkge31cclxuXHJcbiAgQ2xhc3MuZXh0ZW5kID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcblxyXG4gIFx0Ly8gQGZ1bmN0aW9uIGV4dGVuZChwcm9wczogT2JqZWN0KTogRnVuY3Rpb25cclxuICBcdC8vIFtFeHRlbmRzIHRoZSBjdXJyZW50IGNsYXNzXSgjY2xhc3MtaW5oZXJpdGFuY2UpIGdpdmVuIHRoZSBwcm9wZXJ0aWVzIHRvIGJlIGluY2x1ZGVkLlxyXG4gIFx0Ly8gUmV0dXJucyBhIEphdmFzY3JpcHQgZnVuY3Rpb24gdGhhdCBpcyBhIGNsYXNzIGNvbnN0cnVjdG9yICh0byBiZSBjYWxsZWQgd2l0aCBgbmV3YCkuXHJcbiAgXHR2YXIgTmV3Q2xhc3MgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gIFx0XHRzZXRPcHRpb25zKHRoaXMpO1xyXG5cclxuICBcdFx0Ly8gY2FsbCB0aGUgY29uc3RydWN0b3JcclxuICBcdFx0aWYgKHRoaXMuaW5pdGlhbGl6ZSkge1xyXG4gIFx0XHRcdHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBjYWxsIGFsbCBjb25zdHJ1Y3RvciBob29rc1xyXG4gIFx0XHR0aGlzLmNhbGxJbml0SG9va3MoKTtcclxuICBcdH07XHJcblxyXG4gIFx0dmFyIHBhcmVudFByb3RvID0gTmV3Q2xhc3MuX19zdXBlcl9fID0gdGhpcy5wcm90b3R5cGU7XHJcblxyXG4gIFx0dmFyIHByb3RvID0gY3JlYXRlJDIocGFyZW50UHJvdG8pO1xyXG4gIFx0cHJvdG8uY29uc3RydWN0b3IgPSBOZXdDbGFzcztcclxuXHJcbiAgXHROZXdDbGFzcy5wcm90b3R5cGUgPSBwcm90bztcclxuXHJcbiAgXHQvLyBpbmhlcml0IHBhcmVudCdzIHN0YXRpY3NcclxuICBcdGZvciAodmFyIGkgaW4gdGhpcykge1xyXG4gIFx0XHRpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsIGkpICYmIGkgIT09ICdwcm90b3R5cGUnICYmIGkgIT09ICdfX3N1cGVyX18nKSB7XHJcbiAgXHRcdFx0TmV3Q2xhc3NbaV0gPSB0aGlzW2ldO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcblxyXG4gIFx0Ly8gbWl4IHN0YXRpYyBwcm9wZXJ0aWVzIGludG8gdGhlIGNsYXNzXHJcbiAgXHRpZiAocHJvcHMuc3RhdGljcykge1xyXG4gIFx0XHRleHRlbmQoTmV3Q2xhc3MsIHByb3BzLnN0YXRpY3MpO1xyXG4gIFx0fVxyXG5cclxuICBcdC8vIG1peCBpbmNsdWRlcyBpbnRvIHRoZSBwcm90b3R5cGVcclxuICBcdGlmIChwcm9wcy5pbmNsdWRlcykge1xyXG4gIFx0XHRjaGVja0RlcHJlY2F0ZWRNaXhpbkV2ZW50cyhwcm9wcy5pbmNsdWRlcyk7XHJcbiAgXHRcdGV4dGVuZC5hcHBseShudWxsLCBbcHJvdG9dLmNvbmNhdChwcm9wcy5pbmNsdWRlcykpO1xyXG4gIFx0fVxyXG5cclxuICBcdC8vIG1peCBnaXZlbiBwcm9wZXJ0aWVzIGludG8gdGhlIHByb3RvdHlwZVxyXG4gIFx0ZXh0ZW5kKHByb3RvLCBwcm9wcyk7XHJcbiAgXHRkZWxldGUgcHJvdG8uc3RhdGljcztcclxuICBcdGRlbGV0ZSBwcm90by5pbmNsdWRlcztcclxuXHJcbiAgXHQvLyBtZXJnZSBvcHRpb25zXHJcbiAgXHRpZiAocHJvdG8ub3B0aW9ucykge1xyXG4gIFx0XHRwcm90by5vcHRpb25zID0gcGFyZW50UHJvdG8ub3B0aW9ucyA/IGNyZWF0ZSQyKHBhcmVudFByb3RvLm9wdGlvbnMpIDoge307XHJcbiAgXHRcdGV4dGVuZChwcm90by5vcHRpb25zLCBwcm9wcy5vcHRpb25zKTtcclxuICBcdH1cclxuXHJcbiAgXHRwcm90by5faW5pdEhvb2tzID0gW107XHJcblxyXG4gIFx0Ly8gYWRkIG1ldGhvZCBmb3IgY2FsbGluZyBhbGwgaG9va3NcclxuICBcdHByb3RvLmNhbGxJbml0SG9va3MgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5faW5pdEhvb2tzQ2FsbGVkKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0aWYgKHBhcmVudFByb3RvLmNhbGxJbml0SG9va3MpIHtcclxuICBcdFx0XHRwYXJlbnRQcm90by5jYWxsSW5pdEhvb2tzLmNhbGwodGhpcyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2luaXRIb29rc0NhbGxlZCA9IHRydWU7XHJcblxyXG4gIFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gcHJvdG8uX2luaXRIb29rcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRcdHByb3RvLl9pbml0SG9va3NbaV0uY2FsbCh0aGlzKTtcclxuICBcdFx0fVxyXG4gIFx0fTtcclxuXHJcbiAgXHRyZXR1cm4gTmV3Q2xhc3M7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8vIEBmdW5jdGlvbiBpbmNsdWRlKHByb3BlcnRpZXM6IE9iamVjdCk6IHRoaXNcclxuICAvLyBbSW5jbHVkZXMgYSBtaXhpbl0oI2NsYXNzLWluY2x1ZGVzKSBpbnRvIHRoZSBjdXJyZW50IGNsYXNzLlxyXG4gIENsYXNzLmluY2x1ZGUgPSBmdW5jdGlvbiAocHJvcHMpIHtcclxuICBcdHZhciBwYXJlbnRPcHRpb25zID0gdGhpcy5wcm90b3R5cGUub3B0aW9ucztcclxuICBcdGV4dGVuZCh0aGlzLnByb3RvdHlwZSwgcHJvcHMpO1xyXG4gIFx0aWYgKHByb3BzLm9wdGlvbnMpIHtcclxuICBcdFx0dGhpcy5wcm90b3R5cGUub3B0aW9ucyA9IHBhcmVudE9wdGlvbnM7XHJcbiAgXHRcdHRoaXMubWVyZ2VPcHRpb25zKHByb3BzLm9wdGlvbnMpO1xyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgLy8gQGZ1bmN0aW9uIG1lcmdlT3B0aW9ucyhvcHRpb25zOiBPYmplY3QpOiB0aGlzXHJcbiAgLy8gW01lcmdlcyBgb3B0aW9uc2BdKCNjbGFzcy1vcHRpb25zKSBpbnRvIHRoZSBkZWZhdWx0cyBvZiB0aGUgY2xhc3MuXHJcbiAgQ2xhc3MubWVyZ2VPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICBcdGV4dGVuZCh0aGlzLnByb3RvdHlwZS5vcHRpb25zLCBvcHRpb25zKTtcclxuICBcdHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBhZGRJbml0SG9vayhmbjogRnVuY3Rpb24pOiB0aGlzXHJcbiAgLy8gQWRkcyBhIFtjb25zdHJ1Y3RvciBob29rXSgjY2xhc3MtY29uc3RydWN0b3ItaG9va3MpIHRvIHRoZSBjbGFzcy5cclxuICBDbGFzcy5hZGRJbml0SG9vayA9IGZ1bmN0aW9uIChmbikgeyAvLyAoRnVuY3Rpb24pIHx8IChTdHJpbmcsIGFyZ3MuLi4pXHJcbiAgXHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcblxyXG4gIFx0dmFyIGluaXQgPSB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgPyBmbiA6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dGhpc1tmbl0uYXBwbHkodGhpcywgYXJncyk7XHJcbiAgXHR9O1xyXG5cclxuICBcdHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MgPSB0aGlzLnByb3RvdHlwZS5faW5pdEhvb2tzIHx8IFtdO1xyXG4gIFx0dGhpcy5wcm90b3R5cGUuX2luaXRIb29rcy5wdXNoKGluaXQpO1xyXG4gIFx0cmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gY2hlY2tEZXByZWNhdGVkTWl4aW5FdmVudHMoaW5jbHVkZXMpIHtcclxuICBcdC8qIGdsb2JhbCBMOiB0cnVlICovXHJcbiAgXHRpZiAodHlwZW9mIEwgPT09ICd1bmRlZmluZWQnIHx8ICFMIHx8ICFMLk1peGluKSB7IHJldHVybjsgfVxyXG5cclxuICBcdGluY2x1ZGVzID0gaXNBcnJheShpbmNsdWRlcykgPyBpbmNsdWRlcyA6IFtpbmNsdWRlc107XHJcblxyXG4gIFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBpbmNsdWRlcy5sZW5ndGg7IGkrKykge1xyXG4gIFx0XHRpZiAoaW5jbHVkZXNbaV0gPT09IEwuTWl4aW4uRXZlbnRzKSB7XHJcbiAgXHRcdFx0Y29uc29sZS53YXJuKCdEZXByZWNhdGVkIGluY2x1ZGUgb2YgTC5NaXhpbi5FdmVudHM6ICcgK1xyXG4gIFx0XHRcdFx0J3RoaXMgcHJvcGVydHkgd2lsbCBiZSByZW1vdmVkIGluIGZ1dHVyZSByZWxlYXNlcywgJyArXHJcbiAgXHRcdFx0XHQncGxlYXNlIGluaGVyaXQgZnJvbSBMLkV2ZW50ZWQgaW5zdGVhZC4nLCBuZXcgRXJyb3IoKS5zdGFjayk7XHJcbiAgXHRcdH1cclxuICBcdH1cclxuICB9XG5cbiAgLypcclxuICAgKiBAY2xhc3MgRXZlbnRlZFxyXG4gICAqIEBha2EgTC5FdmVudGVkXHJcbiAgICogQGluaGVyaXRzIENsYXNzXHJcbiAgICpcclxuICAgKiBBIHNldCBvZiBtZXRob2RzIHNoYXJlZCBiZXR3ZWVuIGV2ZW50LXBvd2VyZWQgY2xhc3NlcyAobGlrZSBgTWFwYCBhbmQgYE1hcmtlcmApLiBHZW5lcmFsbHksIGV2ZW50cyBhbGxvdyB5b3UgdG8gZXhlY3V0ZSBzb21lIGZ1bmN0aW9uIHdoZW4gc29tZXRoaW5nIGhhcHBlbnMgd2l0aCBhbiBvYmplY3QgKGUuZy4gdGhlIHVzZXIgY2xpY2tzIG9uIHRoZSBtYXAsIGNhdXNpbmcgdGhlIG1hcCB0byBmaXJlIGAnY2xpY2snYCBldmVudCkuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiBtYXAub24oJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xyXG4gICAqIFx0YWxlcnQoZS5sYXRsbmcpO1xyXG4gICAqIH0gKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIExlYWZsZXQgZGVhbHMgd2l0aCBldmVudCBsaXN0ZW5lcnMgYnkgcmVmZXJlbmNlLCBzbyBpZiB5b3Ugd2FudCB0byBhZGQgYSBsaXN0ZW5lciBhbmQgdGhlbiByZW1vdmUgaXQsIGRlZmluZSBpdCBhcyBhIGZ1bmN0aW9uOlxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiBmdW5jdGlvbiBvbkNsaWNrKGUpIHsgLi4uIH1cclxuICAgKlxyXG4gICAqIG1hcC5vbignY2xpY2snLCBvbkNsaWNrKTtcclxuICAgKiBtYXAub2ZmKCdjbGljaycsIG9uQ2xpY2spO1xyXG4gICAqIGBgYFxyXG4gICAqL1xyXG5cclxuICB2YXIgRXZlbnRzID0ge1xyXG4gIFx0LyogQG1ldGhvZCBvbih0eXBlOiBTdHJpbmcsIGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuICBcdCAqIEFkZHMgYSBsaXN0ZW5lciBmdW5jdGlvbiAoYGZuYCkgdG8gYSBwYXJ0aWN1bGFyIGV2ZW50IHR5cGUgb2YgdGhlIG9iamVjdC4gWW91IGNhbiBvcHRpb25hbGx5IHNwZWNpZnkgdGhlIGNvbnRleHQgb2YgdGhlIGxpc3RlbmVyIChvYmplY3QgdGhlIHRoaXMga2V5d29yZCB3aWxsIHBvaW50IHRvKS4gWW91IGNhbiBhbHNvIHBhc3Mgc2V2ZXJhbCBzcGFjZS1zZXBhcmF0ZWQgdHlwZXMgKGUuZy4gYCdjbGljayBkYmxjbGljaydgKS5cclxuICBcdCAqXHJcbiAgXHQgKiBAYWx0ZXJuYXRpdmVcclxuICBcdCAqIEBtZXRob2Qgb24oZXZlbnRNYXA6IE9iamVjdCk6IHRoaXNcclxuICBcdCAqIEFkZHMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycywgZS5nLiBge2NsaWNrOiBvbkNsaWNrLCBtb3VzZW1vdmU6IG9uTW91c2VNb3ZlfWBcclxuICBcdCAqL1xyXG4gIFx0b246IGZ1bmN0aW9uICh0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcbiAgXHRcdC8vIHR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xyXG4gIFx0XHRpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG4gIFx0XHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuICBcdFx0XHRcdC8vIHdlIGRvbid0IHByb2Nlc3Mgc3BhY2Utc2VwYXJhdGVkIGV2ZW50cyBoZXJlIGZvciBwZXJmb3JtYW5jZTtcclxuICBcdFx0XHRcdC8vIGl0J3MgYSBob3QgcGF0aCBzaW5jZSBMYXllciB1c2VzIHRoZSBvbihvYmopIHN5bnRheFxyXG4gIFx0XHRcdFx0dGhpcy5fb24odHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuICBcdFx0XHR9XHJcblxyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdC8vIHR5cGVzIGNhbiBiZSBhIHN0cmluZyBvZiBzcGFjZS1zZXBhcmF0ZWQgd29yZHNcclxuICBcdFx0XHR0eXBlcyA9IHNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuICBcdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0XHRcdHRoaXMuX29uKHR5cGVzW2ldLCBmbiwgY29udGV4dCk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0LyogQG1ldGhvZCBvZmYodHlwZTogU3RyaW5nLCBmbj86IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG4gIFx0ICogUmVtb3ZlcyBhIHByZXZpb3VzbHkgYWRkZWQgbGlzdGVuZXIgZnVuY3Rpb24uIElmIG5vIGZ1bmN0aW9uIGlzIHNwZWNpZmllZCwgaXQgd2lsbCByZW1vdmUgYWxsIHRoZSBsaXN0ZW5lcnMgb2YgdGhhdCBwYXJ0aWN1bGFyIGV2ZW50IGZyb20gdGhlIG9iamVjdC4gTm90ZSB0aGF0IGlmIHlvdSBwYXNzZWQgYSBjdXN0b20gY29udGV4dCB0byBgb25gLCB5b3UgbXVzdCBwYXNzIHRoZSBzYW1lIGNvbnRleHQgdG8gYG9mZmAgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lci5cclxuICBcdCAqXHJcbiAgXHQgKiBAYWx0ZXJuYXRpdmVcclxuICBcdCAqIEBtZXRob2Qgb2ZmKGV2ZW50TWFwOiBPYmplY3QpOiB0aGlzXHJcbiAgXHQgKiBSZW1vdmVzIGEgc2V0IG9mIHR5cGUvbGlzdGVuZXIgcGFpcnMuXHJcbiAgXHQgKlxyXG4gIFx0ICogQGFsdGVybmF0aXZlXHJcbiAgXHQgKiBAbWV0aG9kIG9mZjogdGhpc1xyXG4gIFx0ICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzIHRvIGFsbCBldmVudHMgb24gdGhlIG9iamVjdC4gVGhpcyBpbmNsdWRlcyBpbXBsaWNpdGx5IGF0dGFjaGVkIGV2ZW50cy5cclxuICBcdCAqL1xyXG4gIFx0b2ZmOiBmdW5jdGlvbiAodHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG4gIFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICBcdFx0XHQvLyBjbGVhciBhbGwgbGlzdGVuZXJzIGlmIGNhbGxlZCB3aXRob3V0IGFyZ3VtZW50c1xyXG4gIFx0XHRcdGRlbGV0ZSB0aGlzLl9ldmVudHM7XHJcblxyXG4gIFx0XHR9IGVsc2UgaWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuICBcdFx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcbiAgXHRcdFx0XHR0aGlzLl9vZmYodHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuICBcdFx0XHR9XHJcblxyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdHR5cGVzID0gc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG4gIFx0XHRcdHZhciByZW1vdmVBbGwgPSBhcmd1bWVudHMubGVuZ3RoID09PSAxO1xyXG4gIFx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRcdFx0aWYgKHJlbW92ZUFsbCkge1xyXG4gIFx0XHRcdFx0XHR0aGlzLl9vZmYodHlwZXNbaV0pO1xyXG4gIFx0XHRcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRcdFx0dGhpcy5fb2ZmKHR5cGVzW2ldLCBmbiwgY29udGV4dCk7XHJcbiAgXHRcdFx0XHR9XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gYXR0YWNoIGxpc3RlbmVyICh3aXRob3V0IHN5bnRhY3RpYyBzdWdhciBub3cpXHJcbiAgXHRfb246IGZ1bmN0aW9uICh0eXBlLCBmbiwgY29udGV4dCwgX29uY2UpIHtcclxuICBcdFx0aWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gIFx0XHRcdGNvbnNvbGUud2Fybignd3JvbmcgbGlzdGVuZXIgdHlwZTogJyArIHR5cGVvZiBmbik7XHJcbiAgXHRcdFx0cmV0dXJuO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBjaGVjayBpZiBmbiBhbHJlYWR5IHRoZXJlXHJcbiAgXHRcdGlmICh0aGlzLl9saXN0ZW5zKHR5cGUsIGZuLCBjb250ZXh0KSAhPT0gZmFsc2UpIHtcclxuICBcdFx0XHRyZXR1cm47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChjb250ZXh0ID09PSB0aGlzKSB7XHJcbiAgXHRcdFx0Ly8gTGVzcyBtZW1vcnkgZm9vdHByaW50LlxyXG4gIFx0XHRcdGNvbnRleHQgPSB1bmRlZmluZWQ7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBuZXdMaXN0ZW5lciA9IHtmbjogZm4sIGN0eDogY29udGV4dH07XHJcbiAgXHRcdGlmIChfb25jZSkge1xyXG4gIFx0XHRcdG5ld0xpc3RlbmVyLm9uY2UgPSB0cnVlO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XHJcbiAgXHRcdHRoaXMuX2V2ZW50c1t0eXBlXSA9IHRoaXMuX2V2ZW50c1t0eXBlXSB8fCBbXTtcclxuICBcdFx0dGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobmV3TGlzdGVuZXIpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfb2ZmOiBmdW5jdGlvbiAodHlwZSwgZm4sIGNvbnRleHQpIHtcclxuICBcdFx0dmFyIGxpc3RlbmVycyxcclxuICBcdFx0ICAgIGksXHJcbiAgXHRcdCAgICBsZW47XHJcblxyXG4gIFx0XHRpZiAoIXRoaXMuX2V2ZW50cykge1xyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0bGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG4gIFx0XHRpZiAoIWxpc3RlbmVycykge1xyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHsgLy8gcmVtb3ZlIGFsbFxyXG4gIFx0XHRcdGlmICh0aGlzLl9maXJpbmdDb3VudCkge1xyXG4gIFx0XHRcdFx0Ly8gU2V0IGFsbCByZW1vdmVkIGxpc3RlbmVycyB0byBub29wXHJcbiAgXHRcdFx0XHQvLyBzbyB0aGV5IGFyZSBub3QgY2FsbGVkIGlmIHJlbW92ZSBoYXBwZW5zIGluIGZpcmVcclxuICBcdFx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRcdFx0XHRsaXN0ZW5lcnNbaV0uZm4gPSBmYWxzZUZuO1xyXG4gIFx0XHRcdFx0fVxyXG4gIFx0XHRcdH1cclxuICBcdFx0XHQvLyBjbGVhciBhbGwgbGlzdGVuZXJzIGZvciBhIHR5cGUgaWYgZnVuY3Rpb24gaXNuJ3Qgc3BlY2lmaWVkXHJcbiAgXHRcdFx0ZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuICBcdFx0XHRyZXR1cm47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcclxuICBcdFx0XHRjb25zb2xlLndhcm4oJ3dyb25nIGxpc3RlbmVyIHR5cGU6ICcgKyB0eXBlb2YgZm4pO1xyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gZmluZCBmbiBhbmQgcmVtb3ZlIGl0XHJcbiAgXHRcdHZhciBpbmRleCA9IHRoaXMuX2xpc3RlbnModHlwZSwgZm4sIGNvbnRleHQpO1xyXG4gIFx0XHRpZiAoaW5kZXggIT09IGZhbHNlKSB7XHJcbiAgXHRcdFx0dmFyIGxpc3RlbmVyID0gbGlzdGVuZXJzW2luZGV4XTtcclxuICBcdFx0XHRpZiAodGhpcy5fZmlyaW5nQ291bnQpIHtcclxuICBcdFx0XHRcdC8vIHNldCB0aGUgcmVtb3ZlZCBsaXN0ZW5lciB0byBub29wIHNvIHRoYXQncyBub3QgY2FsbGVkIGlmIHJlbW92ZSBoYXBwZW5zIGluIGZpcmVcclxuICBcdFx0XHRcdGxpc3RlbmVyLmZuID0gZmFsc2VGbjtcclxuXHJcbiAgXHRcdFx0XHQvKiBjb3B5IGFycmF5IGluIGNhc2UgZXZlbnRzIGFyZSBiZWluZyBmaXJlZCAqL1xyXG4gIFx0XHRcdFx0dGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXJzID0gbGlzdGVuZXJzLnNsaWNlKCk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHRcdGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZmlyZSh0eXBlOiBTdHJpbmcsIGRhdGE/OiBPYmplY3QsIHByb3BhZ2F0ZT86IEJvb2xlYW4pOiB0aGlzXHJcbiAgXHQvLyBGaXJlcyBhbiBldmVudCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUuIFlvdSBjYW4gb3B0aW9uYWxseSBwcm92aWRlIGEgZGF0YVxyXG4gIFx0Ly8gb2JqZWN0IOKAlCB0aGUgZmlyc3QgYXJndW1lbnQgb2YgdGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHdpbGwgY29udGFpbiBpdHNcclxuICBcdC8vIHByb3BlcnRpZXMuIFRoZSBldmVudCBjYW4gb3B0aW9uYWxseSBiZSBwcm9wYWdhdGVkIHRvIGV2ZW50IHBhcmVudHMuXHJcbiAgXHRmaXJlOiBmdW5jdGlvbiAodHlwZSwgZGF0YSwgcHJvcGFnYXRlKSB7XHJcbiAgXHRcdGlmICghdGhpcy5saXN0ZW5zKHR5cGUsIHByb3BhZ2F0ZSkpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcbiAgXHRcdHZhciBldmVudCA9IGV4dGVuZCh7fSwgZGF0YSwge1xyXG4gIFx0XHRcdHR5cGU6IHR5cGUsXHJcbiAgXHRcdFx0dGFyZ2V0OiB0aGlzLFxyXG4gIFx0XHRcdHNvdXJjZVRhcmdldDogZGF0YSAmJiBkYXRhLnNvdXJjZVRhcmdldCB8fCB0aGlzXHJcbiAgXHRcdH0pO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2V2ZW50cykge1xyXG4gIFx0XHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XHJcbiAgXHRcdFx0aWYgKGxpc3RlbmVycykge1xyXG4gIFx0XHRcdFx0dGhpcy5fZmlyaW5nQ291bnQgPSAodGhpcy5fZmlyaW5nQ291bnQgKyAxKSB8fCAxO1xyXG4gIFx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRcdFx0XHR2YXIgbCA9IGxpc3RlbmVyc1tpXTtcclxuICBcdFx0XHRcdFx0Ly8gb2ZmIG92ZXJ3cml0ZXMgbC5mbiwgc28gd2UgbmVlZCB0byBjb3B5IGZuIHRvIGEgdmFyXHJcbiAgXHRcdFx0XHRcdHZhciBmbiA9IGwuZm47XHJcbiAgXHRcdFx0XHRcdGlmIChsLm9uY2UpIHtcclxuICBcdFx0XHRcdFx0XHR0aGlzLm9mZih0eXBlLCBmbiwgbC5jdHgpO1xyXG4gIFx0XHRcdFx0XHR9XHJcbiAgXHRcdFx0XHRcdGZuLmNhbGwobC5jdHggfHwgdGhpcywgZXZlbnQpO1xyXG4gIFx0XHRcdFx0fVxyXG5cclxuICBcdFx0XHRcdHRoaXMuX2ZpcmluZ0NvdW50LS07XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAocHJvcGFnYXRlKSB7XHJcbiAgXHRcdFx0Ly8gcHJvcGFnYXRlIHRoZSBldmVudCB0byBwYXJlbnRzIChzZXQgd2l0aCBhZGRFdmVudFBhcmVudClcclxuICBcdFx0XHR0aGlzLl9wcm9wYWdhdGVFdmVudChldmVudCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGxpc3RlbnModHlwZTogU3RyaW5nLCBwcm9wYWdhdGU/OiBCb29sZWFuKTogQm9vbGVhblxyXG4gIFx0Ly8gQG1ldGhvZCBsaXN0ZW5zKHR5cGU6IFN0cmluZywgZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0LCBwcm9wYWdhdGU/OiBCb29sZWFuKTogQm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgYSBwYXJ0aWN1bGFyIGV2ZW50IHR5cGUgaGFzIGFueSBsaXN0ZW5lcnMgYXR0YWNoZWQgdG8gaXQuXHJcbiAgXHQvLyBUaGUgdmVyaWZpY2F0aW9uIGNhbiBvcHRpb25hbGx5IGJlIHByb3BhZ2F0ZWQsIGl0IHdpbGwgcmV0dXJuIGB0cnVlYCBpZiBwYXJlbnRzIGhhdmUgdGhlIGxpc3RlbmVyIGF0dGFjaGVkIHRvIGl0LlxyXG4gIFx0bGlzdGVuczogZnVuY3Rpb24gKHR5cGUsIGZuLCBjb250ZXh0LCBwcm9wYWdhdGUpIHtcclxuICBcdFx0aWYgKHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJykge1xyXG4gIFx0XHRcdGNvbnNvbGUud2FybignXCJzdHJpbmdcIiB0eXBlIGFyZ3VtZW50IGV4cGVjdGVkJyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIHdlIGRvbid0IG92ZXJ3cml0ZSB0aGUgaW5wdXQgYGZuYCB2YWx1ZSwgYmVjYXVzZSB3ZSBuZWVkIHRvIHVzZSBpdCBmb3IgcHJvcGFnYXRpb25cclxuICBcdFx0dmFyIF9mbiA9IGZuO1xyXG4gIFx0XHRpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgXHRcdFx0cHJvcGFnYXRlID0gISFmbjtcclxuICBcdFx0XHRfZm4gPSB1bmRlZmluZWQ7XHJcbiAgXHRcdFx0Y29udGV4dCA9IHVuZGVmaW5lZDtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50cyAmJiB0aGlzLl9ldmVudHNbdHlwZV07XHJcbiAgXHRcdGlmIChsaXN0ZW5lcnMgJiYgbGlzdGVuZXJzLmxlbmd0aCkge1xyXG4gIFx0XHRcdGlmICh0aGlzLl9saXN0ZW5zKHR5cGUsIF9mbiwgY29udGV4dCkgIT09IGZhbHNlKSB7XHJcbiAgXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChwcm9wYWdhdGUpIHtcclxuICBcdFx0XHQvLyBhbHNvIGNoZWNrIHBhcmVudHMgZm9yIGxpc3RlbmVycyBpZiBldmVudCBwcm9wYWdhdGVzXHJcbiAgXHRcdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fZXZlbnRQYXJlbnRzKSB7XHJcbiAgXHRcdFx0XHRpZiAodGhpcy5fZXZlbnRQYXJlbnRzW2lkXS5saXN0ZW5zKHR5cGUsIGZuLCBjb250ZXh0LCBwcm9wYWdhdGUpKSB7IHJldHVybiB0cnVlOyB9XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiBmYWxzZTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gcmV0dXJucyB0aGUgaW5kZXggKG51bWJlcikgb3IgZmFsc2VcclxuICBcdF9saXN0ZW5zOiBmdW5jdGlvbiAodHlwZSwgZm4sIGNvbnRleHQpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9ldmVudHMpIHtcclxuICBcdFx0XHRyZXR1cm4gZmFsc2U7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV0gfHwgW107XHJcbiAgXHRcdGlmICghZm4pIHtcclxuICBcdFx0XHRyZXR1cm4gISFsaXN0ZW5lcnMubGVuZ3RoO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAoY29udGV4dCA9PT0gdGhpcykge1xyXG4gIFx0XHRcdC8vIExlc3MgbWVtb3J5IGZvb3RwcmludC5cclxuICBcdFx0XHRjb250ZXh0ID0gdW5kZWZpbmVkO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdFx0aWYgKGxpc3RlbmVyc1tpXS5mbiA9PT0gZm4gJiYgbGlzdGVuZXJzW2ldLmN0eCA9PT0gY29udGV4dCkge1xyXG4gIFx0XHRcdFx0cmV0dXJuIGk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiBmYWxzZTtcclxuXHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgb25jZSjigKYpOiB0aGlzXHJcbiAgXHQvLyBCZWhhdmVzIGFzIFtgb24o4oCmKWBdKCNldmVudGVkLW9uKSwgZXhjZXB0IHRoZSBsaXN0ZW5lciB3aWxsIG9ubHkgZ2V0IGZpcmVkIG9uY2UgYW5kIHRoZW4gcmVtb3ZlZC5cclxuICBcdG9uY2U6IGZ1bmN0aW9uICh0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcbiAgXHRcdC8vIHR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xyXG4gIFx0XHRpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG4gIFx0XHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuICBcdFx0XHRcdC8vIHdlIGRvbid0IHByb2Nlc3Mgc3BhY2Utc2VwYXJhdGVkIGV2ZW50cyBoZXJlIGZvciBwZXJmb3JtYW5jZTtcclxuICBcdFx0XHRcdC8vIGl0J3MgYSBob3QgcGF0aCBzaW5jZSBMYXllciB1c2VzIHRoZSBvbihvYmopIHN5bnRheFxyXG4gIFx0XHRcdFx0dGhpcy5fb24odHlwZSwgdHlwZXNbdHlwZV0sIGZuLCB0cnVlKTtcclxuICBcdFx0XHR9XHJcblxyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdC8vIHR5cGVzIGNhbiBiZSBhIHN0cmluZyBvZiBzcGFjZS1zZXBhcmF0ZWQgd29yZHNcclxuICBcdFx0XHR0eXBlcyA9IHNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuICBcdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0XHRcdHRoaXMuX29uKHR5cGVzW2ldLCBmbiwgY29udGV4dCwgdHJ1ZSk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBhZGRFdmVudFBhcmVudChvYmo6IEV2ZW50ZWQpOiB0aGlzXHJcbiAgXHQvLyBBZGRzIGFuIGV2ZW50IHBhcmVudCAtIGFuIGBFdmVudGVkYCB0aGF0IHdpbGwgcmVjZWl2ZSBwcm9wYWdhdGVkIGV2ZW50c1xyXG4gIFx0YWRkRXZlbnRQYXJlbnQ6IGZ1bmN0aW9uIChvYmopIHtcclxuICBcdFx0dGhpcy5fZXZlbnRQYXJlbnRzID0gdGhpcy5fZXZlbnRQYXJlbnRzIHx8IHt9O1xyXG4gIFx0XHR0aGlzLl9ldmVudFBhcmVudHNbc3RhbXAob2JqKV0gPSBvYmo7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHJlbW92ZUV2ZW50UGFyZW50KG9iajogRXZlbnRlZCk6IHRoaXNcclxuICBcdC8vIFJlbW92ZXMgYW4gZXZlbnQgcGFyZW50LCBzbyBpdCB3aWxsIHN0b3AgcmVjZWl2aW5nIHByb3BhZ2F0ZWQgZXZlbnRzXHJcbiAgXHRyZW1vdmVFdmVudFBhcmVudDogZnVuY3Rpb24gKG9iaikge1xyXG4gIFx0XHRpZiAodGhpcy5fZXZlbnRQYXJlbnRzKSB7XHJcbiAgXHRcdFx0ZGVsZXRlIHRoaXMuX2V2ZW50UGFyZW50c1tzdGFtcChvYmopXTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X3Byb3BhZ2F0ZUV2ZW50OiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9ldmVudFBhcmVudHMpIHtcclxuICBcdFx0XHR0aGlzLl9ldmVudFBhcmVudHNbaWRdLmZpcmUoZS50eXBlLCBleHRlbmQoe1xyXG4gIFx0XHRcdFx0bGF5ZXI6IGUudGFyZ2V0LFxyXG4gIFx0XHRcdFx0cHJvcGFnYXRlZEZyb206IGUudGFyZ2V0XHJcbiAgXHRcdFx0fSwgZSksIHRydWUpO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcbiAgfTtcclxuXHJcbiAgLy8gYWxpYXNlczsgd2Ugc2hvdWxkIGRpdGNoIHRob3NlIGV2ZW50dWFsbHlcclxuXHJcbiAgLy8gQG1ldGhvZCBhZGRFdmVudExpc3RlbmVyKOKApik6IHRoaXNcclxuICAvLyBBbGlhcyB0byBbYG9uKOKApilgXSgjZXZlbnRlZC1vbilcclxuICBFdmVudHMuYWRkRXZlbnRMaXN0ZW5lciA9IEV2ZW50cy5vbjtcclxuXHJcbiAgLy8gQG1ldGhvZCByZW1vdmVFdmVudExpc3RlbmVyKOKApik6IHRoaXNcclxuICAvLyBBbGlhcyB0byBbYG9mZijigKYpYF0oI2V2ZW50ZWQtb2ZmKVxyXG5cclxuICAvLyBAbWV0aG9kIGNsZWFyQWxsRXZlbnRMaXN0ZW5lcnMo4oCmKTogdGhpc1xyXG4gIC8vIEFsaWFzIHRvIFtgb2ZmKClgXSgjZXZlbnRlZC1vZmYpXHJcbiAgRXZlbnRzLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBFdmVudHMuY2xlYXJBbGxFdmVudExpc3RlbmVycyA9IEV2ZW50cy5vZmY7XHJcblxyXG4gIC8vIEBtZXRob2QgYWRkT25lVGltZUV2ZW50TGlzdGVuZXIo4oCmKTogdGhpc1xyXG4gIC8vIEFsaWFzIHRvIFtgb25jZSjigKYpYF0oI2V2ZW50ZWQtb25jZSlcclxuICBFdmVudHMuYWRkT25lVGltZUV2ZW50TGlzdGVuZXIgPSBFdmVudHMub25jZTtcclxuXHJcbiAgLy8gQG1ldGhvZCBmaXJlRXZlbnQo4oCmKTogdGhpc1xyXG4gIC8vIEFsaWFzIHRvIFtgZmlyZSjigKYpYF0oI2V2ZW50ZWQtZmlyZSlcclxuICBFdmVudHMuZmlyZUV2ZW50ID0gRXZlbnRzLmZpcmU7XHJcblxyXG4gIC8vIEBtZXRob2QgaGFzRXZlbnRMaXN0ZW5lcnMo4oCmKTogQm9vbGVhblxyXG4gIC8vIEFsaWFzIHRvIFtgbGlzdGVucyjigKYpYF0oI2V2ZW50ZWQtbGlzdGVucylcclxuICBFdmVudHMuaGFzRXZlbnRMaXN0ZW5lcnMgPSBFdmVudHMubGlzdGVucztcclxuXHJcbiAgdmFyIEV2ZW50ZWQgPSBDbGFzcy5leHRlbmQoRXZlbnRzKTtcblxuICAvKlxyXG4gICAqIEBjbGFzcyBQb2ludFxyXG4gICAqIEBha2EgTC5Qb2ludFxyXG4gICAqXHJcbiAgICogUmVwcmVzZW50cyBhIHBvaW50IHdpdGggYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMgaW4gcGl4ZWxzLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogdmFyIHBvaW50ID0gTC5wb2ludCgyMDAsIDMwMCk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBBbGwgTGVhZmxldCBtZXRob2RzIGFuZCBvcHRpb25zIHRoYXQgYWNjZXB0IGBQb2ludGAgb2JqZWN0cyBhbHNvIGFjY2VwdCB0aGVtIGluIGEgc2ltcGxlIEFycmF5IGZvcm0gKHVubGVzcyBub3RlZCBvdGhlcndpc2UpLCBzbyB0aGVzZSBsaW5lcyBhcmUgZXF1aXZhbGVudDpcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogbWFwLnBhbkJ5KFsyMDAsIDMwMF0pO1xyXG4gICAqIG1hcC5wYW5CeShMLnBvaW50KDIwMCwgMzAwKSk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBOb3RlIHRoYXQgYFBvaW50YCBkb2VzIG5vdCBpbmhlcml0IGZyb20gTGVhZmxldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gICAqIHdoaWNoIG1lYW5zIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSBpdCwgYW5kIG5ldyBtZXRob2RzXHJcbiAgICogY2FuJ3QgYmUgYWRkZWQgdG8gaXQgd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxyXG4gICAqL1xyXG5cclxuICBmdW5jdGlvbiBQb2ludCh4LCB5LCByb3VuZCkge1xyXG4gIFx0Ly8gQHByb3BlcnR5IHg6IE51bWJlcjsgVGhlIGB4YCBjb29yZGluYXRlIG9mIHRoZSBwb2ludFxyXG4gIFx0dGhpcy54ID0gKHJvdW5kID8gTWF0aC5yb3VuZCh4KSA6IHgpO1xyXG4gIFx0Ly8gQHByb3BlcnR5IHk6IE51bWJlcjsgVGhlIGB5YCBjb29yZGluYXRlIG9mIHRoZSBwb2ludFxyXG4gIFx0dGhpcy55ID0gKHJvdW5kID8gTWF0aC5yb3VuZCh5KSA6IHkpO1xyXG4gIH1cclxuXHJcbiAgdmFyIHRydW5jID0gTWF0aC50cnVuYyB8fCBmdW5jdGlvbiAodikge1xyXG4gIFx0cmV0dXJuIHYgPiAwID8gTWF0aC5mbG9vcih2KSA6IE1hdGguY2VpbCh2KTtcclxuICB9O1xyXG5cclxuICBQb2ludC5wcm90b3R5cGUgPSB7XHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjbG9uZSgpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQuXHJcbiAgXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBhZGQob3RoZXJQb2ludDogUG9pbnQpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGFkZGl0aW9uIG9mIHRoZSBjdXJyZW50IGFuZCB0aGUgZ2l2ZW4gcG9pbnRzLlxyXG4gIFx0YWRkOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuICBcdFx0Ly8gbm9uLWRlc3RydWN0aXZlLCByZXR1cm5zIGEgbmV3IHBvaW50XHJcbiAgXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2FkZCh0b1BvaW50KHBvaW50KSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9hZGQ6IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gIFx0XHQvLyBkZXN0cnVjdGl2ZSwgdXNlZCBkaXJlY3RseSBmb3IgcGVyZm9ybWFuY2UgaW4gc2l0dWF0aW9ucyB3aGVyZSBpdCdzIHNhZmUgdG8gbW9kaWZ5IGV4aXN0aW5nIHBvaW50XHJcbiAgXHRcdHRoaXMueCArPSBwb2ludC54O1xyXG4gIFx0XHR0aGlzLnkgKz0gcG9pbnQueTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc3VidHJhY3Qob3RoZXJQb2ludDogUG9pbnQpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIHN1YnRyYWN0aW9uIG9mIHRoZSBnaXZlbiBwb2ludCBmcm9tIHRoZSBjdXJyZW50LlxyXG4gIFx0c3VidHJhY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9zdWJ0cmFjdCh0b1BvaW50KHBvaW50KSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9zdWJ0cmFjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgXHRcdHRoaXMueCAtPSBwb2ludC54O1xyXG4gIFx0XHR0aGlzLnkgLT0gcG9pbnQueTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZGl2aWRlQnkobnVtOiBOdW1iZXIpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGRpdmlzaW9uIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5IHRoZSBnaXZlbiBudW1iZXIuXHJcbiAgXHRkaXZpZGVCeTogZnVuY3Rpb24gKG51bSkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9kaXZpZGVCeShudW0pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfZGl2aWRlQnk6IGZ1bmN0aW9uIChudW0pIHtcclxuICBcdFx0dGhpcy54IC89IG51bTtcclxuICBcdFx0dGhpcy55IC89IG51bTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgbXVsdGlwbHlCeShudW06IE51bWJlcik6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgbXVsdGlwbGljYXRpb24gb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnkgdGhlIGdpdmVuIG51bWJlci5cclxuICBcdG11bHRpcGx5Qnk6IGZ1bmN0aW9uIChudW0pIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fbXVsdGlwbHlCeShudW0pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfbXVsdGlwbHlCeTogZnVuY3Rpb24gKG51bSkge1xyXG4gIFx0XHR0aGlzLnggKj0gbnVtO1xyXG4gIFx0XHR0aGlzLnkgKj0gbnVtO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzY2FsZUJ5KHNjYWxlOiBQb2ludCk6IFBvaW50XHJcbiAgXHQvLyBNdWx0aXBseSBlYWNoIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnkgZWFjaCBjb29yZGluYXRlIG9mXHJcbiAgXHQvLyBgc2NhbGVgLiBJbiBsaW5lYXIgYWxnZWJyYSB0ZXJtcywgbXVsdGlwbHkgdGhlIHBvaW50IGJ5IHRoZVxyXG4gIFx0Ly8gW3NjYWxpbmcgbWF0cml4XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TY2FsaW5nXyUyOGdlb21ldHJ5JTI5I01hdHJpeF9yZXByZXNlbnRhdGlvbilcclxuICBcdC8vIGRlZmluZWQgYnkgYHNjYWxlYC5cclxuICBcdHNjYWxlQnk6IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gIFx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCAqIHBvaW50LngsIHRoaXMueSAqIHBvaW50LnkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHVuc2NhbGVCeShzY2FsZTogUG9pbnQpOiBQb2ludFxyXG4gIFx0Ly8gSW52ZXJzZSBvZiBgc2NhbGVCeWAuIERpdmlkZSBlYWNoIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnlcclxuICBcdC8vIGVhY2ggY29vcmRpbmF0ZSBvZiBgc2NhbGVgLlxyXG4gIFx0dW5zY2FsZUJ5OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuICBcdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLnggLyBwb2ludC54LCB0aGlzLnkgLyBwb2ludC55KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCByb3VuZCgpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQgd2l0aCByb3VuZGVkIGNvb3JkaW5hdGVzLlxyXG4gIFx0cm91bmQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fcm91bmQoKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3JvdW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHRoaXMueCA9IE1hdGgucm91bmQodGhpcy54KTtcclxuICBcdFx0dGhpcy55ID0gTWF0aC5yb3VuZCh0aGlzLnkpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBmbG9vcigpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQgd2l0aCBmbG9vcmVkIGNvb3JkaW5hdGVzIChyb3VuZGVkIGRvd24pLlxyXG4gIFx0Zmxvb3I6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fZmxvb3IoKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2Zsb29yOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHRoaXMueCA9IE1hdGguZmxvb3IodGhpcy54KTtcclxuICBcdFx0dGhpcy55ID0gTWF0aC5mbG9vcih0aGlzLnkpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjZWlsKCk6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIGNlaWxlZCBjb29yZGluYXRlcyAocm91bmRlZCB1cCkuXHJcbiAgXHRjZWlsOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2NlaWwoKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2NlaWw6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dGhpcy54ID0gTWF0aC5jZWlsKHRoaXMueCk7XHJcbiAgXHRcdHRoaXMueSA9IE1hdGguY2VpbCh0aGlzLnkpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB0cnVuYygpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQgd2l0aCB0cnVuY2F0ZWQgY29vcmRpbmF0ZXMgKHJvdW5kZWQgdG93YXJkcyB6ZXJvKS5cclxuICBcdHRydW5jOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX3RydW5jKCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF90cnVuYzogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR0aGlzLnggPSB0cnVuYyh0aGlzLngpO1xyXG4gIFx0XHR0aGlzLnkgPSB0cnVuYyh0aGlzLnkpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBkaXN0YW5jZVRvKG90aGVyUG9pbnQ6IFBvaW50KTogTnVtYmVyXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBjYXJ0ZXNpYW4gZGlzdGFuY2UgYmV0d2VlbiB0aGUgY3VycmVudCBhbmQgdGhlIGdpdmVuIHBvaW50cy5cclxuICBcdGRpc3RhbmNlVG86IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gIFx0XHRwb2ludCA9IHRvUG9pbnQocG9pbnQpO1xyXG5cclxuICBcdFx0dmFyIHggPSBwb2ludC54IC0gdGhpcy54LFxyXG4gIFx0XHQgICAgeSA9IHBvaW50LnkgLSB0aGlzLnk7XHJcblxyXG4gIFx0XHRyZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGVxdWFscyhvdGhlclBvaW50OiBQb2ludCk6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBwb2ludCBoYXMgdGhlIHNhbWUgY29vcmRpbmF0ZXMuXHJcbiAgXHRlcXVhbHM6IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gIFx0XHRwb2ludCA9IHRvUG9pbnQocG9pbnQpO1xyXG5cclxuICBcdFx0cmV0dXJuIHBvaW50LnggPT09IHRoaXMueCAmJlxyXG4gIFx0XHQgICAgICAgcG9pbnQueSA9PT0gdGhpcy55O1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGNvbnRhaW5zKG90aGVyUG9pbnQ6IFBvaW50KTogQm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgYm90aCBjb29yZGluYXRlcyBvZiB0aGUgZ2l2ZW4gcG9pbnQgYXJlIGxlc3MgdGhhbiB0aGUgY29ycmVzcG9uZGluZyBjdXJyZW50IHBvaW50IGNvb3JkaW5hdGVzIChpbiBhYnNvbHV0ZSB2YWx1ZXMpLlxyXG4gIFx0Y29udGFpbnM6IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gIFx0XHRwb2ludCA9IHRvUG9pbnQocG9pbnQpO1xyXG5cclxuICBcdFx0cmV0dXJuIE1hdGguYWJzKHBvaW50LngpIDw9IE1hdGguYWJzKHRoaXMueCkgJiZcclxuICBcdFx0ICAgICAgIE1hdGguYWJzKHBvaW50LnkpIDw9IE1hdGguYWJzKHRoaXMueSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgdG9TdHJpbmcoKTogU3RyaW5nXHJcbiAgXHQvLyBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2ludCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLlxyXG4gIFx0dG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuICdQb2ludCgnICtcclxuICBcdFx0ICAgICAgICBmb3JtYXROdW0odGhpcy54KSArICcsICcgK1xyXG4gIFx0XHQgICAgICAgIGZvcm1hdE51bSh0aGlzLnkpICsgJyknO1xyXG4gIFx0fVxyXG4gIH07XHJcblxyXG4gIC8vIEBmYWN0b3J5IEwucG9pbnQoeDogTnVtYmVyLCB5OiBOdW1iZXIsIHJvdW5kPzogQm9vbGVhbilcclxuICAvLyBDcmVhdGVzIGEgUG9pbnQgb2JqZWN0IHdpdGggdGhlIGdpdmVuIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzLiBJZiBvcHRpb25hbCBgcm91bmRgIGlzIHNldCB0byB0cnVlLCByb3VuZHMgdGhlIGB4YCBhbmQgYHlgIHZhbHVlcy5cclxuXHJcbiAgLy8gQGFsdGVybmF0aXZlXHJcbiAgLy8gQGZhY3RvcnkgTC5wb2ludChjb29yZHM6IE51bWJlcltdKVxyXG4gIC8vIEV4cGVjdHMgYW4gYXJyYXkgb2YgdGhlIGZvcm0gYFt4LCB5XWAgaW5zdGVhZC5cclxuXHJcbiAgLy8gQGFsdGVybmF0aXZlXHJcbiAgLy8gQGZhY3RvcnkgTC5wb2ludChjb29yZHM6IE9iamVjdClcclxuICAvLyBFeHBlY3RzIGEgcGxhaW4gb2JqZWN0IG9mIHRoZSBmb3JtIGB7eDogTnVtYmVyLCB5OiBOdW1iZXJ9YCBpbnN0ZWFkLlxyXG4gIGZ1bmN0aW9uIHRvUG9pbnQoeCwgeSwgcm91bmQpIHtcclxuICBcdGlmICh4IGluc3RhbmNlb2YgUG9pbnQpIHtcclxuICBcdFx0cmV0dXJuIHg7XHJcbiAgXHR9XHJcbiAgXHRpZiAoaXNBcnJheSh4KSkge1xyXG4gIFx0XHRyZXR1cm4gbmV3IFBvaW50KHhbMF0sIHhbMV0pO1xyXG4gIFx0fVxyXG4gIFx0aWYgKHggPT09IHVuZGVmaW5lZCB8fCB4ID09PSBudWxsKSB7XHJcbiAgXHRcdHJldHVybiB4O1xyXG4gIFx0fVxyXG4gIFx0aWYgKHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiAneCcgaW4geCAmJiAneScgaW4geCkge1xyXG4gIFx0XHRyZXR1cm4gbmV3IFBvaW50KHgueCwgeC55KTtcclxuICBcdH1cclxuICBcdHJldHVybiBuZXcgUG9pbnQoeCwgeSwgcm91bmQpO1xyXG4gIH1cblxuICAvKlxyXG4gICAqIEBjbGFzcyBCb3VuZHNcclxuICAgKiBAYWthIEwuQm91bmRzXHJcbiAgICpcclxuICAgKiBSZXByZXNlbnRzIGEgcmVjdGFuZ3VsYXIgYXJlYSBpbiBwaXhlbCBjb29yZGluYXRlcy5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIHZhciBwMSA9IEwucG9pbnQoMTAsIDEwKSxcclxuICAgKiBwMiA9IEwucG9pbnQoNDAsIDYwKSxcclxuICAgKiBib3VuZHMgPSBMLmJvdW5kcyhwMSwgcDIpO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQWxsIExlYWZsZXQgbWV0aG9kcyB0aGF0IGFjY2VwdCBgQm91bmRzYCBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSAodW5sZXNzIG5vdGVkIG90aGVyd2lzZSksIHNvIHRoZSBib3VuZHMgZXhhbXBsZSBhYm92ZSBjYW4gYmUgcGFzc2VkIGxpa2UgdGhpczpcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogb3RoZXJCb3VuZHMuaW50ZXJzZWN0cyhbWzEwLCAxMF0sIFs0MCwgNjBdXSk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBOb3RlIHRoYXQgYEJvdW5kc2AgZG9lcyBub3QgaW5oZXJpdCBmcm9tIExlYWZsZXQncyBgQ2xhc3NgIG9iamVjdCxcclxuICAgKiB3aGljaCBtZWFucyBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gaXQsIGFuZCBuZXcgbWV0aG9kc1xyXG4gICAqIGNhbid0IGJlIGFkZGVkIHRvIGl0IHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICAgKi9cclxuXHJcbiAgZnVuY3Rpb24gQm91bmRzKGEsIGIpIHtcclxuICBcdGlmICghYSkgeyByZXR1cm47IH1cclxuXHJcbiAgXHR2YXIgcG9pbnRzID0gYiA/IFthLCBiXSA6IGE7XHJcblxyXG4gIFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHR0aGlzLmV4dGVuZChwb2ludHNbaV0pO1xyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgQm91bmRzLnByb3RvdHlwZSA9IHtcclxuICBcdC8vIEBtZXRob2QgZXh0ZW5kKHBvaW50OiBQb2ludCk6IHRoaXNcclxuICBcdC8vIEV4dGVuZHMgdGhlIGJvdW5kcyB0byBjb250YWluIHRoZSBnaXZlbiBwb2ludC5cclxuXHJcbiAgXHQvLyBAYWx0ZXJuYXRpdmVcclxuICBcdC8vIEBtZXRob2QgZXh0ZW5kKG90aGVyQm91bmRzOiBCb3VuZHMpOiB0aGlzXHJcbiAgXHQvLyBFeHRlbmQgdGhlIGJvdW5kcyB0byBjb250YWluIHRoZSBnaXZlbiBib3VuZHNcclxuICBcdGV4dGVuZDogZnVuY3Rpb24gKG9iaikge1xyXG4gIFx0XHR2YXIgbWluMiwgbWF4MjtcclxuICBcdFx0aWYgKCFvYmopIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcbiAgXHRcdGlmIChvYmogaW5zdGFuY2VvZiBQb2ludCB8fCB0eXBlb2Ygb2JqWzBdID09PSAnbnVtYmVyJyB8fCAneCcgaW4gb2JqKSB7XHJcbiAgXHRcdFx0bWluMiA9IG1heDIgPSB0b1BvaW50KG9iaik7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0b2JqID0gdG9Cb3VuZHMob2JqKTtcclxuICBcdFx0XHRtaW4yID0gb2JqLm1pbjtcclxuICBcdFx0XHRtYXgyID0gb2JqLm1heDtcclxuXHJcbiAgXHRcdFx0aWYgKCFtaW4yIHx8ICFtYXgyKSB7IHJldHVybiB0aGlzOyB9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIEBwcm9wZXJ0eSBtaW46IFBvaW50XHJcbiAgXHRcdC8vIFRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZS5cclxuICBcdFx0Ly8gQHByb3BlcnR5IG1heDogUG9pbnRcclxuICBcdFx0Ly8gVGhlIGJvdHRvbSByaWdodCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZS5cclxuICBcdFx0aWYgKCF0aGlzLm1pbiAmJiAhdGhpcy5tYXgpIHtcclxuICBcdFx0XHR0aGlzLm1pbiA9IG1pbjIuY2xvbmUoKTtcclxuICBcdFx0XHR0aGlzLm1heCA9IG1heDIuY2xvbmUoKTtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHR0aGlzLm1pbi54ID0gTWF0aC5taW4obWluMi54LCB0aGlzLm1pbi54KTtcclxuICBcdFx0XHR0aGlzLm1heC54ID0gTWF0aC5tYXgobWF4Mi54LCB0aGlzLm1heC54KTtcclxuICBcdFx0XHR0aGlzLm1pbi55ID0gTWF0aC5taW4obWluMi55LCB0aGlzLm1pbi55KTtcclxuICBcdFx0XHR0aGlzLm1heC55ID0gTWF0aC5tYXgobWF4Mi55LCB0aGlzLm1heC55KTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIocm91bmQ/OiBCb29sZWFuKTogUG9pbnRcclxuICBcdC8vIFJldHVybnMgdGhlIGNlbnRlciBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG4gIFx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAocm91bmQpIHtcclxuICBcdFx0cmV0dXJuIHRvUG9pbnQoXHJcbiAgXHRcdCAgICAgICAgKHRoaXMubWluLnggKyB0aGlzLm1heC54KSAvIDIsXHJcbiAgXHRcdCAgICAgICAgKHRoaXMubWluLnkgKyB0aGlzLm1heC55KSAvIDIsIHJvdW5kKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRCb3R0b21MZWZ0KCk6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBib3R0b20tbGVmdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG4gIFx0Z2V0Qm90dG9tTGVmdDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdG9Qb2ludCh0aGlzLm1pbi54LCB0aGlzLm1heC55KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRUb3BSaWdodCgpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgdG9wLXJpZ2h0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcbiAgXHRnZXRUb3BSaWdodDogZnVuY3Rpb24gKCkgeyAvLyAtPiBQb2ludFxyXG4gIFx0XHRyZXR1cm4gdG9Qb2ludCh0aGlzLm1heC54LCB0aGlzLm1pbi55KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRUb3BMZWZ0KCk6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSB0b3AtbGVmdCBwb2ludCBvZiB0aGUgYm91bmRzIChpLmUuIFtgdGhpcy5taW5gXSgjYm91bmRzLW1pbikpLlxyXG4gIFx0Z2V0VG9wTGVmdDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5taW47IC8vIGxlZnQsIHRvcFxyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldEJvdHRvbVJpZ2h0KCk6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBib3R0b20tcmlnaHQgcG9pbnQgb2YgdGhlIGJvdW5kcyAoaS5lLiBbYHRoaXMubWF4YF0oI2JvdW5kcy1tYXgpKS5cclxuICBcdGdldEJvdHRvbVJpZ2h0OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLm1heDsgLy8gcmlnaHQsIGJvdHRvbVxyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFNpemUoKTogUG9pbnRcclxuICBcdC8vIFJldHVybnMgdGhlIHNpemUgb2YgdGhlIGdpdmVuIGJvdW5kc1xyXG4gIFx0Z2V0U2l6ZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5tYXguc3VidHJhY3QodGhpcy5taW4pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGNvbnRhaW5zKG90aGVyQm91bmRzOiBCb3VuZHMpOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBvbmUuXHJcbiAgXHQvLyBAYWx0ZXJuYXRpdmVcclxuICBcdC8vIEBtZXRob2QgY29udGFpbnMocG9pbnQ6IFBvaW50KTogQm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBjb250YWlucyB0aGUgZ2l2ZW4gcG9pbnQuXHJcbiAgXHRjb250YWluczogZnVuY3Rpb24gKG9iaikge1xyXG4gIFx0XHR2YXIgbWluLCBtYXg7XHJcblxyXG4gIFx0XHRpZiAodHlwZW9mIG9ialswXSA9PT0gJ251bWJlcicgfHwgb2JqIGluc3RhbmNlb2YgUG9pbnQpIHtcclxuICBcdFx0XHRvYmogPSB0b1BvaW50KG9iaik7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0b2JqID0gdG9Cb3VuZHMob2JqKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKG9iaiBpbnN0YW5jZW9mIEJvdW5kcykge1xyXG4gIFx0XHRcdG1pbiA9IG9iai5taW47XHJcbiAgXHRcdFx0bWF4ID0gb2JqLm1heDtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRtaW4gPSBtYXggPSBvYmo7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiAobWluLnggPj0gdGhpcy5taW4ueCkgJiZcclxuICBcdFx0ICAgICAgIChtYXgueCA8PSB0aGlzLm1heC54KSAmJlxyXG4gIFx0XHQgICAgICAgKG1pbi55ID49IHRoaXMubWluLnkpICYmXHJcbiAgXHRcdCAgICAgICAobWF4LnkgPD0gdGhpcy5tYXgueSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgaW50ZXJzZWN0cyhvdGhlckJvdW5kczogQm91bmRzKTogQm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBpbnRlcnNlY3RzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHNcclxuICBcdC8vIGludGVyc2VjdCBpZiB0aGV5IGhhdmUgYXQgbGVhc3Qgb25lIHBvaW50IGluIGNvbW1vbi5cclxuICBcdGludGVyc2VjdHM6IGZ1bmN0aW9uIChib3VuZHMpIHsgLy8gKEJvdW5kcykgLT4gQm9vbGVhblxyXG4gIFx0XHRib3VuZHMgPSB0b0JvdW5kcyhib3VuZHMpO1xyXG5cclxuICBcdFx0dmFyIG1pbiA9IHRoaXMubWluLFxyXG4gIFx0XHQgICAgbWF4ID0gdGhpcy5tYXgsXHJcbiAgXHRcdCAgICBtaW4yID0gYm91bmRzLm1pbixcclxuICBcdFx0ICAgIG1heDIgPSBib3VuZHMubWF4LFxyXG4gIFx0XHQgICAgeEludGVyc2VjdHMgPSAobWF4Mi54ID49IG1pbi54KSAmJiAobWluMi54IDw9IG1heC54KSxcclxuICBcdFx0ICAgIHlJbnRlcnNlY3RzID0gKG1heDIueSA+PSBtaW4ueSkgJiYgKG1pbjIueSA8PSBtYXgueSk7XHJcblxyXG4gIFx0XHRyZXR1cm4geEludGVyc2VjdHMgJiYgeUludGVyc2VjdHM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgb3ZlcmxhcHMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgb3ZlcmxhcHMgdGhlIGdpdmVuIGJvdW5kcy4gVHdvIGJvdW5kc1xyXG4gIFx0Ly8gb3ZlcmxhcCBpZiB0aGVpciBpbnRlcnNlY3Rpb24gaXMgYW4gYXJlYS5cclxuICBcdG92ZXJsYXBzOiBmdW5jdGlvbiAoYm91bmRzKSB7IC8vIChCb3VuZHMpIC0+IEJvb2xlYW5cclxuICBcdFx0Ym91bmRzID0gdG9Cb3VuZHMoYm91bmRzKTtcclxuXHJcbiAgXHRcdHZhciBtaW4gPSB0aGlzLm1pbixcclxuICBcdFx0ICAgIG1heCA9IHRoaXMubWF4LFxyXG4gIFx0XHQgICAgbWluMiA9IGJvdW5kcy5taW4sXHJcbiAgXHRcdCAgICBtYXgyID0gYm91bmRzLm1heCxcclxuICBcdFx0ICAgIHhPdmVybGFwcyA9IChtYXgyLnggPiBtaW4ueCkgJiYgKG1pbjIueCA8IG1heC54KSxcclxuICBcdFx0ICAgIHlPdmVybGFwcyA9IChtYXgyLnkgPiBtaW4ueSkgJiYgKG1pbjIueSA8IG1heC55KTtcclxuXHJcbiAgXHRcdHJldHVybiB4T3ZlcmxhcHMgJiYgeU92ZXJsYXBzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGlzVmFsaWQoKTogQm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGJvdW5kcyBhcmUgcHJvcGVybHkgaW5pdGlhbGl6ZWQuXHJcbiAgXHRpc1ZhbGlkOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiAhISh0aGlzLm1pbiAmJiB0aGlzLm1heCk7XHJcbiAgXHR9LFxyXG5cclxuXHJcbiAgXHQvLyBAbWV0aG9kIHBhZChidWZmZXJSYXRpbzogTnVtYmVyKTogQm91bmRzXHJcbiAgXHQvLyBSZXR1cm5zIGJvdW5kcyBjcmVhdGVkIGJ5IGV4dGVuZGluZyBvciByZXRyYWN0aW5nIHRoZSBjdXJyZW50IGJvdW5kcyBieSBhIGdpdmVuIHJhdGlvIGluIGVhY2ggZGlyZWN0aW9uLlxyXG4gIFx0Ly8gRm9yIGV4YW1wbGUsIGEgcmF0aW8gb2YgMC41IGV4dGVuZHMgdGhlIGJvdW5kcyBieSA1MCUgaW4gZWFjaCBkaXJlY3Rpb24uXHJcbiAgXHQvLyBOZWdhdGl2ZSB2YWx1ZXMgd2lsbCByZXRyYWN0IHRoZSBib3VuZHMuXHJcbiAgXHRwYWQ6IGZ1bmN0aW9uIChidWZmZXJSYXRpbykge1xyXG4gIFx0XHR2YXIgbWluID0gdGhpcy5taW4sXHJcbiAgXHRcdG1heCA9IHRoaXMubWF4LFxyXG4gIFx0XHRoZWlnaHRCdWZmZXIgPSBNYXRoLmFicyhtaW4ueCAtIG1heC54KSAqIGJ1ZmZlclJhdGlvLFxyXG4gIFx0XHR3aWR0aEJ1ZmZlciA9IE1hdGguYWJzKG1pbi55IC0gbWF4LnkpICogYnVmZmVyUmF0aW87XHJcblxyXG5cclxuICBcdFx0cmV0dXJuIHRvQm91bmRzKFxyXG4gIFx0XHRcdHRvUG9pbnQobWluLnggLSBoZWlnaHRCdWZmZXIsIG1pbi55IC0gd2lkdGhCdWZmZXIpLFxyXG4gIFx0XHRcdHRvUG9pbnQobWF4LnggKyBoZWlnaHRCdWZmZXIsIG1heC55ICsgd2lkdGhCdWZmZXIpKTtcclxuICBcdH0sXHJcblxyXG5cclxuICBcdC8vIEBtZXRob2QgZXF1YWxzKG90aGVyQm91bmRzOiBCb3VuZHMpOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGlzIGVxdWl2YWxlbnQgdG8gdGhlIGdpdmVuIGJvdW5kcy5cclxuICBcdGVxdWFsczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG4gIFx0XHRpZiAoIWJvdW5kcykgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbiAgXHRcdGJvdW5kcyA9IHRvQm91bmRzKGJvdW5kcyk7XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcy5taW4uZXF1YWxzKGJvdW5kcy5nZXRUb3BMZWZ0KCkpICYmXHJcbiAgXHRcdFx0dGhpcy5tYXguZXF1YWxzKGJvdW5kcy5nZXRCb3R0b21SaWdodCgpKTtcclxuICBcdH0sXHJcbiAgfTtcclxuXHJcblxyXG4gIC8vIEBmYWN0b3J5IEwuYm91bmRzKGNvcm5lcjE6IFBvaW50LCBjb3JuZXIyOiBQb2ludClcclxuICAvLyBDcmVhdGVzIGEgQm91bmRzIG9iamVjdCBmcm9tIHR3byBjb3JuZXJzIGNvb3JkaW5hdGUgcGFpcnMuXHJcbiAgLy8gQGFsdGVybmF0aXZlXHJcbiAgLy8gQGZhY3RvcnkgTC5ib3VuZHMocG9pbnRzOiBQb2ludFtdKVxyXG4gIC8vIENyZWF0ZXMgYSBCb3VuZHMgb2JqZWN0IGZyb20gdGhlIGdpdmVuIGFycmF5IG9mIHBvaW50cy5cclxuICBmdW5jdGlvbiB0b0JvdW5kcyhhLCBiKSB7XHJcbiAgXHRpZiAoIWEgfHwgYSBpbnN0YW5jZW9mIEJvdW5kcykge1xyXG4gIFx0XHRyZXR1cm4gYTtcclxuICBcdH1cclxuICBcdHJldHVybiBuZXcgQm91bmRzKGEsIGIpO1xyXG4gIH1cblxuICAvKlxyXG4gICAqIEBjbGFzcyBMYXRMbmdCb3VuZHNcclxuICAgKiBAYWthIEwuTGF0TG5nQm91bmRzXHJcbiAgICpcclxuICAgKiBSZXByZXNlbnRzIGEgcmVjdGFuZ3VsYXIgZ2VvZ3JhcGhpY2FsIGFyZWEgb24gYSBtYXAuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB2YXIgY29ybmVyMSA9IEwubGF0TG5nKDQwLjcxMiwgLTc0LjIyNyksXHJcbiAgICogY29ybmVyMiA9IEwubGF0TG5nKDQwLjc3NCwgLTc0LjEyNSksXHJcbiAgICogYm91bmRzID0gTC5sYXRMbmdCb3VuZHMoY29ybmVyMSwgY29ybmVyMik7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBBbGwgTGVhZmxldCBtZXRob2RzIHRoYXQgYWNjZXB0IExhdExuZ0JvdW5kcyBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSAodW5sZXNzIG5vdGVkIG90aGVyd2lzZSksIHNvIHRoZSBib3VuZHMgZXhhbXBsZSBhYm92ZSBjYW4gYmUgcGFzc2VkIGxpa2UgdGhpczpcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogbWFwLmZpdEJvdW5kcyhbXHJcbiAgICogXHRbNDAuNzEyLCAtNzQuMjI3XSxcclxuICAgKiBcdFs0MC43NzQsIC03NC4xMjVdXHJcbiAgICogXSk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBDYXV0aW9uOiBpZiB0aGUgYXJlYSBjcm9zc2VzIHRoZSBhbnRpbWVyaWRpYW4gKG9mdGVuIGNvbmZ1c2VkIHdpdGggdGhlIEludGVybmF0aW9uYWwgRGF0ZSBMaW5lKSwgeW91IG11c3Qgc3BlY2lmeSBjb3JuZXJzIF9vdXRzaWRlXyB0aGUgWy0xODAsIDE4MF0gZGVncmVlcyBsb25naXR1ZGUgcmFuZ2UuXHJcbiAgICpcclxuICAgKiBOb3RlIHRoYXQgYExhdExuZ0JvdW5kc2AgZG9lcyBub3QgaW5oZXJpdCBmcm9tIExlYWZsZXQncyBgQ2xhc3NgIG9iamVjdCxcclxuICAgKiB3aGljaCBtZWFucyBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gaXQsIGFuZCBuZXcgbWV0aG9kc1xyXG4gICAqIGNhbid0IGJlIGFkZGVkIHRvIGl0IHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICAgKi9cclxuXHJcbiAgZnVuY3Rpb24gTGF0TG5nQm91bmRzKGNvcm5lcjEsIGNvcm5lcjIpIHsgLy8gKExhdExuZywgTGF0TG5nKSBvciAoTGF0TG5nW10pXHJcbiAgXHRpZiAoIWNvcm5lcjEpIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0dmFyIGxhdGxuZ3MgPSBjb3JuZXIyID8gW2Nvcm5lcjEsIGNvcm5lcjJdIDogY29ybmVyMTtcclxuXHJcbiAgXHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF0bG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHR0aGlzLmV4dGVuZChsYXRsbmdzW2ldKTtcclxuICBcdH1cclxuICB9XHJcblxyXG4gIExhdExuZ0JvdW5kcy5wcm90b3R5cGUgPSB7XHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBleHRlbmQobGF0bG5nOiBMYXRMbmcpOiB0aGlzXHJcbiAgXHQvLyBFeHRlbmQgdGhlIGJvdW5kcyB0byBjb250YWluIHRoZSBnaXZlbiBwb2ludFxyXG5cclxuICBcdC8vIEBhbHRlcm5hdGl2ZVxyXG4gIFx0Ly8gQG1ldGhvZCBleHRlbmQob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IHRoaXNcclxuICBcdC8vIEV4dGVuZCB0aGUgYm91bmRzIHRvIGNvbnRhaW4gdGhlIGdpdmVuIGJvdW5kc1xyXG4gIFx0ZXh0ZW5kOiBmdW5jdGlvbiAob2JqKSB7XHJcbiAgXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuICBcdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG4gIFx0XHQgICAgc3cyLCBuZTI7XHJcblxyXG4gIFx0XHRpZiAob2JqIGluc3RhbmNlb2YgTGF0TG5nKSB7XHJcbiAgXHRcdFx0c3cyID0gb2JqO1xyXG4gIFx0XHRcdG5lMiA9IG9iajtcclxuXHJcbiAgXHRcdH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgTGF0TG5nQm91bmRzKSB7XHJcbiAgXHRcdFx0c3cyID0gb2JqLl9zb3V0aFdlc3Q7XHJcbiAgXHRcdFx0bmUyID0gb2JqLl9ub3J0aEVhc3Q7XHJcblxyXG4gIFx0XHRcdGlmICghc3cyIHx8ICFuZTIpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0cmV0dXJuIG9iaiA/IHRoaXMuZXh0ZW5kKHRvTGF0TG5nKG9iaikgfHwgdG9MYXRMbmdCb3VuZHMob2JqKSkgOiB0aGlzO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAoIXN3ICYmICFuZSkge1xyXG4gIFx0XHRcdHRoaXMuX3NvdXRoV2VzdCA9IG5ldyBMYXRMbmcoc3cyLmxhdCwgc3cyLmxuZyk7XHJcbiAgXHRcdFx0dGhpcy5fbm9ydGhFYXN0ID0gbmV3IExhdExuZyhuZTIubGF0LCBuZTIubG5nKTtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRzdy5sYXQgPSBNYXRoLm1pbihzdzIubGF0LCBzdy5sYXQpO1xyXG4gIFx0XHRcdHN3LmxuZyA9IE1hdGgubWluKHN3Mi5sbmcsIHN3LmxuZyk7XHJcbiAgXHRcdFx0bmUubGF0ID0gTWF0aC5tYXgobmUyLmxhdCwgbmUubGF0KTtcclxuICBcdFx0XHRuZS5sbmcgPSBNYXRoLm1heChuZTIubG5nLCBuZS5sbmcpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBwYWQoYnVmZmVyUmF0aW86IE51bWJlcik6IExhdExuZ0JvdW5kc1xyXG4gIFx0Ly8gUmV0dXJucyBib3VuZHMgY3JlYXRlZCBieSBleHRlbmRpbmcgb3IgcmV0cmFjdGluZyB0aGUgY3VycmVudCBib3VuZHMgYnkgYSBnaXZlbiByYXRpbyBpbiBlYWNoIGRpcmVjdGlvbi5cclxuICBcdC8vIEZvciBleGFtcGxlLCBhIHJhdGlvIG9mIDAuNSBleHRlbmRzIHRoZSBib3VuZHMgYnkgNTAlIGluIGVhY2ggZGlyZWN0aW9uLlxyXG4gIFx0Ly8gTmVnYXRpdmUgdmFsdWVzIHdpbGwgcmV0cmFjdCB0aGUgYm91bmRzLlxyXG4gIFx0cGFkOiBmdW5jdGlvbiAoYnVmZmVyUmF0aW8pIHtcclxuICBcdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG4gIFx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcbiAgXHRcdCAgICBoZWlnaHRCdWZmZXIgPSBNYXRoLmFicyhzdy5sYXQgLSBuZS5sYXQpICogYnVmZmVyUmF0aW8sXHJcbiAgXHRcdCAgICB3aWR0aEJ1ZmZlciA9IE1hdGguYWJzKHN3LmxuZyAtIG5lLmxuZykgKiBidWZmZXJSYXRpbztcclxuXHJcbiAgXHRcdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKFxyXG4gIFx0XHQgICAgICAgIG5ldyBMYXRMbmcoc3cubGF0IC0gaGVpZ2h0QnVmZmVyLCBzdy5sbmcgLSB3aWR0aEJ1ZmZlciksXHJcbiAgXHRcdCAgICAgICAgbmV3IExhdExuZyhuZS5sYXQgKyBoZWlnaHRCdWZmZXIsIG5lLmxuZyArIHdpZHRoQnVmZmVyKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xyXG4gIFx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIHBvaW50IG9mIHRoZSBib3VuZHMuXHJcbiAgXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIG5ldyBMYXRMbmcoXHJcbiAgXHRcdCAgICAgICAgKHRoaXMuX3NvdXRoV2VzdC5sYXQgKyB0aGlzLl9ub3J0aEVhc3QubGF0KSAvIDIsXHJcbiAgXHRcdCAgICAgICAgKHRoaXMuX3NvdXRoV2VzdC5sbmcgKyB0aGlzLl9ub3J0aEVhc3QubG5nKSAvIDIpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFNvdXRoV2VzdCgpOiBMYXRMbmdcclxuICBcdC8vIFJldHVybnMgdGhlIHNvdXRoLXdlc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuICBcdGdldFNvdXRoV2VzdDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0O1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldE5vcnRoRWFzdCgpOiBMYXRMbmdcclxuICBcdC8vIFJldHVybnMgdGhlIG5vcnRoLWVhc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuICBcdGdldE5vcnRoRWFzdDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fbm9ydGhFYXN0O1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldE5vcnRoV2VzdCgpOiBMYXRMbmdcclxuICBcdC8vIFJldHVybnMgdGhlIG5vcnRoLXdlc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuICBcdGdldE5vcnRoV2VzdDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gbmV3IExhdExuZyh0aGlzLmdldE5vcnRoKCksIHRoaXMuZ2V0V2VzdCgpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRTb3V0aEVhc3QoKTogTGF0TG5nXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBzb3V0aC1lYXN0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcbiAgXHRnZXRTb3V0aEVhc3Q6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIG5ldyBMYXRMbmcodGhpcy5nZXRTb3V0aCgpLCB0aGlzLmdldEVhc3QoKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0V2VzdCgpOiBOdW1iZXJcclxuICBcdC8vIFJldHVybnMgdGhlIHdlc3QgbG9uZ2l0dWRlIG9mIHRoZSBib3VuZHNcclxuICBcdGdldFdlc3Q6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdC5sbmc7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0U291dGgoKTogTnVtYmVyXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBzb3V0aCBsYXRpdHVkZSBvZiB0aGUgYm91bmRzXHJcbiAgXHRnZXRTb3V0aDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0LmxhdDtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRFYXN0KCk6IE51bWJlclxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgZWFzdCBsb25naXR1ZGUgb2YgdGhlIGJvdW5kc1xyXG4gIFx0Z2V0RWFzdDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fbm9ydGhFYXN0LmxuZztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXROb3J0aCgpOiBOdW1iZXJcclxuICBcdC8vIFJldHVybnMgdGhlIG5vcnRoIGxhdGl0dWRlIG9mIHRoZSBib3VuZHNcclxuICBcdGdldE5vcnRoOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9ub3J0aEVhc3QubGF0O1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGNvbnRhaW5zKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMpOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBvbmUuXHJcblxyXG4gIFx0Ly8gQGFsdGVybmF0aXZlXHJcbiAgXHQvLyBAbWV0aG9kIGNvbnRhaW5zIChsYXRsbmc6IExhdExuZyk6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIHBvaW50LlxyXG4gIFx0Y29udGFpbnM6IGZ1bmN0aW9uIChvYmopIHsgLy8gKExhdExuZ0JvdW5kcykgb3IgKExhdExuZykgLT4gQm9vbGVhblxyXG4gIFx0XHRpZiAodHlwZW9mIG9ialswXSA9PT0gJ251bWJlcicgfHwgb2JqIGluc3RhbmNlb2YgTGF0TG5nIHx8ICdsYXQnIGluIG9iaikge1xyXG4gIFx0XHRcdG9iaiA9IHRvTGF0TG5nKG9iaik7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0b2JqID0gdG9MYXRMbmdCb3VuZHMob2JqKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG4gIFx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcbiAgXHRcdCAgICBzdzIsIG5lMjtcclxuXHJcbiAgXHRcdGlmIChvYmogaW5zdGFuY2VvZiBMYXRMbmdCb3VuZHMpIHtcclxuICBcdFx0XHRzdzIgPSBvYmouZ2V0U291dGhXZXN0KCk7XHJcbiAgXHRcdFx0bmUyID0gb2JqLmdldE5vcnRoRWFzdCgpO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdHN3MiA9IG5lMiA9IG9iajtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIChzdzIubGF0ID49IHN3LmxhdCkgJiYgKG5lMi5sYXQgPD0gbmUubGF0KSAmJlxyXG4gIFx0XHQgICAgICAgKHN3Mi5sbmcgPj0gc3cubG5nKSAmJiAobmUyLmxuZyA8PSBuZS5sbmcpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGludGVyc2VjdHMob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgaW50ZXJzZWN0cyB0aGUgZ2l2ZW4gYm91bmRzLiBUd28gYm91bmRzIGludGVyc2VjdCBpZiB0aGV5IGhhdmUgYXQgbGVhc3Qgb25lIHBvaW50IGluIGNvbW1vbi5cclxuICBcdGludGVyc2VjdHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuICBcdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcbiAgXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuICBcdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG4gIFx0XHQgICAgc3cyID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLFxyXG4gIFx0XHQgICAgbmUyID0gYm91bmRzLmdldE5vcnRoRWFzdCgpLFxyXG5cclxuICBcdFx0ICAgIGxhdEludGVyc2VjdHMgPSAobmUyLmxhdCA+PSBzdy5sYXQpICYmIChzdzIubGF0IDw9IG5lLmxhdCksXHJcbiAgXHRcdCAgICBsbmdJbnRlcnNlY3RzID0gKG5lMi5sbmcgPj0gc3cubG5nKSAmJiAoc3cyLmxuZyA8PSBuZS5sbmcpO1xyXG5cclxuICBcdFx0cmV0dXJuIGxhdEludGVyc2VjdHMgJiYgbG5nSW50ZXJzZWN0cztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBvdmVybGFwcyhvdGhlckJvdW5kczogTGF0TG5nQm91bmRzKTogQm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBvdmVybGFwcyB0aGUgZ2l2ZW4gYm91bmRzLiBUd28gYm91bmRzIG92ZXJsYXAgaWYgdGhlaXIgaW50ZXJzZWN0aW9uIGlzIGFuIGFyZWEuXHJcbiAgXHRvdmVybGFwczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG4gIFx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuICBcdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG4gIFx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcbiAgXHRcdCAgICBzdzIgPSBib3VuZHMuZ2V0U291dGhXZXN0KCksXHJcbiAgXHRcdCAgICBuZTIgPSBib3VuZHMuZ2V0Tm9ydGhFYXN0KCksXHJcblxyXG4gIFx0XHQgICAgbGF0T3ZlcmxhcHMgPSAobmUyLmxhdCA+IHN3LmxhdCkgJiYgKHN3Mi5sYXQgPCBuZS5sYXQpLFxyXG4gIFx0XHQgICAgbG5nT3ZlcmxhcHMgPSAobmUyLmxuZyA+IHN3LmxuZykgJiYgKHN3Mi5sbmcgPCBuZS5sbmcpO1xyXG5cclxuICBcdFx0cmV0dXJuIGxhdE92ZXJsYXBzICYmIGxuZ092ZXJsYXBzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHRvQkJveFN0cmluZygpOiBTdHJpbmdcclxuICBcdC8vIFJldHVybnMgYSBzdHJpbmcgd2l0aCBib3VuZGluZyBib3ggY29vcmRpbmF0ZXMgaW4gYSAnc291dGh3ZXN0X2xuZyxzb3V0aHdlc3RfbGF0LG5vcnRoZWFzdF9sbmcsbm9ydGhlYXN0X2xhdCcgZm9ybWF0LiBVc2VmdWwgZm9yIHNlbmRpbmcgcmVxdWVzdHMgdG8gd2ViIHNlcnZpY2VzIHRoYXQgcmV0dXJuIGdlbyBkYXRhLlxyXG4gIFx0dG9CQm94U3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiBbdGhpcy5nZXRXZXN0KCksIHRoaXMuZ2V0U291dGgoKSwgdGhpcy5nZXRFYXN0KCksIHRoaXMuZ2V0Tm9ydGgoKV0uam9pbignLCcpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGVxdWFscyhvdGhlckJvdW5kczogTGF0TG5nQm91bmRzLCBtYXhNYXJnaW4/OiBOdW1iZXIpOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGlzIGVxdWl2YWxlbnQgKHdpdGhpbiBhIHNtYWxsIG1hcmdpbiBvZiBlcnJvcikgdG8gdGhlIGdpdmVuIGJvdW5kcy4gVGhlIG1hcmdpbiBvZiBlcnJvciBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzZXR0aW5nIGBtYXhNYXJnaW5gIHRvIGEgc21hbGwgbnVtYmVyLlxyXG4gIFx0ZXF1YWxzOiBmdW5jdGlvbiAoYm91bmRzLCBtYXhNYXJnaW4pIHtcclxuICBcdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4gIFx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuICBcdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdC5lcXVhbHMoYm91bmRzLmdldFNvdXRoV2VzdCgpLCBtYXhNYXJnaW4pICYmXHJcbiAgXHRcdCAgICAgICB0aGlzLl9ub3J0aEVhc3QuZXF1YWxzKGJvdW5kcy5nZXROb3J0aEVhc3QoKSwgbWF4TWFyZ2luKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBpc1ZhbGlkKCk6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBib3VuZHMgYXJlIHByb3Blcmx5IGluaXRpYWxpemVkLlxyXG4gIFx0aXNWYWxpZDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gISEodGhpcy5fc291dGhXZXN0ICYmIHRoaXMuX25vcnRoRWFzdCk7XHJcbiAgXHR9XHJcbiAgfTtcclxuXHJcbiAgLy8gVE9ETyBJbnRlcm5hdGlvbmFsIGRhdGUgbGluZT9cclxuXHJcbiAgLy8gQGZhY3RvcnkgTC5sYXRMbmdCb3VuZHMoY29ybmVyMTogTGF0TG5nLCBjb3JuZXIyOiBMYXRMbmcpXHJcbiAgLy8gQ3JlYXRlcyBhIGBMYXRMbmdCb3VuZHNgIG9iamVjdCBieSBkZWZpbmluZyB0d28gZGlhZ29uYWxseSBvcHBvc2l0ZSBjb3JuZXJzIG9mIHRoZSByZWN0YW5nbGUuXHJcblxyXG4gIC8vIEBhbHRlcm5hdGl2ZVxyXG4gIC8vIEBmYWN0b3J5IEwubGF0TG5nQm91bmRzKGxhdGxuZ3M6IExhdExuZ1tdKVxyXG4gIC8vIENyZWF0ZXMgYSBgTGF0TG5nQm91bmRzYCBvYmplY3QgZGVmaW5lZCBieSB0aGUgZ2VvZ3JhcGhpY2FsIHBvaW50cyBpdCBjb250YWlucy4gVmVyeSB1c2VmdWwgZm9yIHpvb21pbmcgdGhlIG1hcCB0byBmaXQgYSBwYXJ0aWN1bGFyIHNldCBvZiBsb2NhdGlvbnMgd2l0aCBbYGZpdEJvdW5kc2BdKCNtYXAtZml0Ym91bmRzKS5cclxuICBmdW5jdGlvbiB0b0xhdExuZ0JvdW5kcyhhLCBiKSB7XHJcbiAgXHRpZiAoYSBpbnN0YW5jZW9mIExhdExuZ0JvdW5kcykge1xyXG4gIFx0XHRyZXR1cm4gYTtcclxuICBcdH1cclxuICBcdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKGEsIGIpO1xyXG4gIH1cblxuICAvKiBAY2xhc3MgTGF0TG5nXHJcbiAgICogQGFrYSBMLkxhdExuZ1xyXG4gICAqXHJcbiAgICogUmVwcmVzZW50cyBhIGdlb2dyYXBoaWNhbCBwb2ludCB3aXRoIGEgY2VydGFpbiBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYFxyXG4gICAqIHZhciBsYXRsbmcgPSBMLmxhdExuZyg1MC41LCAzMC41KTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEFsbCBMZWFmbGV0IG1ldGhvZHMgdGhhdCBhY2NlcHQgTGF0TG5nIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtIGFuZCBzaW1wbGUgb2JqZWN0IGZvcm0gKHVubGVzcyBub3RlZCBvdGhlcndpc2UpLCBzbyB0aGVzZSBsaW5lcyBhcmUgZXF1aXZhbGVudDpcclxuICAgKlxyXG4gICAqIGBgYFxyXG4gICAqIG1hcC5wYW5UbyhbNTAsIDMwXSk7XHJcbiAgICogbWFwLnBhblRvKHtsb246IDMwLCBsYXQ6IDUwfSk7XHJcbiAgICogbWFwLnBhblRvKHtsYXQ6IDUwLCBsbmc6IDMwfSk7XHJcbiAgICogbWFwLnBhblRvKEwubGF0TG5nKDUwLCAzMCkpO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogTm90ZSB0aGF0IGBMYXRMbmdgIGRvZXMgbm90IGluaGVyaXQgZnJvbSBMZWFmbGV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAgICogd2hpY2ggbWVhbnMgbmV3IGNsYXNzZXMgY2FuJ3QgaW5oZXJpdCBmcm9tIGl0LCBhbmQgbmV3IG1ldGhvZHNcclxuICAgKiBjYW4ndCBiZSBhZGRlZCB0byBpdCB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXHJcbiAgICovXHJcblxyXG4gIGZ1bmN0aW9uIExhdExuZyhsYXQsIGxuZywgYWx0KSB7XHJcbiAgXHRpZiAoaXNOYU4obGF0KSB8fCBpc05hTihsbmcpKSB7XHJcbiAgXHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBMYXRMbmcgb2JqZWN0OiAoJyArIGxhdCArICcsICcgKyBsbmcgKyAnKScpO1xyXG4gIFx0fVxyXG5cclxuICBcdC8vIEBwcm9wZXJ0eSBsYXQ6IE51bWJlclxyXG4gIFx0Ly8gTGF0aXR1ZGUgaW4gZGVncmVlc1xyXG4gIFx0dGhpcy5sYXQgPSArbGF0O1xyXG5cclxuICBcdC8vIEBwcm9wZXJ0eSBsbmc6IE51bWJlclxyXG4gIFx0Ly8gTG9uZ2l0dWRlIGluIGRlZ3JlZXNcclxuICBcdHRoaXMubG5nID0gK2xuZztcclxuXHJcbiAgXHQvLyBAcHJvcGVydHkgYWx0OiBOdW1iZXJcclxuICBcdC8vIEFsdGl0dWRlIGluIG1ldGVycyAob3B0aW9uYWwpXHJcbiAgXHRpZiAoYWx0ICE9PSB1bmRlZmluZWQpIHtcclxuICBcdFx0dGhpcy5hbHQgPSArYWx0O1xyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgTGF0TG5nLnByb3RvdHlwZSA9IHtcclxuICBcdC8vIEBtZXRob2QgZXF1YWxzKG90aGVyTGF0TG5nOiBMYXRMbmcsIG1heE1hcmdpbj86IE51bWJlcik6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBgTGF0TG5nYCBwb2ludCBpcyBhdCB0aGUgc2FtZSBwb3NpdGlvbiAod2l0aGluIGEgc21hbGwgbWFyZ2luIG9mIGVycm9yKS4gVGhlIG1hcmdpbiBvZiBlcnJvciBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzZXR0aW5nIGBtYXhNYXJnaW5gIHRvIGEgc21hbGwgbnVtYmVyLlxyXG4gIFx0ZXF1YWxzOiBmdW5jdGlvbiAob2JqLCBtYXhNYXJnaW4pIHtcclxuICBcdFx0aWYgKCFvYmopIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4gIFx0XHRvYmogPSB0b0xhdExuZyhvYmopO1xyXG5cclxuICBcdFx0dmFyIG1hcmdpbiA9IE1hdGgubWF4KFxyXG4gIFx0XHQgICAgICAgIE1hdGguYWJzKHRoaXMubGF0IC0gb2JqLmxhdCksXHJcbiAgXHRcdCAgICAgICAgTWF0aC5hYnModGhpcy5sbmcgLSBvYmoubG5nKSk7XHJcblxyXG4gIFx0XHRyZXR1cm4gbWFyZ2luIDw9IChtYXhNYXJnaW4gPT09IHVuZGVmaW5lZCA/IDEuMEUtOSA6IG1heE1hcmdpbik7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgdG9TdHJpbmcoKTogU3RyaW5nXHJcbiAgXHQvLyBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2ludCAoZm9yIGRlYnVnZ2luZyBwdXJwb3NlcykuXHJcbiAgXHR0b1N0cmluZzogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG4gIFx0XHRyZXR1cm4gJ0xhdExuZygnICtcclxuICBcdFx0ICAgICAgICBmb3JtYXROdW0odGhpcy5sYXQsIHByZWNpc2lvbikgKyAnLCAnICtcclxuICBcdFx0ICAgICAgICBmb3JtYXROdW0odGhpcy5sbmcsIHByZWNpc2lvbikgKyAnKSc7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZGlzdGFuY2VUbyhvdGhlckxhdExuZzogTGF0TG5nKTogTnVtYmVyXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSAoaW4gbWV0ZXJzKSB0byB0aGUgZ2l2ZW4gYExhdExuZ2AgY2FsY3VsYXRlZCB1c2luZyB0aGUgW1NwaGVyaWNhbCBMYXcgb2YgQ29zaW5lc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3BoZXJpY2FsX2xhd19vZl9jb3NpbmVzKS5cclxuICBcdGRpc3RhbmNlVG86IGZ1bmN0aW9uIChvdGhlcikge1xyXG4gIFx0XHRyZXR1cm4gRWFydGguZGlzdGFuY2UodGhpcywgdG9MYXRMbmcob3RoZXIpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB3cmFwKCk6IExhdExuZ1xyXG4gIFx0Ly8gUmV0dXJucyBhIG5ldyBgTGF0TG5nYCBvYmplY3Qgd2l0aCB0aGUgbG9uZ2l0dWRlIHdyYXBwZWQgc28gaXQncyBhbHdheXMgYmV0d2VlbiAtMTgwIGFuZCArMTgwIGRlZ3JlZXMuXHJcbiAgXHR3cmFwOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiBFYXJ0aC53cmFwTGF0TG5nKHRoaXMpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHRvQm91bmRzKHNpemVJbk1ldGVyczogTnVtYmVyKTogTGF0TG5nQm91bmRzXHJcbiAgXHQvLyBSZXR1cm5zIGEgbmV3IGBMYXRMbmdCb3VuZHNgIG9iamVjdCBpbiB3aGljaCBlYWNoIGJvdW5kYXJ5IGlzIGBzaXplSW5NZXRlcnMvMmAgbWV0ZXJzIGFwYXJ0IGZyb20gdGhlIGBMYXRMbmdgLlxyXG4gIFx0dG9Cb3VuZHM6IGZ1bmN0aW9uIChzaXplSW5NZXRlcnMpIHtcclxuICBcdFx0dmFyIGxhdEFjY3VyYWN5ID0gMTgwICogc2l6ZUluTWV0ZXJzIC8gNDAwNzUwMTcsXHJcbiAgXHRcdCAgICBsbmdBY2N1cmFjeSA9IGxhdEFjY3VyYWN5IC8gTWF0aC5jb3MoKE1hdGguUEkgLyAxODApICogdGhpcy5sYXQpO1xyXG5cclxuICBcdFx0cmV0dXJuIHRvTGF0TG5nQm91bmRzKFxyXG4gIFx0XHQgICAgICAgIFt0aGlzLmxhdCAtIGxhdEFjY3VyYWN5LCB0aGlzLmxuZyAtIGxuZ0FjY3VyYWN5XSxcclxuICBcdFx0ICAgICAgICBbdGhpcy5sYXQgKyBsYXRBY2N1cmFjeSwgdGhpcy5sbmcgKyBsbmdBY2N1cmFjeV0pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gbmV3IExhdExuZyh0aGlzLmxhdCwgdGhpcy5sbmcsIHRoaXMuYWx0KTtcclxuICBcdH1cclxuICB9O1xyXG5cclxuXHJcblxyXG4gIC8vIEBmYWN0b3J5IEwubGF0TG5nKGxhdGl0dWRlOiBOdW1iZXIsIGxvbmdpdHVkZTogTnVtYmVyLCBhbHRpdHVkZT86IE51bWJlcik6IExhdExuZ1xyXG4gIC8vIENyZWF0ZXMgYW4gb2JqZWN0IHJlcHJlc2VudGluZyBhIGdlb2dyYXBoaWNhbCBwb2ludCB3aXRoIHRoZSBnaXZlbiBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlIChhbmQgb3B0aW9uYWxseSBhbHRpdHVkZSkuXHJcblxyXG4gIC8vIEBhbHRlcm5hdGl2ZVxyXG4gIC8vIEBmYWN0b3J5IEwubGF0TG5nKGNvb3JkczogQXJyYXkpOiBMYXRMbmdcclxuICAvLyBFeHBlY3RzIGFuIGFycmF5IG9mIHRoZSBmb3JtIGBbTnVtYmVyLCBOdW1iZXJdYCBvciBgW051bWJlciwgTnVtYmVyLCBOdW1iZXJdYCBpbnN0ZWFkLlxyXG5cclxuICAvLyBAYWx0ZXJuYXRpdmVcclxuICAvLyBAZmFjdG9yeSBMLmxhdExuZyhjb29yZHM6IE9iamVjdCk6IExhdExuZ1xyXG4gIC8vIEV4cGVjdHMgYW4gcGxhaW4gb2JqZWN0IG9mIHRoZSBmb3JtIGB7bGF0OiBOdW1iZXIsIGxuZzogTnVtYmVyfWAgb3IgYHtsYXQ6IE51bWJlciwgbG5nOiBOdW1iZXIsIGFsdDogTnVtYmVyfWAgaW5zdGVhZC5cclxuXHJcbiAgZnVuY3Rpb24gdG9MYXRMbmcoYSwgYiwgYykge1xyXG4gIFx0aWYgKGEgaW5zdGFuY2VvZiBMYXRMbmcpIHtcclxuICBcdFx0cmV0dXJuIGE7XHJcbiAgXHR9XHJcbiAgXHRpZiAoaXNBcnJheShhKSAmJiB0eXBlb2YgYVswXSAhPT0gJ29iamVjdCcpIHtcclxuICBcdFx0aWYgKGEubGVuZ3RoID09PSAzKSB7XHJcbiAgXHRcdFx0cmV0dXJuIG5ldyBMYXRMbmcoYVswXSwgYVsxXSwgYVsyXSk7XHJcbiAgXHRcdH1cclxuICBcdFx0aWYgKGEubGVuZ3RoID09PSAyKSB7XHJcbiAgXHRcdFx0cmV0dXJuIG5ldyBMYXRMbmcoYVswXSwgYVsxXSk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIG51bGw7XHJcbiAgXHR9XHJcbiAgXHRpZiAoYSA9PT0gdW5kZWZpbmVkIHx8IGEgPT09IG51bGwpIHtcclxuICBcdFx0cmV0dXJuIGE7XHJcbiAgXHR9XHJcbiAgXHRpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnICYmICdsYXQnIGluIGEpIHtcclxuICBcdFx0cmV0dXJuIG5ldyBMYXRMbmcoYS5sYXQsICdsbmcnIGluIGEgPyBhLmxuZyA6IGEubG9uLCBhLmFsdCk7XHJcbiAgXHR9XHJcbiAgXHRpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgXHRcdHJldHVybiBudWxsO1xyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIG5ldyBMYXRMbmcoYSwgYiwgYyk7XHJcbiAgfVxuXG4gIC8qXHJcbiAgICogQG5hbWVzcGFjZSBDUlNcclxuICAgKiBAY3JzIEwuQ1JTLkJhc2VcclxuICAgKiBPYmplY3QgdGhhdCBkZWZpbmVzIGNvb3JkaW5hdGUgcmVmZXJlbmNlIHN5c3RlbXMgZm9yIHByb2plY3RpbmdcclxuICAgKiBnZW9ncmFwaGljYWwgcG9pbnRzIGludG8gcGl4ZWwgKHNjcmVlbikgY29vcmRpbmF0ZXMgYW5kIGJhY2sgKGFuZCB0b1xyXG4gICAqIGNvb3JkaW5hdGVzIGluIG90aGVyIHVuaXRzIGZvciBbV01TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XZWJfTWFwX1NlcnZpY2UpIHNlcnZpY2VzKS4gU2VlXHJcbiAgICogW3NwYXRpYWwgcmVmZXJlbmNlIHN5c3RlbV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3BhdGlhbF9yZWZlcmVuY2Vfc3lzdGVtKS5cclxuICAgKlxyXG4gICAqIExlYWZsZXQgZGVmaW5lcyB0aGUgbW9zdCB1c3VhbCBDUlNzIGJ5IGRlZmF1bHQuIElmIHlvdSB3YW50IHRvIHVzZSBhXHJcbiAgICogQ1JTIG5vdCBkZWZpbmVkIGJ5IGRlZmF1bHQsIHRha2UgYSBsb29rIGF0IHRoZVxyXG4gICAqIFtQcm9qNExlYWZsZXRdKGh0dHBzOi8vZ2l0aHViLmNvbS9rYXJ0ZW5hL1Byb2o0TGVhZmxldCkgcGx1Z2luLlxyXG4gICAqXHJcbiAgICogTm90ZSB0aGF0IHRoZSBDUlMgaW5zdGFuY2VzIGRvIG5vdCBpbmhlcml0IGZyb20gTGVhZmxldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gICAqIGFuZCBjYW4ndCBiZSBpbnN0YW50aWF0ZWQuIEFsc28sIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSB0aGVtLFxyXG4gICAqIGFuZCBtZXRob2RzIGNhbid0IGJlIGFkZGVkIHRvIHRoZW0gd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxyXG4gICAqL1xyXG5cclxuICB2YXIgQ1JTID0ge1xyXG4gIFx0Ly8gQG1ldGhvZCBsYXRMbmdUb1BvaW50KGxhdGxuZzogTGF0TG5nLCB6b29tOiBOdW1iZXIpOiBQb2ludFxyXG4gIFx0Ly8gUHJvamVjdHMgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIGludG8gcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIGEgZ2l2ZW4gem9vbS5cclxuICBcdGxhdExuZ1RvUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20pIHtcclxuICBcdFx0dmFyIHByb2plY3RlZFBvaW50ID0gdGhpcy5wcm9qZWN0aW9uLnByb2plY3QobGF0bG5nKSxcclxuICBcdFx0ICAgIHNjYWxlID0gdGhpcy5zY2FsZSh6b29tKTtcclxuXHJcbiAgXHRcdHJldHVybiB0aGlzLnRyYW5zZm9ybWF0aW9uLl90cmFuc2Zvcm0ocHJvamVjdGVkUG9pbnQsIHNjYWxlKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBwb2ludFRvTGF0TG5nKHBvaW50OiBQb2ludCwgem9vbTogTnVtYmVyKTogTGF0TG5nXHJcbiAgXHQvLyBUaGUgaW52ZXJzZSBvZiBgbGF0TG5nVG9Qb2ludGAuIFByb2plY3RzIHBpeGVsIGNvb3JkaW5hdGVzIG9uIGEgZ2l2ZW5cclxuICBcdC8vIHpvb20gaW50byBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMuXHJcbiAgXHRwb2ludFRvTGF0TG5nOiBmdW5jdGlvbiAocG9pbnQsIHpvb20pIHtcclxuICBcdFx0dmFyIHNjYWxlID0gdGhpcy5zY2FsZSh6b29tKSxcclxuICBcdFx0ICAgIHVudHJhbnNmb3JtZWRQb2ludCA9IHRoaXMudHJhbnNmb3JtYXRpb24udW50cmFuc2Zvcm0ocG9pbnQsIHNjYWxlKTtcclxuXHJcbiAgXHRcdHJldHVybiB0aGlzLnByb2plY3Rpb24udW5wcm9qZWN0KHVudHJhbnNmb3JtZWRQb2ludCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgcHJvamVjdChsYXRsbmc6IExhdExuZyk6IFBvaW50XHJcbiAgXHQvLyBQcm9qZWN0cyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgaW50byBjb29yZGluYXRlcyBpbiB1bml0cyBhY2NlcHRlZCBmb3JcclxuICBcdC8vIHRoaXMgQ1JTIChlLmcuIG1ldGVycyBmb3IgRVBTRzozODU3LCBmb3IgcGFzc2luZyBpdCB0byBXTVMgc2VydmljZXMpLlxyXG4gIFx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0aW9uLnByb2plY3QobGF0bG5nKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB1bnByb2plY3QocG9pbnQ6IFBvaW50KTogTGF0TG5nXHJcbiAgXHQvLyBHaXZlbiBhIHByb2plY3RlZCBjb29yZGluYXRlIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgTGF0TG5nLlxyXG4gIFx0Ly8gVGhlIGludmVyc2Ugb2YgYHByb2plY3RgLlxyXG4gIFx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMucHJvamVjdGlvbi51bnByb2plY3QocG9pbnQpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNjYWxlKHpvb206IE51bWJlcik6IE51bWJlclxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgc2NhbGUgdXNlZCB3aGVuIHRyYW5zZm9ybWluZyBwcm9qZWN0ZWQgY29vcmRpbmF0ZXMgaW50b1xyXG4gIFx0Ly8gcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIGEgcGFydGljdWxhciB6b29tLiBGb3IgZXhhbXBsZSwgaXQgcmV0dXJuc1xyXG4gIFx0Ly8gYDI1NiAqIDJeem9vbWAgZm9yIE1lcmNhdG9yLWJhc2VkIENSUy5cclxuICBcdHNjYWxlOiBmdW5jdGlvbiAoem9vbSkge1xyXG4gIFx0XHRyZXR1cm4gMjU2ICogTWF0aC5wb3coMiwgem9vbSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgem9vbShzY2FsZTogTnVtYmVyKTogTnVtYmVyXHJcbiAgXHQvLyBJbnZlcnNlIG9mIGBzY2FsZSgpYCwgcmV0dXJucyB0aGUgem9vbSBsZXZlbCBjb3JyZXNwb25kaW5nIHRvIGEgc2NhbGVcclxuICBcdC8vIGZhY3RvciBvZiBgc2NhbGVgLlxyXG4gIFx0em9vbTogZnVuY3Rpb24gKHNjYWxlKSB7XHJcbiAgXHRcdHJldHVybiBNYXRoLmxvZyhzY2FsZSAvIDI1NikgLyBNYXRoLkxOMjtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRQcm9qZWN0ZWRCb3VuZHMoem9vbTogTnVtYmVyKTogQm91bmRzXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBwcm9qZWN0aW9uJ3MgYm91bmRzIHNjYWxlZCBhbmQgdHJhbnNmb3JtZWQgZm9yIHRoZSBwcm92aWRlZCBgem9vbWAuXHJcbiAgXHRnZXRQcm9qZWN0ZWRCb3VuZHM6IGZ1bmN0aW9uICh6b29tKSB7XHJcbiAgXHRcdGlmICh0aGlzLmluZmluaXRlKSB7IHJldHVybiBudWxsOyB9XHJcblxyXG4gIFx0XHR2YXIgYiA9IHRoaXMucHJvamVjdGlvbi5ib3VuZHMsXHJcbiAgXHRcdCAgICBzID0gdGhpcy5zY2FsZSh6b29tKSxcclxuICBcdFx0ICAgIG1pbiA9IHRoaXMudHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKGIubWluLCBzKSxcclxuICBcdFx0ICAgIG1heCA9IHRoaXMudHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKGIubWF4LCBzKTtcclxuXHJcbiAgXHRcdHJldHVybiBuZXcgQm91bmRzKG1pbiwgbWF4KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBkaXN0YW5jZShsYXRsbmcxOiBMYXRMbmcsIGxhdGxuZzI6IExhdExuZyk6IE51bWJlclxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzLlxyXG5cclxuICBcdC8vIEBwcm9wZXJ0eSBjb2RlOiBTdHJpbmdcclxuICBcdC8vIFN0YW5kYXJkIGNvZGUgbmFtZSBvZiB0aGUgQ1JTIHBhc3NlZCBpbnRvIFdNUyBzZXJ2aWNlcyAoZS5nLiBgJ0VQU0c6Mzg1NydgKVxyXG4gIFx0Ly9cclxuICBcdC8vIEBwcm9wZXJ0eSB3cmFwTG5nOiBOdW1iZXJbXVxyXG4gIFx0Ly8gQW4gYXJyYXkgb2YgdHdvIG51bWJlcnMgZGVmaW5pbmcgd2hldGhlciB0aGUgbG9uZ2l0dWRlIChob3Jpem9udGFsKSBjb29yZGluYXRlXHJcbiAgXHQvLyBheGlzIHdyYXBzIGFyb3VuZCBhIGdpdmVuIHJhbmdlIGFuZCBob3cuIERlZmF1bHRzIHRvIGBbLTE4MCwgMTgwXWAgaW4gbW9zdFxyXG4gIFx0Ly8gZ2VvZ3JhcGhpY2FsIENSU3MuIElmIGB1bmRlZmluZWRgLCB0aGUgbG9uZ2l0dWRlIGF4aXMgZG9lcyBub3Qgd3JhcCBhcm91bmQuXHJcbiAgXHQvL1xyXG4gIFx0Ly8gQHByb3BlcnR5IHdyYXBMYXQ6IE51bWJlcltdXHJcbiAgXHQvLyBMaWtlIGB3cmFwTG5nYCwgYnV0IGZvciB0aGUgbGF0aXR1ZGUgKHZlcnRpY2FsKSBheGlzLlxyXG5cclxuICBcdC8vIHdyYXBMbmc6IFttaW4sIG1heF0sXHJcbiAgXHQvLyB3cmFwTGF0OiBbbWluLCBtYXhdLFxyXG5cclxuICBcdC8vIEBwcm9wZXJ0eSBpbmZpbml0ZTogQm9vbGVhblxyXG4gIFx0Ly8gSWYgdHJ1ZSwgdGhlIGNvb3JkaW5hdGUgc3BhY2Ugd2lsbCBiZSB1bmJvdW5kZWQgKGluZmluaXRlIGluIGJvdGggYXhlcylcclxuICBcdGluZmluaXRlOiBmYWxzZSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiBMYXRMbmdcclxuICBcdC8vIFJldHVybnMgYSBgTGF0TG5nYCB3aGVyZSBsYXQgYW5kIGxuZyBoYXMgYmVlbiB3cmFwcGVkIGFjY29yZGluZyB0byB0aGVcclxuICBcdC8vIENSUydzIGB3cmFwTGF0YCBhbmQgYHdyYXBMbmdgIHByb3BlcnRpZXMsIGlmIHRoZXkgYXJlIG91dHNpZGUgdGhlIENSUydzIGJvdW5kcy5cclxuICBcdHdyYXBMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuICBcdFx0dmFyIGxuZyA9IHRoaXMud3JhcExuZyA/IHdyYXBOdW0obGF0bG5nLmxuZywgdGhpcy53cmFwTG5nLCB0cnVlKSA6IGxhdGxuZy5sbmcsXHJcbiAgXHRcdCAgICBsYXQgPSB0aGlzLndyYXBMYXQgPyB3cmFwTnVtKGxhdGxuZy5sYXQsIHRoaXMud3JhcExhdCwgdHJ1ZSkgOiBsYXRsbmcubGF0LFxyXG4gIFx0XHQgICAgYWx0ID0gbGF0bG5nLmFsdDtcclxuXHJcbiAgXHRcdHJldHVybiBuZXcgTGF0TG5nKGxhdCwgbG5nLCBhbHQpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmdCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMpOiBMYXRMbmdCb3VuZHNcclxuICBcdC8vIFJldHVybnMgYSBgTGF0TG5nQm91bmRzYCB3aXRoIHRoZSBzYW1lIHNpemUgYXMgdGhlIGdpdmVuIG9uZSwgZW5zdXJpbmdcclxuICBcdC8vIHRoYXQgaXRzIGNlbnRlciBpcyB3aXRoaW4gdGhlIENSUydzIGJvdW5kcy5cclxuICBcdC8vIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuTGF0TG5nQm91bmRzYCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXHJcbiAgXHR3cmFwTGF0TG5nQm91bmRzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcbiAgXHRcdHZhciBjZW50ZXIgPSBib3VuZHMuZ2V0Q2VudGVyKCksXHJcbiAgXHRcdCAgICBuZXdDZW50ZXIgPSB0aGlzLndyYXBMYXRMbmcoY2VudGVyKSxcclxuICBcdFx0ICAgIGxhdFNoaWZ0ID0gY2VudGVyLmxhdCAtIG5ld0NlbnRlci5sYXQsXHJcbiAgXHRcdCAgICBsbmdTaGlmdCA9IGNlbnRlci5sbmcgLSBuZXdDZW50ZXIubG5nO1xyXG5cclxuICBcdFx0aWYgKGxhdFNoaWZ0ID09PSAwICYmIGxuZ1NoaWZ0ID09PSAwKSB7XHJcbiAgXHRcdFx0cmV0dXJuIGJvdW5kcztcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIHN3ID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLFxyXG4gIFx0XHQgICAgbmUgPSBib3VuZHMuZ2V0Tm9ydGhFYXN0KCksXHJcbiAgXHRcdCAgICBuZXdTdyA9IG5ldyBMYXRMbmcoc3cubGF0IC0gbGF0U2hpZnQsIHN3LmxuZyAtIGxuZ1NoaWZ0KSxcclxuICBcdFx0ICAgIG5ld05lID0gbmV3IExhdExuZyhuZS5sYXQgLSBsYXRTaGlmdCwgbmUubG5nIC0gbG5nU2hpZnQpO1xyXG5cclxuICBcdFx0cmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMobmV3U3csIG5ld05lKTtcclxuICBcdH1cclxuICB9O1xuXG4gIC8qXG4gICAqIEBuYW1lc3BhY2UgQ1JTXG4gICAqIEBjcnMgTC5DUlMuRWFydGhcbiAgICpcbiAgICogU2VydmVzIGFzIHRoZSBiYXNlIGZvciBDUlMgdGhhdCBhcmUgZ2xvYmFsIHN1Y2ggdGhhdCB0aGV5IGNvdmVyIHRoZSBlYXJ0aC5cbiAgICogQ2FuIG9ubHkgYmUgdXNlZCBhcyB0aGUgYmFzZSBmb3Igb3RoZXIgQ1JTIGFuZCBjYW5ub3QgYmUgdXNlZCBkaXJlY3RseSxcbiAgICogc2luY2UgaXQgZG9lcyBub3QgaGF2ZSBhIGBjb2RlYCwgYHByb2plY3Rpb25gIG9yIGB0cmFuc2Zvcm1hdGlvbmAuIGBkaXN0YW5jZSgpYCByZXR1cm5zXG4gICAqIG1ldGVycy5cbiAgICovXG5cbiAgdmFyIEVhcnRoID0gZXh0ZW5kKHt9LCBDUlMsIHtcbiAgXHR3cmFwTG5nOiBbLTE4MCwgMTgwXSxcblxuICBcdC8vIE1lYW4gRWFydGggUmFkaXVzLCBhcyByZWNvbW1lbmRlZCBmb3IgdXNlIGJ5XG4gIFx0Ly8gdGhlIEludGVybmF0aW9uYWwgVW5pb24gb2YgR2VvZGVzeSBhbmQgR2VvcGh5c2ljcyxcbiAgXHQvLyBzZWUgaHR0cHM6Ly9yb3NldHRhY29kZS5vcmcvd2lraS9IYXZlcnNpbmVfZm9ybXVsYVxuICBcdFI6IDYzNzEwMDAsXG5cbiAgXHQvLyBkaXN0YW5jZSBiZXR3ZWVuIHR3byBnZW9ncmFwaGljYWwgcG9pbnRzIHVzaW5nIHNwaGVyaWNhbCBsYXcgb2YgY29zaW5lcyBhcHByb3hpbWF0aW9uXG4gIFx0ZGlzdGFuY2U6IGZ1bmN0aW9uIChsYXRsbmcxLCBsYXRsbmcyKSB7XG4gIFx0XHR2YXIgcmFkID0gTWF0aC5QSSAvIDE4MCxcbiAgXHRcdCAgICBsYXQxID0gbGF0bG5nMS5sYXQgKiByYWQsXG4gIFx0XHQgICAgbGF0MiA9IGxhdGxuZzIubGF0ICogcmFkLFxuICBcdFx0ICAgIHNpbkRMYXQgPSBNYXRoLnNpbigobGF0bG5nMi5sYXQgLSBsYXRsbmcxLmxhdCkgKiByYWQgLyAyKSxcbiAgXHRcdCAgICBzaW5ETG9uID0gTWF0aC5zaW4oKGxhdGxuZzIubG5nIC0gbGF0bG5nMS5sbmcpICogcmFkIC8gMiksXG4gIFx0XHQgICAgYSA9IHNpbkRMYXQgKiBzaW5ETGF0ICsgTWF0aC5jb3MobGF0MSkgKiBNYXRoLmNvcyhsYXQyKSAqIHNpbkRMb24gKiBzaW5ETG9uLFxuICBcdFx0ICAgIGMgPSAyICogTWF0aC5hdGFuMihNYXRoLnNxcnQoYSksIE1hdGguc3FydCgxIC0gYSkpO1xuICBcdFx0cmV0dXJuIHRoaXMuUiAqIGM7XG4gIFx0fVxuICB9KTtcblxuICAvKlxyXG4gICAqIEBuYW1lc3BhY2UgUHJvamVjdGlvblxyXG4gICAqIEBwcm9qZWN0aW9uIEwuUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvclxyXG4gICAqXHJcbiAgICogU3BoZXJpY2FsIE1lcmNhdG9yIHByb2plY3Rpb24g4oCUIHRoZSBtb3N0IGNvbW1vbiBwcm9qZWN0aW9uIGZvciBvbmxpbmUgbWFwcyxcclxuICAgKiB1c2VkIGJ5IGFsbW9zdCBhbGwgZnJlZSBhbmQgY29tbWVyY2lhbCB0aWxlIHByb3ZpZGVycy4gQXNzdW1lcyB0aGF0IEVhcnRoIGlzXHJcbiAgICogYSBzcGhlcmUuIFVzZWQgYnkgdGhlIGBFUFNHOjM4NTdgIENSUy5cclxuICAgKi9cclxuXHJcbiAgdmFyIGVhcnRoUmFkaXVzID0gNjM3ODEzNztcclxuXHJcbiAgdmFyIFNwaGVyaWNhbE1lcmNhdG9yID0ge1xyXG5cclxuICBcdFI6IGVhcnRoUmFkaXVzLFxyXG4gIFx0TUFYX0xBVElUVURFOiA4NS4wNTExMjg3Nzk4LFxyXG5cclxuICBcdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuICBcdFx0dmFyIGQgPSBNYXRoLlBJIC8gMTgwLFxyXG4gIFx0XHQgICAgbWF4ID0gdGhpcy5NQVhfTEFUSVRVREUsXHJcbiAgXHRcdCAgICBsYXQgPSBNYXRoLm1heChNYXRoLm1pbihtYXgsIGxhdGxuZy5sYXQpLCAtbWF4KSxcclxuICBcdFx0ICAgIHNpbiA9IE1hdGguc2luKGxhdCAqIGQpO1xyXG5cclxuICBcdFx0cmV0dXJuIG5ldyBQb2ludChcclxuICBcdFx0XHR0aGlzLlIgKiBsYXRsbmcubG5nICogZCxcclxuICBcdFx0XHR0aGlzLlIgKiBNYXRoLmxvZygoMSArIHNpbikgLyAoMSAtIHNpbikpIC8gMik7XHJcbiAgXHR9LFxyXG5cclxuICBcdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgXHRcdHZhciBkID0gMTgwIC8gTWF0aC5QSTtcclxuXHJcbiAgXHRcdHJldHVybiBuZXcgTGF0TG5nKFxyXG4gIFx0XHRcdCgyICogTWF0aC5hdGFuKE1hdGguZXhwKHBvaW50LnkgLyB0aGlzLlIpKSAtIChNYXRoLlBJIC8gMikpICogZCxcclxuICBcdFx0XHRwb2ludC54ICogZCAvIHRoaXMuUik7XHJcbiAgXHR9LFxyXG5cclxuICBcdGJvdW5kczogKGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIGQgPSBlYXJ0aFJhZGl1cyAqIE1hdGguUEk7XHJcbiAgXHRcdHJldHVybiBuZXcgQm91bmRzKFstZCwgLWRdLCBbZCwgZF0pO1xyXG4gIFx0fSkoKVxyXG4gIH07XG5cbiAgLypcclxuICAgKiBAY2xhc3MgVHJhbnNmb3JtYXRpb25cclxuICAgKiBAYWthIEwuVHJhbnNmb3JtYXRpb25cclxuICAgKlxyXG4gICAqIFJlcHJlc2VudHMgYW4gYWZmaW5lIHRyYW5zZm9ybWF0aW9uOiBhIHNldCBvZiBjb2VmZmljaWVudHMgYGFgLCBgYmAsIGBjYCwgYGRgXHJcbiAgICogZm9yIHRyYW5zZm9ybWluZyBhIHBvaW50IG9mIGEgZm9ybSBgKHgsIHkpYCBpbnRvIGAoYSp4ICsgYiwgYyp5ICsgZClgIGFuZCBkb2luZ1xyXG4gICAqIHRoZSByZXZlcnNlLiBVc2VkIGJ5IExlYWZsZXQgaW4gaXRzIHByb2plY3Rpb25zIGNvZGUuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB2YXIgdHJhbnNmb3JtYXRpb24gPSBMLnRyYW5zZm9ybWF0aW9uKDIsIDUsIC0xLCAxMCksXHJcbiAgICogXHRwID0gTC5wb2ludCgxLCAyKSxcclxuICAgKiBcdHAyID0gdHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKHApLCAvLyAgTC5wb2ludCg3LCA4KVxyXG4gICAqIFx0cDMgPSB0cmFuc2Zvcm1hdGlvbi51bnRyYW5zZm9ybShwMik7IC8vICBMLnBvaW50KDEsIDIpXHJcbiAgICogYGBgXHJcbiAgICovXHJcblxyXG5cclxuICAvLyBmYWN0b3J5IG5ldyBMLlRyYW5zZm9ybWF0aW9uKGE6IE51bWJlciwgYjogTnVtYmVyLCBjOiBOdW1iZXIsIGQ6IE51bWJlcilcclxuICAvLyBDcmVhdGVzIGEgYFRyYW5zZm9ybWF0aW9uYCBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gY29lZmZpY2llbnRzLlxyXG4gIGZ1bmN0aW9uIFRyYW5zZm9ybWF0aW9uKGEsIGIsIGMsIGQpIHtcclxuICBcdGlmIChpc0FycmF5KGEpKSB7XHJcbiAgXHRcdC8vIHVzZSBhcnJheSBwcm9wZXJ0aWVzXHJcbiAgXHRcdHRoaXMuX2EgPSBhWzBdO1xyXG4gIFx0XHR0aGlzLl9iID0gYVsxXTtcclxuICBcdFx0dGhpcy5fYyA9IGFbMl07XHJcbiAgXHRcdHRoaXMuX2QgPSBhWzNdO1xyXG4gIFx0XHRyZXR1cm47XHJcbiAgXHR9XHJcbiAgXHR0aGlzLl9hID0gYTtcclxuICBcdHRoaXMuX2IgPSBiO1xyXG4gIFx0dGhpcy5fYyA9IGM7XHJcbiAgXHR0aGlzLl9kID0gZDtcclxuICB9XHJcblxyXG4gIFRyYW5zZm9ybWF0aW9uLnByb3RvdHlwZSA9IHtcclxuICBcdC8vIEBtZXRob2QgdHJhbnNmb3JtKHBvaW50OiBQb2ludCwgc2NhbGU/OiBOdW1iZXIpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyBhIHRyYW5zZm9ybWVkIHBvaW50LCBvcHRpb25hbGx5IG11bHRpcGxpZWQgYnkgdGhlIGdpdmVuIHNjYWxlLlxyXG4gIFx0Ly8gT25seSBhY2NlcHRzIGFjdHVhbCBgTC5Qb2ludGAgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxyXG4gIFx0dHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7IC8vIChQb2ludCwgTnVtYmVyKSAtPiBQb2ludFxyXG4gIFx0XHRyZXR1cm4gdGhpcy5fdHJhbnNmb3JtKHBvaW50LmNsb25lKCksIHNjYWxlKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gZGVzdHJ1Y3RpdmUgdHJhbnNmb3JtIChmYXN0ZXIpXHJcbiAgXHRfdHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7XHJcbiAgXHRcdHNjYWxlID0gc2NhbGUgfHwgMTtcclxuICBcdFx0cG9pbnQueCA9IHNjYWxlICogKHRoaXMuX2EgKiBwb2ludC54ICsgdGhpcy5fYik7XHJcbiAgXHRcdHBvaW50LnkgPSBzY2FsZSAqICh0aGlzLl9jICogcG9pbnQueSArIHRoaXMuX2QpO1xyXG4gIFx0XHRyZXR1cm4gcG9pbnQ7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgdW50cmFuc2Zvcm0ocG9pbnQ6IFBvaW50LCBzY2FsZT86IE51bWJlcik6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSByZXZlcnNlIHRyYW5zZm9ybWF0aW9uIG9mIHRoZSBnaXZlbiBwb2ludCwgb3B0aW9uYWxseSBkaXZpZGVkXHJcbiAgXHQvLyBieSB0aGUgZ2l2ZW4gc2NhbGUuIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuUG9pbnRgIGluc3RhbmNlcywgbm90IGFycmF5cy5cclxuICBcdHVudHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7XHJcbiAgXHRcdHNjYWxlID0gc2NhbGUgfHwgMTtcclxuICBcdFx0cmV0dXJuIG5ldyBQb2ludChcclxuICBcdFx0ICAgICAgICAocG9pbnQueCAvIHNjYWxlIC0gdGhpcy5fYikgLyB0aGlzLl9hLFxyXG4gIFx0XHQgICAgICAgIChwb2ludC55IC8gc2NhbGUgLSB0aGlzLl9kKSAvIHRoaXMuX2MpO1xyXG4gIFx0fVxyXG4gIH07XHJcblxyXG4gIC8vIGZhY3RvcnkgTC50cmFuc2Zvcm1hdGlvbihhOiBOdW1iZXIsIGI6IE51bWJlciwgYzogTnVtYmVyLCBkOiBOdW1iZXIpXHJcblxyXG4gIC8vIEBmYWN0b3J5IEwudHJhbnNmb3JtYXRpb24oYTogTnVtYmVyLCBiOiBOdW1iZXIsIGM6IE51bWJlciwgZDogTnVtYmVyKVxyXG4gIC8vIEluc3RhbnRpYXRlcyBhIFRyYW5zZm9ybWF0aW9uIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBjb2VmZmljaWVudHMuXHJcblxyXG4gIC8vIEBhbHRlcm5hdGl2ZVxyXG4gIC8vIEBmYWN0b3J5IEwudHJhbnNmb3JtYXRpb24oY29lZmZpY2llbnRzOiBBcnJheSk6IFRyYW5zZm9ybWF0aW9uXHJcbiAgLy8gRXhwZWN0cyBhbiBjb2VmZmljaWVudHMgYXJyYXkgb2YgdGhlIGZvcm1cclxuICAvLyBgW2E6IE51bWJlciwgYjogTnVtYmVyLCBjOiBOdW1iZXIsIGQ6IE51bWJlcl1gLlxyXG5cclxuICBmdW5jdGlvbiB0b1RyYW5zZm9ybWF0aW9uKGEsIGIsIGMsIGQpIHtcclxuICBcdHJldHVybiBuZXcgVHJhbnNmb3JtYXRpb24oYSwgYiwgYywgZCk7XHJcbiAgfVxuXG4gIC8qXHJcbiAgICogQG5hbWVzcGFjZSBDUlNcclxuICAgKiBAY3JzIEwuQ1JTLkVQU0czODU3XHJcbiAgICpcclxuICAgKiBUaGUgbW9zdCBjb21tb24gQ1JTIGZvciBvbmxpbmUgbWFwcywgdXNlZCBieSBhbG1vc3QgYWxsIGZyZWUgYW5kIGNvbW1lcmNpYWxcclxuICAgKiB0aWxlIHByb3ZpZGVycy4gVXNlcyBTcGhlcmljYWwgTWVyY2F0b3IgcHJvamVjdGlvbi4gU2V0IGluIGJ5IGRlZmF1bHQgaW5cclxuICAgKiBNYXAncyBgY3JzYCBvcHRpb24uXHJcbiAgICovXHJcblxyXG4gIHZhciBFUFNHMzg1NyA9IGV4dGVuZCh7fSwgRWFydGgsIHtcclxuICBcdGNvZGU6ICdFUFNHOjM4NTcnLFxyXG4gIFx0cHJvamVjdGlvbjogU3BoZXJpY2FsTWVyY2F0b3IsXHJcblxyXG4gIFx0dHJhbnNmb3JtYXRpb246IChmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBzY2FsZSA9IDAuNSAvIChNYXRoLlBJICogU3BoZXJpY2FsTWVyY2F0b3IuUik7XHJcbiAgXHRcdHJldHVybiB0b1RyYW5zZm9ybWF0aW9uKHNjYWxlLCAwLjUsIC1zY2FsZSwgMC41KTtcclxuICBcdH0oKSlcclxuICB9KTtcclxuXHJcbiAgdmFyIEVQU0c5MDA5MTMgPSBleHRlbmQoe30sIEVQU0czODU3LCB7XHJcbiAgXHRjb2RlOiAnRVBTRzo5MDA5MTMnXHJcbiAgfSk7XG5cbiAgLy8gQG5hbWVzcGFjZSBTVkc7IEBzZWN0aW9uXG4gIC8vIFRoZXJlIGFyZSBzZXZlcmFsIHN0YXRpYyBmdW5jdGlvbnMgd2hpY2ggY2FuIGJlIGNhbGxlZCB3aXRob3V0IGluc3RhbnRpYXRpbmcgTC5TVkc6XG5cbiAgLy8gQGZ1bmN0aW9uIGNyZWF0ZShuYW1lOiBTdHJpbmcpOiBTVkdFbGVtZW50XG4gIC8vIFJldHVybnMgYSBpbnN0YW5jZSBvZiBbU1ZHRWxlbWVudF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1NWR0VsZW1lbnQpLFxuICAvLyBjb3JyZXNwb25kaW5nIHRvIHRoZSBjbGFzcyBuYW1lIHBhc3NlZC4gRm9yIGV4YW1wbGUsIHVzaW5nICdsaW5lJyB3aWxsIHJldHVyblxuICAvLyBhbiBpbnN0YW5jZSBvZiBbU1ZHTGluZUVsZW1lbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9TVkdMaW5lRWxlbWVudCkuXG4gIGZ1bmN0aW9uIHN2Z0NyZWF0ZShuYW1lKSB7XG4gIFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCBuYW1lKTtcbiAgfVxuXG4gIC8vIEBmdW5jdGlvbiBwb2ludHNUb1BhdGgocmluZ3M6IFBvaW50W10sIGNsb3NlZDogQm9vbGVhbik6IFN0cmluZ1xuICAvLyBHZW5lcmF0ZXMgYSBTVkcgcGF0aCBzdHJpbmcgZm9yIG11bHRpcGxlIHJpbmdzLCB3aXRoIGVhY2ggcmluZyB0dXJuaW5nXG4gIC8vIGludG8gXCJNLi5MLi5MLi5cIiBpbnN0cnVjdGlvbnNcbiAgZnVuY3Rpb24gcG9pbnRzVG9QYXRoKHJpbmdzLCBjbG9zZWQpIHtcbiAgXHR2YXIgc3RyID0gJycsXG4gIFx0aSwgaiwgbGVuLCBsZW4yLCBwb2ludHMsIHA7XG5cbiAgXHRmb3IgKGkgPSAwLCBsZW4gPSByaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICBcdFx0cG9pbnRzID0gcmluZ3NbaV07XG5cbiAgXHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwb2ludHMubGVuZ3RoOyBqIDwgbGVuMjsgaisrKSB7XG4gIFx0XHRcdHAgPSBwb2ludHNbal07XG4gIFx0XHRcdHN0ciArPSAoaiA/ICdMJyA6ICdNJykgKyBwLnggKyAnICcgKyBwLnk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIGNsb3NlcyB0aGUgcmluZyBmb3IgcG9seWdvbnM7IFwieFwiIGlzIFZNTCBzeW50YXhcbiAgXHRcdHN0ciArPSBjbG9zZWQgPyAoQnJvd3Nlci5zdmcgPyAneicgOiAneCcpIDogJyc7XG4gIFx0fVxuXG4gIFx0Ly8gU1ZHIGNvbXBsYWlucyBhYm91dCBlbXB0eSBwYXRoIHN0cmluZ3NcbiAgXHRyZXR1cm4gc3RyIHx8ICdNMCAwJztcbiAgfVxuXG4gIC8qXHJcbiAgICogQG5hbWVzcGFjZSBCcm93c2VyXHJcbiAgICogQGFrYSBMLkJyb3dzZXJcclxuICAgKlxyXG4gICAqIEEgbmFtZXNwYWNlIHdpdGggc3RhdGljIHByb3BlcnRpZXMgZm9yIGJyb3dzZXIvZmVhdHVyZSBkZXRlY3Rpb24gdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiBpZiAoTC5Ccm93c2VyLmllbHQ5KSB7XHJcbiAgICogICBhbGVydCgnVXBncmFkZSB5b3VyIGJyb3dzZXIsIGR1ZGUhJyk7XHJcbiAgICogfVxyXG4gICAqIGBgYFxyXG4gICAqL1xyXG5cclxuICB2YXIgc3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBpZTogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbnMgKG5vdCBFZGdlKS5cclxuICB2YXIgaWUgPSAnQWN0aXZlWE9iamVjdCcgaW4gd2luZG93O1xyXG5cclxuICAvLyBAcHJvcGVydHkgaWVsdDk6IEJvb2xlYW47IGB0cnVlYCBmb3IgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbnMgbGVzcyB0aGFuIDkuXHJcbiAgdmFyIGllbHQ5ID0gaWUgJiYgIWRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXI7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBlZGdlOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBFZGdlIHdlYiBicm93c2VyLlxyXG4gIHZhciBlZGdlID0gJ21zTGF1bmNoVXJpJyBpbiBuYXZpZ2F0b3IgJiYgISgnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCk7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSB3ZWJraXQ6IEJvb2xlYW47XHJcbiAgLy8gYHRydWVgIGZvciB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgbGlrZSBDaHJvbWUgYW5kIFNhZmFyaSAoaW5jbHVkaW5nIG1vYmlsZSB2ZXJzaW9ucykuXHJcbiAgdmFyIHdlYmtpdCA9IHVzZXJBZ2VudENvbnRhaW5zKCd3ZWJraXQnKTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IGFuZHJvaWQ6IEJvb2xlYW5cclxuICAvLyAqKkRlcHJlY2F0ZWQuKiogYHRydWVgIGZvciBhbnkgYnJvd3NlciBydW5uaW5nIG9uIGFuIEFuZHJvaWQgcGxhdGZvcm0uXHJcbiAgdmFyIGFuZHJvaWQgPSB1c2VyQWdlbnRDb250YWlucygnYW5kcm9pZCcpO1xyXG5cclxuICAvLyBAcHJvcGVydHkgYW5kcm9pZDIzOiBCb29sZWFuOyAqKkRlcHJlY2F0ZWQuKiogYHRydWVgIGZvciBicm93c2VycyBydW5uaW5nIG9uIEFuZHJvaWQgMiBvciBBbmRyb2lkIDMuXHJcbiAgdmFyIGFuZHJvaWQyMyA9IHVzZXJBZ2VudENvbnRhaW5zKCdhbmRyb2lkIDInKSB8fCB1c2VyQWdlbnRDb250YWlucygnYW5kcm9pZCAzJyk7XHJcblxyXG4gIC8qIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTc5NjEyNjYgZm9yIGRldGFpbHMgb24gZGV0ZWN0aW5nIHN0b2NrIEFuZHJvaWQgKi9cclxuICB2YXIgd2Via2l0VmVyID0gcGFyc2VJbnQoL1dlYktpdFxcLyhbMC05XSspfCQvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudClbMV0sIDEwKTsgLy8gYWxzbyBtYXRjaGVzIEFwcGxlV2ViS2l0XHJcbiAgLy8gQHByb3BlcnR5IGFuZHJvaWRTdG9jazogQm9vbGVhbjsgKipEZXByZWNhdGVkLioqIGB0cnVlYCBmb3IgdGhlIEFuZHJvaWQgc3RvY2sgYnJvd3NlciAoaS5lLiBub3QgQ2hyb21lKVxyXG4gIHZhciBhbmRyb2lkU3RvY2sgPSBhbmRyb2lkICYmIHVzZXJBZ2VudENvbnRhaW5zKCdHb29nbGUnKSAmJiB3ZWJraXRWZXIgPCA1MzcgJiYgISgnQXVkaW9Ob2RlJyBpbiB3aW5kb3cpO1xyXG5cclxuICAvLyBAcHJvcGVydHkgb3BlcmE6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIE9wZXJhIGJyb3dzZXJcclxuICB2YXIgb3BlcmEgPSAhIXdpbmRvdy5vcGVyYTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IGNocm9tZTogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgQ2hyb21lIGJyb3dzZXIuXHJcbiAgdmFyIGNocm9tZSA9ICFlZGdlICYmIHVzZXJBZ2VudENvbnRhaW5zKCdjaHJvbWUnKTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IGdlY2tvOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGdlY2tvLWJhc2VkIGJyb3dzZXJzIGxpa2UgRmlyZWZveC5cclxuICB2YXIgZ2Vja28gPSB1c2VyQWdlbnRDb250YWlucygnZ2Vja28nKSAmJiAhd2Via2l0ICYmICFvcGVyYSAmJiAhaWU7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBzYWZhcmk6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIFNhZmFyaSBicm93c2VyLlxyXG4gIHZhciBzYWZhcmkgPSAhY2hyb21lICYmIHVzZXJBZ2VudENvbnRhaW5zKCdzYWZhcmknKTtcclxuXHJcbiAgdmFyIHBoYW50b20gPSB1c2VyQWdlbnRDb250YWlucygncGhhbnRvbScpO1xyXG5cclxuICAvLyBAcHJvcGVydHkgb3BlcmExMjogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCBmb3IgdGhlIE9wZXJhIGJyb3dzZXIgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3JtcyAodmVyc2lvbiAxMiBvciBsYXRlcikuXHJcbiAgdmFyIG9wZXJhMTIgPSAnT1RyYW5zaXRpb24nIGluIHN0eWxlO1xyXG5cclxuICAvLyBAcHJvcGVydHkgd2luOiBCb29sZWFuOyBgdHJ1ZWAgd2hlbiB0aGUgYnJvd3NlciBpcyBydW5uaW5nIGluIGEgV2luZG93cyBwbGF0Zm9ybVxyXG4gIHZhciB3aW4gPSBuYXZpZ2F0b3IucGxhdGZvcm0uaW5kZXhPZignV2luJykgPT09IDA7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBpZTNkOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGFsbCBJbnRlcm5ldCBFeHBsb3JlciB2ZXJzaW9ucyBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG4gIHZhciBpZTNkID0gaWUgJiYgKCd0cmFuc2l0aW9uJyBpbiBzdHlsZSk7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSB3ZWJraXQzZDogQm9vbGVhbjsgYHRydWVgIGZvciB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxuICB2YXIgd2Via2l0M2QgPSAoJ1dlYktpdENTU01hdHJpeCcgaW4gd2luZG93KSAmJiAoJ20xMScgaW4gbmV3IHdpbmRvdy5XZWJLaXRDU1NNYXRyaXgoKSkgJiYgIWFuZHJvaWQyMztcclxuXHJcbiAgLy8gQHByb3BlcnR5IGdlY2tvM2Q6IEJvb2xlYW47IGB0cnVlYCBmb3IgZ2Vja28tYmFzZWQgYnJvd3NlcnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxuICB2YXIgZ2Vja28zZCA9ICdNb3pQZXJzcGVjdGl2ZScgaW4gc3R5bGU7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBhbnkzZDogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcbiAgdmFyIGFueTNkID0gIXdpbmRvdy5MX0RJU0FCTEVfM0QgJiYgKGllM2QgfHwgd2Via2l0M2QgfHwgZ2Vja28zZCkgJiYgIW9wZXJhMTIgJiYgIXBoYW50b207XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBtb2JpbGU6IEJvb2xlYW47IGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHJ1bm5pbmcgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG4gIHZhciBtb2JpbGUgPSB0eXBlb2Ygb3JpZW50YXRpb24gIT09ICd1bmRlZmluZWQnIHx8IHVzZXJBZ2VudENvbnRhaW5zKCdtb2JpbGUnKTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IG1vYmlsZVdlYmtpdDogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgd2Via2l0LWJhc2VkIGJyb3dzZXJzIGluIGEgbW9iaWxlIGRldmljZS5cclxuICB2YXIgbW9iaWxlV2Via2l0ID0gbW9iaWxlICYmIHdlYmtpdDtcclxuXHJcbiAgLy8gQHByb3BlcnR5IG1vYmlsZVdlYmtpdDNkOiBCb29sZWFuXHJcbiAgLy8gYHRydWVgIGZvciBhbGwgd2Via2l0LWJhc2VkIGJyb3dzZXJzIGluIGEgbW9iaWxlIGRldmljZSBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG4gIHZhciBtb2JpbGVXZWJraXQzZCA9IG1vYmlsZSAmJiB3ZWJraXQzZDtcclxuXHJcbiAgLy8gQHByb3BlcnR5IG1zUG9pbnRlcjogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCBmb3IgYnJvd3NlcnMgaW1wbGVtZW50aW5nIHRoZSBNaWNyb3NvZnQgdG91Y2ggZXZlbnRzIG1vZGVsIChub3RhYmx5IElFMTApLlxyXG4gIHZhciBtc1BvaW50ZXIgPSAhd2luZG93LlBvaW50ZXJFdmVudCAmJiB3aW5kb3cuTVNQb2ludGVyRXZlbnQ7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBwb2ludGVyOiBCb29sZWFuXHJcbiAgLy8gYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgc3VwcG9ydGluZyBbcG9pbnRlciBldmVudHNdKGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvZG40MzMyNDQlMjh2PXZzLjg1JTI5LmFzcHgpLlxyXG4gIHZhciBwb2ludGVyID0gISEod2luZG93LlBvaW50ZXJFdmVudCB8fCBtc1BvaW50ZXIpO1xyXG5cclxuICAvLyBAcHJvcGVydHkgdG91Y2hOYXRpdmU6IEJvb2xlYW5cclxuICAvLyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBzdXBwb3J0aW5nIFt0b3VjaCBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9Ub3VjaF9ldmVudHMpLlxyXG4gIC8vICoqVGhpcyBkb2VzIG5vdCBuZWNlc3NhcmlseSBtZWFuKiogdGhhdCB0aGUgYnJvd3NlciBpcyBydW5uaW5nIGluIGEgY29tcHV0ZXIgd2l0aFxyXG4gIC8vIGEgdG91Y2hzY3JlZW4sIGl0IG9ubHkgbWVhbnMgdGhhdCB0aGUgYnJvd3NlciBpcyBjYXBhYmxlIG9mIHVuZGVyc3RhbmRpbmdcclxuICAvLyB0b3VjaCBldmVudHMuXHJcbiAgdmFyIHRvdWNoTmF0aXZlID0gJ29udG91Y2hzdGFydCcgaW4gd2luZG93IHx8ICEhd2luZG93LlRvdWNoRXZlbnQ7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSB0b3VjaDogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHN1cHBvcnRpbmcgZWl0aGVyIFt0b3VjaF0oI2Jyb3dzZXItdG91Y2gpIG9yIFtwb2ludGVyXSgjYnJvd3Nlci1wb2ludGVyKSBldmVudHMuXHJcbiAgLy8gTm90ZTogcG9pbnRlciBldmVudHMgd2lsbCBiZSBwcmVmZXJyZWQgKGlmIGF2YWlsYWJsZSksIGFuZCBwcm9jZXNzZWQgZm9yIGFsbCBgdG91Y2gqYCBsaXN0ZW5lcnMuXHJcbiAgdmFyIHRvdWNoID0gIXdpbmRvdy5MX05PX1RPVUNIICYmICh0b3VjaE5hdGl2ZSB8fCBwb2ludGVyKTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IG1vYmlsZU9wZXJhOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBPcGVyYSBicm93c2VyIGluIGEgbW9iaWxlIGRldmljZS5cclxuICB2YXIgbW9iaWxlT3BlcmEgPSBtb2JpbGUgJiYgb3BlcmE7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBtb2JpbGVHZWNrbzogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCBmb3IgZ2Vja28tYmFzZWQgYnJvd3NlcnMgcnVubmluZyBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcbiAgdmFyIG1vYmlsZUdlY2tvID0gbW9iaWxlICYmIGdlY2tvO1xyXG5cclxuICAvLyBAcHJvcGVydHkgcmV0aW5hOiBCb29sZWFuXHJcbiAgLy8gYHRydWVgIGZvciBicm93c2VycyBvbiBhIGhpZ2gtcmVzb2x1dGlvbiBcInJldGluYVwiIHNjcmVlbiBvciBvbiBhbnkgc2NyZWVuIHdoZW4gYnJvd3NlcidzIGRpc3BsYXkgem9vbSBpcyBtb3JlIHRoYW4gMTAwJS5cclxuICB2YXIgcmV0aW5hID0gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8ICh3aW5kb3cuc2NyZWVuLmRldmljZVhEUEkgLyB3aW5kb3cuc2NyZWVuLmxvZ2ljYWxYRFBJKSkgPiAxO1xyXG5cclxuICAvLyBAcHJvcGVydHkgcGFzc2l2ZUV2ZW50czogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCBmb3IgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IHBhc3NpdmUgZXZlbnRzLlxyXG4gIHZhciBwYXNzaXZlRXZlbnRzID0gKGZ1bmN0aW9uICgpIHtcclxuICBcdHZhciBzdXBwb3J0c1Bhc3NpdmVPcHRpb24gPSBmYWxzZTtcclxuICBcdHRyeSB7XHJcbiAgXHRcdHZhciBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcclxuICBcdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBnZXR0ZXItcmV0dXJuXHJcbiAgXHRcdFx0XHRzdXBwb3J0c1Bhc3NpdmVPcHRpb24gPSB0cnVlO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fSk7XHJcbiAgXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0UGFzc2l2ZUV2ZW50U3VwcG9ydCcsIGZhbHNlRm4sIG9wdHMpO1xyXG4gIFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdFBhc3NpdmVFdmVudFN1cHBvcnQnLCBmYWxzZUZuLCBvcHRzKTtcclxuICBcdH0gY2F0Y2ggKGUpIHtcclxuICBcdFx0Ly8gRXJyb3JzIGNhbiBzYWZlbHkgYmUgaWdub3JlZCBzaW5jZSB0aGlzIGlzIG9ubHkgYSBicm93c2VyIHN1cHBvcnQgdGVzdC5cclxuICBcdH1cclxuICBcdHJldHVybiBzdXBwb3J0c1Bhc3NpdmVPcHRpb247XHJcbiAgfSgpKTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IGNhbnZhczogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIFtgPGNhbnZhcz5gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzX0FQSSkuXHJcbiAgdmFyIGNhbnZhcyQxID0gKGZ1bmN0aW9uICgpIHtcclxuICBcdHJldHVybiAhIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQ7XHJcbiAgfSgpKTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IHN2ZzogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIFtTVkddKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRykuXHJcbiAgdmFyIHN2ZyQxID0gISEoZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TICYmIHN2Z0NyZWF0ZSgnc3ZnJykuY3JlYXRlU1ZHUmVjdCk7XHJcblxyXG4gIHZhciBpbmxpbmVTdmcgPSAhIXN2ZyQxICYmIChmdW5jdGlvbiAoKSB7XHJcbiAgXHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgXHRkaXYuaW5uZXJIVE1MID0gJzxzdmcvPic7XHJcbiAgXHRyZXR1cm4gKGRpdi5maXJzdENoaWxkICYmIGRpdi5maXJzdENoaWxkLm5hbWVzcGFjZVVSSSkgPT09ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XHJcbiAgfSkoKTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IHZtbDogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyBbVk1MXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WZWN0b3JfTWFya3VwX0xhbmd1YWdlKS5cclxuICB2YXIgdm1sID0gIXN2ZyQxICYmIChmdW5jdGlvbiAoKSB7XHJcbiAgXHR0cnkge1xyXG4gIFx0XHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgXHRcdGRpdi5pbm5lckhUTUwgPSAnPHY6c2hhcGUgYWRqPVwiMVwiLz4nO1xyXG5cclxuICBcdFx0dmFyIHNoYXBlID0gZGl2LmZpcnN0Q2hpbGQ7XHJcbiAgXHRcdHNoYXBlLnN0eWxlLmJlaGF2aW9yID0gJ3VybCgjZGVmYXVsdCNWTUwpJztcclxuXHJcbiAgXHRcdHJldHVybiBzaGFwZSAmJiAodHlwZW9mIHNoYXBlLmFkaiA9PT0gJ29iamVjdCcpO1xyXG5cclxuICBcdH0gY2F0Y2ggKGUpIHtcclxuICBcdFx0cmV0dXJuIGZhbHNlO1xyXG4gIFx0fVxyXG4gIH0oKSk7XHJcblxyXG5cclxuICAvLyBAcHJvcGVydHkgbWFjOiBCb29sZWFuOyBgdHJ1ZWAgd2hlbiB0aGUgYnJvd3NlciBpcyBydW5uaW5nIGluIGEgTWFjIHBsYXRmb3JtXHJcbiAgdmFyIG1hYyA9IG5hdmlnYXRvci5wbGF0Zm9ybS5pbmRleE9mKCdNYWMnKSA9PT0gMDtcclxuXHJcbiAgLy8gQHByb3BlcnR5IG1hYzogQm9vbGVhbjsgYHRydWVgIHdoZW4gdGhlIGJyb3dzZXIgaXMgcnVubmluZyBpbiBhIExpbnV4IHBsYXRmb3JtXHJcbiAgdmFyIGxpbnV4ID0gbmF2aWdhdG9yLnBsYXRmb3JtLmluZGV4T2YoJ0xpbnV4JykgPT09IDA7XHJcblxyXG4gIGZ1bmN0aW9uIHVzZXJBZ2VudENvbnRhaW5zKHN0cikge1xyXG4gIFx0cmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKHN0cikgPj0gMDtcclxuICB9XHJcblxyXG5cclxuICB2YXIgQnJvd3NlciA9IHtcclxuICBcdGllOiBpZSxcclxuICBcdGllbHQ5OiBpZWx0OSxcclxuICBcdGVkZ2U6IGVkZ2UsXHJcbiAgXHR3ZWJraXQ6IHdlYmtpdCxcclxuICBcdGFuZHJvaWQ6IGFuZHJvaWQsXHJcbiAgXHRhbmRyb2lkMjM6IGFuZHJvaWQyMyxcclxuICBcdGFuZHJvaWRTdG9jazogYW5kcm9pZFN0b2NrLFxyXG4gIFx0b3BlcmE6IG9wZXJhLFxyXG4gIFx0Y2hyb21lOiBjaHJvbWUsXHJcbiAgXHRnZWNrbzogZ2Vja28sXHJcbiAgXHRzYWZhcmk6IHNhZmFyaSxcclxuICBcdHBoYW50b206IHBoYW50b20sXHJcbiAgXHRvcGVyYTEyOiBvcGVyYTEyLFxyXG4gIFx0d2luOiB3aW4sXHJcbiAgXHRpZTNkOiBpZTNkLFxyXG4gIFx0d2Via2l0M2Q6IHdlYmtpdDNkLFxyXG4gIFx0Z2Vja28zZDogZ2Vja28zZCxcclxuICBcdGFueTNkOiBhbnkzZCxcclxuICBcdG1vYmlsZTogbW9iaWxlLFxyXG4gIFx0bW9iaWxlV2Via2l0OiBtb2JpbGVXZWJraXQsXHJcbiAgXHRtb2JpbGVXZWJraXQzZDogbW9iaWxlV2Via2l0M2QsXHJcbiAgXHRtc1BvaW50ZXI6IG1zUG9pbnRlcixcclxuICBcdHBvaW50ZXI6IHBvaW50ZXIsXHJcbiAgXHR0b3VjaDogdG91Y2gsXHJcbiAgXHR0b3VjaE5hdGl2ZTogdG91Y2hOYXRpdmUsXHJcbiAgXHRtb2JpbGVPcGVyYTogbW9iaWxlT3BlcmEsXHJcbiAgXHRtb2JpbGVHZWNrbzogbW9iaWxlR2Vja28sXHJcbiAgXHRyZXRpbmE6IHJldGluYSxcclxuICBcdHBhc3NpdmVFdmVudHM6IHBhc3NpdmVFdmVudHMsXHJcbiAgXHRjYW52YXM6IGNhbnZhcyQxLFxyXG4gIFx0c3ZnOiBzdmckMSxcclxuICBcdHZtbDogdm1sLFxyXG4gIFx0aW5saW5lU3ZnOiBpbmxpbmVTdmcsXHJcbiAgXHRtYWM6IG1hYyxcclxuICBcdGxpbnV4OiBsaW51eFxyXG4gIH07XG5cbiAgLypcbiAgICogRXh0ZW5kcyBMLkRvbUV2ZW50IHRvIHByb3ZpZGUgdG91Y2ggc3VwcG9ydCBmb3IgSW50ZXJuZXQgRXhwbG9yZXIgYW5kIFdpbmRvd3MtYmFzZWQgZGV2aWNlcy5cbiAgICovXG5cbiAgdmFyIFBPSU5URVJfRE9XTiA9ICAgQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyRG93bicgICA6ICdwb2ludGVyZG93bic7XG4gIHZhciBQT0lOVEVSX01PVkUgPSAgIEJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlck1vdmUnICAgOiAncG9pbnRlcm1vdmUnO1xuICB2YXIgUE9JTlRFUl9VUCA9ICAgICBCcm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJVcCcgICAgIDogJ3BvaW50ZXJ1cCc7XG4gIHZhciBQT0lOVEVSX0NBTkNFTCA9IEJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlckNhbmNlbCcgOiAncG9pbnRlcmNhbmNlbCc7XG4gIHZhciBwRXZlbnQgPSB7XG4gIFx0dG91Y2hzdGFydCAgOiBQT0lOVEVSX0RPV04sXG4gIFx0dG91Y2htb3ZlICAgOiBQT0lOVEVSX01PVkUsXG4gIFx0dG91Y2hlbmQgICAgOiBQT0lOVEVSX1VQLFxuICBcdHRvdWNoY2FuY2VsIDogUE9JTlRFUl9DQU5DRUxcbiAgfTtcbiAgdmFyIGhhbmRsZSA9IHtcbiAgXHR0b3VjaHN0YXJ0ICA6IF9vblBvaW50ZXJTdGFydCxcbiAgXHR0b3VjaG1vdmUgICA6IF9oYW5kbGVQb2ludGVyLFxuICBcdHRvdWNoZW5kICAgIDogX2hhbmRsZVBvaW50ZXIsXG4gIFx0dG91Y2hjYW5jZWwgOiBfaGFuZGxlUG9pbnRlclxuICB9O1xuICB2YXIgX3BvaW50ZXJzID0ge307XG4gIHZhciBfcG9pbnRlckRvY0xpc3RlbmVyID0gZmFsc2U7XG5cbiAgLy8gUHJvdmlkZXMgYSB0b3VjaCBldmVudHMgd3JhcHBlciBmb3IgKG1zKXBvaW50ZXIgZXZlbnRzLlxuICAvLyByZWYgaHR0cHM6Ly93d3cudzMub3JnL1RSL3BvaW50ZXJldmVudHMvIGh0dHBzOi8vd3d3LnczLm9yZy9CdWdzL1B1YmxpYy9zaG93X2J1Zy5jZ2k/aWQ9MjI4OTBcblxuICBmdW5jdGlvbiBhZGRQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBoYW5kbGVyKSB7XG4gIFx0aWYgKHR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuICBcdFx0X2FkZFBvaW50ZXJEb2NMaXN0ZW5lcigpO1xuICBcdH1cbiAgXHRpZiAoIWhhbmRsZVt0eXBlXSkge1xuICBcdFx0Y29uc29sZS53YXJuKCd3cm9uZyBldmVudCBzcGVjaWZpZWQ6JywgdHlwZSk7XG4gIFx0XHRyZXR1cm4gZmFsc2VGbjtcbiAgXHR9XG4gIFx0aGFuZGxlciA9IGhhbmRsZVt0eXBlXS5iaW5kKHRoaXMsIGhhbmRsZXIpO1xuICBcdG9iai5hZGRFdmVudExpc3RlbmVyKHBFdmVudFt0eXBlXSwgaGFuZGxlciwgZmFsc2UpO1xuICBcdHJldHVybiBoYW5kbGVyO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlUG9pbnRlckxpc3RlbmVyKG9iaiwgdHlwZSwgaGFuZGxlcikge1xuICBcdGlmICghcEV2ZW50W3R5cGVdKSB7XG4gIFx0XHRjb25zb2xlLndhcm4oJ3dyb25nIGV2ZW50IHNwZWNpZmllZDonLCB0eXBlKTtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG4gIFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIocEV2ZW50W3R5cGVdLCBoYW5kbGVyLCBmYWxzZSk7XG4gIH1cblxuICBmdW5jdGlvbiBfZ2xvYmFsUG9pbnRlckRvd24oZSkge1xuICBcdF9wb2ludGVyc1tlLnBvaW50ZXJJZF0gPSBlO1xuICB9XG5cbiAgZnVuY3Rpb24gX2dsb2JhbFBvaW50ZXJNb3ZlKGUpIHtcbiAgXHRpZiAoX3BvaW50ZXJzW2UucG9pbnRlcklkXSkge1xuICBcdFx0X3BvaW50ZXJzW2UucG9pbnRlcklkXSA9IGU7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gX2dsb2JhbFBvaW50ZXJVcChlKSB7XG4gIFx0ZGVsZXRlIF9wb2ludGVyc1tlLnBvaW50ZXJJZF07XG4gIH1cblxuICBmdW5jdGlvbiBfYWRkUG9pbnRlckRvY0xpc3RlbmVyKCkge1xuICBcdC8vIG5lZWQgdG8ga2VlcCB0cmFjayBvZiB3aGF0IHBvaW50ZXJzIGFuZCBob3cgbWFueSBhcmUgYWN0aXZlIHRvIHByb3ZpZGUgZS50b3VjaGVzIGVtdWxhdGlvblxuICBcdGlmICghX3BvaW50ZXJEb2NMaXN0ZW5lcikge1xuICBcdFx0Ly8gd2UgbGlzdGVuIGRvY3VtZW50IGFzIGFueSBkcmFncyB0aGF0IGVuZCBieSBtb3ZpbmcgdGhlIHRvdWNoIG9mZiB0aGUgc2NyZWVuIGdldCBmaXJlZCB0aGVyZVxuICBcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX0RPV04sIF9nbG9iYWxQb2ludGVyRG93biwgdHJ1ZSk7XG4gIFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfTU9WRSwgX2dsb2JhbFBvaW50ZXJNb3ZlLCB0cnVlKTtcbiAgXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9VUCwgX2dsb2JhbFBvaW50ZXJVcCwgdHJ1ZSk7XG4gIFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfQ0FOQ0VMLCBfZ2xvYmFsUG9pbnRlclVwLCB0cnVlKTtcblxuICBcdFx0X3BvaW50ZXJEb2NMaXN0ZW5lciA9IHRydWU7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gX2hhbmRsZVBvaW50ZXIoaGFuZGxlciwgZSkge1xuICBcdGlmIChlLnBvaW50ZXJUeXBlID09PSAoZS5NU1BPSU5URVJfVFlQRV9NT1VTRSB8fCAnbW91c2UnKSkgeyByZXR1cm47IH1cblxuICBcdGUudG91Y2hlcyA9IFtdO1xuICBcdGZvciAodmFyIGkgaW4gX3BvaW50ZXJzKSB7XG4gIFx0XHRlLnRvdWNoZXMucHVzaChfcG9pbnRlcnNbaV0pO1xuICBcdH1cbiAgXHRlLmNoYW5nZWRUb3VjaGVzID0gW2VdO1xuXG4gIFx0aGFuZGxlcihlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9vblBvaW50ZXJTdGFydChoYW5kbGVyLCBlKSB7XG4gIFx0Ly8gSUUxMCBzcGVjaWZpYzogTXNUb3VjaCBuZWVkcyBwcmV2ZW50RGVmYXVsdC4gU2VlICMyMDAwXG4gIFx0aWYgKGUuTVNQT0lOVEVSX1RZUEVfVE9VQ0ggJiYgZS5wb2ludGVyVHlwZSA9PT0gZS5NU1BPSU5URVJfVFlQRV9UT1VDSCkge1xuICBcdFx0cHJldmVudERlZmF1bHQoZSk7XG4gIFx0fVxuICBcdF9oYW5kbGVQb2ludGVyKGhhbmRsZXIsIGUpO1xuICB9XG5cbiAgLypcclxuICAgKiBFeHRlbmRzIHRoZSBldmVudCBoYW5kbGluZyBjb2RlIHdpdGggZG91YmxlIHRhcCBzdXBwb3J0IGZvciBtb2JpbGUgYnJvd3NlcnMuXHJcbiAgICpcclxuICAgKiBOb3RlOiBjdXJyZW50bHkgbW9zdCBicm93c2VycyBmaXJlIG5hdGl2ZSBkYmxjbGljaywgd2l0aCBvbmx5IGEgZmV3IGV4Y2VwdGlvbnNcclxuICAgKiAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzcwMTIjaXNzdWVjb21tZW50LTU5NTA4NzM4NilcclxuICAgKi9cclxuXHJcbiAgZnVuY3Rpb24gbWFrZURibGNsaWNrKGV2ZW50KSB7XHJcbiAgXHQvLyBpbiBtb2Rlcm4gYnJvd3NlcnMgYHR5cGVgIGNhbm5vdCBiZSBqdXN0IG92ZXJyaWRkZW46XHJcbiAgXHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9FcnJvcnMvR2V0dGVyX29ubHlcclxuICBcdHZhciBuZXdFdmVudCA9IHt9LFxyXG4gIFx0ICAgIHByb3AsIGk7XHJcbiAgXHRmb3IgKGkgaW4gZXZlbnQpIHtcclxuICBcdFx0cHJvcCA9IGV2ZW50W2ldO1xyXG4gIFx0XHRuZXdFdmVudFtpXSA9IHByb3AgJiYgcHJvcC5iaW5kID8gcHJvcC5iaW5kKGV2ZW50KSA6IHByb3A7XHJcbiAgXHR9XHJcbiAgXHRldmVudCA9IG5ld0V2ZW50O1xyXG4gIFx0bmV3RXZlbnQudHlwZSA9ICdkYmxjbGljayc7XHJcbiAgXHRuZXdFdmVudC5kZXRhaWwgPSAyO1xyXG4gIFx0bmV3RXZlbnQuaXNUcnVzdGVkID0gZmFsc2U7XHJcbiAgXHRuZXdFdmVudC5fc2ltdWxhdGVkID0gdHJ1ZTsgLy8gZm9yIGRlYnVnIHB1cnBvc2VzXHJcbiAgXHRyZXR1cm4gbmV3RXZlbnQ7XHJcbiAgfVxyXG5cclxuICB2YXIgZGVsYXkgPSAyMDA7XHJcbiAgZnVuY3Rpb24gYWRkRG91YmxlVGFwTGlzdGVuZXIob2JqLCBoYW5kbGVyKSB7XHJcbiAgXHQvLyBNb3N0IGJyb3dzZXJzIGhhbmRsZSBkb3VibGUgdGFwIG5hdGl2ZWx5XHJcbiAgXHRvYmouYWRkRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCBoYW5kbGVyKTtcclxuXHJcbiAgXHQvLyBPbiBzb21lIHBsYXRmb3JtcyB0aGUgYnJvd3NlciBkb2Vzbid0IGZpcmUgbmF0aXZlIGRibGNsaWNrcyBmb3IgdG91Y2ggZXZlbnRzLlxyXG4gIFx0Ly8gSXQgc2VlbXMgdGhhdCBpbiBhbGwgc3VjaCBjYXNlcyBgZGV0YWlsYCBwcm9wZXJ0eSBvZiBgY2xpY2tgIGV2ZW50IGlzIGFsd2F5cyBgMWAuXHJcbiAgXHQvLyBTbyBoZXJlIHdlIHJlbHkgb24gdGhhdCBmYWN0IHRvIGF2b2lkIGV4Y2Vzc2l2ZSAnZGJsY2xpY2snIHNpbXVsYXRpb24gd2hlbiBub3QgbmVlZGVkLlxyXG4gIFx0dmFyIGxhc3QgPSAwLFxyXG4gIFx0ICAgIGRldGFpbDtcclxuICBcdGZ1bmN0aW9uIHNpbURibGNsaWNrKGUpIHtcclxuICBcdFx0aWYgKGUuZGV0YWlsICE9PSAxKSB7XHJcbiAgXHRcdFx0ZGV0YWlsID0gZS5kZXRhaWw7IC8vIGtlZXAgaW4gc3luYyB0byBhdm9pZCBmYWxzZSBkYmxjbGljayBpbiBzb21lIGNhc2VzXHJcbiAgXHRcdFx0cmV0dXJuO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAoZS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyB8fFxyXG4gIFx0XHRcdChlLnNvdXJjZUNhcGFiaWxpdGllcyAmJiAhZS5zb3VyY2VDYXBhYmlsaXRpZXMuZmlyZXNUb3VjaEV2ZW50cykpIHtcclxuXHJcbiAgXHRcdFx0cmV0dXJuO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBXaGVuIGNsaWNraW5nIG9uIGFuIDxpbnB1dD4sIHRoZSBicm93c2VyIGdlbmVyYXRlcyBhIGNsaWNrIG9uIGl0c1xyXG4gIFx0XHQvLyA8bGFiZWw+IChhbmQgdmljZSB2ZXJzYSkgdHJpZ2dlcmluZyB0d28gY2xpY2tzIGluIHF1aWNrIHN1Y2Nlc3Npb24uXHJcbiAgXHRcdC8vIFRoaXMgaWdub3JlcyBjbGlja3Mgb24gZWxlbWVudHMgd2hpY2ggYXJlIGEgbGFiZWwgd2l0aCBhICdmb3InXHJcbiAgXHRcdC8vIGF0dHJpYnV0ZSAob3IgY2hpbGRyZW4gb2Ygc3VjaCBhIGxhYmVsKSwgYnV0IG5vdCBjaGlsZHJlbiBvZlxyXG4gIFx0XHQvLyBhIDxpbnB1dD4uXHJcbiAgXHRcdHZhciBwYXRoID0gZ2V0UHJvcGFnYXRpb25QYXRoKGUpO1xyXG4gIFx0XHRpZiAocGF0aC5zb21lKGZ1bmN0aW9uIChlbCkge1xyXG4gIFx0XHRcdHJldHVybiBlbCBpbnN0YW5jZW9mIEhUTUxMYWJlbEVsZW1lbnQgJiYgZWwuYXR0cmlidXRlcy5mb3I7XHJcbiAgXHRcdH0pICYmXHJcbiAgXHRcdFx0IXBhdGguc29tZShmdW5jdGlvbiAoZWwpIHtcclxuICBcdFx0XHRcdHJldHVybiAoXHJcbiAgXHRcdFx0XHRcdGVsIGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCB8fFxyXG4gIFx0XHRcdFx0XHRlbCBpbnN0YW5jZW9mIEhUTUxTZWxlY3RFbGVtZW50XHJcbiAgXHRcdFx0XHQpO1xyXG4gIFx0XHRcdH0pXHJcbiAgXHRcdCkge1xyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIG5vdyA9IERhdGUubm93KCk7XHJcbiAgXHRcdGlmIChub3cgLSBsYXN0IDw9IGRlbGF5KSB7XHJcbiAgXHRcdFx0ZGV0YWlsKys7XHJcbiAgXHRcdFx0aWYgKGRldGFpbCA9PT0gMikge1xyXG4gIFx0XHRcdFx0aGFuZGxlcihtYWtlRGJsY2xpY2soZSkpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRkZXRhaWwgPSAxO1xyXG4gIFx0XHR9XHJcbiAgXHRcdGxhc3QgPSBub3c7XHJcbiAgXHR9XHJcblxyXG4gIFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgc2ltRGJsY2xpY2spO1xyXG5cclxuICBcdHJldHVybiB7XHJcbiAgXHRcdGRibGNsaWNrOiBoYW5kbGVyLFxyXG4gIFx0XHRzaW1EYmxjbGljazogc2ltRGJsY2xpY2tcclxuICBcdH07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZW1vdmVEb3VibGVUYXBMaXN0ZW5lcihvYmosIGhhbmRsZXJzKSB7XHJcbiAgXHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCBoYW5kbGVycy5kYmxjbGljayk7XHJcbiAgXHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVycy5zaW1EYmxjbGljayk7XHJcbiAgfVxuXG4gIC8qXHJcbiAgICogQG5hbWVzcGFjZSBEb21VdGlsXHJcbiAgICpcclxuICAgKiBVdGlsaXR5IGZ1bmN0aW9ucyB0byB3b3JrIHdpdGggdGhlIFtET01dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9Eb2N1bWVudF9PYmplY3RfTW9kZWwpXHJcbiAgICogdHJlZSwgdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkuXHJcbiAgICpcclxuICAgKiBNb3N0IGZ1bmN0aW9ucyBleHBlY3Rpbmcgb3IgcmV0dXJuaW5nIGEgYEhUTUxFbGVtZW50YCBhbHNvIHdvcmsgZm9yXHJcbiAgICogU1ZHIGVsZW1lbnRzLiBUaGUgb25seSBkaWZmZXJlbmNlIGlzIHRoYXQgY2xhc3NlcyByZWZlciB0byBDU1MgY2xhc3Nlc1xyXG4gICAqIGluIEhUTUwgYW5kIFNWRyBjbGFzc2VzIGluIFNWRy5cclxuICAgKi9cclxuXHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBUUkFOU0ZPUk06IFN0cmluZ1xyXG4gIC8vIFZlbmRvci1wcmVmaXhlZCB0cmFuc2Zvcm0gc3R5bGUgbmFtZSAoZS5nLiBgJ3dlYmtpdFRyYW5zZm9ybSdgIGZvciBXZWJLaXQpLlxyXG4gIHZhciBUUkFOU0ZPUk0gPSB0ZXN0UHJvcChcclxuICBcdFsndHJhbnNmb3JtJywgJ3dlYmtpdFRyYW5zZm9ybScsICdPVHJhbnNmb3JtJywgJ01velRyYW5zZm9ybScsICdtc1RyYW5zZm9ybSddKTtcclxuXHJcbiAgLy8gd2Via2l0VHJhbnNpdGlvbiBjb21lcyBmaXJzdCBiZWNhdXNlIHNvbWUgYnJvd3NlciB2ZXJzaW9ucyB0aGF0IGRyb3AgdmVuZG9yIHByZWZpeCBkb24ndCBkb1xyXG4gIC8vIHRoZSBzYW1lIGZvciB0aGUgdHJhbnNpdGlvbmVuZCBldmVudCwgaW4gcGFydGljdWxhciB0aGUgQW5kcm9pZCA0LjEgc3RvY2sgYnJvd3NlclxyXG5cclxuICAvLyBAcHJvcGVydHkgVFJBTlNJVElPTjogU3RyaW5nXHJcbiAgLy8gVmVuZG9yLXByZWZpeGVkIHRyYW5zaXRpb24gc3R5bGUgbmFtZS5cclxuICB2YXIgVFJBTlNJVElPTiA9IHRlc3RQcm9wKFxyXG4gIFx0Wyd3ZWJraXRUcmFuc2l0aW9uJywgJ3RyYW5zaXRpb24nLCAnT1RyYW5zaXRpb24nLCAnTW96VHJhbnNpdGlvbicsICdtc1RyYW5zaXRpb24nXSk7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBUUkFOU0lUSU9OX0VORDogU3RyaW5nXHJcbiAgLy8gVmVuZG9yLXByZWZpeGVkIHRyYW5zaXRpb25lbmQgZXZlbnQgbmFtZS5cclxuICB2YXIgVFJBTlNJVElPTl9FTkQgPVxyXG4gIFx0VFJBTlNJVElPTiA9PT0gJ3dlYmtpdFRyYW5zaXRpb24nIHx8IFRSQU5TSVRJT04gPT09ICdPVHJhbnNpdGlvbicgPyBUUkFOU0lUSU9OICsgJ0VuZCcgOiAndHJhbnNpdGlvbmVuZCc7XHJcblxyXG5cclxuICAvLyBAZnVuY3Rpb24gZ2V0KGlkOiBTdHJpbmd8SFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG4gIC8vIFJldHVybnMgYW4gZWxlbWVudCBnaXZlbiBpdHMgRE9NIGlkLCBvciByZXR1cm5zIHRoZSBlbGVtZW50IGl0c2VsZlxyXG4gIC8vIGlmIGl0IHdhcyBwYXNzZWQgZGlyZWN0bHkuXHJcbiAgZnVuY3Rpb24gZ2V0KGlkKSB7XHJcbiAgXHRyZXR1cm4gdHlwZW9mIGlkID09PSAnc3RyaW5nJyA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSA6IGlkO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGdldFN0eWxlKGVsOiBIVE1MRWxlbWVudCwgc3R5bGVBdHRyaWI6IFN0cmluZyk6IFN0cmluZ1xyXG4gIC8vIFJldHVybnMgdGhlIHZhbHVlIGZvciBhIGNlcnRhaW4gc3R5bGUgYXR0cmlidXRlIG9uIGFuIGVsZW1lbnQsXHJcbiAgLy8gaW5jbHVkaW5nIGNvbXB1dGVkIHZhbHVlcyBvciB2YWx1ZXMgc2V0IHRocm91Z2ggQ1NTLlxyXG4gIGZ1bmN0aW9uIGdldFN0eWxlKGVsLCBzdHlsZSkge1xyXG4gIFx0dmFyIHZhbHVlID0gZWwuc3R5bGVbc3R5bGVdIHx8IChlbC5jdXJyZW50U3R5bGUgJiYgZWwuY3VycmVudFN0eWxlW3N0eWxlXSk7XHJcblxyXG4gIFx0aWYgKCghdmFsdWUgfHwgdmFsdWUgPT09ICdhdXRvJykgJiYgZG9jdW1lbnQuZGVmYXVsdFZpZXcpIHtcclxuICBcdFx0dmFyIGNzcyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWwsIG51bGwpO1xyXG4gIFx0XHR2YWx1ZSA9IGNzcyA/IGNzc1tzdHlsZV0gOiBudWxsO1xyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIHZhbHVlID09PSAnYXV0bycgPyBudWxsIDogdmFsdWU7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gY3JlYXRlKHRhZ05hbWU6IFN0cmluZywgY2xhc3NOYW1lPzogU3RyaW5nLCBjb250YWluZXI/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcbiAgLy8gQ3JlYXRlcyBhbiBIVE1MIGVsZW1lbnQgd2l0aCBgdGFnTmFtZWAsIHNldHMgaXRzIGNsYXNzIHRvIGBjbGFzc05hbWVgLCBhbmQgb3B0aW9uYWxseSBhcHBlbmRzIGl0IHRvIGBjb250YWluZXJgIGVsZW1lbnQuXHJcbiAgZnVuY3Rpb24gY3JlYXRlJDEodGFnTmFtZSwgY2xhc3NOYW1lLCBjb250YWluZXIpIHtcclxuICBcdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XHJcbiAgXHRlbC5jbGFzc05hbWUgPSBjbGFzc05hbWUgfHwgJyc7XHJcblxyXG4gIFx0aWYgKGNvbnRhaW5lcikge1xyXG4gIFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwpO1xyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIGVsO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHJlbW92ZShlbDogSFRNTEVsZW1lbnQpXHJcbiAgLy8gUmVtb3ZlcyBgZWxgIGZyb20gaXRzIHBhcmVudCBlbGVtZW50XHJcbiAgZnVuY3Rpb24gcmVtb3ZlKGVsKSB7XHJcbiAgXHR2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcclxuICBcdGlmIChwYXJlbnQpIHtcclxuICBcdFx0cGFyZW50LnJlbW92ZUNoaWxkKGVsKTtcclxuICBcdH1cclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBlbXB0eShlbDogSFRNTEVsZW1lbnQpXHJcbiAgLy8gUmVtb3ZlcyBhbGwgb2YgYGVsYCdzIGNoaWxkcmVuIGVsZW1lbnRzIGZyb20gYGVsYFxyXG4gIGZ1bmN0aW9uIGVtcHR5KGVsKSB7XHJcbiAgXHR3aGlsZSAoZWwuZmlyc3RDaGlsZCkge1xyXG4gIFx0XHRlbC5yZW1vdmVDaGlsZChlbC5maXJzdENoaWxkKTtcclxuICBcdH1cclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiB0b0Zyb250KGVsOiBIVE1MRWxlbWVudClcclxuICAvLyBNYWtlcyBgZWxgIHRoZSBsYXN0IGNoaWxkIG9mIGl0cyBwYXJlbnQsIHNvIGl0IHJlbmRlcnMgaW4gZnJvbnQgb2YgdGhlIG90aGVyIGNoaWxkcmVuLlxyXG4gIGZ1bmN0aW9uIHRvRnJvbnQoZWwpIHtcclxuICBcdHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xyXG4gIFx0aWYgKHBhcmVudCAmJiBwYXJlbnQubGFzdENoaWxkICE9PSBlbCkge1xyXG4gIFx0XHRwYXJlbnQuYXBwZW5kQ2hpbGQoZWwpO1xyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHRvQmFjayhlbDogSFRNTEVsZW1lbnQpXHJcbiAgLy8gTWFrZXMgYGVsYCB0aGUgZmlyc3QgY2hpbGQgb2YgaXRzIHBhcmVudCwgc28gaXQgcmVuZGVycyBiZWhpbmQgdGhlIG90aGVyIGNoaWxkcmVuLlxyXG4gIGZ1bmN0aW9uIHRvQmFjayhlbCkge1xyXG4gIFx0dmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XHJcbiAgXHRpZiAocGFyZW50ICYmIHBhcmVudC5maXJzdENoaWxkICE9PSBlbCkge1xyXG4gIFx0XHRwYXJlbnQuaW5zZXJ0QmVmb3JlKGVsLCBwYXJlbnQuZmlyc3RDaGlsZCk7XHJcbiAgXHR9XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gaGFzQ2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpOiBCb29sZWFuXHJcbiAgLy8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVsZW1lbnQncyBjbGFzcyBhdHRyaWJ1dGUgY29udGFpbnMgYG5hbWVgLlxyXG4gIGZ1bmN0aW9uIGhhc0NsYXNzKGVsLCBuYW1lKSB7XHJcbiAgXHRpZiAoZWwuY2xhc3NMaXN0ICE9PSB1bmRlZmluZWQpIHtcclxuICBcdFx0cmV0dXJuIGVsLmNsYXNzTGlzdC5jb250YWlucyhuYW1lKTtcclxuICBcdH1cclxuICBcdHZhciBjbGFzc05hbWUgPSBnZXRDbGFzcyhlbCk7XHJcbiAgXHRyZXR1cm4gY2xhc3NOYW1lLmxlbmd0aCA+IDAgJiYgbmV3IFJlZ0V4cCgnKF58XFxcXHMpJyArIG5hbWUgKyAnKFxcXFxzfCQpJykudGVzdChjbGFzc05hbWUpO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGFkZENsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKVxyXG4gIC8vIEFkZHMgYG5hbWVgIHRvIHRoZSBlbGVtZW50J3MgY2xhc3MgYXR0cmlidXRlLlxyXG4gIGZ1bmN0aW9uIGFkZENsYXNzKGVsLCBuYW1lKSB7XHJcbiAgXHRpZiAoZWwuY2xhc3NMaXN0ICE9PSB1bmRlZmluZWQpIHtcclxuICBcdFx0dmFyIGNsYXNzZXMgPSBzcGxpdFdvcmRzKG5hbWUpO1xyXG4gIFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gY2xhc3Nlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRcdGVsLmNsYXNzTGlzdC5hZGQoY2xhc3Nlc1tpXSk7XHJcbiAgXHRcdH1cclxuICBcdH0gZWxzZSBpZiAoIWhhc0NsYXNzKGVsLCBuYW1lKSkge1xyXG4gIFx0XHR2YXIgY2xhc3NOYW1lID0gZ2V0Q2xhc3MoZWwpO1xyXG4gIFx0XHRzZXRDbGFzcyhlbCwgKGNsYXNzTmFtZSA/IGNsYXNzTmFtZSArICcgJyA6ICcnKSArIG5hbWUpO1xyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKVxyXG4gIC8vIFJlbW92ZXMgYG5hbWVgIGZyb20gdGhlIGVsZW1lbnQncyBjbGFzcyBhdHRyaWJ1dGUuXHJcbiAgZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWwsIG5hbWUpIHtcclxuICBcdGlmIChlbC5jbGFzc0xpc3QgIT09IHVuZGVmaW5lZCkge1xyXG4gIFx0XHRlbC5jbGFzc0xpc3QucmVtb3ZlKG5hbWUpO1xyXG4gIFx0fSBlbHNlIHtcclxuICBcdFx0c2V0Q2xhc3MoZWwsIHRyaW0oKCcgJyArIGdldENsYXNzKGVsKSArICcgJykucmVwbGFjZSgnICcgKyBuYW1lICsgJyAnLCAnICcpKSk7XHJcbiAgXHR9XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gc2V0Q2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpXHJcbiAgLy8gU2V0cyB0aGUgZWxlbWVudCdzIGNsYXNzLlxyXG4gIGZ1bmN0aW9uIHNldENsYXNzKGVsLCBuYW1lKSB7XHJcbiAgXHRpZiAoZWwuY2xhc3NOYW1lLmJhc2VWYWwgPT09IHVuZGVmaW5lZCkge1xyXG4gIFx0XHRlbC5jbGFzc05hbWUgPSBuYW1lO1xyXG4gIFx0fSBlbHNlIHtcclxuICBcdFx0Ly8gaW4gY2FzZSBvZiBTVkcgZWxlbWVudFxyXG4gIFx0XHRlbC5jbGFzc05hbWUuYmFzZVZhbCA9IG5hbWU7XHJcbiAgXHR9XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gZ2V0Q2xhc3MoZWw6IEhUTUxFbGVtZW50KTogU3RyaW5nXHJcbiAgLy8gUmV0dXJucyB0aGUgZWxlbWVudCdzIGNsYXNzLlxyXG4gIGZ1bmN0aW9uIGdldENsYXNzKGVsKSB7XHJcbiAgXHQvLyBDaGVjayBpZiB0aGUgZWxlbWVudCBpcyBhbiBTVkdFbGVtZW50SW5zdGFuY2UgYW5kIHVzZSB0aGUgY29ycmVzcG9uZGluZ0VsZW1lbnQgaW5zdGVhZFxyXG4gIFx0Ly8gKFJlcXVpcmVkIGZvciBsaW5rZWQgU1ZHIGVsZW1lbnRzIGluIElFMTEuKVxyXG4gIFx0aWYgKGVsLmNvcnJlc3BvbmRpbmdFbGVtZW50KSB7XHJcbiAgXHRcdGVsID0gZWwuY29ycmVzcG9uZGluZ0VsZW1lbnQ7XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gZWwuY2xhc3NOYW1lLmJhc2VWYWwgPT09IHVuZGVmaW5lZCA/IGVsLmNsYXNzTmFtZSA6IGVsLmNsYXNzTmFtZS5iYXNlVmFsO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHNldE9wYWNpdHkoZWw6IEhUTUxFbGVtZW50LCBvcGFjaXR5OiBOdW1iZXIpXHJcbiAgLy8gU2V0IHRoZSBvcGFjaXR5IG9mIGFuIGVsZW1lbnQgKGluY2x1ZGluZyBvbGQgSUUgc3VwcG9ydCkuXHJcbiAgLy8gYG9wYWNpdHlgIG11c3QgYmUgYSBudW1iZXIgZnJvbSBgMGAgdG8gYDFgLlxyXG4gIGZ1bmN0aW9uIHNldE9wYWNpdHkoZWwsIHZhbHVlKSB7XHJcbiAgXHRpZiAoJ29wYWNpdHknIGluIGVsLnN0eWxlKSB7XHJcbiAgXHRcdGVsLnN0eWxlLm9wYWNpdHkgPSB2YWx1ZTtcclxuICBcdH0gZWxzZSBpZiAoJ2ZpbHRlcicgaW4gZWwuc3R5bGUpIHtcclxuICBcdFx0X3NldE9wYWNpdHlJRShlbCwgdmFsdWUpO1xyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gX3NldE9wYWNpdHlJRShlbCwgdmFsdWUpIHtcclxuICBcdHZhciBmaWx0ZXIgPSBmYWxzZSxcclxuICBcdCAgICBmaWx0ZXJOYW1lID0gJ0RYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkFscGhhJztcclxuXHJcbiAgXHQvLyBmaWx0ZXJzIGNvbGxlY3Rpb24gdGhyb3dzIGFuIGVycm9yIGlmIHdlIHRyeSB0byByZXRyaWV2ZSBhIGZpbHRlciB0aGF0IGRvZXNuJ3QgZXhpc3RcclxuICBcdHRyeSB7XHJcbiAgXHRcdGZpbHRlciA9IGVsLmZpbHRlcnMuaXRlbShmaWx0ZXJOYW1lKTtcclxuICBcdH0gY2F0Y2ggKGUpIHtcclxuICBcdFx0Ly8gZG9uJ3Qgc2V0IG9wYWNpdHkgdG8gMSBpZiB3ZSBoYXZlbid0IGFscmVhZHkgc2V0IGFuIG9wYWNpdHksXHJcbiAgXHRcdC8vIGl0IGlzbid0IG5lZWRlZCBhbmQgYnJlYWtzIHRyYW5zcGFyZW50IHBuZ3MuXHJcbiAgXHRcdGlmICh2YWx1ZSA9PT0gMSkgeyByZXR1cm47IH1cclxuICBcdH1cclxuXHJcbiAgXHR2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUgKiAxMDApO1xyXG5cclxuICBcdGlmIChmaWx0ZXIpIHtcclxuICBcdFx0ZmlsdGVyLkVuYWJsZWQgPSAodmFsdWUgIT09IDEwMCk7XHJcbiAgXHRcdGZpbHRlci5PcGFjaXR5ID0gdmFsdWU7XHJcbiAgXHR9IGVsc2Uge1xyXG4gIFx0XHRlbC5zdHlsZS5maWx0ZXIgKz0gJyBwcm9naWQ6JyArIGZpbHRlck5hbWUgKyAnKG9wYWNpdHk9JyArIHZhbHVlICsgJyknO1xyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHRlc3RQcm9wKHByb3BzOiBTdHJpbmdbXSk6IFN0cmluZ3xmYWxzZVxyXG4gIC8vIEdvZXMgdGhyb3VnaCB0aGUgYXJyYXkgb2Ygc3R5bGUgbmFtZXMgYW5kIHJldHVybnMgdGhlIGZpcnN0IG5hbWVcclxuICAvLyB0aGF0IGlzIGEgdmFsaWQgc3R5bGUgbmFtZSBmb3IgYW4gZWxlbWVudC4gSWYgbm8gc3VjaCBuYW1lIGlzIGZvdW5kLFxyXG4gIC8vIGl0IHJldHVybnMgZmFsc2UuIFVzZWZ1bCBmb3IgdmVuZG9yLXByZWZpeGVkIHN0eWxlcyBsaWtlIGB0cmFuc2Zvcm1gLlxyXG4gIGZ1bmN0aW9uIHRlc3RQcm9wKHByb3BzKSB7XHJcbiAgXHR2YXIgc3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XHJcblxyXG4gIFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gIFx0XHRpZiAocHJvcHNbaV0gaW4gc3R5bGUpIHtcclxuICBcdFx0XHRyZXR1cm4gcHJvcHNbaV07XHJcbiAgXHRcdH1cclxuICBcdH1cclxuICBcdHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBzZXRUcmFuc2Zvcm0oZWw6IEhUTUxFbGVtZW50LCBvZmZzZXQ6IFBvaW50LCBzY2FsZT86IE51bWJlcilcclxuICAvLyBSZXNldHMgdGhlIDNEIENTUyB0cmFuc2Zvcm0gb2YgYGVsYCBzbyBpdCBpcyB0cmFuc2xhdGVkIGJ5IGBvZmZzZXRgIHBpeGVsc1xyXG4gIC8vIGFuZCBvcHRpb25hbGx5IHNjYWxlZCBieSBgc2NhbGVgLiBEb2VzIG5vdCBoYXZlIGFuIGVmZmVjdCBpZiB0aGVcclxuICAvLyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCAzRCBDU1MgdHJhbnNmb3Jtcy5cclxuICBmdW5jdGlvbiBzZXRUcmFuc2Zvcm0oZWwsIG9mZnNldCwgc2NhbGUpIHtcclxuICBcdHZhciBwb3MgPSBvZmZzZXQgfHwgbmV3IFBvaW50KDAsIDApO1xyXG5cclxuICBcdGVsLnN0eWxlW1RSQU5TRk9STV0gPVxyXG4gIFx0XHQoQnJvd3Nlci5pZTNkID9cclxuICBcdFx0XHQndHJhbnNsYXRlKCcgKyBwb3MueCArICdweCwnICsgcG9zLnkgKyAncHgpJyA6XHJcbiAgXHRcdFx0J3RyYW5zbGF0ZTNkKCcgKyBwb3MueCArICdweCwnICsgcG9zLnkgKyAncHgsMCknKSArXHJcbiAgXHRcdChzY2FsZSA/ICcgc2NhbGUoJyArIHNjYWxlICsgJyknIDogJycpO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHNldFBvc2l0aW9uKGVsOiBIVE1MRWxlbWVudCwgcG9zaXRpb246IFBvaW50KVxyXG4gIC8vIFNldHMgdGhlIHBvc2l0aW9uIG9mIGBlbGAgdG8gY29vcmRpbmF0ZXMgc3BlY2lmaWVkIGJ5IGBwb3NpdGlvbmAsXHJcbiAgLy8gdXNpbmcgQ1NTIHRyYW5zbGF0ZSBvciB0b3AvbGVmdCBwb3NpdGlvbmluZyBkZXBlbmRpbmcgb24gdGhlIGJyb3dzZXJcclxuICAvLyAodXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkgdG8gcG9zaXRpb24gaXRzIGxheWVycykuXHJcbiAgZnVuY3Rpb24gc2V0UG9zaXRpb24oZWwsIHBvaW50KSB7XHJcblxyXG4gIFx0Lyplc2xpbnQtZGlzYWJsZSAqL1xyXG4gIFx0ZWwuX2xlYWZsZXRfcG9zID0gcG9pbnQ7XHJcbiAgXHQvKiBlc2xpbnQtZW5hYmxlICovXHJcblxyXG4gIFx0aWYgKEJyb3dzZXIuYW55M2QpIHtcclxuICBcdFx0c2V0VHJhbnNmb3JtKGVsLCBwb2ludCk7XHJcbiAgXHR9IGVsc2Uge1xyXG4gIFx0XHRlbC5zdHlsZS5sZWZ0ID0gcG9pbnQueCArICdweCc7XHJcbiAgXHRcdGVsLnN0eWxlLnRvcCA9IHBvaW50LnkgKyAncHgnO1xyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGdldFBvc2l0aW9uKGVsOiBIVE1MRWxlbWVudCk6IFBvaW50XHJcbiAgLy8gUmV0dXJucyB0aGUgY29vcmRpbmF0ZXMgb2YgYW4gZWxlbWVudCBwcmV2aW91c2x5IHBvc2l0aW9uZWQgd2l0aCBzZXRQb3NpdGlvbi5cclxuICBmdW5jdGlvbiBnZXRQb3NpdGlvbihlbCkge1xyXG4gIFx0Ly8gdGhpcyBtZXRob2QgaXMgb25seSB1c2VkIGZvciBlbGVtZW50cyBwcmV2aW91c2x5IHBvc2l0aW9uZWQgdXNpbmcgc2V0UG9zaXRpb24sXHJcbiAgXHQvLyBzbyBpdCdzIHNhZmUgdG8gY2FjaGUgdGhlIHBvc2l0aW9uIGZvciBwZXJmb3JtYW5jZVxyXG5cclxuICBcdHJldHVybiBlbC5fbGVhZmxldF9wb3MgfHwgbmV3IFBvaW50KDAsIDApO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGRpc2FibGVUZXh0U2VsZWN0aW9uKClcclxuICAvLyBQcmV2ZW50cyB0aGUgdXNlciBmcm9tIGdlbmVyYXRpbmcgYHNlbGVjdHN0YXJ0YCBET00gZXZlbnRzLCB1c3VhbGx5IGdlbmVyYXRlZFxyXG4gIC8vIHdoZW4gdGhlIHVzZXIgZHJhZ3MgdGhlIG1vdXNlIHRocm91Z2ggYSBwYWdlIHdpdGggdGV4dC4gVXNlZCBpbnRlcm5hbGx5XHJcbiAgLy8gYnkgTGVhZmxldCB0byBvdmVycmlkZSB0aGUgYmVoYXZpb3VyIG9mIGFueSBjbGljay1hbmQtZHJhZyBpbnRlcmFjdGlvbiBvblxyXG4gIC8vIHRoZSBtYXAuIEFmZmVjdHMgZHJhZyBpbnRlcmFjdGlvbnMgb24gdGhlIHdob2xlIGRvY3VtZW50LlxyXG5cclxuICAvLyBAZnVuY3Rpb24gZW5hYmxlVGV4dFNlbGVjdGlvbigpXHJcbiAgLy8gQ2FuY2VscyB0aGUgZWZmZWN0cyBvZiBhIHByZXZpb3VzIFtgTC5Eb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uYF0oI2RvbXV0aWwtZGlzYWJsZXRleHRzZWxlY3Rpb24pLlxyXG4gIHZhciBkaXNhYmxlVGV4dFNlbGVjdGlvbjtcclxuICB2YXIgZW5hYmxlVGV4dFNlbGVjdGlvbjtcclxuICB2YXIgX3VzZXJTZWxlY3Q7XHJcbiAgaWYgKCdvbnNlbGVjdHN0YXJ0JyBpbiBkb2N1bWVudCkge1xyXG4gIFx0ZGlzYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdG9uKHdpbmRvdywgJ3NlbGVjdHN0YXJ0JywgcHJldmVudERlZmF1bHQpO1xyXG4gIFx0fTtcclxuICBcdGVuYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdG9mZih3aW5kb3csICdzZWxlY3RzdGFydCcsIHByZXZlbnREZWZhdWx0KTtcclxuICBcdH07XHJcbiAgfSBlbHNlIHtcclxuICBcdHZhciB1c2VyU2VsZWN0UHJvcGVydHkgPSB0ZXN0UHJvcChcclxuICBcdFx0Wyd1c2VyU2VsZWN0JywgJ1dlYmtpdFVzZXJTZWxlY3QnLCAnT1VzZXJTZWxlY3QnLCAnTW96VXNlclNlbGVjdCcsICdtc1VzZXJTZWxlY3QnXSk7XHJcblxyXG4gIFx0ZGlzYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICh1c2VyU2VsZWN0UHJvcGVydHkpIHtcclxuICBcdFx0XHR2YXIgc3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XHJcbiAgXHRcdFx0X3VzZXJTZWxlY3QgPSBzdHlsZVt1c2VyU2VsZWN0UHJvcGVydHldO1xyXG4gIFx0XHRcdHN0eWxlW3VzZXJTZWxlY3RQcm9wZXJ0eV0gPSAnbm9uZSc7XHJcbiAgXHRcdH1cclxuICBcdH07XHJcbiAgXHRlbmFibGVUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAodXNlclNlbGVjdFByb3BlcnR5KSB7XHJcbiAgXHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlW3VzZXJTZWxlY3RQcm9wZXJ0eV0gPSBfdXNlclNlbGVjdDtcclxuICBcdFx0XHRfdXNlclNlbGVjdCA9IHVuZGVmaW5lZDtcclxuICBcdFx0fVxyXG4gIFx0fTtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBkaXNhYmxlSW1hZ2VEcmFnKClcclxuICAvLyBBcyBbYEwuRG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbmBdKCNkb211dGlsLWRpc2FibGV0ZXh0c2VsZWN0aW9uKSwgYnV0XHJcbiAgLy8gZm9yIGBkcmFnc3RhcnRgIERPTSBldmVudHMsIHVzdWFsbHkgZ2VuZXJhdGVkIHdoZW4gdGhlIHVzZXIgZHJhZ3MgYW4gaW1hZ2UuXHJcbiAgZnVuY3Rpb24gZGlzYWJsZUltYWdlRHJhZygpIHtcclxuICBcdG9uKHdpbmRvdywgJ2RyYWdzdGFydCcsIHByZXZlbnREZWZhdWx0KTtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBlbmFibGVJbWFnZURyYWcoKVxyXG4gIC8vIENhbmNlbHMgdGhlIGVmZmVjdHMgb2YgYSBwcmV2aW91cyBbYEwuRG9tVXRpbC5kaXNhYmxlSW1hZ2VEcmFnYF0oI2RvbXV0aWwtZGlzYWJsZXRleHRzZWxlY3Rpb24pLlxyXG4gIGZ1bmN0aW9uIGVuYWJsZUltYWdlRHJhZygpIHtcclxuICBcdG9mZih3aW5kb3csICdkcmFnc3RhcnQnLCBwcmV2ZW50RGVmYXVsdCk7XHJcbiAgfVxyXG5cclxuICB2YXIgX291dGxpbmVFbGVtZW50LCBfb3V0bGluZVN0eWxlO1xyXG4gIC8vIEBmdW5jdGlvbiBwcmV2ZW50T3V0bGluZShlbDogSFRNTEVsZW1lbnQpXHJcbiAgLy8gTWFrZXMgdGhlIFtvdXRsaW5lXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9DU1Mvb3V0bGluZSlcclxuICAvLyBvZiB0aGUgZWxlbWVudCBgZWxgIGludmlzaWJsZS4gVXNlZCBpbnRlcm5hbGx5IGJ5IExlYWZsZXQgdG8gcHJldmVudFxyXG4gIC8vIGZvY3VzYWJsZSBlbGVtZW50cyBmcm9tIGRpc3BsYXlpbmcgYW4gb3V0bGluZSB3aGVuIHRoZSB1c2VyIHBlcmZvcm1zIGFcclxuICAvLyBkcmFnIGludGVyYWN0aW9uIG9uIHRoZW0uXHJcbiAgZnVuY3Rpb24gcHJldmVudE91dGxpbmUoZWxlbWVudCkge1xyXG4gIFx0d2hpbGUgKGVsZW1lbnQudGFiSW5kZXggPT09IC0xKSB7XHJcbiAgXHRcdGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XHJcbiAgXHR9XHJcbiAgXHRpZiAoIWVsZW1lbnQuc3R5bGUpIHsgcmV0dXJuOyB9XHJcbiAgXHRyZXN0b3JlT3V0bGluZSgpO1xyXG4gIFx0X291dGxpbmVFbGVtZW50ID0gZWxlbWVudDtcclxuICBcdF9vdXRsaW5lU3R5bGUgPSBlbGVtZW50LnN0eWxlLm91dGxpbmU7XHJcbiAgXHRlbGVtZW50LnN0eWxlLm91dGxpbmUgPSAnbm9uZSc7XHJcbiAgXHRvbih3aW5kb3csICdrZXlkb3duJywgcmVzdG9yZU91dGxpbmUpO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHJlc3RvcmVPdXRsaW5lKClcclxuICAvLyBDYW5jZWxzIHRoZSBlZmZlY3RzIG9mIGEgcHJldmlvdXMgW2BMLkRvbVV0aWwucHJldmVudE91dGxpbmVgXSgpLlxyXG4gIGZ1bmN0aW9uIHJlc3RvcmVPdXRsaW5lKCkge1xyXG4gIFx0aWYgKCFfb3V0bGluZUVsZW1lbnQpIHsgcmV0dXJuOyB9XHJcbiAgXHRfb3V0bGluZUVsZW1lbnQuc3R5bGUub3V0bGluZSA9IF9vdXRsaW5lU3R5bGU7XHJcbiAgXHRfb3V0bGluZUVsZW1lbnQgPSB1bmRlZmluZWQ7XHJcbiAgXHRfb3V0bGluZVN0eWxlID0gdW5kZWZpbmVkO1xyXG4gIFx0b2ZmKHdpbmRvdywgJ2tleWRvd24nLCByZXN0b3JlT3V0bGluZSk7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gZ2V0U2l6ZWRQYXJlbnROb2RlKGVsOiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcbiAgLy8gRmluZHMgdGhlIGNsb3Nlc3QgcGFyZW50IG5vZGUgd2hpY2ggc2l6ZSAod2lkdGggYW5kIGhlaWdodCkgaXMgbm90IG51bGwuXHJcbiAgZnVuY3Rpb24gZ2V0U2l6ZWRQYXJlbnROb2RlKGVsZW1lbnQpIHtcclxuICBcdGRvIHtcclxuICBcdFx0ZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcclxuICBcdH0gd2hpbGUgKCghZWxlbWVudC5vZmZzZXRXaWR0aCB8fCAhZWxlbWVudC5vZmZzZXRIZWlnaHQpICYmIGVsZW1lbnQgIT09IGRvY3VtZW50LmJvZHkpO1xyXG4gIFx0cmV0dXJuIGVsZW1lbnQ7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gZ2V0U2NhbGUoZWw6IEhUTUxFbGVtZW50KTogT2JqZWN0XHJcbiAgLy8gQ29tcHV0ZXMgdGhlIENTUyBzY2FsZSBjdXJyZW50bHkgYXBwbGllZCBvbiB0aGUgZWxlbWVudC5cclxuICAvLyBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIGB4YCBhbmQgYHlgIG1lbWJlcnMgYXMgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgc2NhbGVzIHJlc3BlY3RpdmVseSxcclxuICAvLyBhbmQgYGJvdW5kaW5nQ2xpZW50UmVjdGAgYXMgdGhlIHJlc3VsdCBvZiBbYGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvZ2V0Qm91bmRpbmdDbGllbnRSZWN0KS5cclxuICBmdW5jdGlvbiBnZXRTY2FsZShlbGVtZW50KSB7XHJcbiAgXHR2YXIgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IC8vIFJlYWQtb25seSBpbiBvbGQgYnJvd3NlcnMuXHJcblxyXG4gIFx0cmV0dXJuIHtcclxuICBcdFx0eDogcmVjdC53aWR0aCAvIGVsZW1lbnQub2Zmc2V0V2lkdGggfHwgMSxcclxuICBcdFx0eTogcmVjdC5oZWlnaHQgLyBlbGVtZW50Lm9mZnNldEhlaWdodCB8fCAxLFxyXG4gIFx0XHRib3VuZGluZ0NsaWVudFJlY3Q6IHJlY3RcclxuICBcdH07XHJcbiAgfVxuXG4gIHZhciBEb21VdGlsID0ge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBUUkFOU0ZPUk06IFRSQU5TRk9STSxcbiAgICBUUkFOU0lUSU9OOiBUUkFOU0lUSU9OLFxuICAgIFRSQU5TSVRJT05fRU5EOiBUUkFOU0lUSU9OX0VORCxcbiAgICBnZXQ6IGdldCxcbiAgICBnZXRTdHlsZTogZ2V0U3R5bGUsXG4gICAgY3JlYXRlOiBjcmVhdGUkMSxcbiAgICByZW1vdmU6IHJlbW92ZSxcbiAgICBlbXB0eTogZW1wdHksXG4gICAgdG9Gcm9udDogdG9Gcm9udCxcbiAgICB0b0JhY2s6IHRvQmFjayxcbiAgICBoYXNDbGFzczogaGFzQ2xhc3MsXG4gICAgYWRkQ2xhc3M6IGFkZENsYXNzLFxuICAgIHJlbW92ZUNsYXNzOiByZW1vdmVDbGFzcyxcbiAgICBzZXRDbGFzczogc2V0Q2xhc3MsXG4gICAgZ2V0Q2xhc3M6IGdldENsYXNzLFxuICAgIHNldE9wYWNpdHk6IHNldE9wYWNpdHksXG4gICAgdGVzdFByb3A6IHRlc3RQcm9wLFxuICAgIHNldFRyYW5zZm9ybTogc2V0VHJhbnNmb3JtLFxuICAgIHNldFBvc2l0aW9uOiBzZXRQb3NpdGlvbixcbiAgICBnZXRQb3NpdGlvbjogZ2V0UG9zaXRpb24sXG4gICAgZ2V0IGRpc2FibGVUZXh0U2VsZWN0aW9uICgpIHsgcmV0dXJuIGRpc2FibGVUZXh0U2VsZWN0aW9uOyB9LFxuICAgIGdldCBlbmFibGVUZXh0U2VsZWN0aW9uICgpIHsgcmV0dXJuIGVuYWJsZVRleHRTZWxlY3Rpb247IH0sXG4gICAgZGlzYWJsZUltYWdlRHJhZzogZGlzYWJsZUltYWdlRHJhZyxcbiAgICBlbmFibGVJbWFnZURyYWc6IGVuYWJsZUltYWdlRHJhZyxcbiAgICBwcmV2ZW50T3V0bGluZTogcHJldmVudE91dGxpbmUsXG4gICAgcmVzdG9yZU91dGxpbmU6IHJlc3RvcmVPdXRsaW5lLFxuICAgIGdldFNpemVkUGFyZW50Tm9kZTogZ2V0U2l6ZWRQYXJlbnROb2RlLFxuICAgIGdldFNjYWxlOiBnZXRTY2FsZVxuICB9O1xuXG4gIC8qXHJcbiAgICogQG5hbWVzcGFjZSBEb21FdmVudFxyXG4gICAqIFV0aWxpdHkgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aCB0aGUgW0RPTSBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9FdmVudCksIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gICAqL1xyXG5cclxuICAvLyBJbnNwaXJlZCBieSBKb2huIFJlc2lnLCBEZWFuIEVkd2FyZHMgYW5kIFlVSSBhZGRFdmVudCBpbXBsZW1lbnRhdGlvbnMuXHJcblxyXG4gIC8vIEBmdW5jdGlvbiBvbihlbDogSFRNTEVsZW1lbnQsIHR5cGVzOiBTdHJpbmcsIGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuICAvLyBBZGRzIGEgbGlzdGVuZXIgZnVuY3Rpb24gKGBmbmApIHRvIGEgcGFydGljdWxhciBET00gZXZlbnQgdHlwZSBvZiB0aGVcclxuICAvLyBlbGVtZW50IGBlbGAuIFlvdSBjYW4gb3B0aW9uYWxseSBzcGVjaWZ5IHRoZSBjb250ZXh0IG9mIHRoZSBsaXN0ZW5lclxyXG4gIC8vIChvYmplY3QgdGhlIGB0aGlzYCBrZXl3b3JkIHdpbGwgcG9pbnQgdG8pLiBZb3UgY2FuIGFsc28gcGFzcyBzZXZlcmFsXHJcbiAgLy8gc3BhY2Utc2VwYXJhdGVkIHR5cGVzIChlLmcuIGAnY2xpY2sgZGJsY2xpY2snYCkuXHJcblxyXG4gIC8vIEBhbHRlcm5hdGl2ZVxyXG4gIC8vIEBmdW5jdGlvbiBvbihlbDogSFRNTEVsZW1lbnQsIGV2ZW50TWFwOiBPYmplY3QsIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbiAgLy8gQWRkcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLCBlLmcuIGB7Y2xpY2s6IG9uQ2xpY2ssIG1vdXNlbW92ZTogb25Nb3VzZU1vdmV9YFxyXG4gIGZ1bmN0aW9uIG9uKG9iaiwgdHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG4gIFx0aWYgKHR5cGVzICYmIHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuICBcdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG4gIFx0XHRcdGFkZE9uZShvYmosIHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcbiAgXHRcdH1cclxuICBcdH0gZWxzZSB7XHJcbiAgXHRcdHR5cGVzID0gc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG4gIFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0XHRhZGRPbmUob2JqLCB0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcblxyXG4gIFx0cmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICB2YXIgZXZlbnRzS2V5ID0gJ19sZWFmbGV0X2V2ZW50cyc7XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBvZmYoZWw6IEhUTUxFbGVtZW50LCB0eXBlczogU3RyaW5nLCBmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbiAgLy8gUmVtb3ZlcyBhIHByZXZpb3VzbHkgYWRkZWQgbGlzdGVuZXIgZnVuY3Rpb24uXHJcbiAgLy8gTm90ZSB0aGF0IGlmIHlvdSBwYXNzZWQgYSBjdXN0b20gY29udGV4dCB0byBvbiwgeW91IG11c3QgcGFzcyB0aGUgc2FtZVxyXG4gIC8vIGNvbnRleHQgdG8gYG9mZmAgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lci5cclxuXHJcbiAgLy8gQGFsdGVybmF0aXZlXHJcbiAgLy8gQGZ1bmN0aW9uIG9mZihlbDogSFRNTEVsZW1lbnQsIGV2ZW50TWFwOiBPYmplY3QsIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbiAgLy8gUmVtb3ZlcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLCBlLmcuIGB7Y2xpY2s6IG9uQ2xpY2ssIG1vdXNlbW92ZTogb25Nb3VzZU1vdmV9YFxyXG5cclxuICAvLyBAYWx0ZXJuYXRpdmVcclxuICAvLyBAZnVuY3Rpb24gb2ZmKGVsOiBIVE1MRWxlbWVudCwgdHlwZXM6IFN0cmluZyk6IHRoaXNcclxuICAvLyBSZW1vdmVzIGFsbCBwcmV2aW91c2x5IGFkZGVkIGxpc3RlbmVycyBvZiBnaXZlbiB0eXBlcy5cclxuXHJcbiAgLy8gQGFsdGVybmF0aXZlXHJcbiAgLy8gQGZ1bmN0aW9uIG9mZihlbDogSFRNTEVsZW1lbnQpOiB0aGlzXHJcbiAgLy8gUmVtb3ZlcyBhbGwgcHJldmlvdXNseSBhZGRlZCBsaXN0ZW5lcnMgZnJvbSBnaXZlbiBIVE1MRWxlbWVudFxyXG4gIGZ1bmN0aW9uIG9mZihvYmosIHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuICBcdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XHJcbiAgXHRcdGJhdGNoUmVtb3ZlKG9iaik7XHJcbiAgXHRcdGRlbGV0ZSBvYmpbZXZlbnRzS2V5XTtcclxuXHJcbiAgXHR9IGVsc2UgaWYgKHR5cGVzICYmIHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuICBcdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG4gIFx0XHRcdHJlbW92ZU9uZShvYmosIHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHR9IGVsc2Uge1xyXG4gIFx0XHR0eXBlcyA9IHNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuICBcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcclxuICBcdFx0XHRiYXRjaFJlbW92ZShvYmosIGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgXHRcdFx0XHRyZXR1cm4gaW5kZXhPZih0eXBlcywgdHlwZSkgIT09IC0xO1xyXG4gIFx0XHRcdH0pO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRcdFx0cmVtb3ZlT25lKG9iaiwgdHlwZXNbaV0sIGZuLCBjb250ZXh0KTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuICBcdH1cclxuXHJcbiAgXHRyZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGJhdGNoUmVtb3ZlKG9iaiwgZmlsdGVyRm4pIHtcclxuICBcdGZvciAodmFyIGlkIGluIG9ialtldmVudHNLZXldKSB7XHJcbiAgXHRcdHZhciB0eXBlID0gaWQuc3BsaXQoL1xcZC8pWzBdO1xyXG4gIFx0XHRpZiAoIWZpbHRlckZuIHx8IGZpbHRlckZuKHR5cGUpKSB7XHJcbiAgXHRcdFx0cmVtb3ZlT25lKG9iaiwgdHlwZSwgbnVsbCwgbnVsbCwgaWQpO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcbiAgfVxyXG5cclxuICB2YXIgbW91c2VTdWJzdCA9IHtcclxuICBcdG1vdXNlZW50ZXI6ICdtb3VzZW92ZXInLFxyXG4gIFx0bW91c2VsZWF2ZTogJ21vdXNlb3V0JyxcclxuICBcdHdoZWVsOiAhKCdvbndoZWVsJyBpbiB3aW5kb3cpICYmICdtb3VzZXdoZWVsJ1xyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIGFkZE9uZShvYmosIHR5cGUsIGZuLCBjb250ZXh0KSB7XHJcbiAgXHR2YXIgaWQgPSB0eXBlICsgc3RhbXAoZm4pICsgKGNvbnRleHQgPyAnXycgKyBzdGFtcChjb250ZXh0KSA6ICcnKTtcclxuXHJcbiAgXHRpZiAob2JqW2V2ZW50c0tleV0gJiYgb2JqW2V2ZW50c0tleV1baWRdKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG4gIFx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHRyZXR1cm4gZm4uY2FsbChjb250ZXh0IHx8IG9iaiwgZSB8fCB3aW5kb3cuZXZlbnQpO1xyXG4gIFx0fTtcclxuXHJcbiAgXHR2YXIgb3JpZ2luYWxIYW5kbGVyID0gaGFuZGxlcjtcclxuXHJcbiAgXHRpZiAoIUJyb3dzZXIudG91Y2hOYXRpdmUgJiYgQnJvd3Nlci5wb2ludGVyICYmIHR5cGUuaW5kZXhPZigndG91Y2gnKSA9PT0gMCkge1xyXG4gIFx0XHQvLyBOZWVkcyBEb21FdmVudC5Qb2ludGVyLmpzXHJcbiAgXHRcdGhhbmRsZXIgPSBhZGRQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBoYW5kbGVyKTtcclxuXHJcbiAgXHR9IGVsc2UgaWYgKEJyb3dzZXIudG91Y2ggJiYgKHR5cGUgPT09ICdkYmxjbGljaycpKSB7XHJcbiAgXHRcdGhhbmRsZXIgPSBhZGREb3VibGVUYXBMaXN0ZW5lcihvYmosIGhhbmRsZXIpO1xyXG5cclxuICBcdH0gZWxzZSBpZiAoJ2FkZEV2ZW50TGlzdGVuZXInIGluIG9iaikge1xyXG5cclxuICBcdFx0aWYgKHR5cGUgPT09ICd0b3VjaHN0YXJ0JyB8fCB0eXBlID09PSAndG91Y2htb3ZlJyB8fCB0eXBlID09PSAnd2hlZWwnIHx8ICB0eXBlID09PSAnbW91c2V3aGVlbCcpIHtcclxuICBcdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcihtb3VzZVN1YnN0W3R5cGVdIHx8IHR5cGUsIGhhbmRsZXIsIEJyb3dzZXIucGFzc2l2ZUV2ZW50cyA/IHtwYXNzaXZlOiBmYWxzZX0gOiBmYWxzZSk7XHJcblxyXG4gIFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdtb3VzZWVudGVyJyB8fCB0eXBlID09PSAnbW91c2VsZWF2ZScpIHtcclxuICBcdFx0XHRoYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0XHRcdGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcclxuICBcdFx0XHRcdGlmIChpc0V4dGVybmFsVGFyZ2V0KG9iaiwgZSkpIHtcclxuICBcdFx0XHRcdFx0b3JpZ2luYWxIYW5kbGVyKGUpO1xyXG4gIFx0XHRcdFx0fVxyXG4gIFx0XHRcdH07XHJcbiAgXHRcdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIobW91c2VTdWJzdFt0eXBlXSwgaGFuZGxlciwgZmFsc2UpO1xyXG5cclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBvcmlnaW5hbEhhbmRsZXIsIGZhbHNlKTtcclxuICBcdFx0fVxyXG5cclxuICBcdH0gZWxzZSB7XHJcbiAgXHRcdG9iai5hdHRhY2hFdmVudCgnb24nICsgdHlwZSwgaGFuZGxlcik7XHJcbiAgXHR9XHJcblxyXG4gIFx0b2JqW2V2ZW50c0tleV0gPSBvYmpbZXZlbnRzS2V5XSB8fCB7fTtcclxuICBcdG9ialtldmVudHNLZXldW2lkXSA9IGhhbmRsZXI7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZW1vdmVPbmUob2JqLCB0eXBlLCBmbiwgY29udGV4dCwgaWQpIHtcclxuICBcdGlkID0gaWQgfHwgdHlwZSArIHN0YW1wKGZuKSArIChjb250ZXh0ID8gJ18nICsgc3RhbXAoY29udGV4dCkgOiAnJyk7XHJcbiAgXHR2YXIgaGFuZGxlciA9IG9ialtldmVudHNLZXldICYmIG9ialtldmVudHNLZXldW2lkXTtcclxuXHJcbiAgXHRpZiAoIWhhbmRsZXIpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcbiAgXHRpZiAoIUJyb3dzZXIudG91Y2hOYXRpdmUgJiYgQnJvd3Nlci5wb2ludGVyICYmIHR5cGUuaW5kZXhPZigndG91Y2gnKSA9PT0gMCkge1xyXG4gIFx0XHRyZW1vdmVQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBoYW5kbGVyKTtcclxuXHJcbiAgXHR9IGVsc2UgaWYgKEJyb3dzZXIudG91Y2ggJiYgKHR5cGUgPT09ICdkYmxjbGljaycpKSB7XHJcbiAgXHRcdHJlbW92ZURvdWJsZVRhcExpc3RlbmVyKG9iaiwgaGFuZGxlcik7XHJcblxyXG4gIFx0fSBlbHNlIGlmICgncmVtb3ZlRXZlbnRMaXN0ZW5lcicgaW4gb2JqKSB7XHJcblxyXG4gIFx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihtb3VzZVN1YnN0W3R5cGVdIHx8IHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHJcbiAgXHR9IGVsc2Uge1xyXG4gIFx0XHRvYmouZGV0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGhhbmRsZXIpO1xyXG4gIFx0fVxyXG5cclxuICBcdG9ialtldmVudHNLZXldW2lkXSA9IG51bGw7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKGV2OiBET01FdmVudCk6IHRoaXNcclxuICAvLyBTdG9wIHRoZSBnaXZlbiBldmVudCBmcm9tIHByb3BhZ2F0aW9uIHRvIHBhcmVudCBlbGVtZW50cy4gVXNlZCBpbnNpZGUgdGhlIGxpc3RlbmVyIGZ1bmN0aW9uczpcclxuICAvLyBgYGBqc1xyXG4gIC8vIEwuRG9tRXZlbnQub24oZGl2LCAnY2xpY2snLCBmdW5jdGlvbiAoZXYpIHtcclxuICAvLyBcdEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKGV2KTtcclxuICAvLyB9KTtcclxuICAvLyBgYGBcclxuICBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oZSkge1xyXG5cclxuICBcdGlmIChlLnN0b3BQcm9wYWdhdGlvbikge1xyXG4gIFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gIFx0fSBlbHNlIGlmIChlLm9yaWdpbmFsRXZlbnQpIHsgIC8vIEluIGNhc2Ugb2YgTGVhZmxldCBldmVudC5cclxuICBcdFx0ZS5vcmlnaW5hbEV2ZW50Ll9zdG9wcGVkID0gdHJ1ZTtcclxuICBcdH0gZWxzZSB7XHJcbiAgXHRcdGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuICBcdH1cclxuXHJcbiAgXHRyZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24oZWw6IEhUTUxFbGVtZW50KTogdGhpc1xyXG4gIC8vIEFkZHMgYHN0b3BQcm9wYWdhdGlvbmAgdG8gdGhlIGVsZW1lbnQncyBgJ3doZWVsJ2AgZXZlbnRzIChwbHVzIGJyb3dzZXIgdmFyaWFudHMpLlxyXG4gIGZ1bmN0aW9uIGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbihlbCkge1xyXG4gIFx0YWRkT25lKGVsLCAnd2hlZWwnLCBzdG9wUHJvcGFnYXRpb24pO1xyXG4gIFx0cmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24oZWw6IEhUTUxFbGVtZW50KTogdGhpc1xyXG4gIC8vIEFkZHMgYHN0b3BQcm9wYWdhdGlvbmAgdG8gdGhlIGVsZW1lbnQncyBgJ2NsaWNrJ2AsIGAnZGJsY2xpY2snYCwgYCdjb250ZXh0bWVudSdgLFxyXG4gIC8vIGAnbW91c2Vkb3duJ2AgYW5kIGAndG91Y2hzdGFydCdgIGV2ZW50cyAocGx1cyBicm93c2VyIHZhcmlhbnRzKS5cclxuICBmdW5jdGlvbiBkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihlbCkge1xyXG4gIFx0b24oZWwsICdtb3VzZWRvd24gdG91Y2hzdGFydCBkYmxjbGljayBjb250ZXh0bWVudScsIHN0b3BQcm9wYWdhdGlvbik7XHJcbiAgXHRlbFsnX2xlYWZsZXRfZGlzYWJsZV9jbGljayddID0gdHJ1ZTtcclxuICBcdHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGV2OiBET01FdmVudCk6IHRoaXNcclxuICAvLyBQcmV2ZW50cyB0aGUgZGVmYXVsdCBhY3Rpb24gb2YgdGhlIERPTSBFdmVudCBgZXZgIGZyb20gaGFwcGVuaW5nIChzdWNoIGFzXHJcbiAgLy8gZm9sbG93aW5nIGEgbGluayBpbiB0aGUgaHJlZiBvZiB0aGUgYSBlbGVtZW50LCBvciBkb2luZyBhIFBPU1QgcmVxdWVzdFxyXG4gIC8vIHdpdGggcGFnZSByZWxvYWQgd2hlbiBhIGA8Zm9ybT5gIGlzIHN1Ym1pdHRlZCkuXHJcbiAgLy8gVXNlIGl0IGluc2lkZSBsaXN0ZW5lciBmdW5jdGlvbnMuXHJcbiAgZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZSkge1xyXG4gIFx0aWYgKGUucHJldmVudERlZmF1bHQpIHtcclxuICBcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gIFx0fSBlbHNlIHtcclxuICBcdFx0ZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gc3RvcChldjogRE9NRXZlbnQpOiB0aGlzXHJcbiAgLy8gRG9lcyBgc3RvcFByb3BhZ2F0aW9uYCBhbmQgYHByZXZlbnREZWZhdWx0YCBhdCB0aGUgc2FtZSB0aW1lLlxyXG4gIGZ1bmN0aW9uIHN0b3AoZSkge1xyXG4gIFx0cHJldmVudERlZmF1bHQoZSk7XHJcbiAgXHRzdG9wUHJvcGFnYXRpb24oZSk7XHJcbiAgXHRyZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBnZXRQcm9wYWdhdGlvblBhdGgoZXY6IERPTUV2ZW50KTogQXJyYXlcclxuICAvLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbYEV2ZW50LmNvbXBvc2VkUGF0aCgpYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50L2NvbXBvc2VkUGF0aCkuXHJcbiAgLy8gUmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBgSFRNTEVsZW1lbnRgcyB0aGF0IHRoZSBnaXZlbiBET00gZXZlbnRcclxuICAvLyBzaG91bGQgcHJvcGFnYXRlIHRvIChpZiBub3Qgc3RvcHBlZCkuXHJcbiAgZnVuY3Rpb24gZ2V0UHJvcGFnYXRpb25QYXRoKGV2KSB7XHJcbiAgXHRpZiAoZXYuY29tcG9zZWRQYXRoKSB7XHJcbiAgXHRcdHJldHVybiBldi5jb21wb3NlZFBhdGgoKTtcclxuICBcdH1cclxuXHJcbiAgXHR2YXIgcGF0aCA9IFtdO1xyXG4gIFx0dmFyIGVsID0gZXYudGFyZ2V0O1xyXG5cclxuICBcdHdoaWxlIChlbCkge1xyXG4gIFx0XHRwYXRoLnB1c2goZWwpO1xyXG4gIFx0XHRlbCA9IGVsLnBhcmVudE5vZGU7XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gcGF0aDtcclxuICB9XHJcblxyXG5cclxuICAvLyBAZnVuY3Rpb24gZ2V0TW91c2VQb3NpdGlvbihldjogRE9NRXZlbnQsIGNvbnRhaW5lcj86IEhUTUxFbGVtZW50KTogUG9pbnRcclxuICAvLyBHZXRzIG5vcm1hbGl6ZWQgbW91c2UgcG9zaXRpb24gZnJvbSBhIERPTSBldmVudCByZWxhdGl2ZSB0byB0aGVcclxuICAvLyBgY29udGFpbmVyYCAoYm9yZGVyIGV4Y2x1ZGVkKSBvciB0byB0aGUgd2hvbGUgcGFnZSBpZiBub3Qgc3BlY2lmaWVkLlxyXG4gIGZ1bmN0aW9uIGdldE1vdXNlUG9zaXRpb24oZSwgY29udGFpbmVyKSB7XHJcbiAgXHRpZiAoIWNvbnRhaW5lcikge1xyXG4gIFx0XHRyZXR1cm4gbmV3IFBvaW50KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcclxuICBcdH1cclxuXHJcbiAgXHR2YXIgc2NhbGUgPSBnZXRTY2FsZShjb250YWluZXIpLFxyXG4gIFx0ICAgIG9mZnNldCA9IHNjYWxlLmJvdW5kaW5nQ2xpZW50UmVjdDsgLy8gbGVmdCBhbmQgdG9wICB2YWx1ZXMgYXJlIGluIHBhZ2Ugc2NhbGUgKGxpa2UgdGhlIGV2ZW50IGNsaWVudFgvWSlcclxuXHJcbiAgXHRyZXR1cm4gbmV3IFBvaW50KFxyXG4gIFx0XHQvLyBvZmZzZXQubGVmdC90b3AgdmFsdWVzIGFyZSBpbiBwYWdlIHNjYWxlIChsaWtlIGNsaWVudFgvWSksXHJcbiAgXHRcdC8vIHdoZXJlYXMgY2xpZW50TGVmdC9Ub3AgKGJvcmRlciB3aWR0aCkgdmFsdWVzIGFyZSB0aGUgb3JpZ2luYWwgdmFsdWVzIChiZWZvcmUgQ1NTIHNjYWxlIGFwcGxpZXMpLlxyXG4gIFx0XHQoZS5jbGllbnRYIC0gb2Zmc2V0LmxlZnQpIC8gc2NhbGUueCAtIGNvbnRhaW5lci5jbGllbnRMZWZ0LFxyXG4gIFx0XHQoZS5jbGllbnRZIC0gb2Zmc2V0LnRvcCkgLyBzY2FsZS55IC0gY29udGFpbmVyLmNsaWVudFRvcFxyXG4gIFx0KTtcclxuICB9XHJcblxyXG5cclxuICAvLyAgZXhjZXB0ICwgU2FmYXJpIGFuZFxyXG4gIC8vIFdlIG5lZWQgZG91YmxlIHRoZSBzY3JvbGwgcGl4ZWxzIChzZWUgIzc0MDMgYW5kICM0NTM4KSBmb3IgYWxsIEJyb3dzZXJzXHJcbiAgLy8gZXhjZXB0IE9TWCAoTWFjKSAtPiAzeCwgQ2hyb21lIHJ1bm5pbmcgb24gTGludXggMXhcclxuXHJcbiAgdmFyIHdoZWVsUHhGYWN0b3IgPVxyXG4gIFx0KEJyb3dzZXIubGludXggJiYgQnJvd3Nlci5jaHJvbWUpID8gd2luZG93LmRldmljZVBpeGVsUmF0aW8gOlxyXG4gIFx0QnJvd3Nlci5tYWMgPyB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyAqIDMgOlxyXG4gIFx0d2luZG93LmRldmljZVBpeGVsUmF0aW8gPiAwID8gMiAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDogMTtcclxuICAvLyBAZnVuY3Rpb24gZ2V0V2hlZWxEZWx0YShldjogRE9NRXZlbnQpOiBOdW1iZXJcclxuICAvLyBHZXRzIG5vcm1hbGl6ZWQgd2hlZWwgZGVsdGEgZnJvbSBhIHdoZWVsIERPTSBldmVudCwgaW4gdmVydGljYWxcclxuICAvLyBwaXhlbHMgc2Nyb2xsZWQgKG5lZ2F0aXZlIGlmIHNjcm9sbGluZyBkb3duKS5cclxuICAvLyBFdmVudHMgZnJvbSBwb2ludGluZyBkZXZpY2VzIHdpdGhvdXQgcHJlY2lzZSBzY3JvbGxpbmcgYXJlIG1hcHBlZCB0b1xyXG4gIC8vIGEgYmVzdCBndWVzcyBvZiA2MCBwaXhlbHMuXHJcbiAgZnVuY3Rpb24gZ2V0V2hlZWxEZWx0YShlKSB7XHJcbiAgXHRyZXR1cm4gKEJyb3dzZXIuZWRnZSkgPyBlLndoZWVsRGVsdGFZIC8gMiA6IC8vIERvbid0IHRydXN0IHdpbmRvdy1nZW9tZXRyeS1iYXNlZCBkZWx0YVxyXG4gIFx0ICAgICAgIChlLmRlbHRhWSAmJiBlLmRlbHRhTW9kZSA9PT0gMCkgPyAtZS5kZWx0YVkgLyB3aGVlbFB4RmFjdG9yIDogLy8gUGl4ZWxzXHJcbiAgXHQgICAgICAgKGUuZGVsdGFZICYmIGUuZGVsdGFNb2RlID09PSAxKSA/IC1lLmRlbHRhWSAqIDIwIDogLy8gTGluZXNcclxuICBcdCAgICAgICAoZS5kZWx0YVkgJiYgZS5kZWx0YU1vZGUgPT09IDIpID8gLWUuZGVsdGFZICogNjAgOiAvLyBQYWdlc1xyXG4gIFx0ICAgICAgIChlLmRlbHRhWCB8fCBlLmRlbHRhWikgPyAwIDpcdC8vIFNraXAgaG9yaXpvbnRhbC9kZXB0aCB3aGVlbCBldmVudHNcclxuICBcdCAgICAgICBlLndoZWVsRGVsdGEgPyAoZS53aGVlbERlbHRhWSB8fCBlLndoZWVsRGVsdGEpIC8gMiA6IC8vIExlZ2FjeSBJRSBwaXhlbHNcclxuICBcdCAgICAgICAoZS5kZXRhaWwgJiYgTWF0aC5hYnMoZS5kZXRhaWwpIDwgMzI3NjUpID8gLWUuZGV0YWlsICogMjAgOiAvLyBMZWdhY3kgTW96IGxpbmVzXHJcbiAgXHQgICAgICAgZS5kZXRhaWwgPyBlLmRldGFpbCAvIC0zMjc2NSAqIDYwIDogLy8gTGVnYWN5IE1veiBwYWdlc1xyXG4gIFx0ICAgICAgIDA7XHJcbiAgfVxyXG5cclxuICAvLyBjaGVjayBpZiBlbGVtZW50IHJlYWxseSBsZWZ0L2VudGVyZWQgdGhlIGV2ZW50IHRhcmdldCAoZm9yIG1vdXNlZW50ZXIvbW91c2VsZWF2ZSlcclxuICBmdW5jdGlvbiBpc0V4dGVybmFsVGFyZ2V0KGVsLCBlKSB7XHJcblxyXG4gIFx0dmFyIHJlbGF0ZWQgPSBlLnJlbGF0ZWRUYXJnZXQ7XHJcblxyXG4gIFx0aWYgKCFyZWxhdGVkKSB7IHJldHVybiB0cnVlOyB9XHJcblxyXG4gIFx0dHJ5IHtcclxuICBcdFx0d2hpbGUgKHJlbGF0ZWQgJiYgKHJlbGF0ZWQgIT09IGVsKSkge1xyXG4gIFx0XHRcdHJlbGF0ZWQgPSByZWxhdGVkLnBhcmVudE5vZGU7XHJcbiAgXHRcdH1cclxuICBcdH0gY2F0Y2ggKGVycikge1xyXG4gIFx0XHRyZXR1cm4gZmFsc2U7XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gKHJlbGF0ZWQgIT09IGVsKTtcclxuICB9XG5cbiAgdmFyIERvbUV2ZW50ID0ge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBvbjogb24sXG4gICAgb2ZmOiBvZmYsXG4gICAgc3RvcFByb3BhZ2F0aW9uOiBzdG9wUHJvcGFnYXRpb24sXG4gICAgZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uOiBkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24sXG4gICAgZGlzYWJsZUNsaWNrUHJvcGFnYXRpb246IGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uLFxuICAgIHByZXZlbnREZWZhdWx0OiBwcmV2ZW50RGVmYXVsdCxcbiAgICBzdG9wOiBzdG9wLFxuICAgIGdldFByb3BhZ2F0aW9uUGF0aDogZ2V0UHJvcGFnYXRpb25QYXRoLFxuICAgIGdldE1vdXNlUG9zaXRpb246IGdldE1vdXNlUG9zaXRpb24sXG4gICAgZ2V0V2hlZWxEZWx0YTogZ2V0V2hlZWxEZWx0YSxcbiAgICBpc0V4dGVybmFsVGFyZ2V0OiBpc0V4dGVybmFsVGFyZ2V0LFxuICAgIGFkZExpc3RlbmVyOiBvbixcbiAgICByZW1vdmVMaXN0ZW5lcjogb2ZmXG4gIH07XG5cbiAgLypcbiAgICogQGNsYXNzIFBvc0FuaW1hdGlvblxuICAgKiBAYWthIEwuUG9zQW5pbWF0aW9uXG4gICAqIEBpbmhlcml0cyBFdmVudGVkXG4gICAqIFVzZWQgaW50ZXJuYWxseSBmb3IgcGFubmluZyBhbmltYXRpb25zLCB1dGlsaXppbmcgQ1NTMyBUcmFuc2l0aW9ucyBmb3IgbW9kZXJuIGJyb3dzZXJzIGFuZCBhIHRpbWVyIGZhbGxiYWNrIGZvciBJRTYtOS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogdmFyIG15UG9zaXRpb25NYXJrZXIgPSBMLm1hcmtlcihbNDguODY0NzE2LCAyLjI5NDY5NF0pLmFkZFRvKG1hcCk7XG4gICAqXG4gICAqIG15UG9zaXRpb25NYXJrZXIub24oXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcbiAgICogXHR2YXIgcG9zID0gbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChteVBvc2l0aW9uTWFya2VyLmdldExhdExuZygpKTtcbiAgICogXHRwb3MueSAtPSAyNTtcbiAgICogXHR2YXIgZnggPSBuZXcgTC5Qb3NBbmltYXRpb24oKTtcbiAgICpcbiAgICogXHRmeC5vbmNlKCdlbmQnLGZ1bmN0aW9uKCkge1xuICAgKiBcdFx0cG9zLnkgKz0gMjU7XG4gICAqIFx0XHRmeC5ydW4obXlQb3NpdGlvbk1hcmtlci5faWNvbiwgcG9zLCAwLjgpO1xuICAgKiBcdH0pO1xuICAgKlxuICAgKiBcdGZ4LnJ1bihteVBvc2l0aW9uTWFya2VyLl9pY29uLCBwb3MsIDAuMyk7XG4gICAqIH0pO1xuICAgKlxuICAgKiBgYGBcbiAgICpcbiAgICogQGNvbnN0cnVjdG9yIEwuUG9zQW5pbWF0aW9uKClcbiAgICogQ3JlYXRlcyBhIGBQb3NBbmltYXRpb25gIG9iamVjdC5cbiAgICpcbiAgICovXG5cbiAgdmFyIFBvc0FuaW1hdGlvbiA9IEV2ZW50ZWQuZXh0ZW5kKHtcblxuICBcdC8vIEBtZXRob2QgcnVuKGVsOiBIVE1MRWxlbWVudCwgbmV3UG9zOiBQb2ludCwgZHVyYXRpb24/OiBOdW1iZXIsIGVhc2VMaW5lYXJpdHk/OiBOdW1iZXIpXG4gIFx0Ly8gUnVuIGFuIGFuaW1hdGlvbiBvZiBhIGdpdmVuIGVsZW1lbnQgdG8gYSBuZXcgcG9zaXRpb24sIG9wdGlvbmFsbHkgc2V0dGluZ1xuICBcdC8vIGR1cmF0aW9uIGluIHNlY29uZHMgKGAwLjI1YCBieSBkZWZhdWx0KSBhbmQgZWFzaW5nIGxpbmVhcml0eSBmYWN0b3IgKDNyZFxuICBcdC8vIGFyZ3VtZW50IG9mIHRoZSBbY3ViaWMgYmV6aWVyIGN1cnZlXShodHRwczovL2N1YmljLWJlemllci5jb20vIzAsMCwuNSwxKSxcbiAgXHQvLyBgMC41YCBieSBkZWZhdWx0KS5cbiAgXHRydW46IGZ1bmN0aW9uIChlbCwgbmV3UG9zLCBkdXJhdGlvbiwgZWFzZUxpbmVhcml0eSkge1xuICBcdFx0dGhpcy5zdG9wKCk7XG5cbiAgXHRcdHRoaXMuX2VsID0gZWw7XG4gIFx0XHR0aGlzLl9pblByb2dyZXNzID0gdHJ1ZTtcbiAgXHRcdHRoaXMuX2R1cmF0aW9uID0gZHVyYXRpb24gfHwgMC4yNTtcbiAgXHRcdHRoaXMuX2Vhc2VPdXRQb3dlciA9IDEgLyBNYXRoLm1heChlYXNlTGluZWFyaXR5IHx8IDAuNSwgMC4yKTtcblxuICBcdFx0dGhpcy5fc3RhcnRQb3MgPSBnZXRQb3NpdGlvbihlbCk7XG4gIFx0XHR0aGlzLl9vZmZzZXQgPSBuZXdQb3Muc3VidHJhY3QodGhpcy5fc3RhcnRQb3MpO1xuICBcdFx0dGhpcy5fc3RhcnRUaW1lID0gK25ldyBEYXRlKCk7XG5cbiAgXHRcdC8vIEBldmVudCBzdGFydDogRXZlbnRcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIGFuaW1hdGlvbiBzdGFydHNcbiAgXHRcdHRoaXMuZmlyZSgnc3RhcnQnKTtcblxuICBcdFx0dGhpcy5fYW5pbWF0ZSgpO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHN0b3AoKVxuICBcdC8vIFN0b3BzIHRoZSBhbmltYXRpb24gKGlmIGN1cnJlbnRseSBydW5uaW5nKS5cbiAgXHRzdG9wOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMuX2luUHJvZ3Jlc3MpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHRoaXMuX3N0ZXAodHJ1ZSk7XG4gIFx0XHR0aGlzLl9jb21wbGV0ZSgpO1xuICBcdH0sXG5cbiAgXHRfYW5pbWF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0Ly8gYW5pbWF0aW9uIGxvb3BcbiAgXHRcdHRoaXMuX2FuaW1JZCA9IHJlcXVlc3RBbmltRnJhbWUodGhpcy5fYW5pbWF0ZSwgdGhpcyk7XG4gIFx0XHR0aGlzLl9zdGVwKCk7XG4gIFx0fSxcblxuICBcdF9zdGVwOiBmdW5jdGlvbiAocm91bmQpIHtcbiAgXHRcdHZhciBlbGFwc2VkID0gKCtuZXcgRGF0ZSgpKSAtIHRoaXMuX3N0YXJ0VGltZSxcbiAgXHRcdCAgICBkdXJhdGlvbiA9IHRoaXMuX2R1cmF0aW9uICogMTAwMDtcblxuICBcdFx0aWYgKGVsYXBzZWQgPCBkdXJhdGlvbikge1xuICBcdFx0XHR0aGlzLl9ydW5GcmFtZSh0aGlzLl9lYXNlT3V0KGVsYXBzZWQgLyBkdXJhdGlvbiksIHJvdW5kKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRoaXMuX3J1bkZyYW1lKDEpO1xuICBcdFx0XHR0aGlzLl9jb21wbGV0ZSgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfcnVuRnJhbWU6IGZ1bmN0aW9uIChwcm9ncmVzcywgcm91bmQpIHtcbiAgXHRcdHZhciBwb3MgPSB0aGlzLl9zdGFydFBvcy5hZGQodGhpcy5fb2Zmc2V0Lm11bHRpcGx5QnkocHJvZ3Jlc3MpKTtcbiAgXHRcdGlmIChyb3VuZCkge1xuICBcdFx0XHRwb3MuX3JvdW5kKCk7XG4gIFx0XHR9XG4gIFx0XHRzZXRQb3NpdGlvbih0aGlzLl9lbCwgcG9zKTtcblxuICBcdFx0Ly8gQGV2ZW50IHN0ZXA6IEV2ZW50XG4gIFx0XHQvLyBGaXJlZCBjb250aW51b3VzbHkgZHVyaW5nIHRoZSBhbmltYXRpb24uXG4gIFx0XHR0aGlzLmZpcmUoJ3N0ZXAnKTtcbiAgXHR9LFxuXG4gIFx0X2NvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRjYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbUlkKTtcblxuICBcdFx0dGhpcy5faW5Qcm9ncmVzcyA9IGZhbHNlO1xuICBcdFx0Ly8gQGV2ZW50IGVuZDogRXZlbnRcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIGFuaW1hdGlvbiBlbmRzLlxuICBcdFx0dGhpcy5maXJlKCdlbmQnKTtcbiAgXHR9LFxuXG4gIFx0X2Vhc2VPdXQ6IGZ1bmN0aW9uICh0KSB7XG4gIFx0XHRyZXR1cm4gMSAtIE1hdGgucG93KDEgLSB0LCB0aGlzLl9lYXNlT3V0UG93ZXIpO1xuICBcdH1cbiAgfSk7XG5cbiAgLypcclxuICAgKiBAY2xhc3MgTWFwXHJcbiAgICogQGFrYSBMLk1hcFxyXG4gICAqIEBpbmhlcml0cyBFdmVudGVkXHJcbiAgICpcclxuICAgKiBUaGUgY2VudHJhbCBjbGFzcyBvZiB0aGUgQVBJIOKAlCBpdCBpcyB1c2VkIHRvIGNyZWF0ZSBhIG1hcCBvbiBhIHBhZ2UgYW5kIG1hbmlwdWxhdGUgaXQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiAvLyBpbml0aWFsaXplIHRoZSBtYXAgb24gdGhlIFwibWFwXCIgZGl2IHdpdGggYSBnaXZlbiBjZW50ZXIgYW5kIHpvb21cclxuICAgKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcsIHtcclxuICAgKiBcdGNlbnRlcjogWzUxLjUwNSwgLTAuMDldLFxyXG4gICAqIFx0em9vbTogMTNcclxuICAgKiB9KTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqL1xyXG5cclxuICB2YXIgTWFwID0gRXZlbnRlZC5leHRlbmQoe1xyXG5cclxuICBcdG9wdGlvbnM6IHtcclxuICBcdFx0Ly8gQHNlY3Rpb24gTWFwIFN0YXRlIE9wdGlvbnNcclxuICBcdFx0Ly8gQG9wdGlvbiBjcnM6IENSUyA9IEwuQ1JTLkVQU0czODU3XHJcbiAgXHRcdC8vIFRoZSBbQ29vcmRpbmF0ZSBSZWZlcmVuY2UgU3lzdGVtXSgjY3JzKSB0byB1c2UuIERvbid0IGNoYW5nZSB0aGlzIGlmIHlvdSdyZSBub3RcclxuICBcdFx0Ly8gc3VyZSB3aGF0IGl0IG1lYW5zLlxyXG4gIFx0XHRjcnM6IEVQU0czODU3LFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBjZW50ZXI6IExhdExuZyA9IHVuZGVmaW5lZFxyXG4gIFx0XHQvLyBJbml0aWFsIGdlb2dyYXBoaWMgY2VudGVyIG9mIHRoZSBtYXBcclxuICBcdFx0Y2VudGVyOiB1bmRlZmluZWQsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHpvb206IE51bWJlciA9IHVuZGVmaW5lZFxyXG4gIFx0XHQvLyBJbml0aWFsIG1hcCB6b29tIGxldmVsXHJcbiAgXHRcdHpvb206IHVuZGVmaW5lZCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gbWluWm9vbTogTnVtYmVyID0gKlxyXG4gIFx0XHQvLyBNaW5pbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcC5cclxuICBcdFx0Ly8gSWYgbm90IHNwZWNpZmllZCBhbmQgYXQgbGVhc3Qgb25lIGBHcmlkTGF5ZXJgIG9yIGBUaWxlTGF5ZXJgIGlzIGluIHRoZSBtYXAsXHJcbiAgXHRcdC8vIHRoZSBsb3dlc3Qgb2YgdGhlaXIgYG1pblpvb21gIG9wdGlvbnMgd2lsbCBiZSB1c2VkIGluc3RlYWQuXHJcbiAgXHRcdG1pblpvb206IHVuZGVmaW5lZCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gbWF4Wm9vbTogTnVtYmVyID0gKlxyXG4gIFx0XHQvLyBNYXhpbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcC5cclxuICBcdFx0Ly8gSWYgbm90IHNwZWNpZmllZCBhbmQgYXQgbGVhc3Qgb25lIGBHcmlkTGF5ZXJgIG9yIGBUaWxlTGF5ZXJgIGlzIGluIHRoZSBtYXAsXHJcbiAgXHRcdC8vIHRoZSBoaWdoZXN0IG9mIHRoZWlyIGBtYXhab29tYCBvcHRpb25zIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxyXG4gIFx0XHRtYXhab29tOiB1bmRlZmluZWQsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGxheWVyczogTGF5ZXJbXSA9IFtdXHJcbiAgXHRcdC8vIEFycmF5IG9mIGxheWVycyB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIG1hcCBpbml0aWFsbHlcclxuICBcdFx0bGF5ZXJzOiBbXSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gbWF4Qm91bmRzOiBMYXRMbmdCb3VuZHMgPSBudWxsXHJcbiAgXHRcdC8vIFdoZW4gdGhpcyBvcHRpb24gaXMgc2V0LCB0aGUgbWFwIHJlc3RyaWN0cyB0aGUgdmlldyB0byB0aGUgZ2l2ZW5cclxuICBcdFx0Ly8gZ2VvZ3JhcGhpY2FsIGJvdW5kcywgYm91bmNpbmcgdGhlIHVzZXIgYmFjayBpZiB0aGUgdXNlciB0cmllcyB0byBwYW5cclxuICBcdFx0Ly8gb3V0c2lkZSB0aGUgdmlldy4gVG8gc2V0IHRoZSByZXN0cmljdGlvbiBkeW5hbWljYWxseSwgdXNlXHJcbiAgXHRcdC8vIFtgc2V0TWF4Qm91bmRzYF0oI21hcC1zZXRtYXhib3VuZHMpIG1ldGhvZC5cclxuICBcdFx0bWF4Qm91bmRzOiB1bmRlZmluZWQsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHJlbmRlcmVyOiBSZW5kZXJlciA9ICpcclxuICBcdFx0Ly8gVGhlIGRlZmF1bHQgbWV0aG9kIGZvciBkcmF3aW5nIHZlY3RvciBsYXllcnMgb24gdGhlIG1hcC4gYEwuU1ZHYFxyXG4gIFx0XHQvLyBvciBgTC5DYW52YXNgIGJ5IGRlZmF1bHQgZGVwZW5kaW5nIG9uIGJyb3dzZXIgc3VwcG9ydC5cclxuICBcdFx0cmVuZGVyZXI6IHVuZGVmaW5lZCxcclxuXHJcblxyXG4gIFx0XHQvLyBAc2VjdGlvbiBBbmltYXRpb24gT3B0aW9uc1xyXG4gIFx0XHQvLyBAb3B0aW9uIHpvb21BbmltYXRpb246IEJvb2xlYW4gPSB0cnVlXHJcbiAgXHRcdC8vIFdoZXRoZXIgdGhlIG1hcCB6b29tIGFuaW1hdGlvbiBpcyBlbmFibGVkLiBCeSBkZWZhdWx0IGl0J3MgZW5hYmxlZFxyXG4gIFx0XHQvLyBpbiBhbGwgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IENTUzMgVHJhbnNpdGlvbnMgZXhjZXB0IEFuZHJvaWQuXHJcbiAgXHRcdHpvb21BbmltYXRpb246IHRydWUsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHpvb21BbmltYXRpb25UaHJlc2hvbGQ6IE51bWJlciA9IDRcclxuICBcdFx0Ly8gV29uJ3QgYW5pbWF0ZSB6b29tIGlmIHRoZSB6b29tIGRpZmZlcmVuY2UgZXhjZWVkcyB0aGlzIHZhbHVlLlxyXG4gIFx0XHR6b29tQW5pbWF0aW9uVGhyZXNob2xkOiA0LFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBmYWRlQW5pbWF0aW9uOiBCb29sZWFuID0gdHJ1ZVxyXG4gIFx0XHQvLyBXaGV0aGVyIHRoZSB0aWxlIGZhZGUgYW5pbWF0aW9uIGlzIGVuYWJsZWQuIEJ5IGRlZmF1bHQgaXQncyBlbmFibGVkXHJcbiAgXHRcdC8vIGluIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucyBleGNlcHQgQW5kcm9pZC5cclxuICBcdFx0ZmFkZUFuaW1hdGlvbjogdHJ1ZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gbWFya2VyWm9vbUFuaW1hdGlvbjogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gV2hldGhlciBtYXJrZXJzIGFuaW1hdGUgdGhlaXIgem9vbSB3aXRoIHRoZSB6b29tIGFuaW1hdGlvbiwgaWYgZGlzYWJsZWRcclxuICBcdFx0Ly8gdGhleSB3aWxsIGRpc2FwcGVhciBmb3IgdGhlIGxlbmd0aCBvZiB0aGUgYW5pbWF0aW9uLiBCeSBkZWZhdWx0IGl0J3NcclxuICBcdFx0Ly8gZW5hYmxlZCBpbiBhbGwgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IENTUzMgVHJhbnNpdGlvbnMgZXhjZXB0IEFuZHJvaWQuXHJcbiAgXHRcdG1hcmtlclpvb21BbmltYXRpb246IHRydWUsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHRyYW5zZm9ybTNETGltaXQ6IE51bWJlciA9IDJeMjNcclxuICBcdFx0Ly8gRGVmaW5lcyB0aGUgbWF4aW11bSBzaXplIG9mIGEgQ1NTIHRyYW5zbGF0aW9uIHRyYW5zZm9ybS4gVGhlIGRlZmF1bHRcclxuICBcdFx0Ly8gdmFsdWUgc2hvdWxkIG5vdCBiZSBjaGFuZ2VkIHVubGVzcyBhIHdlYiBicm93c2VyIHBvc2l0aW9ucyBsYXllcnMgaW5cclxuICBcdFx0Ly8gdGhlIHdyb25nIHBsYWNlIGFmdGVyIGRvaW5nIGEgbGFyZ2UgYHBhbkJ5YC5cclxuICBcdFx0dHJhbnNmb3JtM0RMaW1pdDogODM4ODYwOCwgLy8gUHJlY2lzaW9uIGxpbWl0IG9mIGEgMzItYml0IGZsb2F0XHJcblxyXG4gIFx0XHQvLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXHJcbiAgXHRcdC8vIEBvcHRpb24gem9vbVNuYXA6IE51bWJlciA9IDFcclxuICBcdFx0Ly8gRm9yY2VzIHRoZSBtYXAncyB6b29tIGxldmVsIHRvIGFsd2F5cyBiZSBhIG11bHRpcGxlIG9mIHRoaXMsIHBhcnRpY3VsYXJseVxyXG4gIFx0XHQvLyByaWdodCBhZnRlciBhIFtgZml0Qm91bmRzKClgXSgjbWFwLWZpdGJvdW5kcykgb3IgYSBwaW5jaC16b29tLlxyXG4gIFx0XHQvLyBCeSBkZWZhdWx0LCB0aGUgem9vbSBsZXZlbCBzbmFwcyB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyOyBsb3dlciB2YWx1ZXNcclxuICBcdFx0Ly8gKGUuZy4gYDAuNWAgb3IgYDAuMWApIGFsbG93IGZvciBncmVhdGVyIGdyYW51bGFyaXR5LiBBIHZhbHVlIG9mIGAwYFxyXG4gIFx0XHQvLyBtZWFucyB0aGUgem9vbSBsZXZlbCB3aWxsIG5vdCBiZSBzbmFwcGVkIGFmdGVyIGBmaXRCb3VuZHNgIG9yIGEgcGluY2gtem9vbS5cclxuICBcdFx0em9vbVNuYXA6IDEsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHpvb21EZWx0YTogTnVtYmVyID0gMVxyXG4gIFx0XHQvLyBDb250cm9scyBob3cgbXVjaCB0aGUgbWFwJ3Mgem9vbSBsZXZlbCB3aWxsIGNoYW5nZSBhZnRlciBhXHJcbiAgXHRcdC8vIFtgem9vbUluKClgXSgjbWFwLXpvb21pbiksIFtgem9vbU91dCgpYF0oI21hcC16b29tb3V0KSwgcHJlc3NpbmcgYCtgXHJcbiAgXHRcdC8vIG9yIGAtYCBvbiB0aGUga2V5Ym9hcmQsIG9yIHVzaW5nIHRoZSBbem9vbSBjb250cm9sc10oI2NvbnRyb2wtem9vbSkuXHJcbiAgXHRcdC8vIFZhbHVlcyBzbWFsbGVyIHRoYW4gYDFgIChlLmcuIGAwLjVgKSBhbGxvdyBmb3IgZ3JlYXRlciBncmFudWxhcml0eS5cclxuICBcdFx0em9vbURlbHRhOiAxLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiB0cmFja1Jlc2l6ZTogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gV2hldGhlciB0aGUgbWFwIGF1dG9tYXRpY2FsbHkgaGFuZGxlcyBicm93c2VyIHdpbmRvdyByZXNpemUgdG8gdXBkYXRlIGl0c2VsZi5cclxuICBcdFx0dHJhY2tSZXNpemU6IHRydWVcclxuICBcdH0sXHJcblxyXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGlkLCBvcHRpb25zKSB7IC8vIChIVE1MRWxlbWVudCBvciBTdHJpbmcsIE9iamVjdClcclxuICBcdFx0b3B0aW9ucyA9IHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG4gIFx0XHQvLyBNYWtlIHN1cmUgdG8gYXNzaWduIGludGVybmFsIGZsYWdzIGF0IHRoZSBiZWdpbm5pbmcsXHJcbiAgXHRcdC8vIHRvIGF2b2lkIGluY29uc2lzdGVudCBzdGF0ZSBpbiBzb21lIGVkZ2UgY2FzZXMuXHJcbiAgXHRcdHRoaXMuX2hhbmRsZXJzID0gW107XHJcbiAgXHRcdHRoaXMuX2xheWVycyA9IHt9O1xyXG4gIFx0XHR0aGlzLl96b29tQm91bmRMYXllcnMgPSB7fTtcclxuICBcdFx0dGhpcy5fc2l6ZUNoYW5nZWQgPSB0cnVlO1xyXG5cclxuICBcdFx0dGhpcy5faW5pdENvbnRhaW5lcihpZCk7XHJcbiAgXHRcdHRoaXMuX2luaXRMYXlvdXQoKTtcclxuXHJcbiAgXHRcdC8vIGhhY2sgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzE5ODBcclxuICBcdFx0dGhpcy5fb25SZXNpemUgPSBiaW5kKHRoaXMuX29uUmVzaXplLCB0aGlzKTtcclxuXHJcbiAgXHRcdHRoaXMuX2luaXRFdmVudHMoKTtcclxuXHJcbiAgXHRcdGlmIChvcHRpb25zLm1heEJvdW5kcykge1xyXG4gIFx0XHRcdHRoaXMuc2V0TWF4Qm91bmRzKG9wdGlvbnMubWF4Qm91bmRzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKG9wdGlvbnMuem9vbSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgXHRcdFx0dGhpcy5fem9vbSA9IHRoaXMuX2xpbWl0Wm9vbShvcHRpb25zLnpvb20pO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAob3B0aW9ucy5jZW50ZXIgJiYgb3B0aW9ucy56b29tICE9PSB1bmRlZmluZWQpIHtcclxuICBcdFx0XHR0aGlzLnNldFZpZXcodG9MYXRMbmcob3B0aW9ucy5jZW50ZXIpLCBvcHRpb25zLnpvb20sIHtyZXNldDogdHJ1ZX0pO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLmNhbGxJbml0SG9va3MoKTtcclxuXHJcbiAgXHRcdC8vIGRvbid0IGFuaW1hdGUgb24gYnJvd3NlcnMgd2l0aG91dCBoYXJkd2FyZS1hY2NlbGVyYXRlZCB0cmFuc2l0aW9ucyBvciBvbGQgQW5kcm9pZC9PcGVyYVxyXG4gIFx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSBUUkFOU0lUSU9OICYmIEJyb3dzZXIuYW55M2QgJiYgIUJyb3dzZXIubW9iaWxlT3BlcmEgJiZcclxuICBcdFx0XHRcdHRoaXMub3B0aW9ucy56b29tQW5pbWF0aW9uO1xyXG5cclxuICBcdFx0Ly8gem9vbSB0cmFuc2l0aW9ucyBydW4gd2l0aCB0aGUgc2FtZSBkdXJhdGlvbiBmb3IgYWxsIGxheWVycywgc28gaWYgb25lIG9mIHRyYW5zaXRpb25lbmQgZXZlbnRzXHJcbiAgXHRcdC8vIGhhcHBlbnMgYWZ0ZXIgc3RhcnRpbmcgem9vbSBhbmltYXRpb24gKHByb3BhZ2F0aW5nIHRvIHRoZSBtYXAgcGFuZSksIHdlIGtub3cgdGhhdCBpdCBlbmRlZCBnbG9iYWxseVxyXG4gIFx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcbiAgXHRcdFx0dGhpcy5fY3JlYXRlQW5pbVByb3h5KCk7XHJcbiAgXHRcdFx0b24odGhpcy5fcHJveHksIFRSQU5TSVRJT05fRU5ELCB0aGlzLl9jYXRjaFRyYW5zaXRpb25FbmQsIHRoaXMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9hZGRMYXllcnModGhpcy5vcHRpb25zLmxheWVycyk7XHJcbiAgXHR9LFxyXG5cclxuXHJcbiAgXHQvLyBAc2VjdGlvbiBNZXRob2RzIGZvciBtb2RpZnlpbmcgbWFwIHN0YXRlXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRWaWV3KGNlbnRlcjogTGF0TG5nLCB6b29tOiBOdW1iZXIsIG9wdGlvbnM/OiBab29tL3BhbiBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gU2V0cyB0aGUgdmlldyBvZiB0aGUgbWFwIChnZW9ncmFwaGljYWwgY2VudGVyIGFuZCB6b29tKSB3aXRoIHRoZSBnaXZlblxyXG4gIFx0Ly8gYW5pbWF0aW9uIG9wdGlvbnMuXHJcbiAgXHRzZXRWaWV3OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBvcHRpb25zKSB7XHJcblxyXG4gIFx0XHR6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IHRoaXMuX2xpbWl0Wm9vbSh6b29tKTtcclxuICBcdFx0Y2VudGVyID0gdGhpcy5fbGltaXRDZW50ZXIodG9MYXRMbmcoY2VudGVyKSwgem9vbSwgdGhpcy5vcHRpb25zLm1heEJvdW5kcyk7XHJcbiAgXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICBcdFx0dGhpcy5fc3RvcCgpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2xvYWRlZCAmJiAhb3B0aW9ucy5yZXNldCAmJiBvcHRpb25zICE9PSB0cnVlKSB7XHJcblxyXG4gIFx0XHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IHVuZGVmaW5lZCkge1xyXG4gIFx0XHRcdFx0b3B0aW9ucy56b29tID0gZXh0ZW5kKHthbmltYXRlOiBvcHRpb25zLmFuaW1hdGV9LCBvcHRpb25zLnpvb20pO1xyXG4gIFx0XHRcdFx0b3B0aW9ucy5wYW4gPSBleHRlbmQoe2FuaW1hdGU6IG9wdGlvbnMuYW5pbWF0ZSwgZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb259LCBvcHRpb25zLnBhbik7XHJcbiAgXHRcdFx0fVxyXG5cclxuICBcdFx0XHQvLyB0cnkgYW5pbWF0aW5nIHBhbiBvciB6b29tXHJcbiAgXHRcdFx0dmFyIG1vdmVkID0gKHRoaXMuX3pvb20gIT09IHpvb20pID9cclxuICBcdFx0XHRcdHRoaXMuX3RyeUFuaW1hdGVkWm9vbSAmJiB0aGlzLl90cnlBbmltYXRlZFpvb20oY2VudGVyLCB6b29tLCBvcHRpb25zLnpvb20pIDpcclxuICBcdFx0XHRcdHRoaXMuX3RyeUFuaW1hdGVkUGFuKGNlbnRlciwgb3B0aW9ucy5wYW4pO1xyXG5cclxuICBcdFx0XHRpZiAobW92ZWQpIHtcclxuICBcdFx0XHRcdC8vIHByZXZlbnQgcmVzaXplIGhhbmRsZXIgY2FsbCwgdGhlIHZpZXcgd2lsbCByZWZyZXNoIGFmdGVyIGFuaW1hdGlvbiBhbnl3YXlcclxuICBcdFx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9zaXplVGltZXIpO1xyXG4gIFx0XHRcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBhbmltYXRpb24gZGlkbid0IHN0YXJ0LCBqdXN0IHJlc2V0IHRoZSBtYXAgdmlld1xyXG4gIFx0XHR0aGlzLl9yZXNldFZpZXcoY2VudGVyLCB6b29tLCBvcHRpb25zLnBhbiAmJiBvcHRpb25zLnBhbi5ub01vdmVTdGFydCk7XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRab29tKHpvb206IE51bWJlciwgb3B0aW9ucz86IFpvb20vcGFuIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBTZXRzIHRoZSB6b29tIG9mIHRoZSBtYXAuXHJcbiAgXHRzZXRab29tOiBmdW5jdGlvbiAoem9vbSwgb3B0aW9ucykge1xyXG4gIFx0XHRpZiAoIXRoaXMuX2xvYWRlZCkge1xyXG4gIFx0XHRcdHRoaXMuX3pvb20gPSB6b29tO1xyXG4gIFx0XHRcdHJldHVybiB0aGlzO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzLnNldFZpZXcodGhpcy5nZXRDZW50ZXIoKSwgem9vbSwge3pvb206IG9wdGlvbnN9KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB6b29tSW4oZGVsdGE/OiBOdW1iZXIsIG9wdGlvbnM/OiBab29tIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBJbmNyZWFzZXMgdGhlIHpvb20gb2YgdGhlIG1hcCBieSBgZGVsdGFgIChbYHpvb21EZWx0YWBdKCNtYXAtem9vbWRlbHRhKSBieSBkZWZhdWx0KS5cclxuICBcdHpvb21JbjogZnVuY3Rpb24gKGRlbHRhLCBvcHRpb25zKSB7XHJcbiAgXHRcdGRlbHRhID0gZGVsdGEgfHwgKEJyb3dzZXIuYW55M2QgPyB0aGlzLm9wdGlvbnMuem9vbURlbHRhIDogMSk7XHJcbiAgXHRcdHJldHVybiB0aGlzLnNldFpvb20odGhpcy5fem9vbSArIGRlbHRhLCBvcHRpb25zKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB6b29tT3V0KGRlbHRhPzogTnVtYmVyLCBvcHRpb25zPzogWm9vbSBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gRGVjcmVhc2VzIHRoZSB6b29tIG9mIHRoZSBtYXAgYnkgYGRlbHRhYCAoW2B6b29tRGVsdGFgXSgjbWFwLXpvb21kZWx0YSkgYnkgZGVmYXVsdCkuXHJcbiAgXHR6b29tT3V0OiBmdW5jdGlvbiAoZGVsdGEsIG9wdGlvbnMpIHtcclxuICBcdFx0ZGVsdGEgPSBkZWx0YSB8fCAoQnJvd3Nlci5hbnkzZCA/IHRoaXMub3B0aW9ucy56b29tRGVsdGEgOiAxKTtcclxuICBcdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh0aGlzLl96b29tIC0gZGVsdGEsIG9wdGlvbnMpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldFpvb21Bcm91bmQobGF0bG5nOiBMYXRMbmcsIHpvb206IE51bWJlciwgb3B0aW9uczogWm9vbSBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gWm9vbXMgdGhlIG1hcCB3aGlsZSBrZWVwaW5nIGEgc3BlY2lmaWVkIGdlb2dyYXBoaWNhbCBwb2ludCBvbiB0aGUgbWFwXHJcbiAgXHQvLyBzdGF0aW9uYXJ5IChlLmcuIHVzZWQgaW50ZXJuYWxseSBmb3Igc2Nyb2xsIHpvb20gYW5kIGRvdWJsZS1jbGljayB6b29tKS5cclxuICBcdC8vIEBhbHRlcm5hdGl2ZVxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRab29tQXJvdW5kKG9mZnNldDogUG9pbnQsIHpvb206IE51bWJlciwgb3B0aW9uczogWm9vbSBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gWm9vbXMgdGhlIG1hcCB3aGlsZSBrZWVwaW5nIGEgc3BlY2lmaWVkIHBpeGVsIG9uIHRoZSBtYXAgKHJlbGF0aXZlIHRvIHRoZSB0b3AtbGVmdCBjb3JuZXIpIHN0YXRpb25hcnkuXHJcbiAgXHRzZXRab29tQXJvdW5kOiBmdW5jdGlvbiAobGF0bG5nLCB6b29tLCBvcHRpb25zKSB7XHJcbiAgXHRcdHZhciBzY2FsZSA9IHRoaXMuZ2V0Wm9vbVNjYWxlKHpvb20pLFxyXG4gIFx0XHQgICAgdmlld0hhbGYgPSB0aGlzLmdldFNpemUoKS5kaXZpZGVCeSgyKSxcclxuICBcdFx0ICAgIGNvbnRhaW5lclBvaW50ID0gbGF0bG5nIGluc3RhbmNlb2YgUG9pbnQgPyBsYXRsbmcgOiB0aGlzLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQobGF0bG5nKSxcclxuXHJcbiAgXHRcdCAgICBjZW50ZXJPZmZzZXQgPSBjb250YWluZXJQb2ludC5zdWJ0cmFjdCh2aWV3SGFsZikubXVsdGlwbHlCeSgxIC0gMSAvIHNjYWxlKSxcclxuICBcdFx0ICAgIG5ld0NlbnRlciA9IHRoaXMuY29udGFpbmVyUG9pbnRUb0xhdExuZyh2aWV3SGFsZi5hZGQoY2VudGVyT2Zmc2V0KSk7XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KG5ld0NlbnRlciwgem9vbSwge3pvb206IG9wdGlvbnN9KTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2dldEJvdW5kc0NlbnRlclpvb206IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuXHJcbiAgXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gIFx0XHRib3VuZHMgPSBib3VuZHMuZ2V0Qm91bmRzID8gYm91bmRzLmdldEJvdW5kcygpIDogdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcbiAgXHRcdHZhciBwYWRkaW5nVEwgPSB0b1BvaW50KG9wdGlvbnMucGFkZGluZ1RvcExlZnQgfHwgb3B0aW9ucy5wYWRkaW5nIHx8IFswLCAwXSksXHJcbiAgXHRcdCAgICBwYWRkaW5nQlIgPSB0b1BvaW50KG9wdGlvbnMucGFkZGluZ0JvdHRvbVJpZ2h0IHx8IG9wdGlvbnMucGFkZGluZyB8fCBbMCwgMF0pLFxyXG5cclxuICBcdFx0ICAgIHpvb20gPSB0aGlzLmdldEJvdW5kc1pvb20oYm91bmRzLCBmYWxzZSwgcGFkZGluZ1RMLmFkZChwYWRkaW5nQlIpKTtcclxuXHJcbiAgXHRcdHpvb20gPSAodHlwZW9mIG9wdGlvbnMubWF4Wm9vbSA9PT0gJ251bWJlcicpID8gTWF0aC5taW4ob3B0aW9ucy5tYXhab29tLCB6b29tKSA6IHpvb207XHJcblxyXG4gIFx0XHRpZiAoem9vbSA9PT0gSW5maW5pdHkpIHtcclxuICBcdFx0XHRyZXR1cm4ge1xyXG4gIFx0XHRcdFx0Y2VudGVyOiBib3VuZHMuZ2V0Q2VudGVyKCksXHJcbiAgXHRcdFx0XHR6b29tOiB6b29tXHJcbiAgXHRcdFx0fTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIHBhZGRpbmdPZmZzZXQgPSBwYWRkaW5nQlIuc3VidHJhY3QocGFkZGluZ1RMKS5kaXZpZGVCeSgyKSxcclxuXHJcbiAgXHRcdCAgICBzd1BvaW50ID0gdGhpcy5wcm9qZWN0KGJvdW5kcy5nZXRTb3V0aFdlc3QoKSwgem9vbSksXHJcbiAgXHRcdCAgICBuZVBvaW50ID0gdGhpcy5wcm9qZWN0KGJvdW5kcy5nZXROb3J0aEVhc3QoKSwgem9vbSksXHJcbiAgXHRcdCAgICBjZW50ZXIgPSB0aGlzLnVucHJvamVjdChzd1BvaW50LmFkZChuZVBvaW50KS5kaXZpZGVCeSgyKS5hZGQocGFkZGluZ09mZnNldCksIHpvb20pO1xyXG5cclxuICBcdFx0cmV0dXJuIHtcclxuICBcdFx0XHRjZW50ZXI6IGNlbnRlcixcclxuICBcdFx0XHR6b29tOiB6b29tXHJcbiAgXHRcdH07XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZml0Qm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogZml0Qm91bmRzIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBTZXRzIGEgbWFwIHZpZXcgdGhhdCBjb250YWlucyB0aGUgZ2l2ZW4gZ2VvZ3JhcGhpY2FsIGJvdW5kcyB3aXRoIHRoZVxyXG4gIFx0Ly8gbWF4aW11bSB6b29tIGxldmVsIHBvc3NpYmxlLlxyXG4gIFx0Zml0Qm91bmRzOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcblxyXG4gIFx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuICBcdFx0aWYgKCFib3VuZHMuaXNWYWxpZCgpKSB7XHJcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdCb3VuZHMgYXJlIG5vdCB2YWxpZC4nKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIHRhcmdldCA9IHRoaXMuX2dldEJvdW5kc0NlbnRlclpvb20oYm91bmRzLCBvcHRpb25zKTtcclxuICBcdFx0cmV0dXJuIHRoaXMuc2V0Vmlldyh0YXJnZXQuY2VudGVyLCB0YXJnZXQuem9vbSwgb3B0aW9ucyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZml0V29ybGQob3B0aW9ucz86IGZpdEJvdW5kcyBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gU2V0cyBhIG1hcCB2aWV3IHRoYXQgbW9zdGx5IGNvbnRhaW5zIHRoZSB3aG9sZSB3b3JsZCB3aXRoIHRoZSBtYXhpbXVtXHJcbiAgXHQvLyB6b29tIGxldmVsIHBvc3NpYmxlLlxyXG4gIFx0Zml0V29ybGQ6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmZpdEJvdW5kcyhbWy05MCwgLTE4MF0sIFs5MCwgMTgwXV0sIG9wdGlvbnMpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHBhblRvKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogUGFuIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBQYW5zIHRoZSBtYXAgdG8gYSBnaXZlbiBjZW50ZXIuXHJcbiAgXHRwYW5UbzogZnVuY3Rpb24gKGNlbnRlciwgb3B0aW9ucykgeyAvLyAoTGF0TG5nKVxyXG4gIFx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KGNlbnRlciwgdGhpcy5fem9vbSwge3Bhbjogb3B0aW9uc30pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHBhbkJ5KG9mZnNldDogUG9pbnQsIG9wdGlvbnM/OiBQYW4gb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIFBhbnMgdGhlIG1hcCBieSBhIGdpdmVuIG51bWJlciBvZiBwaXhlbHMgKGFuaW1hdGVkKS5cclxuICBcdHBhbkJ5OiBmdW5jdGlvbiAob2Zmc2V0LCBvcHRpb25zKSB7XHJcbiAgXHRcdG9mZnNldCA9IHRvUG9pbnQob2Zmc2V0KS5yb3VuZCgpO1xyXG4gIFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgXHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7XHJcbiAgXHRcdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdC8vIElmIHdlIHBhbiB0b28gZmFyLCBDaHJvbWUgZ2V0cyBpc3N1ZXMgd2l0aCB0aWxlc1xyXG4gIFx0XHQvLyBhbmQgbWFrZXMgdGhlbSBkaXNhcHBlYXIgb3IgYXBwZWFyIGluIHRoZSB3cm9uZyBwbGFjZSAoc2xpZ2h0bHkgb2Zmc2V0KSAjMjYwMlxyXG4gIFx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSB0cnVlICYmICF0aGlzLmdldFNpemUoKS5jb250YWlucyhvZmZzZXQpKSB7XHJcbiAgXHRcdFx0dGhpcy5fcmVzZXRWaWV3KHRoaXMudW5wcm9qZWN0KHRoaXMucHJvamVjdCh0aGlzLmdldENlbnRlcigpKS5hZGQob2Zmc2V0KSksIHRoaXMuZ2V0Wm9vbSgpKTtcclxuICBcdFx0XHRyZXR1cm4gdGhpcztcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKCF0aGlzLl9wYW5BbmltKSB7XHJcbiAgXHRcdFx0dGhpcy5fcGFuQW5pbSA9IG5ldyBQb3NBbmltYXRpb24oKTtcclxuXHJcbiAgXHRcdFx0dGhpcy5fcGFuQW5pbS5vbih7XHJcbiAgXHRcdFx0XHQnc3RlcCc6IHRoaXMuX29uUGFuVHJhbnNpdGlvblN0ZXAsXHJcbiAgXHRcdFx0XHQnZW5kJzogdGhpcy5fb25QYW5UcmFuc2l0aW9uRW5kXHJcbiAgXHRcdFx0fSwgdGhpcyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIGRvbid0IGZpcmUgbW92ZXN0YXJ0IGlmIGFuaW1hdGluZyBpbmVydGlhXHJcbiAgXHRcdGlmICghb3B0aW9ucy5ub01vdmVTdGFydCkge1xyXG4gIFx0XHRcdHRoaXMuZmlyZSgnbW92ZXN0YXJ0Jyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIGFuaW1hdGUgcGFuIHVubGVzcyBhbmltYXRlOiBmYWxzZSBzcGVjaWZpZWRcclxuICBcdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gZmFsc2UpIHtcclxuICBcdFx0XHRhZGRDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC1wYW4tYW5pbScpO1xyXG5cclxuICBcdFx0XHR2YXIgbmV3UG9zID0gdGhpcy5fZ2V0TWFwUGFuZVBvcygpLnN1YnRyYWN0KG9mZnNldCkucm91bmQoKTtcclxuICBcdFx0XHR0aGlzLl9wYW5BbmltLnJ1bih0aGlzLl9tYXBQYW5lLCBuZXdQb3MsIG9wdGlvbnMuZHVyYXRpb24gfHwgMC4yNSwgb3B0aW9ucy5lYXNlTGluZWFyaXR5KTtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHR0aGlzLl9yYXdQYW5CeShvZmZzZXQpO1xyXG4gIFx0XHRcdHRoaXMuZmlyZSgnbW92ZScpLmZpcmUoJ21vdmVlbmQnKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZmx5VG8obGF0bG5nOiBMYXRMbmcsIHpvb20/OiBOdW1iZXIsIG9wdGlvbnM/OiBab29tL3BhbiBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gU2V0cyB0aGUgdmlldyBvZiB0aGUgbWFwIChnZW9ncmFwaGljYWwgY2VudGVyIGFuZCB6b29tKSBwZXJmb3JtaW5nIGEgc21vb3RoXHJcbiAgXHQvLyBwYW4tem9vbSBhbmltYXRpb24uXHJcbiAgXHRmbHlUbzogZnVuY3Rpb24gKHRhcmdldENlbnRlciwgdGFyZ2V0Wm9vbSwgb3B0aW9ucykge1xyXG5cclxuICBcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgPT09IGZhbHNlIHx8ICFCcm93c2VyLmFueTNkKSB7XHJcbiAgXHRcdFx0cmV0dXJuIHRoaXMuc2V0Vmlldyh0YXJnZXRDZW50ZXIsIHRhcmdldFpvb20sIG9wdGlvbnMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9zdG9wKCk7XHJcblxyXG4gIFx0XHR2YXIgZnJvbSA9IHRoaXMucHJvamVjdCh0aGlzLmdldENlbnRlcigpKSxcclxuICBcdFx0ICAgIHRvID0gdGhpcy5wcm9qZWN0KHRhcmdldENlbnRlciksXHJcbiAgXHRcdCAgICBzaXplID0gdGhpcy5nZXRTaXplKCksXHJcbiAgXHRcdCAgICBzdGFydFpvb20gPSB0aGlzLl96b29tO1xyXG5cclxuICBcdFx0dGFyZ2V0Q2VudGVyID0gdG9MYXRMbmcodGFyZ2V0Q2VudGVyKTtcclxuICBcdFx0dGFyZ2V0Wm9vbSA9IHRhcmdldFpvb20gPT09IHVuZGVmaW5lZCA/IHN0YXJ0Wm9vbSA6IHRhcmdldFpvb207XHJcblxyXG4gIFx0XHR2YXIgdzAgPSBNYXRoLm1heChzaXplLngsIHNpemUueSksXHJcbiAgXHRcdCAgICB3MSA9IHcwICogdGhpcy5nZXRab29tU2NhbGUoc3RhcnRab29tLCB0YXJnZXRab29tKSxcclxuICBcdFx0ICAgIHUxID0gKHRvLmRpc3RhbmNlVG8oZnJvbSkpIHx8IDEsXHJcbiAgXHRcdCAgICByaG8gPSAxLjQyLFxyXG4gIFx0XHQgICAgcmhvMiA9IHJobyAqIHJobztcclxuXHJcbiAgXHRcdGZ1bmN0aW9uIHIoaSkge1xyXG4gIFx0XHRcdHZhciBzMSA9IGkgPyAtMSA6IDEsXHJcbiAgXHRcdFx0ICAgIHMyID0gaSA/IHcxIDogdzAsXHJcbiAgXHRcdFx0ICAgIHQxID0gdzEgKiB3MSAtIHcwICogdzAgKyBzMSAqIHJobzIgKiByaG8yICogdTEgKiB1MSxcclxuICBcdFx0XHQgICAgYjEgPSAyICogczIgKiByaG8yICogdTEsXHJcbiAgXHRcdFx0ICAgIGIgPSB0MSAvIGIxLFxyXG4gIFx0XHRcdCAgICBzcSA9IE1hdGguc3FydChiICogYiArIDEpIC0gYjtcclxuXHJcbiAgXHRcdFx0ICAgIC8vIHdvcmthcm91bmQgZm9yIGZsb2F0aW5nIHBvaW50IHByZWNpc2lvbiBidWcgd2hlbiBzcSA9IDAsIGxvZyA9IC1JbmZpbml0ZSxcclxuICBcdFx0XHQgICAgLy8gdGh1cyB0cmlnZ2VyaW5nIGFuIGluZmluaXRlIGxvb3AgaW4gZmx5VG9cclxuICBcdFx0XHQgICAgdmFyIGxvZyA9IHNxIDwgMC4wMDAwMDAwMDEgPyAtMTggOiBNYXRoLmxvZyhzcSk7XHJcblxyXG4gIFx0XHRcdHJldHVybiBsb2c7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGZ1bmN0aW9uIHNpbmgobikgeyByZXR1cm4gKE1hdGguZXhwKG4pIC0gTWF0aC5leHAoLW4pKSAvIDI7IH1cclxuICBcdFx0ZnVuY3Rpb24gY29zaChuKSB7IHJldHVybiAoTWF0aC5leHAobikgKyBNYXRoLmV4cCgtbikpIC8gMjsgfVxyXG4gIFx0XHRmdW5jdGlvbiB0YW5oKG4pIHsgcmV0dXJuIHNpbmgobikgLyBjb3NoKG4pOyB9XHJcblxyXG4gIFx0XHR2YXIgcjAgPSByKDApO1xyXG5cclxuICBcdFx0ZnVuY3Rpb24gdyhzKSB7IHJldHVybiB3MCAqIChjb3NoKHIwKSAvIGNvc2gocjAgKyByaG8gKiBzKSk7IH1cclxuICBcdFx0ZnVuY3Rpb24gdShzKSB7IHJldHVybiB3MCAqIChjb3NoKHIwKSAqIHRhbmgocjAgKyByaG8gKiBzKSAtIHNpbmgocjApKSAvIHJobzI7IH1cclxuXHJcbiAgXHRcdGZ1bmN0aW9uIGVhc2VPdXQodCkgeyByZXR1cm4gMSAtIE1hdGgucG93KDEgLSB0LCAxLjUpOyB9XHJcblxyXG4gIFx0XHR2YXIgc3RhcnQgPSBEYXRlLm5vdygpLFxyXG4gIFx0XHQgICAgUyA9IChyKDEpIC0gcjApIC8gcmhvLFxyXG4gIFx0XHQgICAgZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uID8gMTAwMCAqIG9wdGlvbnMuZHVyYXRpb24gOiAxMDAwICogUyAqIDAuODtcclxuXHJcbiAgXHRcdGZ1bmN0aW9uIGZyYW1lKCkge1xyXG4gIFx0XHRcdHZhciB0ID0gKERhdGUubm93KCkgLSBzdGFydCkgLyBkdXJhdGlvbixcclxuICBcdFx0XHQgICAgcyA9IGVhc2VPdXQodCkgKiBTO1xyXG5cclxuICBcdFx0XHRpZiAodCA8PSAxKSB7XHJcbiAgXHRcdFx0XHR0aGlzLl9mbHlUb0ZyYW1lID0gcmVxdWVzdEFuaW1GcmFtZShmcmFtZSwgdGhpcyk7XHJcblxyXG4gIFx0XHRcdFx0dGhpcy5fbW92ZShcclxuICBcdFx0XHRcdFx0dGhpcy51bnByb2plY3QoZnJvbS5hZGQodG8uc3VidHJhY3QoZnJvbSkubXVsdGlwbHlCeSh1KHMpIC8gdTEpKSwgc3RhcnRab29tKSxcclxuICBcdFx0XHRcdFx0dGhpcy5nZXRTY2FsZVpvb20odzAgLyB3KHMpLCBzdGFydFpvb20pLFxyXG4gIFx0XHRcdFx0XHR7Zmx5VG86IHRydWV9KTtcclxuXHJcbiAgXHRcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRcdHRoaXNcclxuICBcdFx0XHRcdFx0Ll9tb3ZlKHRhcmdldENlbnRlciwgdGFyZ2V0Wm9vbSlcclxuICBcdFx0XHRcdFx0Ll9tb3ZlRW5kKHRydWUpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fbW92ZVN0YXJ0KHRydWUsIG9wdGlvbnMubm9Nb3ZlU3RhcnQpO1xyXG5cclxuICBcdFx0ZnJhbWUuY2FsbCh0aGlzKTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZmx5VG9Cb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBmaXRCb3VuZHMgb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIFNldHMgdGhlIHZpZXcgb2YgdGhlIG1hcCB3aXRoIGEgc21vb3RoIGFuaW1hdGlvbiBsaWtlIFtgZmx5VG9gXSgjbWFwLWZseXRvKSxcclxuICBcdC8vIGJ1dCB0YWtlcyBhIGJvdW5kcyBwYXJhbWV0ZXIgbGlrZSBbYGZpdEJvdW5kc2BdKCNtYXAtZml0Ym91bmRzKS5cclxuICBcdGZseVRvQm91bmRzOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcbiAgXHRcdHZhciB0YXJnZXQgPSB0aGlzLl9nZXRCb3VuZHNDZW50ZXJab29tKGJvdW5kcywgb3B0aW9ucyk7XHJcbiAgXHRcdHJldHVybiB0aGlzLmZseVRvKHRhcmdldC5jZW50ZXIsIHRhcmdldC56b29tLCBvcHRpb25zKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRNYXhCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMpOiB0aGlzXHJcbiAgXHQvLyBSZXN0cmljdHMgdGhlIG1hcCB2aWV3IHRvIHRoZSBnaXZlbiBib3VuZHMgKHNlZSB0aGUgW21heEJvdW5kc10oI21hcC1tYXhib3VuZHMpIG9wdGlvbikuXHJcbiAgXHRzZXRNYXhCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuICBcdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLmxpc3RlbnMoJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpKSB7XHJcbiAgXHRcdFx0dGhpcy5vZmYoJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAoIWJvdW5kcy5pc1ZhbGlkKCkpIHtcclxuICBcdFx0XHR0aGlzLm9wdGlvbnMubWF4Qm91bmRzID0gbnVsbDtcclxuICBcdFx0XHRyZXR1cm4gdGhpcztcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5vcHRpb25zLm1heEJvdW5kcyA9IGJvdW5kcztcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuICBcdFx0XHR0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMoKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXMub24oJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldE1pblpvb20oem9vbTogTnVtYmVyKTogdGhpc1xyXG4gIFx0Ly8gU2V0cyB0aGUgbG93ZXIgbGltaXQgZm9yIHRoZSBhdmFpbGFibGUgem9vbSBsZXZlbHMgKHNlZSB0aGUgW21pblpvb21dKCNtYXAtbWluem9vbSkgb3B0aW9uKS5cclxuICBcdHNldE1pblpvb206IGZ1bmN0aW9uICh6b29tKSB7XHJcbiAgXHRcdHZhciBvbGRab29tID0gdGhpcy5vcHRpb25zLm1pblpvb207XHJcbiAgXHRcdHRoaXMub3B0aW9ucy5taW5ab29tID0gem9vbTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9sb2FkZWQgJiYgb2xkWm9vbSAhPT0gem9vbSkge1xyXG4gIFx0XHRcdHRoaXMuZmlyZSgnem9vbWxldmVsc2NoYW5nZScpO1xyXG5cclxuICBcdFx0XHRpZiAodGhpcy5nZXRab29tKCkgPCB0aGlzLm9wdGlvbnMubWluWm9vbSkge1xyXG4gIFx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh6b29tKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldE1heFpvb20oem9vbTogTnVtYmVyKTogdGhpc1xyXG4gIFx0Ly8gU2V0cyB0aGUgdXBwZXIgbGltaXQgZm9yIHRoZSBhdmFpbGFibGUgem9vbSBsZXZlbHMgKHNlZSB0aGUgW21heFpvb21dKCNtYXAtbWF4em9vbSkgb3B0aW9uKS5cclxuICBcdHNldE1heFpvb206IGZ1bmN0aW9uICh6b29tKSB7XHJcbiAgXHRcdHZhciBvbGRab29tID0gdGhpcy5vcHRpb25zLm1heFpvb207XHJcbiAgXHRcdHRoaXMub3B0aW9ucy5tYXhab29tID0gem9vbTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9sb2FkZWQgJiYgb2xkWm9vbSAhPT0gem9vbSkge1xyXG4gIFx0XHRcdHRoaXMuZmlyZSgnem9vbWxldmVsc2NoYW5nZScpO1xyXG5cclxuICBcdFx0XHRpZiAodGhpcy5nZXRab29tKCkgPiB0aGlzLm9wdGlvbnMubWF4Wm9vbSkge1xyXG4gIFx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh6b29tKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHBhbkluc2lkZUJvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IFBhbiBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gUGFucyB0aGUgbWFwIHRvIHRoZSBjbG9zZXN0IHZpZXcgdGhhdCB3b3VsZCBsaWUgaW5zaWRlIHRoZSBnaXZlbiBib3VuZHMgKGlmIGl0J3Mgbm90IGFscmVhZHkpLCBjb250cm9sbGluZyB0aGUgYW5pbWF0aW9uIHVzaW5nIHRoZSBvcHRpb25zIHNwZWNpZmljLCBpZiBhbnkuXHJcbiAgXHRwYW5JbnNpZGVCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuICBcdFx0dGhpcy5fZW5mb3JjaW5nQm91bmRzID0gdHJ1ZTtcclxuICBcdFx0dmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyKCksXHJcbiAgXHRcdCAgICBuZXdDZW50ZXIgPSB0aGlzLl9saW1pdENlbnRlcihjZW50ZXIsIHRoaXMuX3pvb20sIHRvTGF0TG5nQm91bmRzKGJvdW5kcykpO1xyXG5cclxuICBcdFx0aWYgKCFjZW50ZXIuZXF1YWxzKG5ld0NlbnRlcikpIHtcclxuICBcdFx0XHR0aGlzLnBhblRvKG5ld0NlbnRlciwgb3B0aW9ucyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2VuZm9yY2luZ0JvdW5kcyA9IGZhbHNlO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBwYW5JbnNpZGUobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBwYWRkaW5nIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBQYW5zIHRoZSBtYXAgdGhlIG1pbmltdW0gYW1vdW50IHRvIG1ha2UgdGhlIGBsYXRsbmdgIHZpc2libGUuIFVzZVxyXG4gIFx0Ly8gcGFkZGluZyBvcHRpb25zIHRvIGZpdCB0aGUgZGlzcGxheSB0byBtb3JlIHJlc3RyaWN0ZWQgYm91bmRzLlxyXG4gIFx0Ly8gSWYgYGxhdGxuZ2AgaXMgYWxyZWFkeSB3aXRoaW4gdGhlIChvcHRpb25hbGx5IHBhZGRlZCkgZGlzcGxheSBib3VuZHMsXHJcbiAgXHQvLyB0aGUgbWFwIHdpbGwgbm90IGJlIHBhbm5lZC5cclxuICBcdHBhbkluc2lkZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xyXG4gIFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgXHRcdHZhciBwYWRkaW5nVEwgPSB0b1BvaW50KG9wdGlvbnMucGFkZGluZ1RvcExlZnQgfHwgb3B0aW9ucy5wYWRkaW5nIHx8IFswLCAwXSksXHJcbiAgXHRcdCAgICBwYWRkaW5nQlIgPSB0b1BvaW50KG9wdGlvbnMucGFkZGluZ0JvdHRvbVJpZ2h0IHx8IG9wdGlvbnMucGFkZGluZyB8fCBbMCwgMF0pLFxyXG4gIFx0XHQgICAgcGl4ZWxDZW50ZXIgPSB0aGlzLnByb2plY3QodGhpcy5nZXRDZW50ZXIoKSksXHJcbiAgXHRcdCAgICBwaXhlbFBvaW50ID0gdGhpcy5wcm9qZWN0KGxhdGxuZyksXHJcbiAgXHRcdCAgICBwaXhlbEJvdW5kcyA9IHRoaXMuZ2V0UGl4ZWxCb3VuZHMoKSxcclxuICBcdFx0ICAgIHBhZGRlZEJvdW5kcyA9IHRvQm91bmRzKFtwaXhlbEJvdW5kcy5taW4uYWRkKHBhZGRpbmdUTCksIHBpeGVsQm91bmRzLm1heC5zdWJ0cmFjdChwYWRkaW5nQlIpXSksXHJcbiAgXHRcdCAgICBwYWRkZWRTaXplID0gcGFkZGVkQm91bmRzLmdldFNpemUoKTtcclxuXHJcbiAgXHRcdGlmICghcGFkZGVkQm91bmRzLmNvbnRhaW5zKHBpeGVsUG9pbnQpKSB7XHJcbiAgXHRcdFx0dGhpcy5fZW5mb3JjaW5nQm91bmRzID0gdHJ1ZTtcclxuICBcdFx0XHR2YXIgY2VudGVyT2Zmc2V0ID0gcGl4ZWxQb2ludC5zdWJ0cmFjdChwYWRkZWRCb3VuZHMuZ2V0Q2VudGVyKCkpO1xyXG4gIFx0XHRcdHZhciBvZmZzZXQgPSBwYWRkZWRCb3VuZHMuZXh0ZW5kKHBpeGVsUG9pbnQpLmdldFNpemUoKS5zdWJ0cmFjdChwYWRkZWRTaXplKTtcclxuICBcdFx0XHRwaXhlbENlbnRlci54ICs9IGNlbnRlck9mZnNldC54IDwgMCA/IC1vZmZzZXQueCA6IG9mZnNldC54O1xyXG4gIFx0XHRcdHBpeGVsQ2VudGVyLnkgKz0gY2VudGVyT2Zmc2V0LnkgPCAwID8gLW9mZnNldC55IDogb2Zmc2V0Lnk7XHJcbiAgXHRcdFx0dGhpcy5wYW5Ubyh0aGlzLnVucHJvamVjdChwaXhlbENlbnRlciksIG9wdGlvbnMpO1xyXG4gIFx0XHRcdHRoaXMuX2VuZm9yY2luZ0JvdW5kcyA9IGZhbHNlO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGludmFsaWRhdGVTaXplKG9wdGlvbnM6IFpvb20vcGFuIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBDaGVja3MgaWYgdGhlIG1hcCBjb250YWluZXIgc2l6ZSBjaGFuZ2VkIGFuZCB1cGRhdGVzIHRoZSBtYXAgaWYgc28g4oCUXHJcbiAgXHQvLyBjYWxsIGl0IGFmdGVyIHlvdSd2ZSBjaGFuZ2VkIHRoZSBtYXAgc2l6ZSBkeW5hbWljYWxseSwgYWxzbyBhbmltYXRpbmdcclxuICBcdC8vIHBhbiBieSBkZWZhdWx0LiBJZiBgb3B0aW9ucy5wYW5gIGlzIGBmYWxzZWAsIHBhbm5pbmcgd2lsbCBub3Qgb2NjdXIuXHJcbiAgXHQvLyBJZiBgb3B0aW9ucy5kZWJvdW5jZU1vdmVlbmRgIGlzIGB0cnVlYCwgaXQgd2lsbCBkZWxheSBgbW92ZWVuZGAgZXZlbnQgc29cclxuICBcdC8vIHRoYXQgaXQgZG9lc24ndCBoYXBwZW4gb2Z0ZW4gZXZlbiBpZiB0aGUgbWV0aG9kIGlzIGNhbGxlZCBtYW55XHJcbiAgXHQvLyB0aW1lcyBpbiBhIHJvdy5cclxuXHJcbiAgXHQvLyBAYWx0ZXJuYXRpdmVcclxuICBcdC8vIEBtZXRob2QgaW52YWxpZGF0ZVNpemUoYW5pbWF0ZTogQm9vbGVhbik6IHRoaXNcclxuICBcdC8vIENoZWNrcyBpZiB0aGUgbWFwIGNvbnRhaW5lciBzaXplIGNoYW5nZWQgYW5kIHVwZGF0ZXMgdGhlIG1hcCBpZiBzbyDigJRcclxuICBcdC8vIGNhbGwgaXQgYWZ0ZXIgeW91J3ZlIGNoYW5nZWQgdGhlIG1hcCBzaXplIGR5bmFtaWNhbGx5LCBhbHNvIGFuaW1hdGluZ1xyXG4gIFx0Ly8gcGFuIGJ5IGRlZmF1bHQuXHJcbiAgXHRpbnZhbGlkYXRlU2l6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9sb2FkZWQpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcbiAgXHRcdG9wdGlvbnMgPSBleHRlbmQoe1xyXG4gIFx0XHRcdGFuaW1hdGU6IGZhbHNlLFxyXG4gIFx0XHRcdHBhbjogdHJ1ZVxyXG4gIFx0XHR9LCBvcHRpb25zID09PSB0cnVlID8ge2FuaW1hdGU6IHRydWV9IDogb3B0aW9ucyk7XHJcblxyXG4gIFx0XHR2YXIgb2xkU2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpO1xyXG4gIFx0XHR0aGlzLl9zaXplQ2hhbmdlZCA9IHRydWU7XHJcbiAgXHRcdHRoaXMuX2xhc3RDZW50ZXIgPSBudWxsO1xyXG5cclxuICBcdFx0dmFyIG5ld1NpemUgPSB0aGlzLmdldFNpemUoKSxcclxuICBcdFx0ICAgIG9sZENlbnRlciA9IG9sZFNpemUuZGl2aWRlQnkoMikucm91bmQoKSxcclxuICBcdFx0ICAgIG5ld0NlbnRlciA9IG5ld1NpemUuZGl2aWRlQnkoMikucm91bmQoKSxcclxuICBcdFx0ICAgIG9mZnNldCA9IG9sZENlbnRlci5zdWJ0cmFjdChuZXdDZW50ZXIpO1xyXG5cclxuICBcdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcbiAgXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgJiYgb3B0aW9ucy5wYW4pIHtcclxuICBcdFx0XHR0aGlzLnBhbkJ5KG9mZnNldCk7XHJcblxyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdGlmIChvcHRpb25zLnBhbikge1xyXG4gIFx0XHRcdFx0dGhpcy5fcmF3UGFuQnkob2Zmc2V0KTtcclxuICBcdFx0XHR9XHJcblxyXG4gIFx0XHRcdHRoaXMuZmlyZSgnbW92ZScpO1xyXG5cclxuICBcdFx0XHRpZiAob3B0aW9ucy5kZWJvdW5jZU1vdmVlbmQpIHtcclxuICBcdFx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9zaXplVGltZXIpO1xyXG4gIFx0XHRcdFx0dGhpcy5fc2l6ZVRpbWVyID0gc2V0VGltZW91dChiaW5kKHRoaXMuZmlyZSwgdGhpcywgJ21vdmVlbmQnKSwgMjAwKTtcclxuICBcdFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdFx0dGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBAc2VjdGlvbiBNYXAgc3RhdGUgY2hhbmdlIGV2ZW50c1xyXG4gIFx0XHQvLyBAZXZlbnQgcmVzaXplOiBSZXNpemVFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgaXMgcmVzaXplZC5cclxuICBcdFx0cmV0dXJuIHRoaXMuZmlyZSgncmVzaXplJywge1xyXG4gIFx0XHRcdG9sZFNpemU6IG9sZFNpemUsXHJcbiAgXHRcdFx0bmV3U2l6ZTogbmV3U2l6ZVxyXG4gIFx0XHR9KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgbW9kaWZ5aW5nIG1hcCBzdGF0ZVxyXG4gIFx0Ly8gQG1ldGhvZCBzdG9wKCk6IHRoaXNcclxuICBcdC8vIFN0b3BzIHRoZSBjdXJyZW50bHkgcnVubmluZyBgcGFuVG9gIG9yIGBmbHlUb2AgYW5pbWF0aW9uLCBpZiBhbnkuXHJcbiAgXHRzdG9wOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHRoaXMuc2V0Wm9vbSh0aGlzLl9saW1pdFpvb20odGhpcy5fem9vbSkpO1xyXG4gIFx0XHRpZiAoIXRoaXMub3B0aW9ucy56b29tU25hcCkge1xyXG4gIFx0XHRcdHRoaXMuZmlyZSgndmlld3Jlc2V0Jyk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXMuX3N0b3AoKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQHNlY3Rpb24gR2VvbG9jYXRpb24gbWV0aG9kc1xyXG4gIFx0Ly8gQG1ldGhvZCBsb2NhdGUob3B0aW9ucz86IExvY2F0ZSBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gVHJpZXMgdG8gbG9jYXRlIHRoZSB1c2VyIHVzaW5nIHRoZSBHZW9sb2NhdGlvbiBBUEksIGZpcmluZyBhIFtgbG9jYXRpb25mb3VuZGBdKCNtYXAtbG9jYXRpb25mb3VuZClcclxuICBcdC8vIGV2ZW50IHdpdGggbG9jYXRpb24gZGF0YSBvbiBzdWNjZXNzIG9yIGEgW2Bsb2NhdGlvbmVycm9yYF0oI21hcC1sb2NhdGlvbmVycm9yKSBldmVudCBvbiBmYWlsdXJlLFxyXG4gIFx0Ly8gYW5kIG9wdGlvbmFsbHkgc2V0cyB0aGUgbWFwIHZpZXcgdG8gdGhlIHVzZXIncyBsb2NhdGlvbiB3aXRoIHJlc3BlY3QgdG9cclxuICBcdC8vIGRldGVjdGlvbiBhY2N1cmFjeSAob3IgdG8gdGhlIHdvcmxkIHZpZXcgaWYgZ2VvbG9jYXRpb24gZmFpbGVkKS5cclxuICBcdC8vIE5vdGUgdGhhdCwgaWYgeW91ciBwYWdlIGRvZXNuJ3QgdXNlIEhUVFBTLCB0aGlzIG1ldGhvZCB3aWxsIGZhaWwgaW5cclxuICBcdC8vIG1vZGVybiBicm93c2VycyAoW0Nocm9tZSA1MCBhbmQgbmV3ZXJdKGh0dHBzOi8vc2l0ZXMuZ29vZ2xlLmNvbS9hL2Nocm9taXVtLm9yZy9kZXYvSG9tZS9jaHJvbWl1bS1zZWN1cml0eS9kZXByZWNhdGluZy1wb3dlcmZ1bC1mZWF0dXJlcy1vbi1pbnNlY3VyZS1vcmlnaW5zKSlcclxuICBcdC8vIFNlZSBgTG9jYXRlIG9wdGlvbnNgIGZvciBtb3JlIGRldGFpbHMuXHJcbiAgXHRsb2NhdGU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblxyXG4gIFx0XHRvcHRpb25zID0gdGhpcy5fbG9jYXRlT3B0aW9ucyA9IGV4dGVuZCh7XHJcbiAgXHRcdFx0dGltZW91dDogMTAwMDAsXHJcbiAgXHRcdFx0d2F0Y2g6IGZhbHNlXHJcbiAgXHRcdFx0Ly8gc2V0VmlldzogZmFsc2VcclxuICBcdFx0XHQvLyBtYXhab29tOiA8TnVtYmVyPlxyXG4gIFx0XHRcdC8vIG1heGltdW1BZ2U6IDBcclxuICBcdFx0XHQvLyBlbmFibGVIaWdoQWNjdXJhY3k6IGZhbHNlXHJcbiAgXHRcdH0sIG9wdGlvbnMpO1xyXG5cclxuICBcdFx0aWYgKCEoJ2dlb2xvY2F0aW9uJyBpbiBuYXZpZ2F0b3IpKSB7XHJcbiAgXHRcdFx0dGhpcy5faGFuZGxlR2VvbG9jYXRpb25FcnJvcih7XHJcbiAgXHRcdFx0XHRjb2RlOiAwLFxyXG4gIFx0XHRcdFx0bWVzc2FnZTogJ0dlb2xvY2F0aW9uIG5vdCBzdXBwb3J0ZWQuJ1xyXG4gIFx0XHRcdH0pO1xyXG4gIFx0XHRcdHJldHVybiB0aGlzO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgb25SZXNwb25zZSA9IGJpbmQodGhpcy5faGFuZGxlR2VvbG9jYXRpb25SZXNwb25zZSwgdGhpcyksXHJcbiAgXHRcdCAgICBvbkVycm9yID0gYmluZCh0aGlzLl9oYW5kbGVHZW9sb2NhdGlvbkVycm9yLCB0aGlzKTtcclxuXHJcbiAgXHRcdGlmIChvcHRpb25zLndhdGNoKSB7XHJcbiAgXHRcdFx0dGhpcy5fbG9jYXRpb25XYXRjaElkID1cclxuICBcdFx0XHQgICAgICAgIG5hdmlnYXRvci5nZW9sb2NhdGlvbi53YXRjaFBvc2l0aW9uKG9uUmVzcG9uc2UsIG9uRXJyb3IsIG9wdGlvbnMpO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdG5hdmlnYXRvci5nZW9sb2NhdGlvbi5nZXRDdXJyZW50UG9zaXRpb24ob25SZXNwb25zZSwgb25FcnJvciwgb3B0aW9ucyk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc3RvcExvY2F0ZSgpOiB0aGlzXHJcbiAgXHQvLyBTdG9wcyB3YXRjaGluZyBsb2NhdGlvbiBwcmV2aW91c2x5IGluaXRpYXRlZCBieSBgbWFwLmxvY2F0ZSh7d2F0Y2g6IHRydWV9KWBcclxuICBcdC8vIGFuZCBhYm9ydHMgcmVzZXR0aW5nIHRoZSBtYXAgdmlldyBpZiBtYXAubG9jYXRlIHdhcyBjYWxsZWQgd2l0aFxyXG4gIFx0Ly8gYHtzZXRWaWV3OiB0cnVlfWAuXHJcbiAgXHRzdG9wTG9jYXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmIChuYXZpZ2F0b3IuZ2VvbG9jYXRpb24gJiYgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLmNsZWFyV2F0Y2gpIHtcclxuICBcdFx0XHRuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCh0aGlzLl9sb2NhdGlvbldhdGNoSWQpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdGlmICh0aGlzLl9sb2NhdGVPcHRpb25zKSB7XHJcbiAgXHRcdFx0dGhpcy5fbG9jYXRlT3B0aW9ucy5zZXRWaWV3ID0gZmFsc2U7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9oYW5kbGVHZW9sb2NhdGlvbkVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQpIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHR2YXIgYyA9IGVycm9yLmNvZGUsXHJcbiAgXHRcdCAgICBtZXNzYWdlID0gZXJyb3IubWVzc2FnZSB8fFxyXG4gIFx0XHQgICAgICAgICAgICAoYyA9PT0gMSA/ICdwZXJtaXNzaW9uIGRlbmllZCcgOlxyXG4gIFx0XHQgICAgICAgICAgICAoYyA9PT0gMiA/ICdwb3NpdGlvbiB1bmF2YWlsYWJsZScgOiAndGltZW91dCcpKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9sb2NhdGVPcHRpb25zLnNldFZpZXcgJiYgIXRoaXMuX2xvYWRlZCkge1xyXG4gIFx0XHRcdHRoaXMuZml0V29ybGQoKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gQHNlY3Rpb24gTG9jYXRpb24gZXZlbnRzXHJcbiAgXHRcdC8vIEBldmVudCBsb2NhdGlvbmVycm9yOiBFcnJvckV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gZ2VvbG9jYXRpb24gKHVzaW5nIHRoZSBbYGxvY2F0ZWBdKCNtYXAtbG9jYXRlKSBtZXRob2QpIGZhaWxlZC5cclxuICBcdFx0dGhpcy5maXJlKCdsb2NhdGlvbmVycm9yJywge1xyXG4gIFx0XHRcdGNvZGU6IGMsXHJcbiAgXHRcdFx0bWVzc2FnZTogJ0dlb2xvY2F0aW9uIGVycm9yOiAnICsgbWVzc2FnZSArICcuJ1xyXG4gIFx0XHR9KTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2hhbmRsZUdlb2xvY2F0aW9uUmVzcG9uc2U6IGZ1bmN0aW9uIChwb3MpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQpIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHR2YXIgbGF0ID0gcG9zLmNvb3Jkcy5sYXRpdHVkZSxcclxuICBcdFx0ICAgIGxuZyA9IHBvcy5jb29yZHMubG9uZ2l0dWRlLFxyXG4gIFx0XHQgICAgbGF0bG5nID0gbmV3IExhdExuZyhsYXQsIGxuZyksXHJcbiAgXHRcdCAgICBib3VuZHMgPSBsYXRsbmcudG9Cb3VuZHMocG9zLmNvb3Jkcy5hY2N1cmFjeSAqIDIpLFxyXG4gIFx0XHQgICAgb3B0aW9ucyA9IHRoaXMuX2xvY2F0ZU9wdGlvbnM7XHJcblxyXG4gIFx0XHRpZiAob3B0aW9ucy5zZXRWaWV3KSB7XHJcbiAgXHRcdFx0dmFyIHpvb20gPSB0aGlzLmdldEJvdW5kc1pvb20oYm91bmRzKTtcclxuICBcdFx0XHR0aGlzLnNldFZpZXcobGF0bG5nLCBvcHRpb25zLm1heFpvb20gPyBNYXRoLm1pbih6b29tLCBvcHRpb25zLm1heFpvb20pIDogem9vbSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBkYXRhID0ge1xyXG4gIFx0XHRcdGxhdGxuZzogbGF0bG5nLFxyXG4gIFx0XHRcdGJvdW5kczogYm91bmRzLFxyXG4gIFx0XHRcdHRpbWVzdGFtcDogcG9zLnRpbWVzdGFtcFxyXG4gIFx0XHR9O1xyXG5cclxuICBcdFx0Zm9yICh2YXIgaSBpbiBwb3MuY29vcmRzKSB7XHJcbiAgXHRcdFx0aWYgKHR5cGVvZiBwb3MuY29vcmRzW2ldID09PSAnbnVtYmVyJykge1xyXG4gIFx0XHRcdFx0ZGF0YVtpXSA9IHBvcy5jb29yZHNbaV07XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBAZXZlbnQgbG9jYXRpb25mb3VuZDogTG9jYXRpb25FdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIGdlb2xvY2F0aW9uICh1c2luZyB0aGUgW2Bsb2NhdGVgXSgjbWFwLWxvY2F0ZSkgbWV0aG9kKVxyXG4gIFx0XHQvLyB3ZW50IHN1Y2Nlc3NmdWxseS5cclxuICBcdFx0dGhpcy5maXJlKCdsb2NhdGlvbmZvdW5kJywgZGF0YSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIFRPRE8gQXBwcm9wcmlhdGUgZG9jcyBzZWN0aW9uP1xyXG4gIFx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xyXG4gIFx0Ly8gQG1ldGhvZCBhZGRIYW5kbGVyKG5hbWU6IFN0cmluZywgSGFuZGxlckNsYXNzOiBGdW5jdGlvbik6IHRoaXNcclxuICBcdC8vIEFkZHMgYSBuZXcgYEhhbmRsZXJgIHRvIHRoZSBtYXAsIGdpdmVuIGl0cyBuYW1lIGFuZCBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cclxuICBcdGFkZEhhbmRsZXI6IGZ1bmN0aW9uIChuYW1lLCBIYW5kbGVyQ2xhc3MpIHtcclxuICBcdFx0aWYgKCFIYW5kbGVyQ2xhc3MpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcbiAgXHRcdHZhciBoYW5kbGVyID0gdGhpc1tuYW1lXSA9IG5ldyBIYW5kbGVyQ2xhc3ModGhpcyk7XHJcblxyXG4gIFx0XHR0aGlzLl9oYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9uc1tuYW1lXSkge1xyXG4gIFx0XHRcdGhhbmRsZXIuZW5hYmxlKCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHJlbW92ZSgpOiB0aGlzXHJcbiAgXHQvLyBEZXN0cm95cyB0aGUgbWFwIGFuZCBjbGVhcnMgYWxsIHJlbGF0ZWQgZXZlbnQgbGlzdGVuZXJzLlxyXG4gIFx0cmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gIFx0XHR0aGlzLl9pbml0RXZlbnRzKHRydWUpO1xyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLm1heEJvdW5kcykgeyB0aGlzLm9mZignbW92ZWVuZCcsIHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcyk7IH1cclxuXHJcbiAgXHRcdGlmICh0aGlzLl9jb250YWluZXJJZCAhPT0gdGhpcy5fY29udGFpbmVyLl9sZWFmbGV0X2lkKSB7XHJcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNYXAgY29udGFpbmVyIGlzIGJlaW5nIHJldXNlZCBieSBhbm90aGVyIGluc3RhbmNlJyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRyeSB7XHJcbiAgXHRcdFx0Ly8gdGhyb3dzIGVycm9yIGluIElFNi04XHJcbiAgXHRcdFx0ZGVsZXRlIHRoaXMuX2NvbnRhaW5lci5fbGVhZmxldF9pZDtcclxuICBcdFx0XHRkZWxldGUgdGhpcy5fY29udGFpbmVySWQ7XHJcbiAgXHRcdH0gY2F0Y2ggKGUpIHtcclxuICBcdFx0XHQvKmVzbGludC1kaXNhYmxlICovXHJcbiAgXHRcdFx0dGhpcy5fY29udGFpbmVyLl9sZWFmbGV0X2lkID0gdW5kZWZpbmVkO1xyXG4gIFx0XHRcdC8qIGVzbGludC1lbmFibGUgKi9cclxuICBcdFx0XHR0aGlzLl9jb250YWluZXJJZCA9IHVuZGVmaW5lZDtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKHRoaXMuX2xvY2F0aW9uV2F0Y2hJZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgXHRcdFx0dGhpcy5zdG9wTG9jYXRlKCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX3N0b3AoKTtcclxuXHJcbiAgXHRcdHJlbW92ZSh0aGlzLl9tYXBQYW5lKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9jbGVhckNvbnRyb2xQb3MpIHtcclxuICBcdFx0XHR0aGlzLl9jbGVhckNvbnRyb2xQb3MoKTtcclxuICBcdFx0fVxyXG4gIFx0XHRpZiAodGhpcy5fcmVzaXplUmVxdWVzdCkge1xyXG4gIFx0XHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9yZXNpemVSZXF1ZXN0KTtcclxuICBcdFx0XHR0aGlzLl9yZXNpemVSZXF1ZXN0ID0gbnVsbDtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fY2xlYXJIYW5kbGVycygpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xyXG4gIFx0XHRcdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXHJcbiAgXHRcdFx0Ly8gQGV2ZW50IHVubG9hZDogRXZlbnRcclxuICBcdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgaXMgZGVzdHJveWVkIHdpdGggW3JlbW92ZV0oI21hcC1yZW1vdmUpIG1ldGhvZC5cclxuICBcdFx0XHR0aGlzLmZpcmUoJ3VubG9hZCcpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgaTtcclxuICBcdFx0Zm9yIChpIGluIHRoaXMuX2xheWVycykge1xyXG4gIFx0XHRcdHRoaXMuX2xheWVyc1tpXS5yZW1vdmUoKTtcclxuICBcdFx0fVxyXG4gIFx0XHRmb3IgKGkgaW4gdGhpcy5fcGFuZXMpIHtcclxuICBcdFx0XHRyZW1vdmUodGhpcy5fcGFuZXNbaV0pO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9sYXllcnMgPSBbXTtcclxuICBcdFx0dGhpcy5fcGFuZXMgPSBbXTtcclxuICBcdFx0ZGVsZXRlIHRoaXMuX21hcFBhbmU7XHJcbiAgXHRcdGRlbGV0ZSB0aGlzLl9yZW5kZXJlcjtcclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAc2VjdGlvbiBPdGhlciBNZXRob2RzXHJcbiAgXHQvLyBAbWV0aG9kIGNyZWF0ZVBhbmUobmFtZTogU3RyaW5nLCBjb250YWluZXI/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcbiAgXHQvLyBDcmVhdGVzIGEgbmV3IFttYXAgcGFuZV0oI21hcC1wYW5lKSB3aXRoIHRoZSBnaXZlbiBuYW1lIGlmIGl0IGRvZXNuJ3QgZXhpc3QgYWxyZWFkeSxcclxuICBcdC8vIHRoZW4gcmV0dXJucyBpdC4gVGhlIHBhbmUgaXMgY3JlYXRlZCBhcyBhIGNoaWxkIG9mIGBjb250YWluZXJgLCBvclxyXG4gIFx0Ly8gYXMgYSBjaGlsZCBvZiB0aGUgbWFpbiBtYXAgcGFuZSBpZiBub3Qgc2V0LlxyXG4gIFx0Y3JlYXRlUGFuZTogZnVuY3Rpb24gKG5hbWUsIGNvbnRhaW5lcikge1xyXG4gIFx0XHR2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtcGFuZScgKyAobmFtZSA/ICcgbGVhZmxldC0nICsgbmFtZS5yZXBsYWNlKCdQYW5lJywgJycpICsgJy1wYW5lJyA6ICcnKSxcclxuICBcdFx0ICAgIHBhbmUgPSBjcmVhdGUkMSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIgfHwgdGhpcy5fbWFwUGFuZSk7XHJcblxyXG4gIFx0XHRpZiAobmFtZSkge1xyXG4gIFx0XHRcdHRoaXMuX3BhbmVzW25hbWVdID0gcGFuZTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gcGFuZTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgR2V0dGluZyBNYXAgU3RhdGVcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldENlbnRlcigpOiBMYXRMbmdcclxuICBcdC8vIFJldHVybnMgdGhlIGdlb2dyYXBoaWNhbCBjZW50ZXIgb2YgdGhlIG1hcCB2aWV3XHJcbiAgXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dGhpcy5fY2hlY2tJZkxvYWRlZCgpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2xhc3RDZW50ZXIgJiYgIXRoaXMuX21vdmVkKCkpIHtcclxuICBcdFx0XHRyZXR1cm4gdGhpcy5fbGFzdENlbnRlci5jbG9uZSgpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLl9nZXRDZW50ZXJMYXllclBvaW50KCkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFpvb20oKTogTnVtYmVyXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwgb2YgdGhlIG1hcCB2aWV3XHJcbiAgXHRnZXRab29tOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl96b29tO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcclxuICBcdC8vIFJldHVybnMgdGhlIGdlb2dyYXBoaWNhbCBib3VuZHMgdmlzaWJsZSBpbiB0aGUgY3VycmVudCBtYXAgdmlld1xyXG4gIFx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBib3VuZHMgPSB0aGlzLmdldFBpeGVsQm91bmRzKCksXHJcbiAgXHRcdCAgICBzdyA9IHRoaXMudW5wcm9qZWN0KGJvdW5kcy5nZXRCb3R0b21MZWZ0KCkpLFxyXG4gIFx0XHQgICAgbmUgPSB0aGlzLnVucHJvamVjdChib3VuZHMuZ2V0VG9wUmlnaHQoKSk7XHJcblxyXG4gIFx0XHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhzdywgbmUpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldE1pblpvb20oKTogTnVtYmVyXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcCAoaWYgc2V0IGluIHRoZSBgbWluWm9vbWAgb3B0aW9uIG9mIHRoZSBtYXAgb3Igb2YgYW55IGxheWVycyksIG9yIGAwYCBieSBkZWZhdWx0LlxyXG4gIFx0Z2V0TWluWm9vbTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLm1pblpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX2xheWVyc01pblpvb20gfHwgMCA6IHRoaXMub3B0aW9ucy5taW5ab29tO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldE1heFpvb20oKTogTnVtYmVyXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcCAoaWYgc2V0IGluIHRoZSBgbWF4Wm9vbWAgb3B0aW9uIG9mIHRoZSBtYXAgb3Igb2YgYW55IGxheWVycykuXHJcbiAgXHRnZXRNYXhab29tOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLm9wdGlvbnMubWF4Wm9vbSA9PT0gdW5kZWZpbmVkID9cclxuICBcdFx0XHQodGhpcy5fbGF5ZXJzTWF4Wm9vbSA9PT0gdW5kZWZpbmVkID8gSW5maW5pdHkgOiB0aGlzLl9sYXllcnNNYXhab29tKSA6XHJcbiAgXHRcdFx0dGhpcy5vcHRpb25zLm1heFpvb207XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Qm91bmRzWm9vbShib3VuZHM6IExhdExuZ0JvdW5kcywgaW5zaWRlPzogQm9vbGVhbiwgcGFkZGluZz86IFBvaW50KTogTnVtYmVyXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgb24gd2hpY2ggdGhlIGdpdmVuIGJvdW5kcyBmaXQgdG8gdGhlIG1hcFxyXG4gIFx0Ly8gdmlldyBpbiBpdHMgZW50aXJldHkuIElmIGBpbnNpZGVgIChvcHRpb25hbCkgaXMgc2V0IHRvIGB0cnVlYCwgdGhlIG1ldGhvZFxyXG4gIFx0Ly8gaW5zdGVhZCByZXR1cm5zIHRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgb24gd2hpY2ggdGhlIG1hcCB2aWV3IGZpdHMgaW50b1xyXG4gIFx0Ly8gdGhlIGdpdmVuIGJvdW5kcyBpbiBpdHMgZW50aXJldHkuXHJcbiAgXHRnZXRCb3VuZHNab29tOiBmdW5jdGlvbiAoYm91bmRzLCBpbnNpZGUsIHBhZGRpbmcpIHsgLy8gKExhdExuZ0JvdW5kc1ssIEJvb2xlYW4sIFBvaW50XSkgLT4gTnVtYmVyXHJcbiAgXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcbiAgXHRcdHBhZGRpbmcgPSB0b1BvaW50KHBhZGRpbmcgfHwgWzAsIDBdKTtcclxuXHJcbiAgXHRcdHZhciB6b29tID0gdGhpcy5nZXRab29tKCkgfHwgMCxcclxuICBcdFx0ICAgIG1pbiA9IHRoaXMuZ2V0TWluWm9vbSgpLFxyXG4gIFx0XHQgICAgbWF4ID0gdGhpcy5nZXRNYXhab29tKCksXHJcbiAgXHRcdCAgICBudyA9IGJvdW5kcy5nZXROb3J0aFdlc3QoKSxcclxuICBcdFx0ICAgIHNlID0gYm91bmRzLmdldFNvdXRoRWFzdCgpLFxyXG4gIFx0XHQgICAgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpLnN1YnRyYWN0KHBhZGRpbmcpLFxyXG4gIFx0XHQgICAgYm91bmRzU2l6ZSA9IHRvQm91bmRzKHRoaXMucHJvamVjdChzZSwgem9vbSksIHRoaXMucHJvamVjdChudywgem9vbSkpLmdldFNpemUoKSxcclxuICBcdFx0ICAgIHNuYXAgPSBCcm93c2VyLmFueTNkID8gdGhpcy5vcHRpb25zLnpvb21TbmFwIDogMSxcclxuICBcdFx0ICAgIHNjYWxleCA9IHNpemUueCAvIGJvdW5kc1NpemUueCxcclxuICBcdFx0ICAgIHNjYWxleSA9IHNpemUueSAvIGJvdW5kc1NpemUueSxcclxuICBcdFx0ICAgIHNjYWxlID0gaW5zaWRlID8gTWF0aC5tYXgoc2NhbGV4LCBzY2FsZXkpIDogTWF0aC5taW4oc2NhbGV4LCBzY2FsZXkpO1xyXG5cclxuICBcdFx0em9vbSA9IHRoaXMuZ2V0U2NhbGVab29tKHNjYWxlLCB6b29tKTtcclxuXHJcbiAgXHRcdGlmIChzbmFwKSB7XHJcbiAgXHRcdFx0em9vbSA9IE1hdGgucm91bmQoem9vbSAvIChzbmFwIC8gMTAwKSkgKiAoc25hcCAvIDEwMCk7IC8vIGRvbid0IGp1bXAgaWYgd2l0aGluIDElIG9mIGEgc25hcCBsZXZlbFxyXG4gIFx0XHRcdHpvb20gPSBpbnNpZGUgPyBNYXRoLmNlaWwoem9vbSAvIHNuYXApICogc25hcCA6IE1hdGguZmxvb3Ioem9vbSAvIHNuYXApICogc25hcDtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB6b29tKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0U2l6ZSgpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCBzaXplIG9mIHRoZSBtYXAgY29udGFpbmVyIChpbiBwaXhlbHMpLlxyXG4gIFx0Z2V0U2l6ZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAoIXRoaXMuX3NpemUgfHwgdGhpcy5fc2l6ZUNoYW5nZWQpIHtcclxuICBcdFx0XHR0aGlzLl9zaXplID0gbmV3IFBvaW50KFxyXG4gIFx0XHRcdFx0dGhpcy5fY29udGFpbmVyLmNsaWVudFdpZHRoIHx8IDAsXHJcbiAgXHRcdFx0XHR0aGlzLl9jb250YWluZXIuY2xpZW50SGVpZ2h0IHx8IDApO1xyXG5cclxuICBcdFx0XHR0aGlzLl9zaXplQ2hhbmdlZCA9IGZhbHNlO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzLl9zaXplLmNsb25lKCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0UGl4ZWxCb3VuZHMoKTogQm91bmRzXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBib3VuZHMgb2YgdGhlIGN1cnJlbnQgbWFwIHZpZXcgaW4gcHJvamVjdGVkIHBpeGVsXHJcbiAgXHQvLyBjb29yZGluYXRlcyAoc29tZXRpbWVzIHVzZWZ1bCBpbiBsYXllciBhbmQgb3ZlcmxheSBpbXBsZW1lbnRhdGlvbnMpLlxyXG4gIFx0Z2V0UGl4ZWxCb3VuZHM6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuICBcdFx0dmFyIHRvcExlZnRQb2ludCA9IHRoaXMuX2dldFRvcExlZnRQb2ludChjZW50ZXIsIHpvb20pO1xyXG4gIFx0XHRyZXR1cm4gbmV3IEJvdW5kcyh0b3BMZWZ0UG9pbnQsIHRvcExlZnRQb2ludC5hZGQodGhpcy5nZXRTaXplKCkpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gVE9ETzogQ2hlY2sgc2VtYW50aWNzIC0gaXNuJ3QgdGhlIHBpeGVsIG9yaWdpbiB0aGUgMCwwIGNvb3JkIHJlbGF0aXZlIHRvXHJcbiAgXHQvLyB0aGUgbWFwIHBhbmU/IFwibGVmdCBwb2ludCBvZiB0aGUgbWFwIGxheWVyXCIgY2FuIGJlIGNvbmZ1c2luZywgc3BlY2lhbGx5XHJcbiAgXHQvLyBzaW5jZSB0aGVyZSBjYW4gYmUgbmVnYXRpdmUgb2Zmc2V0cy5cclxuICBcdC8vIEBtZXRob2QgZ2V0UGl4ZWxPcmlnaW4oKTogUG9pbnRcclxuICBcdC8vIFJldHVybnMgdGhlIHByb2plY3RlZCBwaXhlbCBjb29yZGluYXRlcyBvZiB0aGUgdG9wIGxlZnQgcG9pbnQgb2ZcclxuICBcdC8vIHRoZSBtYXAgbGF5ZXIgKHVzZWZ1bCBpbiBjdXN0b20gbGF5ZXIgYW5kIG92ZXJsYXkgaW1wbGVtZW50YXRpb25zKS5cclxuICBcdGdldFBpeGVsT3JpZ2luOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHRoaXMuX2NoZWNrSWZMb2FkZWQoKTtcclxuICBcdFx0cmV0dXJuIHRoaXMuX3BpeGVsT3JpZ2luO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFBpeGVsV29ybGRCb3VuZHMoem9vbT86IE51bWJlcik6IEJvdW5kc1xyXG4gIFx0Ly8gUmV0dXJucyB0aGUgd29ybGQncyBib3VuZHMgaW4gcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIHpvb20gbGV2ZWwgYHpvb21gLlxyXG4gIFx0Ly8gSWYgYHpvb21gIGlzIG9taXR0ZWQsIHRoZSBtYXAncyBjdXJyZW50IHpvb20gbGV2ZWwgaXMgdXNlZC5cclxuICBcdGdldFBpeGVsV29ybGRCb3VuZHM6IGZ1bmN0aW9uICh6b29tKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLmdldFByb2plY3RlZEJvdW5kcyh6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLmdldFpvb20oKSA6IHpvb20pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAc2VjdGlvbiBPdGhlciBNZXRob2RzXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRQYW5lKHBhbmU6IFN0cmluZ3xIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcbiAgXHQvLyBSZXR1cm5zIGEgW21hcCBwYW5lXSgjbWFwLXBhbmUpLCBnaXZlbiBpdHMgbmFtZSBvciBpdHMgSFRNTCBlbGVtZW50IChpdHMgaWRlbnRpdHkpLlxyXG4gIFx0Z2V0UGFuZTogZnVuY3Rpb24gKHBhbmUpIHtcclxuICBcdFx0cmV0dXJuIHR5cGVvZiBwYW5lID09PSAnc3RyaW5nJyA/IHRoaXMuX3BhbmVzW3BhbmVdIDogcGFuZTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRQYW5lcygpOiBPYmplY3RcclxuICBcdC8vIFJldHVybnMgYSBwbGFpbiBvYmplY3QgY29udGFpbmluZyB0aGUgbmFtZXMgb2YgYWxsIFtwYW5lc10oI21hcC1wYW5lKSBhcyBrZXlzIGFuZFxyXG4gIFx0Ly8gdGhlIHBhbmVzIGFzIHZhbHVlcy5cclxuICBcdGdldFBhbmVzOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9wYW5lcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRDb250YWluZXI6IEhUTUxFbGVtZW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBIVE1MIGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgbWFwLlxyXG4gIFx0Z2V0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcbiAgXHR9LFxyXG5cclxuXHJcbiAgXHQvLyBAc2VjdGlvbiBDb252ZXJzaW9uIE1ldGhvZHNcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFpvb21TY2FsZSh0b1pvb206IE51bWJlciwgZnJvbVpvb206IE51bWJlcik6IE51bWJlclxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgc2NhbGUgZmFjdG9yIHRvIGJlIGFwcGxpZWQgdG8gYSBtYXAgdHJhbnNpdGlvbiBmcm9tIHpvb20gbGV2ZWxcclxuICBcdC8vIGBmcm9tWm9vbWAgdG8gYHRvWm9vbWAuIFVzZWQgaW50ZXJuYWxseSB0byBoZWxwIHdpdGggem9vbSBhbmltYXRpb25zLlxyXG4gIFx0Z2V0Wm9vbVNjYWxlOiBmdW5jdGlvbiAodG9ab29tLCBmcm9tWm9vbSkge1xyXG4gIFx0XHQvLyBUT0RPIHJlcGxhY2Ugd2l0aCB1bml2ZXJzYWwgaW1wbGVtZW50YXRpb24gYWZ0ZXIgcmVmYWN0b3JpbmcgcHJvamVjdGlvbnNcclxuICBcdFx0dmFyIGNycyA9IHRoaXMub3B0aW9ucy5jcnM7XHJcbiAgXHRcdGZyb21ab29tID0gZnJvbVpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiBmcm9tWm9vbTtcclxuICBcdFx0cmV0dXJuIGNycy5zY2FsZSh0b1pvb20pIC8gY3JzLnNjYWxlKGZyb21ab29tKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRTY2FsZVpvb20oc2NhbGU6IE51bWJlciwgZnJvbVpvb206IE51bWJlcik6IE51bWJlclxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgem9vbSBsZXZlbCB0aGF0IHRoZSBtYXAgd291bGQgZW5kIHVwIGF0LCBpZiBpdCBpcyBhdCBgZnJvbVpvb21gXHJcbiAgXHQvLyBsZXZlbCBhbmQgZXZlcnl0aGluZyBpcyBzY2FsZWQgYnkgYSBmYWN0b3Igb2YgYHNjYWxlYC4gSW52ZXJzZSBvZlxyXG4gIFx0Ly8gW2BnZXRab29tU2NhbGVgXSgjbWFwLWdldFpvb21TY2FsZSkuXHJcbiAgXHRnZXRTY2FsZVpvb206IGZ1bmN0aW9uIChzY2FsZSwgZnJvbVpvb20pIHtcclxuICBcdFx0dmFyIGNycyA9IHRoaXMub3B0aW9ucy5jcnM7XHJcbiAgXHRcdGZyb21ab29tID0gZnJvbVpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiBmcm9tWm9vbTtcclxuICBcdFx0dmFyIHpvb20gPSBjcnMuem9vbShzY2FsZSAqIGNycy5zY2FsZShmcm9tWm9vbSkpO1xyXG4gIFx0XHRyZXR1cm4gaXNOYU4oem9vbSkgPyBJbmZpbml0eSA6IHpvb207XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgcHJvamVjdChsYXRsbmc6IExhdExuZywgem9vbTogTnVtYmVyKTogUG9pbnRcclxuICBcdC8vIFByb2plY3RzIGEgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUgYExhdExuZ2AgYWNjb3JkaW5nIHRvIHRoZSBwcm9qZWN0aW9uXHJcbiAgXHQvLyBvZiB0aGUgbWFwJ3MgQ1JTLCB0aGVuIHNjYWxlcyBpdCBhY2NvcmRpbmcgdG8gYHpvb21gIGFuZCB0aGUgQ1JTJ3NcclxuICBcdC8vIGBUcmFuc2Zvcm1hdGlvbmAuIFRoZSByZXN1bHQgaXMgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0b1xyXG4gIFx0Ly8gdGhlIENSUyBvcmlnaW4uXHJcbiAgXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nLCB6b29tKSB7XHJcbiAgXHRcdHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogem9vbTtcclxuICBcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMubGF0TG5nVG9Qb2ludCh0b0xhdExuZyhsYXRsbmcpLCB6b29tKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB1bnByb2plY3QocG9pbnQ6IFBvaW50LCB6b29tOiBOdW1iZXIpOiBMYXRMbmdcclxuICBcdC8vIEludmVyc2Ugb2YgW2Bwcm9qZWN0YF0oI21hcC1wcm9qZWN0KS5cclxuICBcdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50LCB6b29tKSB7XHJcbiAgXHRcdHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogem9vbTtcclxuICBcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMucG9pbnRUb0xhdExuZyh0b1BvaW50KHBvaW50KSwgem9vbSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgbGF5ZXJQb2ludFRvTGF0TG5nKHBvaW50OiBQb2ludCk6IExhdExuZ1xyXG4gIFx0Ly8gR2l2ZW4gYSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKSxcclxuICBcdC8vIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUgKGZvciB0aGUgY3VycmVudCB6b29tIGxldmVsKS5cclxuICBcdGxheWVyUG9pbnRUb0xhdExuZzogZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgXHRcdHZhciBwcm9qZWN0ZWRQb2ludCA9IHRvUG9pbnQocG9pbnQpLmFkZCh0aGlzLmdldFBpeGVsT3JpZ2luKCkpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcy51bnByb2plY3QocHJvamVjdGVkUG9pbnQpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmc6IExhdExuZyk6IFBvaW50XHJcbiAgXHQvLyBHaXZlbiBhIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlLCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBpeGVsIGNvb3JkaW5hdGVcclxuICBcdC8vIHJlbGF0aXZlIHRvIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKS5cclxuICBcdGxhdExuZ1RvTGF5ZXJQb2ludDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG4gIFx0XHR2YXIgcHJvamVjdGVkUG9pbnQgPSB0aGlzLnByb2plY3QodG9MYXRMbmcobGF0bG5nKSkuX3JvdW5kKCk7XHJcbiAgXHRcdHJldHVybiBwcm9qZWN0ZWRQb2ludC5fc3VidHJhY3QodGhpcy5nZXRQaXhlbE9yaWdpbigpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB3cmFwTGF0TG5nKGxhdGxuZzogTGF0TG5nKTogTGF0TG5nXHJcbiAgXHQvLyBSZXR1cm5zIGEgYExhdExuZ2Agd2hlcmUgYGxhdGAgYW5kIGBsbmdgIGhhcyBiZWVuIHdyYXBwZWQgYWNjb3JkaW5nIHRvIHRoZVxyXG4gIFx0Ly8gbWFwJ3MgQ1JTJ3MgYHdyYXBMYXRgIGFuZCBgd3JhcExuZ2AgcHJvcGVydGllcywgaWYgdGhleSBhcmUgb3V0c2lkZSB0aGVcclxuICBcdC8vIENSUydzIGJvdW5kcy5cclxuICBcdC8vIEJ5IGRlZmF1bHQgdGhpcyBtZWFucyBsb25naXR1ZGUgaXMgd3JhcHBlZCBhcm91bmQgdGhlIGRhdGVsaW5lIHNvIGl0c1xyXG4gIFx0Ly8gdmFsdWUgaXMgYmV0d2VlbiAtMTgwIGFuZCArMTgwIGRlZ3JlZXMuXHJcbiAgXHR3cmFwTGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLndyYXBMYXRMbmcodG9MYXRMbmcobGF0bG5nKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgd3JhcExhdExuZ0JvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcyk6IExhdExuZ0JvdW5kc1xyXG4gIFx0Ly8gUmV0dXJucyBhIGBMYXRMbmdCb3VuZHNgIHdpdGggdGhlIHNhbWUgc2l6ZSBhcyB0aGUgZ2l2ZW4gb25lLCBlbnN1cmluZyB0aGF0XHJcbiAgXHQvLyBpdHMgY2VudGVyIGlzIHdpdGhpbiB0aGUgQ1JTJ3MgYm91bmRzLlxyXG4gIFx0Ly8gQnkgZGVmYXVsdCB0aGlzIG1lYW5zIHRoZSBjZW50ZXIgbG9uZ2l0dWRlIGlzIHdyYXBwZWQgYXJvdW5kIHRoZSBkYXRlbGluZSBzbyBpdHNcclxuICBcdC8vIHZhbHVlIGlzIGJldHdlZW4gLTE4MCBhbmQgKzE4MCBkZWdyZWVzLCBhbmQgdGhlIG1ham9yaXR5IG9mIHRoZSBib3VuZHNcclxuICBcdC8vIG92ZXJsYXBzIHRoZSBDUlMncyBib3VuZHMuXHJcbiAgXHR3cmFwTGF0TG5nQm91bmRzOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLndyYXBMYXRMbmdCb3VuZHModG9MYXRMbmdCb3VuZHMobGF0bG5nKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZGlzdGFuY2UobGF0bG5nMTogTGF0TG5nLCBsYXRsbmcyOiBMYXRMbmcpOiBOdW1iZXJcclxuICBcdC8vIFJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBhY2NvcmRpbmcgdG9cclxuICBcdC8vIHRoZSBtYXAncyBDUlMuIEJ5IGRlZmF1bHQgdGhpcyBtZWFzdXJlcyBkaXN0YW5jZSBpbiBtZXRlcnMuXHJcbiAgXHRkaXN0YW5jZTogZnVuY3Rpb24gKGxhdGxuZzEsIGxhdGxuZzIpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMuZGlzdGFuY2UodG9MYXRMbmcobGF0bG5nMSksIHRvTGF0TG5nKGxhdGxuZzIpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChwb2ludDogUG9pbnQpOiBQb2ludFxyXG4gIFx0Ly8gR2l2ZW4gYSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nXHJcbiAgXHQvLyBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKS5cclxuICBcdGNvbnRhaW5lclBvaW50VG9MYXllclBvaW50OiBmdW5jdGlvbiAocG9pbnQpIHsgLy8gKFBvaW50KVxyXG4gIFx0XHRyZXR1cm4gdG9Qb2ludChwb2ludCkuc3VidHJhY3QodGhpcy5fZ2V0TWFwUGFuZVBvcygpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBsYXllclBvaW50VG9Db250YWluZXJQb2ludChwb2ludDogUG9pbnQpOiBQb2ludFxyXG4gIFx0Ly8gR2l2ZW4gYSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKSxcclxuICBcdC8vIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgbWFwIGNvbnRhaW5lci5cclxuICBcdGxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50OiBmdW5jdGlvbiAocG9pbnQpIHsgLy8gKFBvaW50KVxyXG4gIFx0XHRyZXR1cm4gdG9Qb2ludChwb2ludCkuYWRkKHRoaXMuX2dldE1hcFBhbmVQb3MoKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgY29udGFpbmVyUG9pbnRUb0xhdExuZyhwb2ludDogUG9pbnQpOiBMYXRMbmdcclxuICBcdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgbWFwIGNvbnRhaW5lciwgcmV0dXJuc1xyXG4gIFx0Ly8gdGhlIGNvcnJlc3BvbmRpbmcgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUgKGZvciB0aGUgY3VycmVudCB6b29tIGxldmVsKS5cclxuICBcdGNvbnRhaW5lclBvaW50VG9MYXRMbmc6IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gIFx0XHR2YXIgbGF5ZXJQb2ludCA9IHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQodG9Qb2ludChwb2ludCkpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5sYXllclBvaW50VG9MYXRMbmcobGF5ZXJQb2ludCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgbGF0TG5nVG9Db250YWluZXJQb2ludChsYXRsbmc6IExhdExuZyk6IFBvaW50XHJcbiAgXHQvLyBHaXZlbiBhIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlLCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBpeGVsIGNvb3JkaW5hdGVcclxuICBcdC8vIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLlxyXG4gIFx0bGF0TG5nVG9Db250YWluZXJQb2ludDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5sYXllclBvaW50VG9Db250YWluZXJQb2ludCh0aGlzLmxhdExuZ1RvTGF5ZXJQb2ludCh0b0xhdExuZyhsYXRsbmcpKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgbW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZXY6IE1vdXNlRXZlbnQpOiBQb2ludFxyXG4gIFx0Ly8gR2l2ZW4gYSBNb3VzZUV2ZW50IG9iamVjdCwgcmV0dXJucyB0aGUgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGVcclxuICBcdC8vIG1hcCBjb250YWluZXIgd2hlcmUgdGhlIGV2ZW50IHRvb2sgcGxhY2UuXHJcbiAgXHRtb3VzZUV2ZW50VG9Db250YWluZXJQb2ludDogZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0cmV0dXJuIGdldE1vdXNlUG9zaXRpb24oZSwgdGhpcy5fY29udGFpbmVyKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBtb3VzZUV2ZW50VG9MYXllclBvaW50KGV2OiBNb3VzZUV2ZW50KTogUG9pbnRcclxuICBcdC8vIEdpdmVuIGEgTW91c2VFdmVudCBvYmplY3QsIHJldHVybnMgdGhlIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG9cclxuICBcdC8vIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKSB3aGVyZSB0aGUgZXZlbnQgdG9vayBwbGFjZS5cclxuICBcdG1vdXNlRXZlbnRUb0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHRoaXMubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIG1vdXNlRXZlbnRUb0xhdExuZyhldjogTW91c2VFdmVudCk6IExhdExuZ1xyXG4gIFx0Ly8gR2l2ZW4gYSBNb3VzZUV2ZW50IG9iamVjdCwgcmV0dXJucyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSB3aGVyZSB0aGVcclxuICBcdC8vIGV2ZW50IHRvb2sgcGxhY2UuXHJcbiAgXHRtb3VzZUV2ZW50VG9MYXRMbmc6IGZ1bmN0aW9uIChlKSB7IC8vIChNb3VzZUV2ZW50KVxyXG4gIFx0XHRyZXR1cm4gdGhpcy5sYXllclBvaW50VG9MYXRMbmcodGhpcy5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUpKTtcclxuICBcdH0sXHJcblxyXG5cclxuICBcdC8vIG1hcCBpbml0aWFsaXphdGlvbiBtZXRob2RzXHJcblxyXG4gIFx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uIChpZCkge1xyXG4gIFx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gZ2V0KGlkKTtcclxuXHJcbiAgXHRcdGlmICghY29udGFpbmVyKSB7XHJcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNYXAgY29udGFpbmVyIG5vdCBmb3VuZC4nKTtcclxuICBcdFx0fSBlbHNlIGlmIChjb250YWluZXIuX2xlYWZsZXRfaWQpIHtcclxuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01hcCBjb250YWluZXIgaXMgYWxyZWFkeSBpbml0aWFsaXplZC4nKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0b24oY29udGFpbmVyLCAnc2Nyb2xsJywgdGhpcy5fb25TY3JvbGwsIHRoaXMpO1xyXG4gIFx0XHR0aGlzLl9jb250YWluZXJJZCA9IHN0YW1wKGNvbnRhaW5lcik7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXI7XHJcblxyXG4gIFx0XHR0aGlzLl9mYWRlQW5pbWF0ZWQgPSB0aGlzLm9wdGlvbnMuZmFkZUFuaW1hdGlvbiAmJiBCcm93c2VyLmFueTNkO1xyXG5cclxuICBcdFx0YWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC1jb250YWluZXInICtcclxuICBcdFx0XHQoQnJvd3Nlci50b3VjaCA/ICcgbGVhZmxldC10b3VjaCcgOiAnJykgK1xyXG4gIFx0XHRcdChCcm93c2VyLnJldGluYSA/ICcgbGVhZmxldC1yZXRpbmEnIDogJycpICtcclxuICBcdFx0XHQoQnJvd3Nlci5pZWx0OSA/ICcgbGVhZmxldC1vbGRpZScgOiAnJykgK1xyXG4gIFx0XHRcdChCcm93c2VyLnNhZmFyaSA/ICcgbGVhZmxldC1zYWZhcmknIDogJycpICtcclxuICBcdFx0XHQodGhpcy5fZmFkZUFuaW1hdGVkID8gJyBsZWFmbGV0LWZhZGUtYW5pbScgOiAnJykpO1xyXG5cclxuICBcdFx0dmFyIHBvc2l0aW9uID0gZ2V0U3R5bGUoY29udGFpbmVyLCAncG9zaXRpb24nKTtcclxuXHJcbiAgXHRcdGlmIChwb3NpdGlvbiAhPT0gJ2Fic29sdXRlJyAmJiBwb3NpdGlvbiAhPT0gJ3JlbGF0aXZlJyAmJiBwb3NpdGlvbiAhPT0gJ2ZpeGVkJyAmJiBwb3NpdGlvbiAhPT0gJ3N0aWNreScpIHtcclxuICBcdFx0XHRjb250YWluZXIuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9pbml0UGFuZXMoKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9pbml0Q29udHJvbFBvcykge1xyXG4gIFx0XHRcdHRoaXMuX2luaXRDb250cm9sUG9zKCk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X2luaXRQYW5lczogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgcGFuZXMgPSB0aGlzLl9wYW5lcyA9IHt9O1xyXG4gIFx0XHR0aGlzLl9wYW5lUmVuZGVyZXJzID0ge307XHJcblxyXG4gIFx0XHQvLyBAc2VjdGlvblxyXG4gIFx0XHQvL1xyXG4gIFx0XHQvLyBQYW5lcyBhcmUgRE9NIGVsZW1lbnRzIHVzZWQgdG8gY29udHJvbCB0aGUgb3JkZXJpbmcgb2YgbGF5ZXJzIG9uIHRoZSBtYXAuIFlvdVxyXG4gIFx0XHQvLyBjYW4gYWNjZXNzIHBhbmVzIHdpdGggW2BtYXAuZ2V0UGFuZWBdKCNtYXAtZ2V0cGFuZSkgb3JcclxuICBcdFx0Ly8gW2BtYXAuZ2V0UGFuZXNgXSgjbWFwLWdldHBhbmVzKSBtZXRob2RzLiBOZXcgcGFuZXMgY2FuIGJlIGNyZWF0ZWQgd2l0aCB0aGVcclxuICBcdFx0Ly8gW2BtYXAuY3JlYXRlUGFuZWBdKCNtYXAtY3JlYXRlcGFuZSkgbWV0aG9kLlxyXG4gIFx0XHQvL1xyXG4gIFx0XHQvLyBFdmVyeSBtYXAgaGFzIHRoZSBmb2xsb3dpbmcgZGVmYXVsdCBwYW5lcyB0aGF0IGRpZmZlciBvbmx5IGluIHpJbmRleC5cclxuICBcdFx0Ly9cclxuICBcdFx0Ly8gQHBhbmUgbWFwUGFuZTogSFRNTEVsZW1lbnQgPSAnYXV0bydcclxuICBcdFx0Ly8gUGFuZSB0aGF0IGNvbnRhaW5zIGFsbCBvdGhlciBtYXAgcGFuZXNcclxuXHJcbiAgXHRcdHRoaXMuX21hcFBhbmUgPSB0aGlzLmNyZWF0ZVBhbmUoJ21hcFBhbmUnLCB0aGlzLl9jb250YWluZXIpO1xyXG4gIFx0XHRzZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lLCBuZXcgUG9pbnQoMCwgMCkpO1xyXG5cclxuICBcdFx0Ly8gQHBhbmUgdGlsZVBhbmU6IEhUTUxFbGVtZW50ID0gMjAwXHJcbiAgXHRcdC8vIFBhbmUgZm9yIGBHcmlkTGF5ZXJgcyBhbmQgYFRpbGVMYXllcmBzXHJcbiAgXHRcdHRoaXMuY3JlYXRlUGFuZSgndGlsZVBhbmUnKTtcclxuICBcdFx0Ly8gQHBhbmUgb3ZlcmxheVBhbmU6IEhUTUxFbGVtZW50ID0gNDAwXHJcbiAgXHRcdC8vIFBhbmUgZm9yIHZlY3RvcnMgKGBQYXRoYHMsIGxpa2UgYFBvbHlsaW5lYHMgYW5kIGBQb2x5Z29uYHMpLCBgSW1hZ2VPdmVybGF5YHMgYW5kIGBWaWRlb092ZXJsYXlgc1xyXG4gIFx0XHR0aGlzLmNyZWF0ZVBhbmUoJ292ZXJsYXlQYW5lJyk7XHJcbiAgXHRcdC8vIEBwYW5lIHNoYWRvd1BhbmU6IEhUTUxFbGVtZW50ID0gNTAwXHJcbiAgXHRcdC8vIFBhbmUgZm9yIG92ZXJsYXkgc2hhZG93cyAoZS5nLiBgTWFya2VyYCBzaGFkb3dzKVxyXG4gIFx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3NoYWRvd1BhbmUnKTtcclxuICBcdFx0Ly8gQHBhbmUgbWFya2VyUGFuZTogSFRNTEVsZW1lbnQgPSA2MDBcclxuICBcdFx0Ly8gUGFuZSBmb3IgYEljb25gcyBvZiBgTWFya2VyYHNcclxuICBcdFx0dGhpcy5jcmVhdGVQYW5lKCdtYXJrZXJQYW5lJyk7XHJcbiAgXHRcdC8vIEBwYW5lIHRvb2x0aXBQYW5lOiBIVE1MRWxlbWVudCA9IDY1MFxyXG4gIFx0XHQvLyBQYW5lIGZvciBgVG9vbHRpcGBzLlxyXG4gIFx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3Rvb2x0aXBQYW5lJyk7XHJcbiAgXHRcdC8vIEBwYW5lIHBvcHVwUGFuZTogSFRNTEVsZW1lbnQgPSA3MDBcclxuICBcdFx0Ly8gUGFuZSBmb3IgYFBvcHVwYHMuXHJcbiAgXHRcdHRoaXMuY3JlYXRlUGFuZSgncG9wdXBQYW5lJyk7XHJcblxyXG4gIFx0XHRpZiAoIXRoaXMub3B0aW9ucy5tYXJrZXJab29tQW5pbWF0aW9uKSB7XHJcbiAgXHRcdFx0YWRkQ2xhc3MocGFuZXMubWFya2VyUGFuZSwgJ2xlYWZsZXQtem9vbS1oaWRlJyk7XHJcbiAgXHRcdFx0YWRkQ2xhc3MocGFuZXMuc2hhZG93UGFuZSwgJ2xlYWZsZXQtem9vbS1oaWRlJyk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG5cclxuICBcdC8vIHByaXZhdGUgbWV0aG9kcyB0aGF0IG1vZGlmeSBtYXAgc3RhdGVcclxuXHJcbiAgXHQvLyBAc2VjdGlvbiBNYXAgc3RhdGUgY2hhbmdlIGV2ZW50c1xyXG4gIFx0X3Jlc2V0VmlldzogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgbm9Nb3ZlU3RhcnQpIHtcclxuICBcdFx0c2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSwgbmV3IFBvaW50KDAsIDApKTtcclxuXHJcbiAgXHRcdHZhciBsb2FkaW5nID0gIXRoaXMuX2xvYWRlZDtcclxuICBcdFx0dGhpcy5fbG9hZGVkID0gdHJ1ZTtcclxuICBcdFx0em9vbSA9IHRoaXMuX2xpbWl0Wm9vbSh6b29tKTtcclxuXHJcbiAgXHRcdHRoaXMuZmlyZSgndmlld3ByZXJlc2V0Jyk7XHJcblxyXG4gIFx0XHR2YXIgem9vbUNoYW5nZWQgPSB0aGlzLl96b29tICE9PSB6b29tO1xyXG4gIFx0XHR0aGlzXHJcbiAgXHRcdFx0Ll9tb3ZlU3RhcnQoem9vbUNoYW5nZWQsIG5vTW92ZVN0YXJ0KVxyXG4gIFx0XHRcdC5fbW92ZShjZW50ZXIsIHpvb20pXHJcbiAgXHRcdFx0Ll9tb3ZlRW5kKHpvb21DaGFuZ2VkKTtcclxuXHJcbiAgXHRcdC8vIEBldmVudCB2aWV3cmVzZXQ6IEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBuZWVkcyB0byByZWRyYXcgaXRzIGNvbnRlbnQgKHRoaXMgdXN1YWxseSBoYXBwZW5zXHJcbiAgXHRcdC8vIG9uIG1hcCB6b29tIG9yIGxvYWQpLiBWZXJ5IHVzZWZ1bCBmb3IgY3JlYXRpbmcgY3VzdG9tIG92ZXJsYXlzLlxyXG4gIFx0XHR0aGlzLmZpcmUoJ3ZpZXdyZXNldCcpO1xyXG5cclxuICBcdFx0Ly8gQGV2ZW50IGxvYWQ6IEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBpcyBpbml0aWFsaXplZCAod2hlbiBpdHMgY2VudGVyIGFuZCB6b29tIGFyZSBzZXRcclxuICBcdFx0Ly8gZm9yIHRoZSBmaXJzdCB0aW1lKS5cclxuICBcdFx0aWYgKGxvYWRpbmcpIHtcclxuICBcdFx0XHR0aGlzLmZpcmUoJ2xvYWQnKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfbW92ZVN0YXJ0OiBmdW5jdGlvbiAoem9vbUNoYW5nZWQsIG5vTW92ZVN0YXJ0KSB7XHJcbiAgXHRcdC8vIEBldmVudCB6b29tc3RhcnQ6IEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCB6b29tIGlzIGFib3V0IHRvIGNoYW5nZSAoZS5nLiBiZWZvcmUgem9vbSBhbmltYXRpb24pLlxyXG4gIFx0XHQvLyBAZXZlbnQgbW92ZXN0YXJ0OiBFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSB2aWV3IG9mIHRoZSBtYXAgc3RhcnRzIGNoYW5naW5nIChlLmcuIHVzZXIgc3RhcnRzIGRyYWdnaW5nIHRoZSBtYXApLlxyXG4gIFx0XHRpZiAoem9vbUNoYW5nZWQpIHtcclxuICBcdFx0XHR0aGlzLmZpcmUoJ3pvb21zdGFydCcpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdGlmICghbm9Nb3ZlU3RhcnQpIHtcclxuICBcdFx0XHR0aGlzLmZpcmUoJ21vdmVzdGFydCcpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfbW92ZTogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgZGF0YSwgc3VwcmVzc0V2ZW50KSB7XHJcbiAgXHRcdGlmICh6b29tID09PSB1bmRlZmluZWQpIHtcclxuICBcdFx0XHR6b29tID0gdGhpcy5fem9vbTtcclxuICBcdFx0fVxyXG4gIFx0XHR2YXIgem9vbUNoYW5nZWQgPSB0aGlzLl96b29tICE9PSB6b29tO1xyXG5cclxuICBcdFx0dGhpcy5fem9vbSA9IHpvb207XHJcbiAgXHRcdHRoaXMuX2xhc3RDZW50ZXIgPSBjZW50ZXI7XHJcbiAgXHRcdHRoaXMuX3BpeGVsT3JpZ2luID0gdGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyKTtcclxuXHJcbiAgXHRcdGlmICghc3VwcmVzc0V2ZW50KSB7XHJcbiAgXHRcdFx0Ly8gQGV2ZW50IHpvb206IEV2ZW50XHJcbiAgXHRcdFx0Ly8gRmlyZWQgcmVwZWF0ZWRseSBkdXJpbmcgYW55IGNoYW5nZSBpbiB6b29tIGxldmVsLFxyXG4gIFx0XHRcdC8vIGluY2x1ZGluZyB6b29tIGFuZCBmbHkgYW5pbWF0aW9ucy5cclxuICBcdFx0XHRpZiAoem9vbUNoYW5nZWQgfHwgKGRhdGEgJiYgZGF0YS5waW5jaCkpIHtcdC8vIEFsd2F5cyBmaXJlICd6b29tJyBpZiBwaW5jaGluZyBiZWNhdXNlICMzNTMwXHJcbiAgXHRcdFx0XHR0aGlzLmZpcmUoJ3pvb20nLCBkYXRhKTtcclxuICBcdFx0XHR9XHJcblxyXG4gIFx0XHRcdC8vIEBldmVudCBtb3ZlOiBFdmVudFxyXG4gIFx0XHRcdC8vIEZpcmVkIHJlcGVhdGVkbHkgZHVyaW5nIGFueSBtb3ZlbWVudCBvZiB0aGUgbWFwLFxyXG4gIFx0XHRcdC8vIGluY2x1ZGluZyBwYW4gYW5kIGZseSBhbmltYXRpb25zLlxyXG4gIFx0XHRcdHRoaXMuZmlyZSgnbW92ZScsIGRhdGEpO1xyXG4gIFx0XHR9IGVsc2UgaWYgKGRhdGEgJiYgZGF0YS5waW5jaCkge1x0Ly8gQWx3YXlzIGZpcmUgJ3pvb20nIGlmIHBpbmNoaW5nIGJlY2F1c2UgIzM1MzBcclxuICBcdFx0XHR0aGlzLmZpcmUoJ3pvb20nLCBkYXRhKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X21vdmVFbmQ6IGZ1bmN0aW9uICh6b29tQ2hhbmdlZCkge1xyXG4gIFx0XHQvLyBAZXZlbnQgem9vbWVuZDogRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIHpvb20gY2hhbmdlZCwgYWZ0ZXIgYW55IGFuaW1hdGlvbnMuXHJcbiAgXHRcdGlmICh6b29tQ2hhbmdlZCkge1xyXG4gIFx0XHRcdHRoaXMuZmlyZSgnem9vbWVuZCcpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBAZXZlbnQgbW92ZWVuZDogRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgY2VudGVyIG9mIHRoZSBtYXAgc3RvcHMgY2hhbmdpbmdcclxuICBcdFx0Ly8gKGUuZy4gdXNlciBzdG9wcGVkIGRyYWdnaW5nIHRoZSBtYXAgb3IgYWZ0ZXIgbm9uLWNlbnRlcmVkIHpvb20pLlxyXG4gIFx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9zdG9wOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9mbHlUb0ZyYW1lKTtcclxuICBcdFx0aWYgKHRoaXMuX3BhbkFuaW0pIHtcclxuICBcdFx0XHR0aGlzLl9wYW5BbmltLnN0b3AoKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X3Jhd1BhbkJ5OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcbiAgXHRcdHNldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUsIHRoaXMuX2dldE1hcFBhbmVQb3MoKS5zdWJ0cmFjdChvZmZzZXQpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2dldFpvb21TcGFuOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmdldE1heFpvb20oKSAtIHRoaXMuZ2V0TWluWm9vbSgpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfcGFuSW5zaWRlTWF4Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fZW5mb3JjaW5nQm91bmRzKSB7XHJcbiAgXHRcdFx0dGhpcy5wYW5JbnNpZGVCb3VuZHModGhpcy5vcHRpb25zLm1heEJvdW5kcyk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X2NoZWNrSWZMb2FkZWQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9sb2FkZWQpIHtcclxuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1NldCBtYXAgY2VudGVyIGFuZCB6b29tIGZpcnN0LicpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIERPTSBldmVudCBoYW5kbGluZ1xyXG5cclxuICBcdC8vIEBzZWN0aW9uIEludGVyYWN0aW9uIGV2ZW50c1xyXG4gIFx0X2luaXRFdmVudHM6IGZ1bmN0aW9uIChyZW1vdmUpIHtcclxuICBcdFx0dGhpcy5fdGFyZ2V0cyA9IHt9O1xyXG4gIFx0XHR0aGlzLl90YXJnZXRzW3N0YW1wKHRoaXMuX2NvbnRhaW5lcildID0gdGhpcztcclxuXHJcbiAgXHRcdHZhciBvbk9mZiA9IHJlbW92ZSA/IG9mZiA6IG9uO1xyXG5cclxuICBcdFx0Ly8gQGV2ZW50IGNsaWNrOiBNb3VzZUV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIChvciB0YXBzKSB0aGUgbWFwLlxyXG4gIFx0XHQvLyBAZXZlbnQgZGJsY2xpY2s6IE1vdXNlRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBkb3VibGUtY2xpY2tzIChvciBkb3VibGUtdGFwcykgdGhlIG1hcC5cclxuICBcdFx0Ly8gQGV2ZW50IG1vdXNlZG93bjogTW91c2VFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHB1c2hlcyB0aGUgbW91c2UgYnV0dG9uIG9uIHRoZSBtYXAuXHJcbiAgXHRcdC8vIEBldmVudCBtb3VzZXVwOiBNb3VzZUV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcmVsZWFzZXMgdGhlIG1vdXNlIGJ1dHRvbiBvbiB0aGUgbWFwLlxyXG4gIFx0XHQvLyBAZXZlbnQgbW91c2VvdmVyOiBNb3VzZUV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1vdXNlIGVudGVycyB0aGUgbWFwLlxyXG4gIFx0XHQvLyBAZXZlbnQgbW91c2VvdXQ6IE1vdXNlRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbW91c2UgbGVhdmVzIHRoZSBtYXAuXHJcbiAgXHRcdC8vIEBldmVudCBtb3VzZW1vdmU6IE1vdXNlRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hpbGUgdGhlIG1vdXNlIG1vdmVzIG92ZXIgdGhlIG1hcC5cclxuICBcdFx0Ly8gQGV2ZW50IGNvbnRleHRtZW51OiBNb3VzZUV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHVzaGVzIHRoZSByaWdodCBtb3VzZSBidXR0b24gb24gdGhlIG1hcCwgcHJldmVudHNcclxuICBcdFx0Ly8gZGVmYXVsdCBicm93c2VyIGNvbnRleHQgbWVudSBmcm9tIHNob3dpbmcgaWYgdGhlcmUgYXJlIGxpc3RlbmVycyBvblxyXG4gIFx0XHQvLyB0aGlzIGV2ZW50LiBBbHNvIGZpcmVkIG9uIG1vYmlsZSB3aGVuIHRoZSB1c2VyIGhvbGRzIGEgc2luZ2xlIHRvdWNoXHJcbiAgXHRcdC8vIGZvciBhIHNlY29uZCAoYWxzbyBjYWxsZWQgbG9uZyBwcmVzcykuXHJcbiAgXHRcdC8vIEBldmVudCBrZXlwcmVzczogS2V5Ym9hcmRFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHByZXNzZXMgYSBrZXkgZnJvbSB0aGUga2V5Ym9hcmQgdGhhdCBwcm9kdWNlcyBhIGNoYXJhY3RlciB2YWx1ZSB3aGlsZSB0aGUgbWFwIGlzIGZvY3VzZWQuXHJcbiAgXHRcdC8vIEBldmVudCBrZXlkb3duOiBLZXlib2FyZEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyBhIGtleSBmcm9tIHRoZSBrZXlib2FyZCB3aGlsZSB0aGUgbWFwIGlzIGZvY3VzZWQuIFVubGlrZSB0aGUgYGtleXByZXNzYCBldmVudCxcclxuICBcdFx0Ly8gdGhlIGBrZXlkb3duYCBldmVudCBpcyBmaXJlZCBmb3Iga2V5cyB0aGF0IHByb2R1Y2UgYSBjaGFyYWN0ZXIgdmFsdWUgYW5kIGZvciBrZXlzXHJcbiAgXHRcdC8vIHRoYXQgZG8gbm90IHByb2R1Y2UgYSBjaGFyYWN0ZXIgdmFsdWUuXHJcbiAgXHRcdC8vIEBldmVudCBrZXl1cDogS2V5Ym9hcmRFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHJlbGVhc2VzIGEga2V5IGZyb20gdGhlIGtleWJvYXJkIHdoaWxlIHRoZSBtYXAgaXMgZm9jdXNlZC5cclxuICBcdFx0b25PZmYodGhpcy5fY29udGFpbmVyLCAnY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgJyArXHJcbiAgXHRcdFx0J21vdXNlb3ZlciBtb3VzZW91dCBtb3VzZW1vdmUgY29udGV4dG1lbnUga2V5cHJlc3Mga2V5ZG93biBrZXl1cCcsIHRoaXMuX2hhbmRsZURPTUV2ZW50LCB0aGlzKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMudHJhY2tSZXNpemUpIHtcclxuICBcdFx0XHRvbk9mZih3aW5kb3csICdyZXNpemUnLCB0aGlzLl9vblJlc2l6ZSwgdGhpcyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChCcm93c2VyLmFueTNkICYmIHRoaXMub3B0aW9ucy50cmFuc2Zvcm0zRExpbWl0KSB7XHJcbiAgXHRcdFx0KHJlbW92ZSA/IHRoaXMub2ZmIDogdGhpcy5vbikuY2FsbCh0aGlzLCAnbW92ZWVuZCcsIHRoaXMuX29uTW92ZUVuZCk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X29uUmVzaXplOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9yZXNpemVSZXF1ZXN0KTtcclxuICBcdFx0dGhpcy5fcmVzaXplUmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUoXHJcbiAgXHRcdCAgICAgICAgZnVuY3Rpb24gKCkgeyB0aGlzLmludmFsaWRhdGVTaXplKHtkZWJvdW5jZU1vdmVlbmQ6IHRydWV9KTsgfSwgdGhpcyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9vblNjcm9sbDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR0aGlzLl9jb250YWluZXIuc2Nyb2xsVG9wICA9IDA7XHJcbiAgXHRcdHRoaXMuX2NvbnRhaW5lci5zY3JvbGxMZWZ0ID0gMDtcclxuICBcdH0sXHJcblxyXG4gIFx0X29uTW92ZUVuZDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgcG9zID0gdGhpcy5fZ2V0TWFwUGFuZVBvcygpO1xyXG4gIFx0XHRpZiAoTWF0aC5tYXgoTWF0aC5hYnMocG9zLngpLCBNYXRoLmFicyhwb3MueSkpID49IHRoaXMub3B0aW9ucy50cmFuc2Zvcm0zRExpbWl0KSB7XHJcbiAgXHRcdFx0Ly8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTIwMzg3MyBidXQgV2Via2l0IGFsc28gaGF2ZVxyXG4gIFx0XHRcdC8vIGEgcGl4ZWwgb2Zmc2V0IG9uIHZlcnkgaGlnaCB2YWx1ZXMsIHNlZTogaHR0cHM6Ly9qc2ZpZGRsZS5uZXQvZGc2cjVoaGIvXHJcbiAgXHRcdFx0dGhpcy5fcmVzZXRWaWV3KHRoaXMuZ2V0Q2VudGVyKCksIHRoaXMuZ2V0Wm9vbSgpKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfZmluZEV2ZW50VGFyZ2V0czogZnVuY3Rpb24gKGUsIHR5cGUpIHtcclxuICBcdFx0dmFyIHRhcmdldHMgPSBbXSxcclxuICBcdFx0ICAgIHRhcmdldCxcclxuICBcdFx0ICAgIGlzSG92ZXIgPSB0eXBlID09PSAnbW91c2VvdXQnIHx8IHR5cGUgPT09ICdtb3VzZW92ZXInLFxyXG4gIFx0XHQgICAgc3JjID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50LFxyXG4gIFx0XHQgICAgZHJhZ2dpbmcgPSBmYWxzZTtcclxuXHJcbiAgXHRcdHdoaWxlIChzcmMpIHtcclxuICBcdFx0XHR0YXJnZXQgPSB0aGlzLl90YXJnZXRzW3N0YW1wKHNyYyldO1xyXG4gIFx0XHRcdGlmICh0YXJnZXQgJiYgKHR5cGUgPT09ICdjbGljaycgfHwgdHlwZSA9PT0gJ3ByZWNsaWNrJykgJiYgdGhpcy5fZHJhZ2dhYmxlTW92ZWQodGFyZ2V0KSkge1xyXG4gIFx0XHRcdFx0Ly8gUHJldmVudCBmaXJpbmcgY2xpY2sgYWZ0ZXIgeW91IGp1c3QgZHJhZ2dlZCBhbiBvYmplY3QuXHJcbiAgXHRcdFx0XHRkcmFnZ2luZyA9IHRydWU7XHJcbiAgXHRcdFx0XHRicmVhaztcclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0aWYgKHRhcmdldCAmJiB0YXJnZXQubGlzdGVucyh0eXBlLCB0cnVlKSkge1xyXG4gIFx0XHRcdFx0aWYgKGlzSG92ZXIgJiYgIWlzRXh0ZXJuYWxUYXJnZXQoc3JjLCBlKSkgeyBicmVhazsgfVxyXG4gIFx0XHRcdFx0dGFyZ2V0cy5wdXNoKHRhcmdldCk7XHJcbiAgXHRcdFx0XHRpZiAoaXNIb3ZlcikgeyBicmVhazsgfVxyXG4gIFx0XHRcdH1cclxuICBcdFx0XHRpZiAoc3JjID09PSB0aGlzLl9jb250YWluZXIpIHsgYnJlYWs7IH1cclxuICBcdFx0XHRzcmMgPSBzcmMucGFyZW50Tm9kZTtcclxuICBcdFx0fVxyXG4gIFx0XHRpZiAoIXRhcmdldHMubGVuZ3RoICYmICFkcmFnZ2luZyAmJiAhaXNIb3ZlciAmJiB0aGlzLmxpc3RlbnModHlwZSwgdHJ1ZSkpIHtcclxuICBcdFx0XHR0YXJnZXRzID0gW3RoaXNdO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0YXJnZXRzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfaXNDbGlja0Rpc2FibGVkOiBmdW5jdGlvbiAoZWwpIHtcclxuICBcdFx0d2hpbGUgKGVsICYmIGVsICE9PSB0aGlzLl9jb250YWluZXIpIHtcclxuICBcdFx0XHRpZiAoZWxbJ19sZWFmbGV0X2Rpc2FibGVfY2xpY2snXSkgeyByZXR1cm4gdHJ1ZTsgfVxyXG4gIFx0XHRcdGVsID0gZWwucGFyZW50Tm9kZTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfaGFuZGxlRE9NRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdHZhciBlbCA9IChlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQpO1xyXG4gIFx0XHRpZiAoIXRoaXMuX2xvYWRlZCB8fCBlbFsnX2xlYWZsZXRfZGlzYWJsZV9ldmVudHMnXSB8fCBlLnR5cGUgPT09ICdjbGljaycgJiYgdGhpcy5faXNDbGlja0Rpc2FibGVkKGVsKSkge1xyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIHR5cGUgPSBlLnR5cGU7XHJcblxyXG4gIFx0XHRpZiAodHlwZSA9PT0gJ21vdXNlZG93bicpIHtcclxuICBcdFx0XHQvLyBwcmV2ZW50cyBvdXRsaW5lIHdoZW4gY2xpY2tpbmcgb24ga2V5Ym9hcmQtZm9jdXNhYmxlIGVsZW1lbnRcclxuICBcdFx0XHRwcmV2ZW50T3V0bGluZShlbCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2ZpcmVET01FdmVudChlLCB0eXBlKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X21vdXNlRXZlbnRzOiBbJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNlb3ZlcicsICdtb3VzZW91dCcsICdjb250ZXh0bWVudSddLFxyXG5cclxuICBcdF9maXJlRE9NRXZlbnQ6IGZ1bmN0aW9uIChlLCB0eXBlLCBjYW52YXNUYXJnZXRzKSB7XHJcblxyXG4gIFx0XHRpZiAoZS50eXBlID09PSAnY2xpY2snKSB7XHJcbiAgXHRcdFx0Ly8gRmlyZSBhIHN5bnRoZXRpYyAncHJlY2xpY2snIGV2ZW50IHdoaWNoIHByb3BhZ2F0ZXMgdXAgKG1haW5seSBmb3IgY2xvc2luZyBwb3B1cHMpLlxyXG4gIFx0XHRcdC8vIEBldmVudCBwcmVjbGljazogTW91c2VFdmVudFxyXG4gIFx0XHRcdC8vIEZpcmVkIGJlZm9yZSBtb3VzZSBjbGljayBvbiB0aGUgbWFwIChzb21ldGltZXMgdXNlZnVsIHdoZW4geW91XHJcbiAgXHRcdFx0Ly8gd2FudCBzb21ldGhpbmcgdG8gaGFwcGVuIG9uIGNsaWNrIGJlZm9yZSBhbnkgZXhpc3RpbmcgY2xpY2tcclxuICBcdFx0XHQvLyBoYW5kbGVycyBzdGFydCBydW5uaW5nKS5cclxuICBcdFx0XHR2YXIgc3ludGggPSBleHRlbmQoe30sIGUpO1xyXG4gIFx0XHRcdHN5bnRoLnR5cGUgPSAncHJlY2xpY2snO1xyXG4gIFx0XHRcdHRoaXMuX2ZpcmVET01FdmVudChzeW50aCwgc3ludGgudHlwZSwgY2FudmFzVGFyZ2V0cyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIEZpbmQgdGhlIGxheWVyIHRoZSBldmVudCBpcyBwcm9wYWdhdGluZyBmcm9tIGFuZCBpdHMgcGFyZW50cy5cclxuICBcdFx0dmFyIHRhcmdldHMgPSB0aGlzLl9maW5kRXZlbnRUYXJnZXRzKGUsIHR5cGUpO1xyXG5cclxuICBcdFx0aWYgKGNhbnZhc1RhcmdldHMpIHtcclxuICBcdFx0XHR2YXIgZmlsdGVyZWQgPSBbXTsgLy8gcGljayBvbmx5IHRhcmdldHMgd2l0aCBsaXN0ZW5lcnNcclxuICBcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNhbnZhc1RhcmdldHMubGVuZ3RoOyBpKyspIHtcclxuICBcdFx0XHRcdGlmIChjYW52YXNUYXJnZXRzW2ldLmxpc3RlbnModHlwZSwgdHJ1ZSkpIHtcclxuICBcdFx0XHRcdFx0ZmlsdGVyZWQucHVzaChjYW52YXNUYXJnZXRzW2ldKTtcclxuICBcdFx0XHRcdH1cclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0dGFyZ2V0cyA9IGZpbHRlcmVkLmNvbmNhdCh0YXJnZXRzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKCF0YXJnZXRzLmxlbmd0aCkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdGlmICh0eXBlID09PSAnY29udGV4dG1lbnUnKSB7XHJcbiAgXHRcdFx0cHJldmVudERlZmF1bHQoZSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciB0YXJnZXQgPSB0YXJnZXRzWzBdO1xyXG4gIFx0XHR2YXIgZGF0YSA9IHtcclxuICBcdFx0XHRvcmlnaW5hbEV2ZW50OiBlXHJcbiAgXHRcdH07XHJcblxyXG4gIFx0XHRpZiAoZS50eXBlICE9PSAna2V5cHJlc3MnICYmIGUudHlwZSAhPT0gJ2tleWRvd24nICYmIGUudHlwZSAhPT0gJ2tleXVwJykge1xyXG4gIFx0XHRcdHZhciBpc01hcmtlciA9IHRhcmdldC5nZXRMYXRMbmcgJiYgKCF0YXJnZXQuX3JhZGl1cyB8fCB0YXJnZXQuX3JhZGl1cyA8PSAxMCk7XHJcbiAgXHRcdFx0ZGF0YS5jb250YWluZXJQb2ludCA9IGlzTWFya2VyID9cclxuICBcdFx0XHRcdHRoaXMubGF0TG5nVG9Db250YWluZXJQb2ludCh0YXJnZXQuZ2V0TGF0TG5nKCkpIDogdGhpcy5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcclxuICBcdFx0XHRkYXRhLmxheWVyUG9pbnQgPSB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KGRhdGEuY29udGFpbmVyUG9pbnQpO1xyXG4gIFx0XHRcdGRhdGEubGF0bG5nID0gaXNNYXJrZXIgPyB0YXJnZXQuZ2V0TGF0TG5nKCkgOiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyhkYXRhLmxheWVyUG9pbnQpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRmb3IgKGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xyXG4gIFx0XHRcdHRhcmdldHNbaV0uZmlyZSh0eXBlLCBkYXRhLCB0cnVlKTtcclxuICBcdFx0XHRpZiAoZGF0YS5vcmlnaW5hbEV2ZW50Ll9zdG9wcGVkIHx8XHJcbiAgXHRcdFx0XHQodGFyZ2V0c1tpXS5vcHRpb25zLmJ1YmJsaW5nTW91c2VFdmVudHMgPT09IGZhbHNlICYmIGluZGV4T2YodGhpcy5fbW91c2VFdmVudHMsIHR5cGUpICE9PSAtMSkpIHsgcmV0dXJuOyB9XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X2RyYWdnYWJsZU1vdmVkOiBmdW5jdGlvbiAob2JqKSB7XHJcbiAgXHRcdG9iaiA9IG9iai5kcmFnZ2luZyAmJiBvYmouZHJhZ2dpbmcuZW5hYmxlZCgpID8gb2JqIDogdGhpcztcclxuICBcdFx0cmV0dXJuIChvYmouZHJhZ2dpbmcgJiYgb2JqLmRyYWdnaW5nLm1vdmVkKCkpIHx8ICh0aGlzLmJveFpvb20gJiYgdGhpcy5ib3hab29tLm1vdmVkKCkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfY2xlYXJIYW5kbGVyczogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5faGFuZGxlcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0XHR0aGlzLl9oYW5kbGVyc1tpXS5kaXNhYmxlKCk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xyXG5cclxuICBcdC8vIEBtZXRob2Qgd2hlblJlYWR5KGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuICBcdC8vIFJ1bnMgdGhlIGdpdmVuIGZ1bmN0aW9uIGBmbmAgd2hlbiB0aGUgbWFwIGdldHMgaW5pdGlhbGl6ZWQgd2l0aFxyXG4gIFx0Ly8gYSB2aWV3IChjZW50ZXIgYW5kIHpvb20pIGFuZCBhdCBsZWFzdCBvbmUgbGF5ZXIsIG9yIGltbWVkaWF0ZWx5XHJcbiAgXHQvLyBpZiBpdCdzIGFscmVhZHkgaW5pdGlhbGl6ZWQsIG9wdGlvbmFsbHkgcGFzc2luZyBhIGZ1bmN0aW9uIGNvbnRleHQuXHJcbiAgXHR3aGVuUmVhZHk6IGZ1bmN0aW9uIChjYWxsYmFjaywgY29udGV4dCkge1xyXG4gIFx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XHJcbiAgXHRcdFx0Y2FsbGJhY2suY2FsbChjb250ZXh0IHx8IHRoaXMsIHt0YXJnZXQ6IHRoaXN9KTtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHR0aGlzLm9uKCdsb2FkJywgY2FsbGJhY2ssIGNvbnRleHQpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcblxyXG4gIFx0Ly8gcHJpdmF0ZSBtZXRob2RzIGZvciBnZXR0aW5nIG1hcCBzdGF0ZVxyXG5cclxuICBcdF9nZXRNYXBQYW5lUG9zOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiBnZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lKSB8fCBuZXcgUG9pbnQoMCwgMCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9tb3ZlZDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgcG9zID0gdGhpcy5fZ2V0TWFwUGFuZVBvcygpO1xyXG4gIFx0XHRyZXR1cm4gcG9zICYmICFwb3MuZXF1YWxzKFswLCAwXSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9nZXRUb3BMZWZ0UG9pbnQ6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuICBcdFx0dmFyIHBpeGVsT3JpZ2luID0gY2VudGVyICYmIHpvb20gIT09IHVuZGVmaW5lZCA/XHJcbiAgXHRcdFx0dGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKSA6XHJcbiAgXHRcdFx0dGhpcy5nZXRQaXhlbE9yaWdpbigpO1xyXG4gIFx0XHRyZXR1cm4gcGl4ZWxPcmlnaW4uc3VidHJhY3QodGhpcy5fZ2V0TWFwUGFuZVBvcygpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2dldE5ld1BpeGVsT3JpZ2luOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XHJcbiAgXHRcdHZhciB2aWV3SGFsZiA9IHRoaXMuZ2V0U2l6ZSgpLl9kaXZpZGVCeSgyKTtcclxuICBcdFx0cmV0dXJuIHRoaXMucHJvamVjdChjZW50ZXIsIHpvb20pLl9zdWJ0cmFjdCh2aWV3SGFsZikuX2FkZCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpLl9yb3VuZCgpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfbGF0TG5nVG9OZXdMYXllclBvaW50OiBmdW5jdGlvbiAobGF0bG5nLCB6b29tLCBjZW50ZXIpIHtcclxuICBcdFx0dmFyIHRvcExlZnQgPSB0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pO1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0KGxhdGxuZywgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfbGF0TG5nQm91bmRzVG9OZXdMYXllckJvdW5kczogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcywgem9vbSwgY2VudGVyKSB7XHJcbiAgXHRcdHZhciB0b3BMZWZ0ID0gdGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKTtcclxuICBcdFx0cmV0dXJuIHRvQm91bmRzKFtcclxuICBcdFx0XHR0aGlzLnByb2plY3QobGF0TG5nQm91bmRzLmdldFNvdXRoV2VzdCgpLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdCksXHJcbiAgXHRcdFx0dGhpcy5wcm9qZWN0KGxhdExuZ0JvdW5kcy5nZXROb3J0aFdlc3QoKSwgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpLFxyXG4gIFx0XHRcdHRoaXMucHJvamVjdChsYXRMbmdCb3VuZHMuZ2V0U291dGhFYXN0KCksIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KSxcclxuICBcdFx0XHR0aGlzLnByb2plY3QobGF0TG5nQm91bmRzLmdldE5vcnRoRWFzdCgpLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdClcclxuICBcdFx0XSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIGxheWVyIHBvaW50IG9mIHRoZSBjdXJyZW50IGNlbnRlclxyXG4gIFx0X2dldENlbnRlckxheWVyUG9pbnQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQodGhpcy5nZXRTaXplKCkuX2RpdmlkZUJ5KDIpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gb2Zmc2V0IG9mIHRoZSBzcGVjaWZpZWQgcGxhY2UgdG8gdGhlIGN1cnJlbnQgY2VudGVyIGluIHBpeGVsc1xyXG4gIFx0X2dldENlbnRlck9mZnNldDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nKS5zdWJ0cmFjdCh0aGlzLl9nZXRDZW50ZXJMYXllclBvaW50KCkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBhZGp1c3QgY2VudGVyIGZvciB2aWV3IHRvIGdldCBpbnNpZGUgYm91bmRzXHJcbiAgXHRfbGltaXRDZW50ZXI6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIGJvdW5kcykge1xyXG5cclxuICBcdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIGNlbnRlcjsgfVxyXG5cclxuICBcdFx0dmFyIGNlbnRlclBvaW50ID0gdGhpcy5wcm9qZWN0KGNlbnRlciwgem9vbSksXHJcbiAgXHRcdCAgICB2aWV3SGFsZiA9IHRoaXMuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxyXG4gIFx0XHQgICAgdmlld0JvdW5kcyA9IG5ldyBCb3VuZHMoY2VudGVyUG9pbnQuc3VidHJhY3Qodmlld0hhbGYpLCBjZW50ZXJQb2ludC5hZGQodmlld0hhbGYpKSxcclxuICBcdFx0ICAgIG9mZnNldCA9IHRoaXMuX2dldEJvdW5kc09mZnNldCh2aWV3Qm91bmRzLCBib3VuZHMsIHpvb20pO1xyXG5cclxuICBcdFx0Ly8gSWYgb2Zmc2V0IGlzIGxlc3MgdGhhbiBhIHBpeGVsLCBpZ25vcmUuXHJcbiAgXHRcdC8vIFRoaXMgcHJldmVudHMgdW5zdGFibGUgcHJvamVjdGlvbnMgZnJvbSBnZXR0aW5nIGludG9cclxuICBcdFx0Ly8gYW4gaW5maW5pdGUgbG9vcCBvZiB0aW55IG9mZnNldHMuXHJcbiAgXHRcdGlmIChNYXRoLmFicyhvZmZzZXQueCkgPD0gMSAmJiBNYXRoLmFicyhvZmZzZXQueSkgPD0gMSkge1xyXG4gIFx0XHRcdHJldHVybiBjZW50ZXI7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzLnVucHJvamVjdChjZW50ZXJQb2ludC5hZGQob2Zmc2V0KSwgem9vbSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIGFkanVzdCBvZmZzZXQgZm9yIHZpZXcgdG8gZ2V0IGluc2lkZSBib3VuZHNcclxuICBcdF9saW1pdE9mZnNldDogZnVuY3Rpb24gKG9mZnNldCwgYm91bmRzKSB7XHJcbiAgXHRcdGlmICghYm91bmRzKSB7IHJldHVybiBvZmZzZXQ7IH1cclxuXHJcbiAgXHRcdHZhciB2aWV3Qm91bmRzID0gdGhpcy5nZXRQaXhlbEJvdW5kcygpLFxyXG4gIFx0XHQgICAgbmV3Qm91bmRzID0gbmV3IEJvdW5kcyh2aWV3Qm91bmRzLm1pbi5hZGQob2Zmc2V0KSwgdmlld0JvdW5kcy5tYXguYWRkKG9mZnNldCkpO1xyXG5cclxuICBcdFx0cmV0dXJuIG9mZnNldC5hZGQodGhpcy5fZ2V0Qm91bmRzT2Zmc2V0KG5ld0JvdW5kcywgYm91bmRzKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIHJldHVybnMgb2Zmc2V0IG5lZWRlZCBmb3IgcHhCb3VuZHMgdG8gZ2V0IGluc2lkZSBtYXhCb3VuZHMgYXQgYSBzcGVjaWZpZWQgem9vbVxyXG4gIFx0X2dldEJvdW5kc09mZnNldDogZnVuY3Rpb24gKHB4Qm91bmRzLCBtYXhCb3VuZHMsIHpvb20pIHtcclxuICBcdFx0dmFyIHByb2plY3RlZE1heEJvdW5kcyA9IHRvQm91bmRzKFxyXG4gIFx0XHQgICAgICAgIHRoaXMucHJvamVjdChtYXhCb3VuZHMuZ2V0Tm9ydGhFYXN0KCksIHpvb20pLFxyXG4gIFx0XHQgICAgICAgIHRoaXMucHJvamVjdChtYXhCb3VuZHMuZ2V0U291dGhXZXN0KCksIHpvb20pXHJcbiAgXHRcdCAgICApLFxyXG4gIFx0XHQgICAgbWluT2Zmc2V0ID0gcHJvamVjdGVkTWF4Qm91bmRzLm1pbi5zdWJ0cmFjdChweEJvdW5kcy5taW4pLFxyXG4gIFx0XHQgICAgbWF4T2Zmc2V0ID0gcHJvamVjdGVkTWF4Qm91bmRzLm1heC5zdWJ0cmFjdChweEJvdW5kcy5tYXgpLFxyXG5cclxuICBcdFx0ICAgIGR4ID0gdGhpcy5fcmVib3VuZChtaW5PZmZzZXQueCwgLW1heE9mZnNldC54KSxcclxuICBcdFx0ICAgIGR5ID0gdGhpcy5fcmVib3VuZChtaW5PZmZzZXQueSwgLW1heE9mZnNldC55KTtcclxuXHJcbiAgXHRcdHJldHVybiBuZXcgUG9pbnQoZHgsIGR5KTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3JlYm91bmQ6IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xyXG4gIFx0XHRyZXR1cm4gbGVmdCArIHJpZ2h0ID4gMCA/XHJcbiAgXHRcdFx0TWF0aC5yb3VuZChsZWZ0IC0gcmlnaHQpIC8gMiA6XHJcbiAgXHRcdFx0TWF0aC5tYXgoMCwgTWF0aC5jZWlsKGxlZnQpKSAtIE1hdGgubWF4KDAsIE1hdGguZmxvb3IocmlnaHQpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2xpbWl0Wm9vbTogZnVuY3Rpb24gKHpvb20pIHtcclxuICBcdFx0dmFyIG1pbiA9IHRoaXMuZ2V0TWluWm9vbSgpLFxyXG4gIFx0XHQgICAgbWF4ID0gdGhpcy5nZXRNYXhab29tKCksXHJcbiAgXHRcdCAgICBzbmFwID0gQnJvd3Nlci5hbnkzZCA/IHRoaXMub3B0aW9ucy56b29tU25hcCA6IDE7XHJcbiAgXHRcdGlmIChzbmFwKSB7XHJcbiAgXHRcdFx0em9vbSA9IE1hdGgucm91bmQoem9vbSAvIHNuYXApICogc25hcDtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHpvb20pKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X29uUGFuVHJhbnNpdGlvblN0ZXA6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dGhpcy5maXJlKCdtb3ZlJyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9vblBhblRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtcGFuLWFuaW0nKTtcclxuICBcdFx0dGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF90cnlBbmltYXRlZFBhbjogZnVuY3Rpb24gKGNlbnRlciwgb3B0aW9ucykge1xyXG4gIFx0XHQvLyBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIG5ldyBhbmQgY3VycmVudCBjZW50ZXJzIGluIHBpeGVsc1xyXG4gIFx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5fZ2V0Q2VudGVyT2Zmc2V0KGNlbnRlcikuX3RydW5jKCk7XHJcblxyXG4gIFx0XHQvLyBkb24ndCBhbmltYXRlIHRvbyBmYXIgdW5sZXNzIGFuaW1hdGU6IHRydWUgc3BlY2lmaWVkIGluIG9wdGlvbnNcclxuICBcdFx0aWYgKChvcHRpb25zICYmIG9wdGlvbnMuYW5pbWF0ZSkgIT09IHRydWUgJiYgIXRoaXMuZ2V0U2l6ZSgpLmNvbnRhaW5zKG9mZnNldCkpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4gIFx0XHR0aGlzLnBhbkJ5KG9mZnNldCwgb3B0aW9ucyk7XHJcblxyXG4gIFx0XHRyZXR1cm4gdHJ1ZTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2NyZWF0ZUFuaW1Qcm94eTogZnVuY3Rpb24gKCkge1xyXG5cclxuICBcdFx0dmFyIHByb3h5ID0gdGhpcy5fcHJveHkgPSBjcmVhdGUkMSgnZGl2JywgJ2xlYWZsZXQtcHJveHkgbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XHJcbiAgXHRcdHRoaXMuX3BhbmVzLm1hcFBhbmUuYXBwZW5kQ2hpbGQocHJveHkpO1xyXG5cclxuICBcdFx0dGhpcy5vbignem9vbWFuaW0nLCBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHRcdHZhciBwcm9wID0gVFJBTlNGT1JNLFxyXG4gIFx0XHRcdCAgICB0cmFuc2Zvcm0gPSB0aGlzLl9wcm94eS5zdHlsZVtwcm9wXTtcclxuXHJcbiAgXHRcdFx0c2V0VHJhbnNmb3JtKHRoaXMuX3Byb3h5LCB0aGlzLnByb2plY3QoZS5jZW50ZXIsIGUuem9vbSksIHRoaXMuZ2V0Wm9vbVNjYWxlKGUuem9vbSwgMSkpO1xyXG5cclxuICBcdFx0XHQvLyB3b3JrYXJvdW5kIGZvciBjYXNlIHdoZW4gdHJhbnNmb3JtIGlzIHRoZSBzYW1lIGFuZCBzbyB0cmFuc2l0aW9uZW5kIGV2ZW50IGlzIG5vdCBmaXJlZFxyXG4gIFx0XHRcdGlmICh0cmFuc2Zvcm0gPT09IHRoaXMuX3Byb3h5LnN0eWxlW3Byb3BdICYmIHRoaXMuX2FuaW1hdGluZ1pvb20pIHtcclxuICBcdFx0XHRcdHRoaXMuX29uWm9vbVRyYW5zaXRpb25FbmQoKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH0sIHRoaXMpO1xyXG5cclxuICBcdFx0dGhpcy5vbignbG9hZCBtb3ZlZW5kJywgdGhpcy5fYW5pbU1vdmVFbmQsIHRoaXMpO1xyXG5cclxuICBcdFx0dGhpcy5fb24oJ3VubG9hZCcsIHRoaXMuX2Rlc3Ryb3lBbmltUHJveHksIHRoaXMpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfZGVzdHJveUFuaW1Qcm94eTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZW1vdmUodGhpcy5fcHJveHkpO1xyXG4gIFx0XHR0aGlzLm9mZignbG9hZCBtb3ZlZW5kJywgdGhpcy5fYW5pbU1vdmVFbmQsIHRoaXMpO1xyXG4gIFx0XHRkZWxldGUgdGhpcy5fcHJveHk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9hbmltTW92ZUVuZDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgYyA9IHRoaXMuZ2V0Q2VudGVyKCksXHJcbiAgXHRcdCAgICB6ID0gdGhpcy5nZXRab29tKCk7XHJcbiAgXHRcdHNldFRyYW5zZm9ybSh0aGlzLl9wcm94eSwgdGhpcy5wcm9qZWN0KGMsIHopLCB0aGlzLmdldFpvb21TY2FsZSh6LCAxKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9jYXRjaFRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9hbmltYXRpbmdab29tICYmIGUucHJvcGVydHlOYW1lLmluZGV4T2YoJ3RyYW5zZm9ybScpID49IDApIHtcclxuICBcdFx0XHR0aGlzLl9vblpvb21UcmFuc2l0aW9uRW5kKCk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X25vdGhpbmdUb0FuaW1hdGU6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuICF0aGlzLl9jb250YWluZXIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnbGVhZmxldC16b29tLWFuaW1hdGVkJykubGVuZ3RoO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfdHJ5QW5pbWF0ZWRab29tOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBvcHRpb25zKSB7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cclxuICBcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gIFx0XHQvLyBkb24ndCBhbmltYXRlIGlmIGRpc2FibGVkLCBub3Qgc3VwcG9ydGVkIG9yIHpvb20gZGlmZmVyZW5jZSBpcyB0b28gbGFyZ2VcclxuICBcdFx0aWYgKCF0aGlzLl96b29tQW5pbWF0ZWQgfHwgb3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSB8fCB0aGlzLl9ub3RoaW5nVG9BbmltYXRlKCkgfHxcclxuICBcdFx0ICAgICAgICBNYXRoLmFicyh6b29tIC0gdGhpcy5fem9vbSkgPiB0aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvblRocmVzaG9sZCkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbiAgXHRcdC8vIG9mZnNldCBpcyB0aGUgcGl4ZWwgY29vcmRzIG9mIHRoZSB6b29tIG9yaWdpbiByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBjZW50ZXJcclxuICBcdFx0dmFyIHNjYWxlID0gdGhpcy5nZXRab29tU2NhbGUoem9vbSksXHJcbiAgXHRcdCAgICBvZmZzZXQgPSB0aGlzLl9nZXRDZW50ZXJPZmZzZXQoY2VudGVyKS5fZGl2aWRlQnkoMSAtIDEgLyBzY2FsZSk7XHJcblxyXG4gIFx0XHQvLyBkb24ndCBhbmltYXRlIGlmIHRoZSB6b29tIG9yaWdpbiBpc24ndCB3aXRoaW4gb25lIHNjcmVlbiBmcm9tIHRoZSBjdXJyZW50IGNlbnRlciwgdW5sZXNzIGZvcmNlZFxyXG4gIFx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSB0cnVlICYmICF0aGlzLmdldFNpemUoKS5jb250YWlucyhvZmZzZXQpKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuICBcdFx0cmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdFx0dGhpc1xyXG4gIFx0XHRcdCAgICAuX21vdmVTdGFydCh0cnVlLCBmYWxzZSlcclxuICBcdFx0XHQgICAgLl9hbmltYXRlWm9vbShjZW50ZXIsIHpvb20sIHRydWUpO1xyXG4gIFx0XHR9LCB0aGlzKTtcclxuXHJcbiAgXHRcdHJldHVybiB0cnVlO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIHN0YXJ0QW5pbSwgbm9VcGRhdGUpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9tYXBQYW5lKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0aWYgKHN0YXJ0QW5pbSkge1xyXG4gIFx0XHRcdHRoaXMuX2FuaW1hdGluZ1pvb20gPSB0cnVlO1xyXG5cclxuICBcdFx0XHQvLyByZW1lbWJlciB3aGF0IGNlbnRlci96b29tIHRvIHNldCBhZnRlciBhbmltYXRpb25cclxuICBcdFx0XHR0aGlzLl9hbmltYXRlVG9DZW50ZXIgPSBjZW50ZXI7XHJcbiAgXHRcdFx0dGhpcy5fYW5pbWF0ZVRvWm9vbSA9IHpvb207XHJcblxyXG4gIFx0XHRcdGFkZENsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXpvb20tYW5pbScpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBAc2VjdGlvbiBPdGhlciBFdmVudHNcclxuICBcdFx0Ly8gQGV2ZW50IHpvb21hbmltOiBab29tQW5pbUV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIGF0IGxlYXN0IG9uY2UgcGVyIHpvb20gYW5pbWF0aW9uLiBGb3IgY29udGludW91cyB6b29tLCBsaWtlIHBpbmNoIHpvb21pbmcsIGZpcmVkIG9uY2UgcGVyIGZyYW1lIGR1cmluZyB6b29tLlxyXG4gIFx0XHR0aGlzLmZpcmUoJ3pvb21hbmltJywge1xyXG4gIFx0XHRcdGNlbnRlcjogY2VudGVyLFxyXG4gIFx0XHRcdHpvb206IHpvb20sXHJcbiAgXHRcdFx0bm9VcGRhdGU6IG5vVXBkYXRlXHJcbiAgXHRcdH0pO1xyXG5cclxuICBcdFx0aWYgKCF0aGlzLl90ZW1wRmlyZVpvb21FdmVudCkge1xyXG4gIFx0XHRcdHRoaXMuX3RlbXBGaXJlWm9vbUV2ZW50ID0gdGhpcy5fem9vbSAhPT0gdGhpcy5fYW5pbWF0ZVRvWm9vbTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fbW92ZSh0aGlzLl9hbmltYXRlVG9DZW50ZXIsIHRoaXMuX2FuaW1hdGVUb1pvb20sIHVuZGVmaW5lZCwgdHJ1ZSk7XHJcblxyXG4gIFx0XHQvLyBXb3JrIGFyb3VuZCB3ZWJraXQgbm90IGZpcmluZyAndHJhbnNpdGlvbmVuZCcsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8zNjg5LCAyNjkzXHJcbiAgXHRcdHNldFRpbWVvdXQoYmluZCh0aGlzLl9vblpvb21UcmFuc2l0aW9uRW5kLCB0aGlzKSwgMjUwKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X29uWm9vbVRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9hbmltYXRpbmdab29tKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0aWYgKHRoaXMuX21hcFBhbmUpIHtcclxuICBcdFx0XHRyZW1vdmVDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC16b29tLWFuaW0nKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fYW5pbWF0aW5nWm9vbSA9IGZhbHNlO1xyXG5cclxuICBcdFx0dGhpcy5fbW92ZSh0aGlzLl9hbmltYXRlVG9DZW50ZXIsIHRoaXMuX2FuaW1hdGVUb1pvb20sIHVuZGVmaW5lZCwgdHJ1ZSk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fdGVtcEZpcmVab29tRXZlbnQpIHtcclxuICBcdFx0XHR0aGlzLmZpcmUoJ3pvb20nKTtcclxuICBcdFx0fVxyXG4gIFx0XHRkZWxldGUgdGhpcy5fdGVtcEZpcmVab29tRXZlbnQ7XHJcblxyXG4gIFx0XHR0aGlzLmZpcmUoJ21vdmUnKTtcclxuXHJcbiAgXHRcdHRoaXMuX21vdmVFbmQodHJ1ZSk7XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG4gIC8vIEBzZWN0aW9uXHJcblxyXG4gIC8vIEBmYWN0b3J5IEwubWFwKGlkOiBTdHJpbmcsIG9wdGlvbnM/OiBNYXAgb3B0aW9ucylcclxuICAvLyBJbnN0YW50aWF0ZXMgYSBtYXAgb2JqZWN0IGdpdmVuIHRoZSBET00gSUQgb2YgYSBgPGRpdj5gIGVsZW1lbnRcclxuICAvLyBhbmQgb3B0aW9uYWxseSBhbiBvYmplY3QgbGl0ZXJhbCB3aXRoIGBNYXAgb3B0aW9uc2AuXHJcbiAgLy9cclxuICAvLyBAYWx0ZXJuYXRpdmVcclxuICAvLyBAZmFjdG9yeSBMLm1hcChlbDogSFRNTEVsZW1lbnQsIG9wdGlvbnM/OiBNYXAgb3B0aW9ucylcclxuICAvLyBJbnN0YW50aWF0ZXMgYSBtYXAgb2JqZWN0IGdpdmVuIGFuIGluc3RhbmNlIG9mIGEgYDxkaXY+YCBIVE1MIGVsZW1lbnRcclxuICAvLyBhbmQgb3B0aW9uYWxseSBhbiBvYmplY3QgbGl0ZXJhbCB3aXRoIGBNYXAgb3B0aW9uc2AuXHJcbiAgZnVuY3Rpb24gY3JlYXRlTWFwKGlkLCBvcHRpb25zKSB7XHJcbiAgXHRyZXR1cm4gbmV3IE1hcChpZCwgb3B0aW9ucyk7XHJcbiAgfVxuXG4gIC8qXHJcbiAgICogQGNsYXNzIENvbnRyb2xcclxuICAgKiBAYWthIEwuQ29udHJvbFxyXG4gICAqIEBpbmhlcml0cyBDbGFzc1xyXG4gICAqXHJcbiAgICogTC5Db250cm9sIGlzIGEgYmFzZSBjbGFzcyBmb3IgaW1wbGVtZW50aW5nIG1hcCBjb250cm9scy4gSGFuZGxlcyBwb3NpdGlvbmluZy5cclxuICAgKiBBbGwgb3RoZXIgY29udHJvbHMgZXh0ZW5kIGZyb20gdGhpcyBjbGFzcy5cclxuICAgKi9cclxuXHJcbiAgdmFyIENvbnRyb2wgPSBDbGFzcy5leHRlbmQoe1xyXG4gIFx0Ly8gQHNlY3Rpb25cclxuICBcdC8vIEBha2EgQ29udHJvbCBPcHRpb25zXHJcbiAgXHRvcHRpb25zOiB7XHJcbiAgXHRcdC8vIEBvcHRpb24gcG9zaXRpb246IFN0cmluZyA9ICd0b3ByaWdodCdcclxuICBcdFx0Ly8gVGhlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sIChvbmUgb2YgdGhlIG1hcCBjb3JuZXJzKS4gUG9zc2libGUgdmFsdWVzIGFyZSBgJ3RvcGxlZnQnYCxcclxuICBcdFx0Ly8gYCd0b3ByaWdodCdgLCBgJ2JvdHRvbWxlZnQnYCBvciBgJ2JvdHRvbXJpZ2h0J2BcclxuICBcdFx0cG9zaXRpb246ICd0b3ByaWdodCdcclxuICBcdH0sXHJcblxyXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICBcdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuICBcdH0sXHJcblxyXG4gIFx0LyogQHNlY3Rpb25cclxuICBcdCAqIENsYXNzZXMgZXh0ZW5kaW5nIEwuQ29udHJvbCB3aWxsIGluaGVyaXQgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxyXG4gIFx0ICpcclxuICBcdCAqIEBtZXRob2QgZ2V0UG9zaXRpb246IHN0cmluZ1xyXG4gIFx0ICogUmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wuXHJcbiAgXHQgKi9cclxuICBcdGdldFBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLm9wdGlvbnMucG9zaXRpb247XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0UG9zaXRpb24ocG9zaXRpb246IHN0cmluZyk6IHRoaXNcclxuICBcdC8vIFNldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sLlxyXG4gIFx0c2V0UG9zaXRpb246IGZ1bmN0aW9uIChwb3NpdGlvbikge1xyXG4gIFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xyXG5cclxuICBcdFx0aWYgKG1hcCkge1xyXG4gIFx0XHRcdG1hcC5yZW1vdmVDb250cm9sKHRoaXMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLm9wdGlvbnMucG9zaXRpb24gPSBwb3NpdGlvbjtcclxuXHJcbiAgXHRcdGlmIChtYXApIHtcclxuICBcdFx0XHRtYXAuYWRkQ29udHJvbCh0aGlzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Q29udGFpbmVyOiBIVE1MRWxlbWVudFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgSFRNTEVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgY29udHJvbC5cclxuICBcdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGFkZFRvKG1hcDogTWFwKTogdGhpc1xyXG4gIFx0Ly8gQWRkcyB0aGUgY29udHJvbCB0byB0aGUgZ2l2ZW4gbWFwLlxyXG4gIFx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0dGhpcy5yZW1vdmUoKTtcclxuICBcdFx0dGhpcy5fbWFwID0gbWFwO1xyXG5cclxuICBcdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IHRoaXMub25BZGQobWFwKSxcclxuICBcdFx0ICAgIHBvcyA9IHRoaXMuZ2V0UG9zaXRpb24oKSxcclxuICBcdFx0ICAgIGNvcm5lciA9IG1hcC5fY29udHJvbENvcm5lcnNbcG9zXTtcclxuXHJcbiAgXHRcdGFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbCcpO1xyXG5cclxuICBcdFx0aWYgKHBvcy5pbmRleE9mKCdib3R0b20nKSAhPT0gLTEpIHtcclxuICBcdFx0XHRjb3JuZXIuaW5zZXJ0QmVmb3JlKGNvbnRhaW5lciwgY29ybmVyLmZpcnN0Q2hpbGQpO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdGNvcm5lci5hcHBlbmRDaGlsZChjb250YWluZXIpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9tYXAub24oJ3VubG9hZCcsIHRoaXMucmVtb3ZlLCB0aGlzKTtcclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHJlbW92ZTogdGhpc1xyXG4gIFx0Ly8gUmVtb3ZlcyB0aGUgY29udHJvbCBmcm9tIHRoZSBtYXAgaXQgaXMgY3VycmVudGx5IGFjdGl2ZSBvbi5cclxuICBcdHJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAoIXRoaXMuX21hcCkge1xyXG4gIFx0XHRcdHJldHVybiB0aGlzO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZW1vdmUodGhpcy5fY29udGFpbmVyKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLm9uUmVtb3ZlKSB7XHJcbiAgXHRcdFx0dGhpcy5vblJlbW92ZSh0aGlzLl9tYXApO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9tYXAub2ZmKCd1bmxvYWQnLCB0aGlzLnJlbW92ZSwgdGhpcyk7XHJcbiAgXHRcdHRoaXMuX21hcCA9IG51bGw7XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X3JlZm9jdXNPbk1hcDogZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0Ly8gaWYgbWFwIGV4aXN0cyBhbmQgZXZlbnQgaXMgbm90IGEga2V5Ym9hcmQgZXZlbnRcclxuICBcdFx0aWYgKHRoaXMuX21hcCAmJiBlICYmIGUuc2NyZWVuWCA+IDAgJiYgZS5zY3JlZW5ZID4gMCkge1xyXG4gIFx0XHRcdHRoaXMuX21hcC5nZXRDb250YWluZXIoKS5mb2N1cygpO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG4gIHZhciBjb250cm9sID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICBcdHJldHVybiBuZXcgQ29udHJvbChvcHRpb25zKTtcclxuICB9O1xyXG5cclxuICAvKiBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xyXG4gICAqIEB1bmluaGVyaXRhYmxlXHJcbiAgICpcclxuICAgKiBFdmVyeSBjb250cm9sIHNob3VsZCBleHRlbmQgZnJvbSBgTC5Db250cm9sYCBhbmQgKHJlLSlpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBtZXRob2RzLlxyXG4gICAqXHJcbiAgICogQG1ldGhvZCBvbkFkZChtYXA6IE1hcCk6IEhUTUxFbGVtZW50XHJcbiAgICogU2hvdWxkIHJldHVybiB0aGUgY29udGFpbmVyIERPTSBlbGVtZW50IGZvciB0aGUgY29udHJvbCBhbmQgYWRkIGxpc3RlbmVycyBvbiByZWxldmFudCBtYXAgZXZlbnRzLiBDYWxsZWQgb24gW2Bjb250cm9sLmFkZFRvKG1hcClgXSgjY29udHJvbC1hZGRUbykuXHJcbiAgICpcclxuICAgKiBAbWV0aG9kIG9uUmVtb3ZlKG1hcDogTWFwKVxyXG4gICAqIE9wdGlvbmFsIG1ldGhvZC4gU2hvdWxkIGNvbnRhaW4gYWxsIGNsZWFuIHVwIGNvZGUgdGhhdCByZW1vdmVzIHRoZSBsaXN0ZW5lcnMgcHJldmlvdXNseSBhZGRlZCBpbiBbYG9uQWRkYF0oI2NvbnRyb2wtb25hZGQpLiBDYWxsZWQgb24gW2Bjb250cm9sLnJlbW92ZSgpYF0oI2NvbnRyb2wtcmVtb3ZlKS5cclxuICAgKi9cclxuXHJcbiAgLyogQG5hbWVzcGFjZSBNYXBcclxuICAgKiBAc2VjdGlvbiBNZXRob2RzIGZvciBMYXllcnMgYW5kIENvbnRyb2xzXHJcbiAgICovXHJcbiAgTWFwLmluY2x1ZGUoe1xyXG4gIFx0Ly8gQG1ldGhvZCBhZGRDb250cm9sKGNvbnRyb2w6IENvbnRyb2wpOiB0aGlzXHJcbiAgXHQvLyBBZGRzIHRoZSBnaXZlbiBjb250cm9sIHRvIHRoZSBtYXBcclxuICBcdGFkZENvbnRyb2w6IGZ1bmN0aW9uIChjb250cm9sKSB7XHJcbiAgXHRcdGNvbnRyb2wuYWRkVG8odGhpcyk7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHJlbW92ZUNvbnRyb2woY29udHJvbDogQ29udHJvbCk6IHRoaXNcclxuICBcdC8vIFJlbW92ZXMgdGhlIGdpdmVuIGNvbnRyb2wgZnJvbSB0aGUgbWFwXHJcbiAgXHRyZW1vdmVDb250cm9sOiBmdW5jdGlvbiAoY29udHJvbCkge1xyXG4gIFx0XHRjb250cm9sLnJlbW92ZSgpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X2luaXRDb250cm9sUG9zOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBjb3JuZXJzID0gdGhpcy5fY29udHJvbENvcm5lcnMgPSB7fSxcclxuICBcdFx0ICAgIGwgPSAnbGVhZmxldC0nLFxyXG4gIFx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udHJvbENvbnRhaW5lciA9XHJcbiAgXHRcdCAgICAgICAgICAgIGNyZWF0ZSQxKCdkaXYnLCBsICsgJ2NvbnRyb2wtY29udGFpbmVyJywgdGhpcy5fY29udGFpbmVyKTtcclxuXHJcbiAgXHRcdGZ1bmN0aW9uIGNyZWF0ZUNvcm5lcih2U2lkZSwgaFNpZGUpIHtcclxuICBcdFx0XHR2YXIgY2xhc3NOYW1lID0gbCArIHZTaWRlICsgJyAnICsgbCArIGhTaWRlO1xyXG5cclxuICBcdFx0XHRjb3JuZXJzW3ZTaWRlICsgaFNpZGVdID0gY3JlYXRlJDEoJ2RpdicsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Y3JlYXRlQ29ybmVyKCd0b3AnLCAnbGVmdCcpO1xyXG4gIFx0XHRjcmVhdGVDb3JuZXIoJ3RvcCcsICdyaWdodCcpO1xyXG4gIFx0XHRjcmVhdGVDb3JuZXIoJ2JvdHRvbScsICdsZWZ0Jyk7XHJcbiAgXHRcdGNyZWF0ZUNvcm5lcignYm90dG9tJywgJ3JpZ2h0Jyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9jbGVhckNvbnRyb2xQb3M6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9jb250cm9sQ29ybmVycykge1xyXG4gIFx0XHRcdHJlbW92ZSh0aGlzLl9jb250cm9sQ29ybmVyc1tpXSk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmVtb3ZlKHRoaXMuX2NvbnRyb2xDb250YWluZXIpO1xyXG4gIFx0XHRkZWxldGUgdGhpcy5fY29udHJvbENvcm5lcnM7XHJcbiAgXHRcdGRlbGV0ZSB0aGlzLl9jb250cm9sQ29udGFpbmVyO1xyXG4gIFx0fVxyXG4gIH0pO1xuXG4gIC8qXHJcbiAgICogQGNsYXNzIENvbnRyb2wuTGF5ZXJzXHJcbiAgICogQGFrYSBMLkNvbnRyb2wuTGF5ZXJzXHJcbiAgICogQGluaGVyaXRzIENvbnRyb2xcclxuICAgKlxyXG4gICAqIFRoZSBsYXllcnMgY29udHJvbCBnaXZlcyB1c2VycyB0aGUgYWJpbGl0eSB0byBzd2l0Y2ggYmV0d2VlbiBkaWZmZXJlbnQgYmFzZSBsYXllcnMgYW5kIHN3aXRjaCBvdmVybGF5cyBvbi9vZmYgKGNoZWNrIG91dCB0aGUgW2RldGFpbGVkIGV4YW1wbGVdKGh0dHBzOi8vbGVhZmxldGpzLmNvbS9leGFtcGxlcy9sYXllcnMtY29udHJvbC8pKS4gRXh0ZW5kcyBgQ29udHJvbGAuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB2YXIgYmFzZUxheWVycyA9IHtcclxuICAgKiBcdFwiTWFwYm94XCI6IG1hcGJveCxcclxuICAgKiBcdFwiT3BlblN0cmVldE1hcFwiOiBvc21cclxuICAgKiB9O1xyXG4gICAqXHJcbiAgICogdmFyIG92ZXJsYXlzID0ge1xyXG4gICAqIFx0XCJNYXJrZXJcIjogbWFya2VyLFxyXG4gICAqIFx0XCJSb2Fkc1wiOiByb2Fkc0xheWVyXHJcbiAgICogfTtcclxuICAgKlxyXG4gICAqIEwuY29udHJvbC5sYXllcnMoYmFzZUxheWVycywgb3ZlcmxheXMpLmFkZFRvKG1hcCk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBUaGUgYGJhc2VMYXllcnNgIGFuZCBgb3ZlcmxheXNgIHBhcmFtZXRlcnMgYXJlIG9iamVjdCBsaXRlcmFscyB3aXRoIGxheWVyIG5hbWVzIGFzIGtleXMgYW5kIGBMYXllcmAgb2JqZWN0cyBhcyB2YWx1ZXM6XHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIHtcclxuICAgKiAgICAgXCI8c29tZU5hbWUxPlwiOiBsYXllcjEsXHJcbiAgICogICAgIFwiPHNvbWVOYW1lMj5cIjogbGF5ZXIyXHJcbiAgICogfVxyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogVGhlIGxheWVyIG5hbWVzIGNhbiBjb250YWluIEhUTUwsIHdoaWNoIGFsbG93cyB5b3UgdG8gYWRkIGFkZGl0aW9uYWwgc3R5bGluZyB0byB0aGUgaXRlbXM6XHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIHtcIjxpbWcgc3JjPSdteS1sYXllci1pY29uJyAvPiA8c3BhbiBjbGFzcz0nbXktbGF5ZXItaXRlbSc+TXkgTGF5ZXI8L3NwYW4+XCI6IG15TGF5ZXJ9XHJcbiAgICogYGBgXHJcbiAgICovXHJcblxyXG4gIHZhciBMYXllcnMgPSBDb250cm9sLmV4dGVuZCh7XHJcbiAgXHQvLyBAc2VjdGlvblxyXG4gIFx0Ly8gQGFrYSBDb250cm9sLkxheWVycyBvcHRpb25zXHJcbiAgXHRvcHRpb25zOiB7XHJcbiAgXHRcdC8vIEBvcHRpb24gY29sbGFwc2VkOiBCb29sZWFuID0gdHJ1ZVxyXG4gIFx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBjb250cm9sIHdpbGwgYmUgY29sbGFwc2VkIGludG8gYW4gaWNvbiBhbmQgZXhwYW5kZWQgb24gbW91c2UgaG92ZXIsIHRvdWNoLCBvciBrZXlib2FyZCBhY3RpdmF0aW9uLlxyXG4gIFx0XHRjb2xsYXBzZWQ6IHRydWUsXHJcbiAgXHRcdHBvc2l0aW9uOiAndG9wcmlnaHQnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBhdXRvWkluZGV4OiBCb29sZWFuID0gdHJ1ZVxyXG4gIFx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBjb250cm9sIHdpbGwgYXNzaWduIHpJbmRleGVzIGluIGluY3JlYXNpbmcgb3JkZXIgdG8gYWxsIG9mIGl0cyBsYXllcnMgc28gdGhhdCB0aGUgb3JkZXIgaXMgcHJlc2VydmVkIHdoZW4gc3dpdGNoaW5nIHRoZW0gb24vb2ZmLlxyXG4gIFx0XHRhdXRvWkluZGV4OiB0cnVlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBoaWRlU2luZ2xlQmFzZTogQm9vbGVhbiA9IGZhbHNlXHJcbiAgXHRcdC8vIElmIGB0cnVlYCwgdGhlIGJhc2UgbGF5ZXJzIGluIHRoZSBjb250cm9sIHdpbGwgYmUgaGlkZGVuIHdoZW4gdGhlcmUgaXMgb25seSBvbmUuXHJcbiAgXHRcdGhpZGVTaW5nbGVCYXNlOiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gc29ydExheWVyczogQm9vbGVhbiA9IGZhbHNlXHJcbiAgXHRcdC8vIFdoZXRoZXIgdG8gc29ydCB0aGUgbGF5ZXJzLiBXaGVuIGBmYWxzZWAsIGxheWVycyB3aWxsIGtlZXAgdGhlIG9yZGVyXHJcbiAgXHRcdC8vIGluIHdoaWNoIHRoZXkgd2VyZSBhZGRlZCB0byB0aGUgY29udHJvbC5cclxuICBcdFx0c29ydExheWVyczogZmFsc2UsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHNvcnRGdW5jdGlvbjogRnVuY3Rpb24gPSAqXHJcbiAgXHRcdC8vIEEgW2NvbXBhcmUgZnVuY3Rpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NvcnQpXHJcbiAgXHRcdC8vIHRoYXQgd2lsbCBiZSB1c2VkIGZvciBzb3J0aW5nIHRoZSBsYXllcnMsIHdoZW4gYHNvcnRMYXllcnNgIGlzIGB0cnVlYC5cclxuICBcdFx0Ly8gVGhlIGZ1bmN0aW9uIHJlY2VpdmVzIGJvdGggdGhlIGBMLkxheWVyYCBpbnN0YW5jZXMgYW5kIHRoZWlyIG5hbWVzLCBhcyBpblxyXG4gIFx0XHQvLyBgc29ydEZ1bmN0aW9uKGxheWVyQSwgbGF5ZXJCLCBuYW1lQSwgbmFtZUIpYC5cclxuICBcdFx0Ly8gQnkgZGVmYXVsdCwgaXQgc29ydHMgbGF5ZXJzIGFscGhhYmV0aWNhbGx5IGJ5IHRoZWlyIG5hbWUuXHJcbiAgXHRcdHNvcnRGdW5jdGlvbjogZnVuY3Rpb24gKGxheWVyQSwgbGF5ZXJCLCBuYW1lQSwgbmFtZUIpIHtcclxuICBcdFx0XHRyZXR1cm4gbmFtZUEgPCBuYW1lQiA/IC0xIDogKG5hbWVCIDwgbmFtZUEgPyAxIDogMCk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGJhc2VMYXllcnMsIG92ZXJsYXlzLCBvcHRpb25zKSB7XHJcbiAgXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG4gIFx0XHR0aGlzLl9sYXllckNvbnRyb2xJbnB1dHMgPSBbXTtcclxuICBcdFx0dGhpcy5fbGF5ZXJzID0gW107XHJcbiAgXHRcdHRoaXMuX2xhc3RaSW5kZXggPSAwO1xyXG4gIFx0XHR0aGlzLl9oYW5kbGluZ0NsaWNrID0gZmFsc2U7XHJcblxyXG4gIFx0XHRmb3IgKHZhciBpIGluIGJhc2VMYXllcnMpIHtcclxuICBcdFx0XHR0aGlzLl9hZGRMYXllcihiYXNlTGF5ZXJzW2ldLCBpKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Zm9yIChpIGluIG92ZXJsYXlzKSB7XHJcbiAgXHRcdFx0dGhpcy5fYWRkTGF5ZXIob3ZlcmxheXNbaV0sIGksIHRydWUpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgXHRcdHRoaXMuX2luaXRMYXlvdXQoKTtcclxuICBcdFx0dGhpcy5fdXBkYXRlKCk7XHJcblxyXG4gIFx0XHR0aGlzLl9tYXAgPSBtYXA7XHJcbiAgXHRcdG1hcC5vbignem9vbWVuZCcsIHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMsIHRoaXMpO1xyXG5cclxuICBcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuICBcdFx0XHR0aGlzLl9sYXllcnNbaV0ubGF5ZXIub24oJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuICBcdH0sXHJcblxyXG4gIFx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0Q29udHJvbC5wcm90b3R5cGUuYWRkVG8uY2FsbCh0aGlzLCBtYXApO1xyXG4gIFx0XHQvLyBUcmlnZ2VyIGV4cGFuZCBhZnRlciBMYXllcnMgQ29udHJvbCBoYXMgYmVlbiBpbnNlcnRlZCBpbnRvIERPTSBzbyB0aGF0IGlzIG5vdyBoYXMgYW4gYWN0dWFsIGhlaWdodC5cclxuICBcdFx0cmV0dXJuIHRoaXMuX2V4cGFuZElmTm90Q29sbGFwc2VkKCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHRoaXMuX21hcC5vZmYoJ3pvb21lbmQnLCB0aGlzLl9jaGVja0Rpc2FibGVkTGF5ZXJzLCB0aGlzKTtcclxuXHJcbiAgXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgXHRcdFx0dGhpcy5fbGF5ZXJzW2ldLmxheWVyLm9mZignYWRkIHJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgYWRkQmFzZUxheWVyKGxheWVyOiBMYXllciwgbmFtZTogU3RyaW5nKTogdGhpc1xyXG4gIFx0Ly8gQWRkcyBhIGJhc2UgbGF5ZXIgKHJhZGlvIGJ1dHRvbiBlbnRyeSkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSB0byB0aGUgY29udHJvbC5cclxuICBcdGFkZEJhc2VMYXllcjogZnVuY3Rpb24gKGxheWVyLCBuYW1lKSB7XHJcbiAgXHRcdHRoaXMuX2FkZExheWVyKGxheWVyLCBuYW1lKTtcclxuICBcdFx0cmV0dXJuICh0aGlzLl9tYXApID8gdGhpcy5fdXBkYXRlKCkgOiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGFkZE92ZXJsYXkobGF5ZXI6IExheWVyLCBuYW1lOiBTdHJpbmcpOiB0aGlzXHJcbiAgXHQvLyBBZGRzIGFuIG92ZXJsYXkgKGNoZWNrYm94IGVudHJ5KSB3aXRoIHRoZSBnaXZlbiBuYW1lIHRvIHRoZSBjb250cm9sLlxyXG4gIFx0YWRkT3ZlcmxheTogZnVuY3Rpb24gKGxheWVyLCBuYW1lKSB7XHJcbiAgXHRcdHRoaXMuX2FkZExheWVyKGxheWVyLCBuYW1lLCB0cnVlKTtcclxuICBcdFx0cmV0dXJuICh0aGlzLl9tYXApID8gdGhpcy5fdXBkYXRlKCkgOiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGxheWVyOiBMYXllcik6IHRoaXNcclxuICBcdC8vIFJlbW92ZSB0aGUgZ2l2ZW4gbGF5ZXIgZnJvbSB0aGUgY29udHJvbC5cclxuICBcdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuICBcdFx0bGF5ZXIub2ZmKCdhZGQgcmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XHJcblxyXG4gIFx0XHR2YXIgb2JqID0gdGhpcy5fZ2V0TGF5ZXIoc3RhbXAobGF5ZXIpKTtcclxuICBcdFx0aWYgKG9iaikge1xyXG4gIFx0XHRcdHRoaXMuX2xheWVycy5zcGxpY2UodGhpcy5fbGF5ZXJzLmluZGV4T2Yob2JqKSwgMSk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuICh0aGlzLl9tYXApID8gdGhpcy5fdXBkYXRlKCkgOiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGV4cGFuZCgpOiB0aGlzXHJcbiAgXHQvLyBFeHBhbmQgdGhlIGNvbnRyb2wgY29udGFpbmVyIGlmIGNvbGxhcHNlZC5cclxuICBcdGV4cGFuZDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRhZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkJyk7XHJcbiAgXHRcdHRoaXMuX3NlY3Rpb24uc3R5bGUuaGVpZ2h0ID0gbnVsbDtcclxuICBcdFx0dmFyIGFjY2VwdGFibGVIZWlnaHQgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLnkgLSAodGhpcy5fY29udGFpbmVyLm9mZnNldFRvcCArIDUwKTtcclxuICBcdFx0aWYgKGFjY2VwdGFibGVIZWlnaHQgPCB0aGlzLl9zZWN0aW9uLmNsaWVudEhlaWdodCkge1xyXG4gIFx0XHRcdGFkZENsYXNzKHRoaXMuX3NlY3Rpb24sICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNjcm9sbGJhcicpO1xyXG4gIFx0XHRcdHRoaXMuX3NlY3Rpb24uc3R5bGUuaGVpZ2h0ID0gYWNjZXB0YWJsZUhlaWdodCArICdweCc7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fc2VjdGlvbiwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtc2Nyb2xsYmFyJyk7XHJcbiAgXHRcdH1cclxuICBcdFx0dGhpcy5fY2hlY2tEaXNhYmxlZExheWVycygpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjb2xsYXBzZSgpOiB0aGlzXHJcbiAgXHQvLyBDb2xsYXBzZSB0aGUgY29udHJvbCBjb250YWluZXIgaWYgZXhwYW5kZWQuXHJcbiAgXHRjb2xsYXBzZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkJyk7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1sYXllcnMnLFxyXG4gIFx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gY3JlYXRlJDEoJ2RpdicsIGNsYXNzTmFtZSksXHJcbiAgXHRcdCAgICBjb2xsYXBzZWQgPSB0aGlzLm9wdGlvbnMuY29sbGFwc2VkO1xyXG5cclxuICBcdFx0Ly8gbWFrZXMgdGhpcyB3b3JrIG9uIElFIHRvdWNoIGRldmljZXMgYnkgc3RvcHBpbmcgaXQgZnJvbSBmaXJpbmcgYSBtb3VzZW91dCBldmVudCB3aGVuIHRoZSB0b3VjaCBpcyByZWxlYXNlZFxyXG4gIFx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCdhcmlhLWhhc3BvcHVwJywgdHJ1ZSk7XHJcblxyXG4gIFx0XHRkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihjb250YWluZXIpO1xyXG4gIFx0XHRkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24oY29udGFpbmVyKTtcclxuXHJcbiAgXHRcdHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbiA9IGNyZWF0ZSQxKCdzZWN0aW9uJywgY2xhc3NOYW1lICsgJy1saXN0Jyk7XHJcblxyXG4gIFx0XHRpZiAoY29sbGFwc2VkKSB7XHJcbiAgXHRcdFx0dGhpcy5fbWFwLm9uKCdjbGljaycsIHRoaXMuY29sbGFwc2UsIHRoaXMpO1xyXG5cclxuICBcdFx0XHRvbihjb250YWluZXIsIHtcclxuICBcdFx0XHRcdG1vdXNlZW50ZXI6IHRoaXMuX2V4cGFuZFNhZmVseSxcclxuICBcdFx0XHRcdG1vdXNlbGVhdmU6IHRoaXMuY29sbGFwc2VcclxuICBcdFx0XHR9LCB0aGlzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIGxpbmsgPSB0aGlzLl9sYXllcnNMaW5rID0gY3JlYXRlJDEoJ2EnLCBjbGFzc05hbWUgKyAnLXRvZ2dsZScsIGNvbnRhaW5lcik7XHJcbiAgXHRcdGxpbmsuaHJlZiA9ICcjJztcclxuICBcdFx0bGluay50aXRsZSA9ICdMYXllcnMnO1xyXG4gIFx0XHRsaW5rLnNldEF0dHJpYnV0ZSgncm9sZScsICdidXR0b24nKTtcclxuXHJcbiAgXHRcdG9uKGxpbmssIHtcclxuICBcdFx0XHRrZXlkb3duOiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHRcdFx0aWYgKGUua2V5Q29kZSA9PT0gMTMpIHtcclxuICBcdFx0XHRcdFx0dGhpcy5fZXhwYW5kU2FmZWx5KCk7XHJcbiAgXHRcdFx0XHR9XHJcbiAgXHRcdFx0fSxcclxuICBcdFx0XHQvLyBDZXJ0YWluIHNjcmVlbiByZWFkZXJzIGludGVyY2VwdCB0aGUga2V5IGV2ZW50IGFuZCBpbnN0ZWFkIHNlbmQgYSBjbGljayBldmVudFxyXG4gIFx0XHRcdGNsaWNrOiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHRcdFx0cHJldmVudERlZmF1bHQoZSk7XHJcbiAgXHRcdFx0XHR0aGlzLl9leHBhbmRTYWZlbHkoKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH0sIHRoaXMpO1xyXG5cclxuICBcdFx0aWYgKCFjb2xsYXBzZWQpIHtcclxuICBcdFx0XHR0aGlzLmV4cGFuZCgpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9iYXNlTGF5ZXJzTGlzdCA9IGNyZWF0ZSQxKCdkaXYnLCBjbGFzc05hbWUgKyAnLWJhc2UnLCBzZWN0aW9uKTtcclxuICBcdFx0dGhpcy5fc2VwYXJhdG9yID0gY3JlYXRlJDEoJ2RpdicsIGNsYXNzTmFtZSArICctc2VwYXJhdG9yJywgc2VjdGlvbik7XHJcbiAgXHRcdHRoaXMuX292ZXJsYXlzTGlzdCA9IGNyZWF0ZSQxKCdkaXYnLCBjbGFzc05hbWUgKyAnLW92ZXJsYXlzJywgc2VjdGlvbik7XHJcblxyXG4gIFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoc2VjdGlvbik7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9nZXRMYXllcjogZnVuY3Rpb24gKGlkKSB7XHJcbiAgXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblxyXG4gIFx0XHRcdGlmICh0aGlzLl9sYXllcnNbaV0gJiYgc3RhbXAodGhpcy5fbGF5ZXJzW2ldLmxheWVyKSA9PT0gaWQpIHtcclxuICBcdFx0XHRcdHJldHVybiB0aGlzLl9sYXllcnNbaV07XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF9hZGRMYXllcjogZnVuY3Rpb24gKGxheWVyLCBuYW1lLCBvdmVybGF5KSB7XHJcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcclxuICBcdFx0XHRsYXllci5vbignYWRkIHJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9sYXllcnMucHVzaCh7XHJcbiAgXHRcdFx0bGF5ZXI6IGxheWVyLFxyXG4gIFx0XHRcdG5hbWU6IG5hbWUsXHJcbiAgXHRcdFx0b3ZlcmxheTogb3ZlcmxheVxyXG4gIFx0XHR9KTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuc29ydExheWVycykge1xyXG4gIFx0XHRcdHRoaXMuX2xheWVycy5zb3J0KGJpbmQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICBcdFx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnMuc29ydEZ1bmN0aW9uKGEubGF5ZXIsIGIubGF5ZXIsIGEubmFtZSwgYi5uYW1lKTtcclxuICBcdFx0XHR9LCB0aGlzKSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuYXV0b1pJbmRleCAmJiBsYXllci5zZXRaSW5kZXgpIHtcclxuICBcdFx0XHR0aGlzLl9sYXN0WkluZGV4Kys7XHJcbiAgXHRcdFx0bGF5ZXIuc2V0WkluZGV4KHRoaXMuX2xhc3RaSW5kZXgpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9leHBhbmRJZk5vdENvbGxhcHNlZCgpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fY29udGFpbmVyKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG4gIFx0XHRlbXB0eSh0aGlzLl9iYXNlTGF5ZXJzTGlzdCk7XHJcbiAgXHRcdGVtcHR5KHRoaXMuX292ZXJsYXlzTGlzdCk7XHJcblxyXG4gIFx0XHR0aGlzLl9sYXllckNvbnRyb2xJbnB1dHMgPSBbXTtcclxuICBcdFx0dmFyIGJhc2VMYXllcnNQcmVzZW50LCBvdmVybGF5c1ByZXNlbnQsIGksIG9iaiwgYmFzZUxheWVyc0NvdW50ID0gMDtcclxuXHJcbiAgXHRcdGZvciAoaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuICBcdFx0XHRvYmogPSB0aGlzLl9sYXllcnNbaV07XHJcbiAgXHRcdFx0dGhpcy5fYWRkSXRlbShvYmopO1xyXG4gIFx0XHRcdG92ZXJsYXlzUHJlc2VudCA9IG92ZXJsYXlzUHJlc2VudCB8fCBvYmoub3ZlcmxheTtcclxuICBcdFx0XHRiYXNlTGF5ZXJzUHJlc2VudCA9IGJhc2VMYXllcnNQcmVzZW50IHx8ICFvYmoub3ZlcmxheTtcclxuICBcdFx0XHRiYXNlTGF5ZXJzQ291bnQgKz0gIW9iai5vdmVybGF5ID8gMSA6IDA7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIEhpZGUgYmFzZSBsYXllcnMgc2VjdGlvbiBpZiB0aGVyZSdzIG9ubHkgb25lIGxheWVyLlxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLmhpZGVTaW5nbGVCYXNlKSB7XHJcbiAgXHRcdFx0YmFzZUxheWVyc1ByZXNlbnQgPSBiYXNlTGF5ZXJzUHJlc2VudCAmJiBiYXNlTGF5ZXJzQ291bnQgPiAxO1xyXG4gIFx0XHRcdHRoaXMuX2Jhc2VMYXllcnNMaXN0LnN0eWxlLmRpc3BsYXkgPSBiYXNlTGF5ZXJzUHJlc2VudCA/ICcnIDogJ25vbmUnO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9zZXBhcmF0b3Iuc3R5bGUuZGlzcGxheSA9IG92ZXJsYXlzUHJlc2VudCAmJiBiYXNlTGF5ZXJzUHJlc2VudCA/ICcnIDogJ25vbmUnO1xyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9vbkxheWVyQ2hhbmdlOiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHRpZiAoIXRoaXMuX2hhbmRsaW5nQ2xpY2spIHtcclxuICBcdFx0XHR0aGlzLl91cGRhdGUoKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIG9iaiA9IHRoaXMuX2dldExheWVyKHN0YW1wKGUudGFyZ2V0KSk7XHJcblxyXG4gIFx0XHQvLyBAbmFtZXNwYWNlIE1hcFxyXG4gIFx0XHQvLyBAc2VjdGlvbiBMYXllciBldmVudHNcclxuICBcdFx0Ly8gQGV2ZW50IGJhc2VsYXllcmNoYW5nZTogTGF5ZXJzQ29udHJvbEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIGJhc2UgbGF5ZXIgaXMgY2hhbmdlZCB0aHJvdWdoIHRoZSBbbGF5ZXJzIGNvbnRyb2xdKCNjb250cm9sLWxheWVycykuXHJcbiAgXHRcdC8vIEBldmVudCBvdmVybGF5YWRkOiBMYXllcnNDb250cm9sRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiBhbiBvdmVybGF5IGlzIHNlbGVjdGVkIHRocm91Z2ggdGhlIFtsYXllcnMgY29udHJvbF0oI2NvbnRyb2wtbGF5ZXJzKS5cclxuICBcdFx0Ly8gQGV2ZW50IG92ZXJsYXlyZW1vdmU6IExheWVyc0NvbnRyb2xFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIGFuIG92ZXJsYXkgaXMgZGVzZWxlY3RlZCB0aHJvdWdoIHRoZSBbbGF5ZXJzIGNvbnRyb2xdKCNjb250cm9sLWxheWVycykuXHJcbiAgXHRcdC8vIEBuYW1lc3BhY2UgQ29udHJvbC5MYXllcnNcclxuICBcdFx0dmFyIHR5cGUgPSBvYmoub3ZlcmxheSA/XHJcbiAgXHRcdFx0KGUudHlwZSA9PT0gJ2FkZCcgPyAnb3ZlcmxheWFkZCcgOiAnb3ZlcmxheXJlbW92ZScpIDpcclxuICBcdFx0XHQoZS50eXBlID09PSAnYWRkJyA/ICdiYXNlbGF5ZXJjaGFuZ2UnIDogbnVsbCk7XHJcblxyXG4gIFx0XHRpZiAodHlwZSkge1xyXG4gIFx0XHRcdHRoaXMuX21hcC5maXJlKHR5cGUsIG9iaik7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gSUU3IGJ1Z3Mgb3V0IGlmIHlvdSBjcmVhdGUgYSByYWRpbyBkeW5hbWljYWxseSwgc28geW91IGhhdmUgdG8gZG8gaXQgdGhpcyBoYWNreSB3YXkgKHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTE5MDc5KVxyXG4gIFx0X2NyZWF0ZVJhZGlvRWxlbWVudDogZnVuY3Rpb24gKG5hbWUsIGNoZWNrZWQpIHtcclxuXHJcbiAgXHRcdHZhciByYWRpb0h0bWwgPSAnPGlucHV0IHR5cGU9XCJyYWRpb1wiIGNsYXNzPVwibGVhZmxldC1jb250cm9sLWxheWVycy1zZWxlY3RvclwiIG5hbWU9XCInICtcclxuICBcdFx0XHRcdG5hbWUgKyAnXCInICsgKGNoZWNrZWQgPyAnIGNoZWNrZWQ9XCJjaGVja2VkXCInIDogJycpICsgJy8+JztcclxuXHJcbiAgXHRcdHZhciByYWRpb0ZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgXHRcdHJhZGlvRnJhZ21lbnQuaW5uZXJIVE1MID0gcmFkaW9IdG1sO1xyXG5cclxuICBcdFx0cmV0dXJuIHJhZGlvRnJhZ21lbnQuZmlyc3RDaGlsZDtcclxuICBcdH0sXHJcblxyXG4gIFx0X2FkZEl0ZW06IGZ1bmN0aW9uIChvYmopIHtcclxuICBcdFx0dmFyIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKSxcclxuICBcdFx0ICAgIGNoZWNrZWQgPSB0aGlzLl9tYXAuaGFzTGF5ZXIob2JqLmxheWVyKSxcclxuICBcdFx0ICAgIGlucHV0O1xyXG5cclxuICBcdFx0aWYgKG9iai5vdmVybGF5KSB7XHJcbiAgXHRcdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xyXG4gIFx0XHRcdGlucHV0LnR5cGUgPSAnY2hlY2tib3gnO1xyXG4gIFx0XHRcdGlucHV0LmNsYXNzTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9yJztcclxuICBcdFx0XHRpbnB1dC5kZWZhdWx0Q2hlY2tlZCA9IGNoZWNrZWQ7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0aW5wdXQgPSB0aGlzLl9jcmVhdGVSYWRpb0VsZW1lbnQoJ2xlYWZsZXQtYmFzZS1sYXllcnNfJyArIHN0YW1wKHRoaXMpLCBjaGVja2VkKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzLnB1c2goaW5wdXQpO1xyXG4gIFx0XHRpbnB1dC5sYXllcklkID0gc3RhbXAob2JqLmxheWVyKTtcclxuXHJcbiAgXHRcdG9uKGlucHV0LCAnY2xpY2snLCB0aGlzLl9vbklucHV0Q2xpY2ssIHRoaXMpO1xyXG5cclxuICBcdFx0dmFyIG5hbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcbiAgXHRcdG5hbWUuaW5uZXJIVE1MID0gJyAnICsgb2JqLm5hbWU7XHJcblxyXG4gIFx0XHQvLyBIZWxwcyBmcm9tIHByZXZlbnRpbmcgbGF5ZXIgY29udHJvbCBmbGlja2VyIHdoZW4gY2hlY2tib3hlcyBhcmUgZGlzYWJsZWRcclxuICBcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMjc3MVxyXG4gIFx0XHR2YXIgaG9sZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xyXG5cclxuICBcdFx0bGFiZWwuYXBwZW5kQ2hpbGQoaG9sZGVyKTtcclxuICBcdFx0aG9sZGVyLmFwcGVuZENoaWxkKGlucHV0KTtcclxuICBcdFx0aG9sZGVyLmFwcGVuZENoaWxkKG5hbWUpO1xyXG5cclxuICBcdFx0dmFyIGNvbnRhaW5lciA9IG9iai5vdmVybGF5ID8gdGhpcy5fb3ZlcmxheXNMaXN0IDogdGhpcy5fYmFzZUxheWVyc0xpc3Q7XHJcbiAgXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChsYWJlbCk7XHJcblxyXG4gIFx0XHR0aGlzLl9jaGVja0Rpc2FibGVkTGF5ZXJzKCk7XHJcbiAgXHRcdHJldHVybiBsYWJlbDtcclxuICBcdH0sXHJcblxyXG4gIFx0X29uSW5wdXRDbGljazogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgaW5wdXRzID0gdGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzLFxyXG4gIFx0XHQgICAgaW5wdXQsIGxheWVyO1xyXG4gIFx0XHR2YXIgYWRkZWRMYXllcnMgPSBbXSxcclxuICBcdFx0ICAgIHJlbW92ZWRMYXllcnMgPSBbXTtcclxuXHJcbiAgXHRcdHRoaXMuX2hhbmRsaW5nQ2xpY2sgPSB0cnVlO1xyXG5cclxuICBcdFx0Zm9yICh2YXIgaSA9IGlucHV0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gIFx0XHRcdGlucHV0ID0gaW5wdXRzW2ldO1xyXG4gIFx0XHRcdGxheWVyID0gdGhpcy5fZ2V0TGF5ZXIoaW5wdXQubGF5ZXJJZCkubGF5ZXI7XHJcblxyXG4gIFx0XHRcdGlmIChpbnB1dC5jaGVja2VkKSB7XHJcbiAgXHRcdFx0XHRhZGRlZExheWVycy5wdXNoKGxheWVyKTtcclxuICBcdFx0XHR9IGVsc2UgaWYgKCFpbnB1dC5jaGVja2VkKSB7XHJcbiAgXHRcdFx0XHRyZW1vdmVkTGF5ZXJzLnB1c2gobGF5ZXIpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gQnVnZml4IGlzc3VlIDIzMTg6IFNob3VsZCByZW1vdmUgYWxsIG9sZCBsYXllcnMgYmVmb3JlIHJlYWRkaW5nIG5ldyBvbmVzXHJcbiAgXHRcdGZvciAoaSA9IDA7IGkgPCByZW1vdmVkTGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgXHRcdFx0aWYgKHRoaXMuX21hcC5oYXNMYXllcihyZW1vdmVkTGF5ZXJzW2ldKSkge1xyXG4gIFx0XHRcdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHJlbW92ZWRMYXllcnNbaV0pO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG4gIFx0XHRmb3IgKGkgPSAwOyBpIDwgYWRkZWRMYXllcnMubGVuZ3RoOyBpKyspIHtcclxuICBcdFx0XHRpZiAoIXRoaXMuX21hcC5oYXNMYXllcihhZGRlZExheWVyc1tpXSkpIHtcclxuICBcdFx0XHRcdHRoaXMuX21hcC5hZGRMYXllcihhZGRlZExheWVyc1tpXSk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9oYW5kbGluZ0NsaWNrID0gZmFsc2U7XHJcblxyXG4gIFx0XHR0aGlzLl9yZWZvY3VzT25NYXAoKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2NoZWNrRGlzYWJsZWRMYXllcnM6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIGlucHV0cyA9IHRoaXMuX2xheWVyQ29udHJvbElucHV0cyxcclxuICBcdFx0ICAgIGlucHV0LFxyXG4gIFx0XHQgICAgbGF5ZXIsXHJcbiAgXHRcdCAgICB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcclxuXHJcbiAgXHRcdGZvciAodmFyIGkgPSBpbnB1dHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICBcdFx0XHRpbnB1dCA9IGlucHV0c1tpXTtcclxuICBcdFx0XHRsYXllciA9IHRoaXMuX2dldExheWVyKGlucHV0LmxheWVySWQpLmxheWVyO1xyXG4gIFx0XHRcdGlucHV0LmRpc2FibGVkID0gKGxheWVyLm9wdGlvbnMubWluWm9vbSAhPT0gdW5kZWZpbmVkICYmIHpvb20gPCBsYXllci5vcHRpb25zLm1pblpvb20pIHx8XHJcbiAgXHRcdFx0ICAgICAgICAgICAgICAgICAobGF5ZXIub3B0aW9ucy5tYXhab29tICE9PSB1bmRlZmluZWQgJiYgem9vbSA+IGxheWVyLm9wdGlvbnMubWF4Wm9vbSk7XHJcblxyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF9leHBhbmRJZk5vdENvbGxhcHNlZDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAodGhpcy5fbWFwICYmICF0aGlzLm9wdGlvbnMuY29sbGFwc2VkKSB7XHJcbiAgXHRcdFx0dGhpcy5leHBhbmQoKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X2V4cGFuZFNhZmVseTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb247XHJcbiAgXHRcdG9uKHNlY3Rpb24sICdjbGljaycsIHByZXZlbnREZWZhdWx0KTtcclxuICBcdFx0dGhpcy5leHBhbmQoKTtcclxuICBcdFx0c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdFx0b2ZmKHNlY3Rpb24sICdjbGljaycsIHByZXZlbnREZWZhdWx0KTtcclxuICBcdFx0fSk7XHJcbiAgXHR9XHJcblxyXG4gIH0pO1xyXG5cclxuXHJcbiAgLy8gQGZhY3RvcnkgTC5jb250cm9sLmxheWVycyhiYXNlbGF5ZXJzPzogT2JqZWN0LCBvdmVybGF5cz86IE9iamVjdCwgb3B0aW9ucz86IENvbnRyb2wuTGF5ZXJzIG9wdGlvbnMpXHJcbiAgLy8gQ3JlYXRlcyBhIGxheWVycyBjb250cm9sIHdpdGggdGhlIGdpdmVuIGxheWVycy4gQmFzZSBsYXllcnMgd2lsbCBiZSBzd2l0Y2hlZCB3aXRoIHJhZGlvIGJ1dHRvbnMsIHdoaWxlIG92ZXJsYXlzIHdpbGwgYmUgc3dpdGNoZWQgd2l0aCBjaGVja2JveGVzLiBOb3RlIHRoYXQgYWxsIGJhc2UgbGF5ZXJzIHNob3VsZCBiZSBwYXNzZWQgaW4gdGhlIGJhc2UgbGF5ZXJzIG9iamVjdCwgYnV0IG9ubHkgb25lIHNob3VsZCBiZSBhZGRlZCB0byB0aGUgbWFwIGR1cmluZyBtYXAgaW5zdGFudGlhdGlvbi5cclxuICB2YXIgbGF5ZXJzID0gZnVuY3Rpb24gKGJhc2VMYXllcnMsIG92ZXJsYXlzLCBvcHRpb25zKSB7XHJcbiAgXHRyZXR1cm4gbmV3IExheWVycyhiYXNlTGF5ZXJzLCBvdmVybGF5cywgb3B0aW9ucyk7XHJcbiAgfTtcblxuICAvKlxyXG4gICAqIEBjbGFzcyBDb250cm9sLlpvb21cclxuICAgKiBAYWthIEwuQ29udHJvbC5ab29tXHJcbiAgICogQGluaGVyaXRzIENvbnRyb2xcclxuICAgKlxyXG4gICAqIEEgYmFzaWMgem9vbSBjb250cm9sIHdpdGggdHdvIGJ1dHRvbnMgKHpvb20gaW4gYW5kIHpvb20gb3V0KS4gSXQgaXMgcHV0IG9uIHRoZSBtYXAgYnkgZGVmYXVsdCB1bmxlc3MgeW91IHNldCBpdHMgW2B6b29tQ29udHJvbGAgb3B0aW9uXSgjbWFwLXpvb21jb250cm9sKSB0byBgZmFsc2VgLiBFeHRlbmRzIGBDb250cm9sYC5cclxuICAgKi9cclxuXHJcbiAgdmFyIFpvb20gPSBDb250cm9sLmV4dGVuZCh7XHJcbiAgXHQvLyBAc2VjdGlvblxyXG4gIFx0Ly8gQGFrYSBDb250cm9sLlpvb20gb3B0aW9uc1xyXG4gIFx0b3B0aW9uczoge1xyXG4gIFx0XHRwb3NpdGlvbjogJ3RvcGxlZnQnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiB6b29tSW5UZXh0OiBTdHJpbmcgPSAnPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+Kzwvc3Bhbj4nXHJcbiAgXHRcdC8vIFRoZSB0ZXh0IHNldCBvbiB0aGUgJ3pvb20gaW4nIGJ1dHRvbi5cclxuICBcdFx0em9vbUluVGV4dDogJzxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPis8L3NwYW4+JyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gem9vbUluVGl0bGU6IFN0cmluZyA9ICdab29tIGluJ1xyXG4gIFx0XHQvLyBUaGUgdGl0bGUgc2V0IG9uIHRoZSAnem9vbSBpbicgYnV0dG9uLlxyXG4gIFx0XHR6b29tSW5UaXRsZTogJ1pvb20gaW4nLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiB6b29tT3V0VGV4dDogU3RyaW5nID0gJzxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiYjeDIyMTI7PC9zcGFuPidcclxuICBcdFx0Ly8gVGhlIHRleHQgc2V0IG9uIHRoZSAnem9vbSBvdXQnIGJ1dHRvbi5cclxuICBcdFx0em9vbU91dFRleHQ6ICc8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mI3gyMjEyOzwvc3Bhbj4nLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiB6b29tT3V0VGl0bGU6IFN0cmluZyA9ICdab29tIG91dCdcclxuICBcdFx0Ly8gVGhlIHRpdGxlIHNldCBvbiB0aGUgJ3pvb20gb3V0JyBidXR0b24uXHJcbiAgXHRcdHpvb21PdXRUaXRsZTogJ1pvb20gb3V0J1xyXG4gIFx0fSxcclxuXHJcbiAgXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG4gIFx0XHR2YXIgem9vbU5hbWUgPSAnbGVhZmxldC1jb250cm9sLXpvb20nLFxyXG4gIFx0XHQgICAgY29udGFpbmVyID0gY3JlYXRlJDEoJ2RpdicsIHpvb21OYW1lICsgJyBsZWFmbGV0LWJhcicpLFxyXG4gIFx0XHQgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuXHJcbiAgXHRcdHRoaXMuX3pvb21JbkJ1dHRvbiAgPSB0aGlzLl9jcmVhdGVCdXR0b24ob3B0aW9ucy56b29tSW5UZXh0LCBvcHRpb25zLnpvb21JblRpdGxlLFxyXG4gIFx0XHQgICAgICAgIHpvb21OYW1lICsgJy1pbicsICBjb250YWluZXIsIHRoaXMuX3pvb21Jbik7XHJcbiAgXHRcdHRoaXMuX3pvb21PdXRCdXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24ob3B0aW9ucy56b29tT3V0VGV4dCwgb3B0aW9ucy56b29tT3V0VGl0bGUsXHJcbiAgXHRcdCAgICAgICAgem9vbU5hbWUgKyAnLW91dCcsIGNvbnRhaW5lciwgdGhpcy5fem9vbU91dCk7XHJcblxyXG4gIFx0XHR0aGlzLl91cGRhdGVEaXNhYmxlZCgpO1xyXG4gIFx0XHRtYXAub24oJ3pvb21lbmQgem9vbWxldmVsc2NoYW5nZScsIHRoaXMuX3VwZGF0ZURpc2FibGVkLCB0aGlzKTtcclxuXHJcbiAgXHRcdHJldHVybiBjb250YWluZXI7XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgXHRcdG1hcC5vZmYoJ3pvb21lbmQgem9vbWxldmVsc2NoYW5nZScsIHRoaXMuX3VwZGF0ZURpc2FibGVkLCB0aGlzKTtcclxuICBcdH0sXHJcblxyXG4gIFx0ZGlzYWJsZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR0aGlzLl9kaXNhYmxlZCA9IHRydWU7XHJcbiAgXHRcdHRoaXMuX3VwZGF0ZURpc2FibGVkKCk7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRlbmFibGU6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dGhpcy5fZGlzYWJsZWQgPSBmYWxzZTtcclxuICBcdFx0dGhpcy5fdXBkYXRlRGlzYWJsZWQoKTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdF96b29tSW46IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fZGlzYWJsZWQgJiYgdGhpcy5fbWFwLl96b29tIDwgdGhpcy5fbWFwLmdldE1heFpvb20oKSkge1xyXG4gIFx0XHRcdHRoaXMuX21hcC56b29tSW4odGhpcy5fbWFwLm9wdGlvbnMuem9vbURlbHRhICogKGUuc2hpZnRLZXkgPyAzIDogMSkpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF96b29tT3V0OiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHRpZiAoIXRoaXMuX2Rpc2FibGVkICYmIHRoaXMuX21hcC5fem9vbSA+IHRoaXMuX21hcC5nZXRNaW5ab29tKCkpIHtcclxuICBcdFx0XHR0aGlzLl9tYXAuem9vbU91dCh0aGlzLl9tYXAub3B0aW9ucy56b29tRGVsdGEgKiAoZS5zaGlmdEtleSA/IDMgOiAxKSk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X2NyZWF0ZUJ1dHRvbjogZnVuY3Rpb24gKGh0bWwsIHRpdGxlLCBjbGFzc05hbWUsIGNvbnRhaW5lciwgZm4pIHtcclxuICBcdFx0dmFyIGxpbmsgPSBjcmVhdGUkMSgnYScsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcclxuICBcdFx0bGluay5pbm5lckhUTUwgPSBodG1sO1xyXG4gIFx0XHRsaW5rLmhyZWYgPSAnIyc7XHJcbiAgXHRcdGxpbmsudGl0bGUgPSB0aXRsZTtcclxuXHJcbiAgXHRcdC8qXHJcbiAgXHRcdCAqIFdpbGwgZm9yY2Ugc2NyZWVuIHJlYWRlcnMgbGlrZSBWb2ljZU92ZXIgdG8gcmVhZCB0aGlzIGFzIFwiWm9vbSBpbiAtIGJ1dHRvblwiXHJcbiAgXHRcdCAqL1xyXG4gIFx0XHRsaW5rLnNldEF0dHJpYnV0ZSgncm9sZScsICdidXR0b24nKTtcclxuICBcdFx0bGluay5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCB0aXRsZSk7XHJcblxyXG4gIFx0XHRkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihsaW5rKTtcclxuICBcdFx0b24obGluaywgJ2NsaWNrJywgc3RvcCk7XHJcbiAgXHRcdG9uKGxpbmssICdjbGljaycsIGZuLCB0aGlzKTtcclxuICBcdFx0b24obGluaywgJ2NsaWNrJywgdGhpcy5fcmVmb2N1c09uTWFwLCB0aGlzKTtcclxuXHJcbiAgXHRcdHJldHVybiBsaW5rO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfdXBkYXRlRGlzYWJsZWQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcclxuICBcdFx0ICAgIGNsYXNzTmFtZSA9ICdsZWFmbGV0LWRpc2FibGVkJztcclxuXHJcbiAgXHRcdHJlbW92ZUNsYXNzKHRoaXMuX3pvb21JbkJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuICBcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fem9vbU91dEJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuICBcdFx0dGhpcy5fem9vbUluQnV0dG9uLnNldEF0dHJpYnV0ZSgnYXJpYS1kaXNhYmxlZCcsICdmYWxzZScpO1xyXG4gIFx0XHR0aGlzLl96b29tT3V0QnV0dG9uLnNldEF0dHJpYnV0ZSgnYXJpYS1kaXNhYmxlZCcsICdmYWxzZScpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2Rpc2FibGVkIHx8IG1hcC5fem9vbSA9PT0gbWFwLmdldE1pblpvb20oKSkge1xyXG4gIFx0XHRcdGFkZENsYXNzKHRoaXMuX3pvb21PdXRCdXR0b24sIGNsYXNzTmFtZSk7XHJcbiAgXHRcdFx0dGhpcy5fem9vbU91dEJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnLCAndHJ1ZScpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdGlmICh0aGlzLl9kaXNhYmxlZCB8fCBtYXAuX3pvb20gPT09IG1hcC5nZXRNYXhab29tKCkpIHtcclxuICBcdFx0XHRhZGRDbGFzcyh0aGlzLl96b29tSW5CdXR0b24sIGNsYXNzTmFtZSk7XHJcbiAgXHRcdFx0dGhpcy5fem9vbUluQnV0dG9uLnNldEF0dHJpYnV0ZSgnYXJpYS1kaXNhYmxlZCcsICd0cnVlJyk7XHJcbiAgXHRcdH1cclxuICBcdH1cclxuICB9KTtcclxuXHJcbiAgLy8gQG5hbWVzcGFjZSBNYXBcclxuICAvLyBAc2VjdGlvbiBDb250cm9sIG9wdGlvbnNcclxuICAvLyBAb3B0aW9uIHpvb21Db250cm9sOiBCb29sZWFuID0gdHJ1ZVxyXG4gIC8vIFdoZXRoZXIgYSBbem9vbSBjb250cm9sXSgjY29udHJvbC16b29tKSBpcyBhZGRlZCB0byB0aGUgbWFwIGJ5IGRlZmF1bHQuXHJcbiAgTWFwLm1lcmdlT3B0aW9ucyh7XHJcbiAgXHR6b29tQ29udHJvbDogdHJ1ZVxyXG4gIH0pO1xyXG5cclxuICBNYXAuYWRkSW5pdEhvb2soZnVuY3Rpb24gKCkge1xyXG4gIFx0aWYgKHRoaXMub3B0aW9ucy56b29tQ29udHJvbCkge1xyXG4gIFx0XHQvLyBAc2VjdGlvbiBDb250cm9sc1xyXG4gIFx0XHQvLyBAcHJvcGVydHkgem9vbUNvbnRyb2w6IENvbnRyb2wuWm9vbVxyXG4gIFx0XHQvLyBUaGUgZGVmYXVsdCB6b29tIGNvbnRyb2wgKG9ubHkgYXZhaWxhYmxlIGlmIHRoZVxyXG4gIFx0XHQvLyBbYHpvb21Db250cm9sYCBvcHRpb25dKCNtYXAtem9vbWNvbnRyb2wpIHdhcyBgdHJ1ZWAgd2hlbiBjcmVhdGluZyB0aGUgbWFwKS5cclxuICBcdFx0dGhpcy56b29tQ29udHJvbCA9IG5ldyBab29tKCk7XHJcbiAgXHRcdHRoaXMuYWRkQ29udHJvbCh0aGlzLnpvb21Db250cm9sKTtcclxuICBcdH1cclxuICB9KTtcclxuXHJcbiAgLy8gQG5hbWVzcGFjZSBDb250cm9sLlpvb21cclxuICAvLyBAZmFjdG9yeSBMLmNvbnRyb2wuem9vbShvcHRpb25zOiBDb250cm9sLlpvb20gb3B0aW9ucylcclxuICAvLyBDcmVhdGVzIGEgem9vbSBjb250cm9sXHJcbiAgdmFyIHpvb20gPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gIFx0cmV0dXJuIG5ldyBab29tKG9wdGlvbnMpO1xyXG4gIH07XG5cbiAgLypcbiAgICogQGNsYXNzIENvbnRyb2wuU2NhbGVcbiAgICogQGFrYSBMLkNvbnRyb2wuU2NhbGVcbiAgICogQGluaGVyaXRzIENvbnRyb2xcbiAgICpcbiAgICogQSBzaW1wbGUgc2NhbGUgY29udHJvbCB0aGF0IHNob3dzIHRoZSBzY2FsZSBvZiB0aGUgY3VycmVudCBjZW50ZXIgb2Ygc2NyZWVuIGluIG1ldHJpYyAobS9rbSkgYW5kIGltcGVyaWFsIChtaS9mdCkgc3lzdGVtcy4gRXh0ZW5kcyBgQ29udHJvbGAuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIEwuY29udHJvbC5zY2FsZSgpLmFkZFRvKG1hcCk7XG4gICAqIGBgYFxuICAgKi9cblxuICB2YXIgU2NhbGUgPSBDb250cm9sLmV4dGVuZCh7XG4gIFx0Ly8gQHNlY3Rpb25cbiAgXHQvLyBAYWthIENvbnRyb2wuU2NhbGUgb3B0aW9uc1xuICBcdG9wdGlvbnM6IHtcbiAgXHRcdHBvc2l0aW9uOiAnYm90dG9tbGVmdCcsXG5cbiAgXHRcdC8vIEBvcHRpb24gbWF4V2lkdGg6IE51bWJlciA9IDEwMFxuICBcdFx0Ly8gTWF4aW11bSB3aWR0aCBvZiB0aGUgY29udHJvbCBpbiBwaXhlbHMuIFRoZSB3aWR0aCBpcyBzZXQgZHluYW1pY2FsbHkgdG8gc2hvdyByb3VuZCB2YWx1ZXMgKGUuZy4gMTAwLCAyMDAsIDUwMCkuXG4gIFx0XHRtYXhXaWR0aDogMTAwLFxuXG4gIFx0XHQvLyBAb3B0aW9uIG1ldHJpYzogQm9vbGVhbiA9IFRydWVcbiAgXHRcdC8vIFdoZXRoZXIgdG8gc2hvdyB0aGUgbWV0cmljIHNjYWxlIGxpbmUgKG0va20pLlxuICBcdFx0bWV0cmljOiB0cnVlLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGltcGVyaWFsOiBCb29sZWFuID0gVHJ1ZVxuICBcdFx0Ly8gV2hldGhlciB0byBzaG93IHRoZSBpbXBlcmlhbCBzY2FsZSBsaW5lIChtaS9mdCkuXG4gIFx0XHRpbXBlcmlhbDogdHJ1ZVxuXG4gIFx0XHQvLyBAb3B0aW9uIHVwZGF0ZVdoZW5JZGxlOiBCb29sZWFuID0gZmFsc2VcbiAgXHRcdC8vIElmIGB0cnVlYCwgdGhlIGNvbnRyb2wgaXMgdXBkYXRlZCBvbiBbYG1vdmVlbmRgXSgjbWFwLW1vdmVlbmQpLCBvdGhlcndpc2UgaXQncyBhbHdheXMgdXAtdG8tZGF0ZSAodXBkYXRlZCBvbiBbYG1vdmVgXSgjbWFwLW1vdmUpKS5cbiAgXHR9LFxuXG4gIFx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcbiAgXHRcdHZhciBjbGFzc05hbWUgPSAnbGVhZmxldC1jb250cm9sLXNjYWxlJyxcbiAgXHRcdCAgICBjb250YWluZXIgPSBjcmVhdGUkMSgnZGl2JywgY2xhc3NOYW1lKSxcbiAgXHRcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gIFx0XHR0aGlzLl9hZGRTY2FsZXMob3B0aW9ucywgY2xhc3NOYW1lICsgJy1saW5lJywgY29udGFpbmVyKTtcblxuICBcdFx0bWFwLm9uKG9wdGlvbnMudXBkYXRlV2hlbklkbGUgPyAnbW92ZWVuZCcgOiAnbW92ZScsIHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG4gIFx0XHRtYXAud2hlblJlYWR5KHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG5cbiAgXHRcdHJldHVybiBjb250YWluZXI7XG4gIFx0fSxcblxuICBcdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG4gIFx0XHRtYXAub2ZmKHRoaXMub3B0aW9ucy51cGRhdGVXaGVuSWRsZSA/ICdtb3ZlZW5kJyA6ICdtb3ZlJywgdGhpcy5fdXBkYXRlLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0X2FkZFNjYWxlczogZnVuY3Rpb24gKG9wdGlvbnMsIGNsYXNzTmFtZSwgY29udGFpbmVyKSB7XG4gIFx0XHRpZiAob3B0aW9ucy5tZXRyaWMpIHtcbiAgXHRcdFx0dGhpcy5fbVNjYWxlID0gY3JlYXRlJDEoJ2RpdicsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcbiAgXHRcdH1cbiAgXHRcdGlmIChvcHRpb25zLmltcGVyaWFsKSB7XG4gIFx0XHRcdHRoaXMuX2lTY2FsZSA9IGNyZWF0ZSQxKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG4gIFx0XHQgICAgeSA9IG1hcC5nZXRTaXplKCkueSAvIDI7XG5cbiAgXHRcdHZhciBtYXhNZXRlcnMgPSBtYXAuZGlzdGFuY2UoXG4gIFx0XHRcdG1hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKFswLCB5XSksXG4gIFx0XHRcdG1hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKFt0aGlzLm9wdGlvbnMubWF4V2lkdGgsIHldKSk7XG5cbiAgXHRcdHRoaXMuX3VwZGF0ZVNjYWxlcyhtYXhNZXRlcnMpO1xuICBcdH0sXG5cbiAgXHRfdXBkYXRlU2NhbGVzOiBmdW5jdGlvbiAobWF4TWV0ZXJzKSB7XG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLm1ldHJpYyAmJiBtYXhNZXRlcnMpIHtcbiAgXHRcdFx0dGhpcy5fdXBkYXRlTWV0cmljKG1heE1ldGVycyk7XG4gIFx0XHR9XG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLmltcGVyaWFsICYmIG1heE1ldGVycykge1xuICBcdFx0XHR0aGlzLl91cGRhdGVJbXBlcmlhbChtYXhNZXRlcnMpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfdXBkYXRlTWV0cmljOiBmdW5jdGlvbiAobWF4TWV0ZXJzKSB7XG4gIFx0XHR2YXIgbWV0ZXJzID0gdGhpcy5fZ2V0Um91bmROdW0obWF4TWV0ZXJzKSxcbiAgXHRcdCAgICBsYWJlbCA9IG1ldGVycyA8IDEwMDAgPyBtZXRlcnMgKyAnIG0nIDogKG1ldGVycyAvIDEwMDApICsgJyBrbSc7XG5cbiAgXHRcdHRoaXMuX3VwZGF0ZVNjYWxlKHRoaXMuX21TY2FsZSwgbGFiZWwsIG1ldGVycyAvIG1heE1ldGVycyk7XG4gIFx0fSxcblxuICBcdF91cGRhdGVJbXBlcmlhbDogZnVuY3Rpb24gKG1heE1ldGVycykge1xuICBcdFx0dmFyIG1heEZlZXQgPSBtYXhNZXRlcnMgKiAzLjI4MDgzOTksXG4gIFx0XHQgICAgbWF4TWlsZXMsIG1pbGVzLCBmZWV0O1xuXG4gIFx0XHRpZiAobWF4RmVldCA+IDUyODApIHtcbiAgXHRcdFx0bWF4TWlsZXMgPSBtYXhGZWV0IC8gNTI4MDtcbiAgXHRcdFx0bWlsZXMgPSB0aGlzLl9nZXRSb3VuZE51bShtYXhNaWxlcyk7XG4gIFx0XHRcdHRoaXMuX3VwZGF0ZVNjYWxlKHRoaXMuX2lTY2FsZSwgbWlsZXMgKyAnIG1pJywgbWlsZXMgLyBtYXhNaWxlcyk7XG5cbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGZlZXQgPSB0aGlzLl9nZXRSb3VuZE51bShtYXhGZWV0KTtcbiAgXHRcdFx0dGhpcy5fdXBkYXRlU2NhbGUodGhpcy5faVNjYWxlLCBmZWV0ICsgJyBmdCcsIGZlZXQgLyBtYXhGZWV0KTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVNjYWxlOiBmdW5jdGlvbiAoc2NhbGUsIHRleHQsIHJhdGlvKSB7XG4gIFx0XHRzY2FsZS5zdHlsZS53aWR0aCA9IE1hdGgucm91bmQodGhpcy5vcHRpb25zLm1heFdpZHRoICogcmF0aW8pICsgJ3B4JztcbiAgXHRcdHNjYWxlLmlubmVySFRNTCA9IHRleHQ7XG4gIFx0fSxcblxuICBcdF9nZXRSb3VuZE51bTogZnVuY3Rpb24gKG51bSkge1xuICBcdFx0dmFyIHBvdzEwID0gTWF0aC5wb3coMTAsIChNYXRoLmZsb29yKG51bSkgKyAnJykubGVuZ3RoIC0gMSksXG4gIFx0XHQgICAgZCA9IG51bSAvIHBvdzEwO1xuXG4gIFx0XHRkID0gZCA+PSAxMCA/IDEwIDpcbiAgXHRcdCAgICBkID49IDUgPyA1IDpcbiAgXHRcdCAgICBkID49IDMgPyAzIDpcbiAgXHRcdCAgICBkID49IDIgPyAyIDogMTtcblxuICBcdFx0cmV0dXJuIHBvdzEwICogZDtcbiAgXHR9XG4gIH0pO1xuXG5cbiAgLy8gQGZhY3RvcnkgTC5jb250cm9sLnNjYWxlKG9wdGlvbnM/OiBDb250cm9sLlNjYWxlIG9wdGlvbnMpXG4gIC8vIENyZWF0ZXMgYW4gc2NhbGUgY29udHJvbCB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuICB2YXIgc2NhbGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdHJldHVybiBuZXcgU2NhbGUob3B0aW9ucyk7XG4gIH07XG5cbiAgdmFyIHVrcmFpbmlhbkZsYWcgPSAnPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIxMlwiIGhlaWdodD1cIjhcIiB2aWV3Qm94PVwiMCAwIDEyIDhcIiBjbGFzcz1cImxlYWZsZXQtYXR0cmlidXRpb24tZmxhZ1wiPjxwYXRoIGZpbGw9XCIjNEM3QkUxXCIgZD1cIk0wIDBoMTJ2NEgwelwiLz48cGF0aCBmaWxsPVwiI0ZGRDUwMFwiIGQ9XCJNMCA0aDEydjNIMHpcIi8+PHBhdGggZmlsbD1cIiNFMEJDMDBcIiBkPVwiTTAgN2gxMnYxSDB6XCIvPjwvc3ZnPic7XHJcblxyXG5cclxuICAvKlxyXG4gICAqIEBjbGFzcyBDb250cm9sLkF0dHJpYnV0aW9uXHJcbiAgICogQGFrYSBMLkNvbnRyb2wuQXR0cmlidXRpb25cclxuICAgKiBAaW5oZXJpdHMgQ29udHJvbFxyXG4gICAqXHJcbiAgICogVGhlIGF0dHJpYnV0aW9uIGNvbnRyb2wgYWxsb3dzIHlvdSB0byBkaXNwbGF5IGF0dHJpYnV0aW9uIGRhdGEgaW4gYSBzbWFsbCB0ZXh0IGJveCBvbiBhIG1hcC4gSXQgaXMgcHV0IG9uIHRoZSBtYXAgYnkgZGVmYXVsdCB1bmxlc3MgeW91IHNldCBpdHMgW2BhdHRyaWJ1dGlvbkNvbnRyb2xgIG9wdGlvbl0oI21hcC1hdHRyaWJ1dGlvbmNvbnRyb2wpIHRvIGBmYWxzZWAsIGFuZCBpdCBmZXRjaGVzIGF0dHJpYnV0aW9uIHRleHRzIGZyb20gbGF5ZXJzIHdpdGggdGhlIFtgZ2V0QXR0cmlidXRpb25gIG1ldGhvZF0oI2xheWVyLWdldGF0dHJpYnV0aW9uKSBhdXRvbWF0aWNhbGx5LiBFeHRlbmRzIENvbnRyb2wuXHJcbiAgICovXHJcblxyXG4gIHZhciBBdHRyaWJ1dGlvbiA9IENvbnRyb2wuZXh0ZW5kKHtcclxuICBcdC8vIEBzZWN0aW9uXHJcbiAgXHQvLyBAYWthIENvbnRyb2wuQXR0cmlidXRpb24gb3B0aW9uc1xyXG4gIFx0b3B0aW9uczoge1xyXG4gIFx0XHRwb3NpdGlvbjogJ2JvdHRvbXJpZ2h0JyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gcHJlZml4OiBTdHJpbmd8ZmFsc2UgPSAnTGVhZmxldCdcclxuICBcdFx0Ly8gVGhlIEhUTUwgdGV4dCBzaG93biBiZWZvcmUgdGhlIGF0dHJpYnV0aW9ucy4gUGFzcyBgZmFsc2VgIHRvIGRpc2FibGUuXHJcbiAgXHRcdHByZWZpeDogJzxhIGhyZWY9XCJodHRwczovL2xlYWZsZXRqcy5jb21cIiB0aXRsZT1cIkEgSmF2YVNjcmlwdCBsaWJyYXJ5IGZvciBpbnRlcmFjdGl2ZSBtYXBzXCI+JyArIChCcm93c2VyLmlubGluZVN2ZyA/IHVrcmFpbmlhbkZsYWcgKyAnICcgOiAnJykgKyAnTGVhZmxldDwvYT4nXHJcbiAgXHR9LFxyXG5cclxuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG4gIFx0XHR0aGlzLl9hdHRyaWJ1dGlvbnMgPSB7fTtcclxuICBcdH0sXHJcblxyXG4gIFx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0bWFwLmF0dHJpYnV0aW9uQ29udHJvbCA9IHRoaXM7XHJcbiAgXHRcdHRoaXMuX2NvbnRhaW5lciA9IGNyZWF0ZSQxKCdkaXYnLCAnbGVhZmxldC1jb250cm9sLWF0dHJpYnV0aW9uJyk7XHJcbiAgXHRcdGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKHRoaXMuX2NvbnRhaW5lcik7XHJcblxyXG4gIFx0XHQvLyBUT0RPIHVnbHksIHJlZmFjdG9yXHJcbiAgXHRcdGZvciAodmFyIGkgaW4gbWFwLl9sYXllcnMpIHtcclxuICBcdFx0XHRpZiAobWFwLl9sYXllcnNbaV0uZ2V0QXR0cmlidXRpb24pIHtcclxuICBcdFx0XHRcdHRoaXMuYWRkQXR0cmlidXRpb24obWFwLl9sYXllcnNbaV0uZ2V0QXR0cmlidXRpb24oKSk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHJcbiAgXHRcdG1hcC5vbignbGF5ZXJhZGQnLCB0aGlzLl9hZGRBdHRyaWJ1dGlvbiwgdGhpcyk7XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG4gIFx0XHRtYXAub2ZmKCdsYXllcmFkZCcsIHRoaXMuX2FkZEF0dHJpYnV0aW9uLCB0aGlzKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2FkZEF0dHJpYnV0aW9uOiBmdW5jdGlvbiAoZXYpIHtcclxuICBcdFx0aWYgKGV2LmxheWVyLmdldEF0dHJpYnV0aW9uKSB7XHJcbiAgXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGlvbihldi5sYXllci5nZXRBdHRyaWJ1dGlvbigpKTtcclxuICBcdFx0XHRldi5sYXllci5vbmNlKCdyZW1vdmUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdFx0XHR0aGlzLnJlbW92ZUF0dHJpYnV0aW9uKGV2LmxheWVyLmdldEF0dHJpYnV0aW9uKCkpO1xyXG4gIFx0XHRcdH0sIHRoaXMpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0UHJlZml4KHByZWZpeDogU3RyaW5nfGZhbHNlKTogdGhpc1xyXG4gIFx0Ly8gVGhlIEhUTUwgdGV4dCBzaG93biBiZWZvcmUgdGhlIGF0dHJpYnV0aW9ucy4gUGFzcyBgZmFsc2VgIHRvIGRpc2FibGUuXHJcbiAgXHRzZXRQcmVmaXg6IGZ1bmN0aW9uIChwcmVmaXgpIHtcclxuICBcdFx0dGhpcy5vcHRpb25zLnByZWZpeCA9IHByZWZpeDtcclxuICBcdFx0dGhpcy5fdXBkYXRlKCk7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGFkZEF0dHJpYnV0aW9uKHRleHQ6IFN0cmluZyk6IHRoaXNcclxuICBcdC8vIEFkZHMgYW4gYXR0cmlidXRpb24gdGV4dCAoZS5nLiBgJyZjb3B5OyBPcGVuU3RyZWV0TWFwIGNvbnRyaWJ1dG9ycydgKS5cclxuICBcdGFkZEF0dHJpYnV0aW9uOiBmdW5jdGlvbiAodGV4dCkge1xyXG4gIFx0XHRpZiAoIXRleHQpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcbiAgXHRcdGlmICghdGhpcy5fYXR0cmlidXRpb25zW3RleHRdKSB7XHJcbiAgXHRcdFx0dGhpcy5fYXR0cmlidXRpb25zW3RleHRdID0gMDtcclxuICBcdFx0fVxyXG4gIFx0XHR0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0rKztcclxuXHJcbiAgXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgcmVtb3ZlQXR0cmlidXRpb24odGV4dDogU3RyaW5nKTogdGhpc1xyXG4gIFx0Ly8gUmVtb3ZlcyBhbiBhdHRyaWJ1dGlvbiB0ZXh0LlxyXG4gIFx0cmVtb3ZlQXR0cmlidXRpb246IGZ1bmN0aW9uICh0ZXh0KSB7XHJcbiAgXHRcdGlmICghdGV4dCkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuICBcdFx0aWYgKHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSkge1xyXG4gIFx0XHRcdHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XS0tO1xyXG4gIFx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdHZhciBhdHRyaWJzID0gW107XHJcblxyXG4gIFx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2F0dHJpYnV0aW9ucykge1xyXG4gIFx0XHRcdGlmICh0aGlzLl9hdHRyaWJ1dGlvbnNbaV0pIHtcclxuICBcdFx0XHRcdGF0dHJpYnMucHVzaChpKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBwcmVmaXhBbmRBdHRyaWJzID0gW107XHJcblxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLnByZWZpeCkge1xyXG4gIFx0XHRcdHByZWZpeEFuZEF0dHJpYnMucHVzaCh0aGlzLm9wdGlvbnMucHJlZml4KTtcclxuICBcdFx0fVxyXG4gIFx0XHRpZiAoYXR0cmlicy5sZW5ndGgpIHtcclxuICBcdFx0XHRwcmVmaXhBbmRBdHRyaWJzLnB1c2goYXR0cmlicy5qb2luKCcsICcpKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fY29udGFpbmVyLmlubmVySFRNTCA9IHByZWZpeEFuZEF0dHJpYnMuam9pbignIDxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPnw8L3NwYW4+ICcpO1xyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuICAvLyBAbmFtZXNwYWNlIE1hcFxyXG4gIC8vIEBzZWN0aW9uIENvbnRyb2wgb3B0aW9uc1xyXG4gIC8vIEBvcHRpb24gYXR0cmlidXRpb25Db250cm9sOiBCb29sZWFuID0gdHJ1ZVxyXG4gIC8vIFdoZXRoZXIgYSBbYXR0cmlidXRpb24gY29udHJvbF0oI2NvbnRyb2wtYXR0cmlidXRpb24pIGlzIGFkZGVkIHRvIHRoZSBtYXAgYnkgZGVmYXVsdC5cclxuICBNYXAubWVyZ2VPcHRpb25zKHtcclxuICBcdGF0dHJpYnV0aW9uQ29udHJvbDogdHJ1ZVxyXG4gIH0pO1xyXG5cclxuICBNYXAuYWRkSW5pdEhvb2soZnVuY3Rpb24gKCkge1xyXG4gIFx0aWYgKHRoaXMub3B0aW9ucy5hdHRyaWJ1dGlvbkNvbnRyb2wpIHtcclxuICBcdFx0bmV3IEF0dHJpYnV0aW9uKCkuYWRkVG8odGhpcyk7XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG4gIC8vIEBuYW1lc3BhY2UgQ29udHJvbC5BdHRyaWJ1dGlvblxyXG4gIC8vIEBmYWN0b3J5IEwuY29udHJvbC5hdHRyaWJ1dGlvbihvcHRpb25zOiBDb250cm9sLkF0dHJpYnV0aW9uIG9wdGlvbnMpXHJcbiAgLy8gQ3JlYXRlcyBhbiBhdHRyaWJ1dGlvbiBjb250cm9sLlxyXG4gIHZhciBhdHRyaWJ1dGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgXHRyZXR1cm4gbmV3IEF0dHJpYnV0aW9uKG9wdGlvbnMpO1xyXG4gIH07XG5cbiAgQ29udHJvbC5MYXllcnMgPSBMYXllcnM7XG4gIENvbnRyb2wuWm9vbSA9IFpvb207XG4gIENvbnRyb2wuU2NhbGUgPSBTY2FsZTtcbiAgQ29udHJvbC5BdHRyaWJ1dGlvbiA9IEF0dHJpYnV0aW9uO1xuXG4gIGNvbnRyb2wubGF5ZXJzID0gbGF5ZXJzO1xuICBjb250cm9sLnpvb20gPSB6b29tO1xuICBjb250cm9sLnNjYWxlID0gc2NhbGU7XG4gIGNvbnRyb2wuYXR0cmlidXRpb24gPSBhdHRyaWJ1dGlvbjtcblxuICAvKlxuICBcdEwuSGFuZGxlciBpcyBhIGJhc2UgY2xhc3MgZm9yIGhhbmRsZXIgY2xhc3NlcyB0aGF0IGFyZSB1c2VkIGludGVybmFsbHkgdG8gaW5qZWN0XG4gIFx0aW50ZXJhY3Rpb24gZmVhdHVyZXMgbGlrZSBkcmFnZ2luZyB0byBjbGFzc2VzIGxpa2UgTWFwIGFuZCBNYXJrZXIuXG4gICovXG5cbiAgLy8gQGNsYXNzIEhhbmRsZXJcbiAgLy8gQGFrYSBMLkhhbmRsZXJcbiAgLy8gQWJzdHJhY3QgY2xhc3MgZm9yIG1hcCBpbnRlcmFjdGlvbiBoYW5kbGVyc1xuXG4gIHZhciBIYW5kbGVyID0gQ2xhc3MuZXh0ZW5kKHtcbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7XG4gIFx0XHR0aGlzLl9tYXAgPSBtYXA7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgZW5hYmxlKCk6IHRoaXNcbiAgXHQvLyBFbmFibGVzIHRoZSBoYW5kbGVyXG4gIFx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fZW5hYmxlZCkgeyByZXR1cm4gdGhpczsgfVxuXG4gIFx0XHR0aGlzLl9lbmFibGVkID0gdHJ1ZTtcbiAgXHRcdHRoaXMuYWRkSG9va3MoKTtcbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGRpc2FibGUoKTogdGhpc1xuICBcdC8vIERpc2FibGVzIHRoZSBoYW5kbGVyXG4gIFx0ZGlzYWJsZTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybiB0aGlzOyB9XG5cbiAgXHRcdHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcbiAgXHRcdHRoaXMucmVtb3ZlSG9va3MoKTtcbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGVuYWJsZWQoKTogQm9vbGVhblxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBoYW5kbGVyIGlzIGVuYWJsZWRcbiAgXHRlbmFibGVkOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gISF0aGlzLl9lbmFibGVkO1xuICBcdH1cblxuICBcdC8vIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXG4gIFx0Ly8gQ2xhc3NlcyBpbmhlcml0aW5nIGZyb20gYEhhbmRsZXJgIG11c3QgaW1wbGVtZW50IHRoZSB0d28gZm9sbG93aW5nIG1ldGhvZHM6XG4gIFx0Ly8gQG1ldGhvZCBhZGRIb29rcygpXG4gIFx0Ly8gQ2FsbGVkIHdoZW4gdGhlIGhhbmRsZXIgaXMgZW5hYmxlZCwgc2hvdWxkIGFkZCBldmVudCBob29rcy5cbiAgXHQvLyBAbWV0aG9kIHJlbW92ZUhvb2tzKClcbiAgXHQvLyBDYWxsZWQgd2hlbiB0aGUgaGFuZGxlciBpcyBkaXNhYmxlZCwgc2hvdWxkIHJlbW92ZSB0aGUgZXZlbnQgaG9va3MgYWRkZWQgcHJldmlvdXNseS5cbiAgfSk7XG5cbiAgLy8gQHNlY3Rpb24gVGhlcmUgaXMgc3RhdGljIGZ1bmN0aW9uIHdoaWNoIGNhbiBiZSBjYWxsZWQgd2l0aG91dCBpbnN0YW50aWF0aW5nIEwuSGFuZGxlcjpcbiAgLy8gQGZ1bmN0aW9uIGFkZFRvKG1hcDogTWFwLCBuYW1lOiBTdHJpbmcpOiB0aGlzXG4gIC8vIEFkZHMgYSBuZXcgSGFuZGxlciB0byB0aGUgZ2l2ZW4gbWFwIHdpdGggdGhlIGdpdmVuIG5hbWUuXG4gIEhhbmRsZXIuYWRkVG8gPSBmdW5jdGlvbiAobWFwLCBuYW1lKSB7XG4gIFx0bWFwLmFkZEhhbmRsZXIobmFtZSwgdGhpcyk7XG4gIFx0cmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIE1peGluID0ge0V2ZW50czogRXZlbnRzfTtcblxuICAvKlxyXG4gICAqIEBjbGFzcyBEcmFnZ2FibGVcclxuICAgKiBAYWthIEwuRHJhZ2dhYmxlXHJcbiAgICogQGluaGVyaXRzIEV2ZW50ZWRcclxuICAgKlxyXG4gICAqIEEgY2xhc3MgZm9yIG1ha2luZyBET00gZWxlbWVudHMgZHJhZ2dhYmxlIChpbmNsdWRpbmcgdG91Y2ggc3VwcG9ydCkuXHJcbiAgICogVXNlZCBpbnRlcm5hbGx5IGZvciBtYXAgYW5kIG1hcmtlciBkcmFnZ2luZy4gT25seSB3b3JrcyBmb3IgZWxlbWVudHNcclxuICAgKiB0aGF0IHdlcmUgcG9zaXRpb25lZCB3aXRoIFtgTC5Eb21VdGlsLnNldFBvc2l0aW9uYF0oI2RvbXV0aWwtc2V0cG9zaXRpb24pLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBqc1xyXG4gICAqIHZhciBkcmFnZ2FibGUgPSBuZXcgTC5EcmFnZ2FibGUoZWxlbWVudFRvRHJhZyk7XHJcbiAgICogZHJhZ2dhYmxlLmVuYWJsZSgpO1xyXG4gICAqIGBgYFxyXG4gICAqL1xyXG5cclxuICB2YXIgU1RBUlQgPSBCcm93c2VyLnRvdWNoID8gJ3RvdWNoc3RhcnQgbW91c2Vkb3duJyA6ICdtb3VzZWRvd24nO1xyXG5cclxuICB2YXIgRHJhZ2dhYmxlID0gRXZlbnRlZC5leHRlbmQoe1xyXG5cclxuICBcdG9wdGlvbnM6IHtcclxuICBcdFx0Ly8gQHNlY3Rpb25cclxuICBcdFx0Ly8gQGFrYSBEcmFnZ2FibGUgb3B0aW9uc1xyXG4gIFx0XHQvLyBAb3B0aW9uIGNsaWNrVG9sZXJhbmNlOiBOdW1iZXIgPSAzXHJcbiAgXHRcdC8vIFRoZSBtYXggbnVtYmVyIG9mIHBpeGVscyBhIHVzZXIgY2FuIHNoaWZ0IHRoZSBtb3VzZSBwb2ludGVyIGR1cmluZyBhIGNsaWNrXHJcbiAgXHRcdC8vIGZvciBpdCB0byBiZSBjb25zaWRlcmVkIGEgdmFsaWQgY2xpY2sgKGFzIG9wcG9zZWQgdG8gYSBtb3VzZSBkcmFnKS5cclxuICBcdFx0Y2xpY2tUb2xlcmFuY2U6IDNcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQGNvbnN0cnVjdG9yIEwuRHJhZ2dhYmxlKGVsOiBIVE1MRWxlbWVudCwgZHJhZ0hhbmRsZT86IEhUTUxFbGVtZW50LCBwcmV2ZW50T3V0bGluZT86IEJvb2xlYW4sIG9wdGlvbnM/OiBEcmFnZ2FibGUgb3B0aW9ucylcclxuICBcdC8vIENyZWF0ZXMgYSBgRHJhZ2dhYmxlYCBvYmplY3QgZm9yIG1vdmluZyBgZWxgIHdoZW4geW91IHN0YXJ0IGRyYWdnaW5nIHRoZSBgZHJhZ0hhbmRsZWAgZWxlbWVudCAoZXF1YWxzIGBlbGAgaXRzZWxmIGJ5IGRlZmF1bHQpLlxyXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGVsZW1lbnQsIGRyYWdTdGFydFRhcmdldCwgcHJldmVudE91dGxpbmUsIG9wdGlvbnMpIHtcclxuICBcdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcbiAgXHRcdHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xyXG4gIFx0XHR0aGlzLl9kcmFnU3RhcnRUYXJnZXQgPSBkcmFnU3RhcnRUYXJnZXQgfHwgZWxlbWVudDtcclxuICBcdFx0dGhpcy5fcHJldmVudE91dGxpbmUgPSBwcmV2ZW50T3V0bGluZTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBlbmFibGUoKVxyXG4gIFx0Ly8gRW5hYmxlcyB0aGUgZHJhZ2dpbmcgYWJpbGl0eVxyXG4gIFx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0b24odGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0LCBTVEFSVCwgdGhpcy5fb25Eb3duLCB0aGlzKTtcclxuXHJcbiAgXHRcdHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGRpc2FibGUoKVxyXG4gIFx0Ly8gRGlzYWJsZXMgdGhlIGRyYWdnaW5nIGFiaWxpdHlcclxuICBcdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0Ly8gSWYgd2UncmUgY3VycmVudGx5IGRyYWdnaW5nIHRoaXMgZHJhZ2dhYmxlLFxyXG4gIFx0XHQvLyBkaXNhYmxpbmcgaXQgY291bnRzIGFzIGZpcnN0IGVuZGluZyB0aGUgZHJhZy5cclxuICBcdFx0aWYgKERyYWdnYWJsZS5fZHJhZ2dpbmcgPT09IHRoaXMpIHtcclxuICBcdFx0XHR0aGlzLmZpbmlzaERyYWcodHJ1ZSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdG9mZih0aGlzLl9kcmFnU3RhcnRUYXJnZXQsIFNUQVJULCB0aGlzLl9vbkRvd24sIHRoaXMpO1xyXG5cclxuICBcdFx0dGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xyXG4gIFx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfb25Eb3duOiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHQvLyBJZ25vcmUgdGhlIGV2ZW50IGlmIGRpc2FibGVkOyB0aGlzIGhhcHBlbnMgaW4gSUUxMVxyXG4gIFx0XHQvLyB1bmRlciBzb21lIGNpcmN1bXN0YW5jZXMsIHNlZSAjMzY2Ni5cclxuICBcdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcclxuXHJcbiAgXHRcdGlmIChoYXNDbGFzcyh0aGlzLl9lbGVtZW50LCAnbGVhZmxldC16b29tLWFuaW0nKSkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdGlmIChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCAhPT0gMSkge1xyXG4gIFx0XHRcdC8vIEZpbmlzaCBkcmFnZ2luZyB0byBhdm9pZCBjb25mbGljdCB3aXRoIHRvdWNoWm9vbVxyXG4gIFx0XHRcdGlmIChEcmFnZ2FibGUuX2RyYWdnaW5nID09PSB0aGlzKSB7XHJcbiAgXHRcdFx0XHR0aGlzLmZpbmlzaERyYWcoKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0cmV0dXJuO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAoRHJhZ2dhYmxlLl9kcmFnZ2luZyB8fCBlLnNoaWZ0S2V5IHx8ICgoZS53aGljaCAhPT0gMSkgJiYgKGUuYnV0dG9uICE9PSAxKSAmJiAhZS50b3VjaGVzKSkgeyByZXR1cm47IH1cclxuICBcdFx0RHJhZ2dhYmxlLl9kcmFnZ2luZyA9IHRoaXM7ICAvLyBQcmV2ZW50IGRyYWdnaW5nIG11bHRpcGxlIG9iamVjdHMgYXQgb25jZS5cclxuXHJcbiAgXHRcdGlmICh0aGlzLl9wcmV2ZW50T3V0bGluZSkge1xyXG4gIFx0XHRcdHByZXZlbnRPdXRsaW5lKHRoaXMuX2VsZW1lbnQpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRkaXNhYmxlSW1hZ2VEcmFnKCk7XHJcbiAgXHRcdGRpc2FibGVUZXh0U2VsZWN0aW9uKCk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fbW92aW5nKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0Ly8gQGV2ZW50IGRvd246IEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gYSBkcmFnIGlzIGFib3V0IHRvIHN0YXJ0LlxyXG4gIFx0XHR0aGlzLmZpcmUoJ2Rvd24nKTtcclxuXHJcbiAgXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGUsXHJcbiAgXHRcdCAgICBzaXplZFBhcmVudCA9IGdldFNpemVkUGFyZW50Tm9kZSh0aGlzLl9lbGVtZW50KTtcclxuXHJcbiAgXHRcdHRoaXMuX3N0YXJ0UG9pbnQgPSBuZXcgUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSk7XHJcbiAgXHRcdHRoaXMuX3N0YXJ0UG9zID0gZ2V0UG9zaXRpb24odGhpcy5fZWxlbWVudCk7XHJcblxyXG4gIFx0XHQvLyBDYWNoZSB0aGUgc2NhbGUsIHNvIHRoYXQgd2UgY2FuIGNvbnRpbnVvdXNseSBjb21wZW5zYXRlIGZvciBpdCBkdXJpbmcgZHJhZyAoX29uTW92ZSkuXHJcbiAgXHRcdHRoaXMuX3BhcmVudFNjYWxlID0gZ2V0U2NhbGUoc2l6ZWRQYXJlbnQpO1xyXG5cclxuICBcdFx0dmFyIG1vdXNlZXZlbnQgPSBlLnR5cGUgPT09ICdtb3VzZWRvd24nO1xyXG4gIFx0XHRvbihkb2N1bWVudCwgbW91c2VldmVudCA/ICdtb3VzZW1vdmUnIDogJ3RvdWNobW92ZScsIHRoaXMuX29uTW92ZSwgdGhpcyk7XHJcbiAgXHRcdG9uKGRvY3VtZW50LCBtb3VzZWV2ZW50ID8gJ21vdXNldXAnIDogJ3RvdWNoZW5kIHRvdWNoY2FuY2VsJywgdGhpcy5fb25VcCwgdGhpcyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9vbk1vdmU6IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdC8vIElnbm9yZSB0aGUgZXZlbnQgaWYgZGlzYWJsZWQ7IHRoaXMgaGFwcGVucyBpbiBJRTExXHJcbiAgXHRcdC8vIHVuZGVyIHNvbWUgY2lyY3Vtc3RhbmNlcywgc2VlICMzNjY2LlxyXG4gIFx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHRpZiAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPiAxKSB7XHJcbiAgXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIGZpcnN0ID0gKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID09PSAxID8gZS50b3VjaGVzWzBdIDogZSksXHJcbiAgXHRcdCAgICBvZmZzZXQgPSBuZXcgUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSkuX3N1YnRyYWN0KHRoaXMuX3N0YXJ0UG9pbnQpO1xyXG5cclxuICBcdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHsgcmV0dXJuOyB9XHJcbiAgXHRcdGlmIChNYXRoLmFicyhvZmZzZXQueCkgKyBNYXRoLmFicyhvZmZzZXQueSkgPCB0aGlzLm9wdGlvbnMuY2xpY2tUb2xlcmFuY2UpIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHQvLyBXZSBhc3N1bWUgdGhhdCB0aGUgcGFyZW50IGNvbnRhaW5lcidzIHBvc2l0aW9uLCBib3JkZXIgYW5kIHNjYWxlIGRvIG5vdCBjaGFuZ2UgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgZHJhZy5cclxuICBcdFx0Ly8gVGhlcmVmb3JlIHRoZXJlIGlzIG5vIG5lZWQgdG8gYWNjb3VudCBmb3IgdGhlIHBvc2l0aW9uIGFuZCBib3JkZXIgKHRoZXkgYXJlIGVsaW1pbmF0ZWQgYnkgdGhlIHN1YnRyYWN0aW9uKVxyXG4gIFx0XHQvLyBhbmQgd2UgY2FuIHVzZSB0aGUgY2FjaGVkIHZhbHVlIGZvciB0aGUgc2NhbGUuXHJcbiAgXHRcdG9mZnNldC54IC89IHRoaXMuX3BhcmVudFNjYWxlLng7XHJcbiAgXHRcdG9mZnNldC55IC89IHRoaXMuX3BhcmVudFNjYWxlLnk7XHJcblxyXG4gIFx0XHRwcmV2ZW50RGVmYXVsdChlKTtcclxuXHJcbiAgXHRcdGlmICghdGhpcy5fbW92ZWQpIHtcclxuICBcdFx0XHQvLyBAZXZlbnQgZHJhZ3N0YXJ0OiBFdmVudFxyXG4gIFx0XHRcdC8vIEZpcmVkIHdoZW4gYSBkcmFnIHN0YXJ0c1xyXG4gIFx0XHRcdHRoaXMuZmlyZSgnZHJhZ3N0YXJ0Jyk7XHJcblxyXG4gIFx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcclxuXHJcbiAgXHRcdFx0YWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ2xlYWZsZXQtZHJhZ2dpbmcnKTtcclxuXHJcbiAgXHRcdFx0dGhpcy5fbGFzdFRhcmdldCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcclxuICBcdFx0XHQvLyBJRSBhbmQgRWRnZSBkbyBub3QgZ2l2ZSB0aGUgPHVzZT4gZWxlbWVudCwgc28gZmV0Y2ggaXRcclxuICBcdFx0XHQvLyBpZiBuZWNlc3NhcnlcclxuICBcdFx0XHRpZiAod2luZG93LlNWR0VsZW1lbnRJbnN0YW5jZSAmJiB0aGlzLl9sYXN0VGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LlNWR0VsZW1lbnRJbnN0YW5jZSkge1xyXG4gIFx0XHRcdFx0dGhpcy5fbGFzdFRhcmdldCA9IHRoaXMuX2xhc3RUYXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQ7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHRcdGFkZENsYXNzKHRoaXMuX2xhc3RUYXJnZXQsICdsZWFmbGV0LWRyYWctdGFyZ2V0Jyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX25ld1BvcyA9IHRoaXMuX3N0YXJ0UG9zLmFkZChvZmZzZXQpO1xyXG4gIFx0XHR0aGlzLl9tb3ZpbmcgPSB0cnVlO1xyXG5cclxuICBcdFx0dGhpcy5fbGFzdEV2ZW50ID0gZTtcclxuICBcdFx0dGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3VwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBlID0ge29yaWdpbmFsRXZlbnQ6IHRoaXMuX2xhc3RFdmVudH07XHJcblxyXG4gIFx0XHQvLyBAZXZlbnQgcHJlZHJhZzogRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgY29udGludW91c2x5IGR1cmluZyBkcmFnZ2luZyAqYmVmb3JlKiBlYWNoIGNvcnJlc3BvbmRpbmdcclxuICBcdFx0Ly8gdXBkYXRlIG9mIHRoZSBlbGVtZW50J3MgcG9zaXRpb24uXHJcbiAgXHRcdHRoaXMuZmlyZSgncHJlZHJhZycsIGUpO1xyXG4gIFx0XHRzZXRQb3NpdGlvbih0aGlzLl9lbGVtZW50LCB0aGlzLl9uZXdQb3MpO1xyXG5cclxuICBcdFx0Ly8gQGV2ZW50IGRyYWc6IEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIGNvbnRpbnVvdXNseSBkdXJpbmcgZHJhZ2dpbmcuXHJcbiAgXHRcdHRoaXMuZmlyZSgnZHJhZycsIGUpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfb25VcDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHQvLyBJZ25vcmUgdGhlIGV2ZW50IGlmIGRpc2FibGVkOyB0aGlzIGhhcHBlbnMgaW4gSUUxMVxyXG4gIFx0XHQvLyB1bmRlciBzb21lIGNpcmN1bXN0YW5jZXMsIHNlZSAjMzY2Ni5cclxuICBcdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG4gIFx0XHR0aGlzLmZpbmlzaERyYWcoKTtcclxuICBcdH0sXHJcblxyXG4gIFx0ZmluaXNoRHJhZzogZnVuY3Rpb24gKG5vSW5lcnRpYSkge1xyXG4gIFx0XHRyZW1vdmVDbGFzcyhkb2N1bWVudC5ib2R5LCAnbGVhZmxldC1kcmFnZ2luZycpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2xhc3RUYXJnZXQpIHtcclxuICBcdFx0XHRyZW1vdmVDbGFzcyh0aGlzLl9sYXN0VGFyZ2V0LCAnbGVhZmxldC1kcmFnLXRhcmdldCcpO1xyXG4gIFx0XHRcdHRoaXMuX2xhc3RUYXJnZXQgPSBudWxsO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRvZmYoZG9jdW1lbnQsICdtb3VzZW1vdmUgdG91Y2htb3ZlJywgdGhpcy5fb25Nb3ZlLCB0aGlzKTtcclxuICBcdFx0b2ZmKGRvY3VtZW50LCAnbW91c2V1cCB0b3VjaGVuZCB0b3VjaGNhbmNlbCcsIHRoaXMuX29uVXAsIHRoaXMpO1xyXG5cclxuICBcdFx0ZW5hYmxlSW1hZ2VEcmFnKCk7XHJcbiAgXHRcdGVuYWJsZVRleHRTZWxlY3Rpb24oKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9tb3ZlZCAmJiB0aGlzLl9tb3ZpbmcpIHtcclxuXHJcbiAgXHRcdFx0Ly8gQGV2ZW50IGRyYWdlbmQ6IERyYWdFbmRFdmVudFxyXG4gIFx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIGRyYWcgZW5kcy5cclxuICBcdFx0XHR0aGlzLmZpcmUoJ2RyYWdlbmQnLCB7XHJcbiAgXHRcdFx0XHRub0luZXJ0aWE6IG5vSW5lcnRpYSxcclxuICBcdFx0XHRcdGRpc3RhbmNlOiB0aGlzLl9uZXdQb3MuZGlzdGFuY2VUbyh0aGlzLl9zdGFydFBvcylcclxuICBcdFx0XHR9KTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fbW92aW5nID0gZmFsc2U7XHJcbiAgXHRcdERyYWdnYWJsZS5fZHJhZ2dpbmcgPSBmYWxzZTtcclxuICBcdH1cclxuXHJcbiAgfSk7XG5cbiAgLypcclxuICAgKiBAbmFtZXNwYWNlIExpbmVVdGlsXHJcbiAgICpcclxuICAgKiBWYXJpb3VzIHV0aWxpdHkgZnVuY3Rpb25zIGZvciBwb2x5bGluZSBwb2ludHMgcHJvY2Vzc2luZywgdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkgdG8gbWFrZSBwb2x5bGluZXMgbGlnaHRuaW5nLWZhc3QuXHJcbiAgICovXHJcblxyXG4gIC8vIFNpbXBsaWZ5IHBvbHlsaW5lIHdpdGggdmVydGV4IHJlZHVjdGlvbiBhbmQgRG91Z2xhcy1QZXVja2VyIHNpbXBsaWZpY2F0aW9uLlxyXG4gIC8vIEltcHJvdmVzIHJlbmRlcmluZyBwZXJmb3JtYW5jZSBkcmFtYXRpY2FsbHkgYnkgbGVzc2VuaW5nIHRoZSBudW1iZXIgb2YgcG9pbnRzIHRvIGRyYXcuXHJcblxyXG4gIC8vIEBmdW5jdGlvbiBzaW1wbGlmeShwb2ludHM6IFBvaW50W10sIHRvbGVyYW5jZTogTnVtYmVyKTogUG9pbnRbXVxyXG4gIC8vIERyYW1hdGljYWxseSByZWR1Y2VzIHRoZSBudW1iZXIgb2YgcG9pbnRzIGluIGEgcG9seWxpbmUgd2hpbGUgcmV0YWluaW5nXHJcbiAgLy8gaXRzIHNoYXBlIGFuZCByZXR1cm5zIGEgbmV3IGFycmF5IG9mIHNpbXBsaWZpZWQgcG9pbnRzLCB1c2luZyB0aGVcclxuICAvLyBbUmFtZXItRG91Z2xhcy1QZXVja2VyIGFsZ29yaXRobV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUmFtZXItRG91Z2xhcy1QZXVja2VyX2FsZ29yaXRobSkuXHJcbiAgLy8gVXNlZCBmb3IgYSBodWdlIHBlcmZvcm1hbmNlIGJvb3N0IHdoZW4gcHJvY2Vzc2luZy9kaXNwbGF5aW5nIExlYWZsZXQgcG9seWxpbmVzIGZvclxyXG4gIC8vIGVhY2ggem9vbSBsZXZlbCBhbmQgYWxzbyByZWR1Y2luZyB2aXN1YWwgbm9pc2UuIHRvbGVyYW5jZSBhZmZlY3RzIHRoZSBhbW91bnQgb2ZcclxuICAvLyBzaW1wbGlmaWNhdGlvbiAobGVzc2VyIHZhbHVlIG1lYW5zIGhpZ2hlciBxdWFsaXR5IGJ1dCBzbG93ZXIgYW5kIHdpdGggbW9yZSBwb2ludHMpLlxyXG4gIC8vIEFsc28gcmVsZWFzZWQgYXMgYSBzZXBhcmF0ZWQgbWljcm8tbGlicmFyeSBbU2ltcGxpZnkuanNdKGh0dHBzOi8vbW91cm5lci5naXRodWIuaW8vc2ltcGxpZnktanMvKS5cclxuICBmdW5jdGlvbiBzaW1wbGlmeShwb2ludHMsIHRvbGVyYW5jZSkge1xyXG4gIFx0aWYgKCF0b2xlcmFuY2UgfHwgIXBvaW50cy5sZW5ndGgpIHtcclxuICBcdFx0cmV0dXJuIHBvaW50cy5zbGljZSgpO1xyXG4gIFx0fVxyXG5cclxuICBcdHZhciBzcVRvbGVyYW5jZSA9IHRvbGVyYW5jZSAqIHRvbGVyYW5jZTtcclxuXHJcbiAgXHQgICAgLy8gc3RhZ2UgMTogdmVydGV4IHJlZHVjdGlvblxyXG4gIFx0ICAgIHBvaW50cyA9IF9yZWR1Y2VQb2ludHMocG9pbnRzLCBzcVRvbGVyYW5jZSk7XHJcblxyXG4gIFx0ICAgIC8vIHN0YWdlIDI6IERvdWdsYXMtUGV1Y2tlciBzaW1wbGlmaWNhdGlvblxyXG4gIFx0ICAgIHBvaW50cyA9IF9zaW1wbGlmeURQKHBvaW50cywgc3FUb2xlcmFuY2UpO1xyXG5cclxuICBcdHJldHVybiBwb2ludHM7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gcG9pbnRUb1NlZ21lbnREaXN0YW5jZShwOiBQb2ludCwgcDE6IFBvaW50LCBwMjogUG9pbnQpOiBOdW1iZXJcclxuICAvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHBvaW50IGBwYCBhbmQgc2VnbWVudCBgcDFgIHRvIGBwMmAuXHJcbiAgZnVuY3Rpb24gcG9pbnRUb1NlZ21lbnREaXN0YW5jZShwLCBwMSwgcDIpIHtcclxuICBcdHJldHVybiBNYXRoLnNxcnQoX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMiwgdHJ1ZSkpO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGNsb3Nlc3RQb2ludE9uU2VnbWVudChwOiBQb2ludCwgcDE6IFBvaW50LCBwMjogUG9pbnQpOiBOdW1iZXJcclxuICAvLyBSZXR1cm5zIHRoZSBjbG9zZXN0IHBvaW50IGZyb20gYSBwb2ludCBgcGAgb24gYSBzZWdtZW50IGBwMWAgdG8gYHAyYC5cclxuICBmdW5jdGlvbiBjbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyKSB7XHJcbiAgXHRyZXR1cm4gX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMik7XHJcbiAgfVxyXG5cclxuICAvLyBSYW1lci1Eb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb24sIHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9SYW1lci1Eb3VnbGFzLVBldWNrZXJfYWxnb3JpdGhtXHJcbiAgZnVuY3Rpb24gX3NpbXBsaWZ5RFAocG9pbnRzLCBzcVRvbGVyYW5jZSkge1xyXG5cclxuICBcdHZhciBsZW4gPSBwb2ludHMubGVuZ3RoLFxyXG4gIFx0ICAgIEFycmF5Q29uc3RydWN0b3IgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gdW5kZWZpbmVkICsgJycgPyBVaW50OEFycmF5IDogQXJyYXksXHJcbiAgXHQgICAgbWFya2VycyA9IG5ldyBBcnJheUNvbnN0cnVjdG9yKGxlbik7XHJcblxyXG4gIFx0ICAgIG1hcmtlcnNbMF0gPSBtYXJrZXJzW2xlbiAtIDFdID0gMTtcclxuXHJcbiAgXHRfc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgMCwgbGVuIC0gMSk7XHJcblxyXG4gIFx0dmFyIGksXHJcbiAgXHQgICAgbmV3UG9pbnRzID0gW107XHJcblxyXG4gIFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdGlmIChtYXJrZXJzW2ldKSB7XHJcbiAgXHRcdFx0bmV3UG9pbnRzLnB1c2gocG9pbnRzW2ldKTtcclxuICBcdFx0fVxyXG4gIFx0fVxyXG5cclxuICBcdHJldHVybiBuZXdQb2ludHM7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBfc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgZmlyc3QsIGxhc3QpIHtcclxuXHJcbiAgXHR2YXIgbWF4U3FEaXN0ID0gMCxcclxuICBcdGluZGV4LCBpLCBzcURpc3Q7XHJcblxyXG4gIFx0Zm9yIChpID0gZmlyc3QgKyAxOyBpIDw9IGxhc3QgLSAxOyBpKyspIHtcclxuICBcdFx0c3FEaXN0ID0gX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHBvaW50c1tpXSwgcG9pbnRzW2ZpcnN0XSwgcG9pbnRzW2xhc3RdLCB0cnVlKTtcclxuXHJcbiAgXHRcdGlmIChzcURpc3QgPiBtYXhTcURpc3QpIHtcclxuICBcdFx0XHRpbmRleCA9IGk7XHJcbiAgXHRcdFx0bWF4U3FEaXN0ID0gc3FEaXN0O1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcblxyXG4gIFx0aWYgKG1heFNxRGlzdCA+IHNxVG9sZXJhbmNlKSB7XHJcbiAgXHRcdG1hcmtlcnNbaW5kZXhdID0gMTtcclxuXHJcbiAgXHRcdF9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCBmaXJzdCwgaW5kZXgpO1xyXG4gIFx0XHRfc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgaW5kZXgsIGxhc3QpO1xyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgLy8gcmVkdWNlIHBvaW50cyB0aGF0IGFyZSB0b28gY2xvc2UgdG8gZWFjaCBvdGhlciB0byBhIHNpbmdsZSBwb2ludFxyXG4gIGZ1bmN0aW9uIF9yZWR1Y2VQb2ludHMocG9pbnRzLCBzcVRvbGVyYW5jZSkge1xyXG4gIFx0dmFyIHJlZHVjZWRQb2ludHMgPSBbcG9pbnRzWzBdXTtcclxuXHJcbiAgXHRmb3IgKHZhciBpID0gMSwgcHJldiA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRpZiAoX3NxRGlzdChwb2ludHNbaV0sIHBvaW50c1twcmV2XSkgPiBzcVRvbGVyYW5jZSkge1xyXG4gIFx0XHRcdHJlZHVjZWRQb2ludHMucHVzaChwb2ludHNbaV0pO1xyXG4gIFx0XHRcdHByZXYgPSBpO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcbiAgXHRpZiAocHJldiA8IGxlbiAtIDEpIHtcclxuICBcdFx0cmVkdWNlZFBvaW50cy5wdXNoKHBvaW50c1tsZW4gLSAxXSk7XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gcmVkdWNlZFBvaW50cztcclxuICB9XHJcblxyXG4gIHZhciBfbGFzdENvZGU7XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBjbGlwU2VnbWVudChhOiBQb2ludCwgYjogUG9pbnQsIGJvdW5kczogQm91bmRzLCB1c2VMYXN0Q29kZT86IEJvb2xlYW4sIHJvdW5kPzogQm9vbGVhbik6IFBvaW50W118Qm9vbGVhblxyXG4gIC8vIENsaXBzIHRoZSBzZWdtZW50IGEgdG8gYiBieSByZWN0YW5ndWxhciBib3VuZHMgd2l0aCB0aGVcclxuICAvLyBbQ29oZW4tU3V0aGVybGFuZCBhbGdvcml0aG1dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvaGVuJUUyJTgwJTkzU3V0aGVybGFuZF9hbGdvcml0aG0pXHJcbiAgLy8gKG1vZGlmeWluZyB0aGUgc2VnbWVudCBwb2ludHMgZGlyZWN0bHkhKS4gVXNlZCBieSBMZWFmbGV0IHRvIG9ubHkgc2hvdyBwb2x5bGluZVxyXG4gIC8vIHBvaW50cyB0aGF0IGFyZSBvbiB0aGUgc2NyZWVuIG9yIG5lYXIsIGluY3JlYXNpbmcgcGVyZm9ybWFuY2UuXHJcbiAgZnVuY3Rpb24gY2xpcFNlZ21lbnQoYSwgYiwgYm91bmRzLCB1c2VMYXN0Q29kZSwgcm91bmQpIHtcclxuICBcdHZhciBjb2RlQSA9IHVzZUxhc3RDb2RlID8gX2xhc3RDb2RlIDogX2dldEJpdENvZGUoYSwgYm91bmRzKSxcclxuICBcdCAgICBjb2RlQiA9IF9nZXRCaXRDb2RlKGIsIGJvdW5kcyksXHJcblxyXG4gIFx0ICAgIGNvZGVPdXQsIHAsIG5ld0NvZGU7XHJcblxyXG4gIFx0ICAgIC8vIHNhdmUgMm5kIGNvZGUgdG8gYXZvaWQgY2FsY3VsYXRpbmcgaXQgb24gdGhlIG5leHQgc2VnbWVudFxyXG4gIFx0ICAgIF9sYXN0Q29kZSA9IGNvZGVCO1xyXG5cclxuICBcdHdoaWxlICh0cnVlKSB7XHJcbiAgXHRcdC8vIGlmIGEsYiBpcyBpbnNpZGUgdGhlIGNsaXAgd2luZG93ICh0cml2aWFsIGFjY2VwdClcclxuICBcdFx0aWYgKCEoY29kZUEgfCBjb2RlQikpIHtcclxuICBcdFx0XHRyZXR1cm4gW2EsIGJdO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBpZiBhLGIgaXMgb3V0c2lkZSB0aGUgY2xpcCB3aW5kb3cgKHRyaXZpYWwgcmVqZWN0KVxyXG4gIFx0XHRpZiAoY29kZUEgJiBjb2RlQikge1xyXG4gIFx0XHRcdHJldHVybiBmYWxzZTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gb3RoZXIgY2FzZXNcclxuICBcdFx0Y29kZU91dCA9IGNvZGVBIHx8IGNvZGVCO1xyXG4gIFx0XHRwID0gX2dldEVkZ2VJbnRlcnNlY3Rpb24oYSwgYiwgY29kZU91dCwgYm91bmRzLCByb3VuZCk7XHJcbiAgXHRcdG5ld0NvZGUgPSBfZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG5cclxuICBcdFx0aWYgKGNvZGVPdXQgPT09IGNvZGVBKSB7XHJcbiAgXHRcdFx0YSA9IHA7XHJcbiAgXHRcdFx0Y29kZUEgPSBuZXdDb2RlO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdGIgPSBwO1xyXG4gIFx0XHRcdGNvZGVCID0gbmV3Q29kZTtcclxuICBcdFx0fVxyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gX2dldEVkZ2VJbnRlcnNlY3Rpb24oYSwgYiwgY29kZSwgYm91bmRzLCByb3VuZCkge1xyXG4gIFx0dmFyIGR4ID0gYi54IC0gYS54LFxyXG4gIFx0ICAgIGR5ID0gYi55IC0gYS55LFxyXG4gIFx0ICAgIG1pbiA9IGJvdW5kcy5taW4sXHJcbiAgXHQgICAgbWF4ID0gYm91bmRzLm1heCxcclxuICBcdCAgICB4LCB5O1xyXG5cclxuICBcdGlmIChjb2RlICYgOCkgeyAvLyB0b3BcclxuICBcdFx0eCA9IGEueCArIGR4ICogKG1heC55IC0gYS55KSAvIGR5O1xyXG4gIFx0XHR5ID0gbWF4Lnk7XHJcblxyXG4gIFx0fSBlbHNlIGlmIChjb2RlICYgNCkgeyAvLyBib3R0b21cclxuICBcdFx0eCA9IGEueCArIGR4ICogKG1pbi55IC0gYS55KSAvIGR5O1xyXG4gIFx0XHR5ID0gbWluLnk7XHJcblxyXG4gIFx0fSBlbHNlIGlmIChjb2RlICYgMikgeyAvLyByaWdodFxyXG4gIFx0XHR4ID0gbWF4Lng7XHJcbiAgXHRcdHkgPSBhLnkgKyBkeSAqIChtYXgueCAtIGEueCkgLyBkeDtcclxuXHJcbiAgXHR9IGVsc2UgaWYgKGNvZGUgJiAxKSB7IC8vIGxlZnRcclxuICBcdFx0eCA9IG1pbi54O1xyXG4gIFx0XHR5ID0gYS55ICsgZHkgKiAobWluLnggLSBhLngpIC8gZHg7XHJcbiAgXHR9XHJcblxyXG4gIFx0cmV0dXJuIG5ldyBQb2ludCh4LCB5LCByb3VuZCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBfZ2V0Qml0Q29kZShwLCBib3VuZHMpIHtcclxuICBcdHZhciBjb2RlID0gMDtcclxuXHJcbiAgXHRpZiAocC54IDwgYm91bmRzLm1pbi54KSB7IC8vIGxlZnRcclxuICBcdFx0Y29kZSB8PSAxO1xyXG4gIFx0fSBlbHNlIGlmIChwLnggPiBib3VuZHMubWF4LngpIHsgLy8gcmlnaHRcclxuICBcdFx0Y29kZSB8PSAyO1xyXG4gIFx0fVxyXG5cclxuICBcdGlmIChwLnkgPCBib3VuZHMubWluLnkpIHsgLy8gYm90dG9tXHJcbiAgXHRcdGNvZGUgfD0gNDtcclxuICBcdH0gZWxzZSBpZiAocC55ID4gYm91bmRzLm1heC55KSB7IC8vIHRvcFxyXG4gIFx0XHRjb2RlIHw9IDg7XHJcbiAgXHR9XHJcblxyXG4gIFx0cmV0dXJuIGNvZGU7XHJcbiAgfVxyXG5cclxuICAvLyBzcXVhcmUgZGlzdGFuY2UgKHRvIGF2b2lkIHVubmVjZXNzYXJ5IE1hdGguc3FydCBjYWxscylcclxuICBmdW5jdGlvbiBfc3FEaXN0KHAxLCBwMikge1xyXG4gIFx0dmFyIGR4ID0gcDIueCAtIHAxLngsXHJcbiAgXHQgICAgZHkgPSBwMi55IC0gcDEueTtcclxuICBcdHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcclxuICB9XHJcblxyXG4gIC8vIHJldHVybiBjbG9zZXN0IHBvaW50IG9uIHNlZ21lbnQgb3IgZGlzdGFuY2UgdG8gdGhhdCBwb2ludFxyXG4gIGZ1bmN0aW9uIF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIsIHNxRGlzdCkge1xyXG4gIFx0dmFyIHggPSBwMS54LFxyXG4gIFx0ICAgIHkgPSBwMS55LFxyXG4gIFx0ICAgIGR4ID0gcDIueCAtIHgsXHJcbiAgXHQgICAgZHkgPSBwMi55IC0geSxcclxuICBcdCAgICBkb3QgPSBkeCAqIGR4ICsgZHkgKiBkeSxcclxuICBcdCAgICB0O1xyXG5cclxuICBcdGlmIChkb3QgPiAwKSB7XHJcbiAgXHRcdHQgPSAoKHAueCAtIHgpICogZHggKyAocC55IC0geSkgKiBkeSkgLyBkb3Q7XHJcblxyXG4gIFx0XHRpZiAodCA+IDEpIHtcclxuICBcdFx0XHR4ID0gcDIueDtcclxuICBcdFx0XHR5ID0gcDIueTtcclxuICBcdFx0fSBlbHNlIGlmICh0ID4gMCkge1xyXG4gIFx0XHRcdHggKz0gZHggKiB0O1xyXG4gIFx0XHRcdHkgKz0gZHkgKiB0O1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcblxyXG4gIFx0ZHggPSBwLnggLSB4O1xyXG4gIFx0ZHkgPSBwLnkgLSB5O1xyXG5cclxuICBcdHJldHVybiBzcURpc3QgPyBkeCAqIGR4ICsgZHkgKiBkeSA6IG5ldyBQb2ludCh4LCB5KTtcclxuICB9XHJcblxyXG5cclxuICAvLyBAZnVuY3Rpb24gaXNGbGF0KGxhdGxuZ3M6IExhdExuZ1tdKTogQm9vbGVhblxyXG4gIC8vIFJldHVybnMgdHJ1ZSBpZiBgbGF0bG5nc2AgaXMgYSBmbGF0IGFycmF5LCBmYWxzZSBpcyBuZXN0ZWQuXHJcbiAgZnVuY3Rpb24gaXNGbGF0KGxhdGxuZ3MpIHtcclxuICBcdHJldHVybiAhaXNBcnJheShsYXRsbmdzWzBdKSB8fCAodHlwZW9mIGxhdGxuZ3NbMF1bMF0gIT09ICdvYmplY3QnICYmIHR5cGVvZiBsYXRsbmdzWzBdWzBdICE9PSAndW5kZWZpbmVkJyk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBfZmxhdChsYXRsbmdzKSB7XHJcbiAgXHRjb25zb2xlLndhcm4oJ0RlcHJlY2F0ZWQgdXNlIG9mIF9mbGF0LCBwbGVhc2UgdXNlIEwuTGluZVV0aWwuaXNGbGF0IGluc3RlYWQuJyk7XHJcbiAgXHRyZXR1cm4gaXNGbGF0KGxhdGxuZ3MpO1xyXG4gIH1cclxuXHJcbiAgLyogQGZ1bmN0aW9uIHBvbHlsaW5lQ2VudGVyKGxhdGxuZ3M6IExhdExuZ1tdLCBjcnM6IENSUyk6IExhdExuZ1xyXG4gICAqIFJldHVybnMgdGhlIGNlbnRlciAoW2NlbnRyb2lkXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NlbnRyb2lkKSkgb2YgdGhlIHBhc3NlZCBMYXRMbmdzIChmaXJzdCByaW5nKSBmcm9tIGEgcG9seWxpbmUuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gcG9seWxpbmVDZW50ZXIobGF0bG5ncywgY3JzKSB7XHJcbiAgXHR2YXIgaSwgaGFsZkRpc3QsIHNlZ0Rpc3QsIGRpc3QsIHAxLCBwMiwgcmF0aW8sIGNlbnRlcjtcclxuXHJcbiAgXHRpZiAoIWxhdGxuZ3MgfHwgbGF0bG5ncy5sZW5ndGggPT09IDApIHtcclxuICBcdFx0dGhyb3cgbmV3IEVycm9yKCdsYXRsbmdzIG5vdCBwYXNzZWQnKTtcclxuICBcdH1cclxuXHJcbiAgXHRpZiAoIWlzRmxhdChsYXRsbmdzKSkge1xyXG4gIFx0XHRjb25zb2xlLndhcm4oJ2xhdGxuZ3MgYXJlIG5vdCBmbGF0ISBPbmx5IHRoZSBmaXJzdCByaW5nIHdpbGwgYmUgdXNlZCcpO1xyXG4gIFx0XHRsYXRsbmdzID0gbGF0bG5nc1swXTtcclxuICBcdH1cclxuXHJcbiAgXHR2YXIgcG9pbnRzID0gW107XHJcbiAgXHRmb3IgKHZhciBqIGluIGxhdGxuZ3MpIHtcclxuICBcdFx0cG9pbnRzLnB1c2goY3JzLnByb2plY3QodG9MYXRMbmcobGF0bG5nc1tqXSkpKTtcclxuICBcdH1cclxuXHJcbiAgXHR2YXIgbGVuID0gcG9pbnRzLmxlbmd0aDtcclxuXHJcbiAgXHRmb3IgKGkgPSAwLCBoYWxmRGlzdCA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcclxuICBcdFx0aGFsZkRpc3QgKz0gcG9pbnRzW2ldLmRpc3RhbmNlVG8ocG9pbnRzW2kgKyAxXSkgLyAyO1xyXG4gIFx0fVxyXG5cclxuICBcdC8vIFRoZSBsaW5lIGlzIHNvIHNtYWxsIGluIHRoZSBjdXJyZW50IHZpZXcgdGhhdCBhbGwgcG9pbnRzIGFyZSBvbiB0aGUgc2FtZSBwaXhlbC5cclxuICBcdGlmIChoYWxmRGlzdCA9PT0gMCkge1xyXG4gIFx0XHRjZW50ZXIgPSBwb2ludHNbMF07XHJcbiAgXHR9IGVsc2Uge1xyXG4gIFx0XHRmb3IgKGkgPSAwLCBkaXN0ID0gMDsgaSA8IGxlbiAtIDE7IGkrKykge1xyXG4gIFx0XHRcdHAxID0gcG9pbnRzW2ldO1xyXG4gIFx0XHRcdHAyID0gcG9pbnRzW2kgKyAxXTtcclxuICBcdFx0XHRzZWdEaXN0ID0gcDEuZGlzdGFuY2VUbyhwMik7XHJcbiAgXHRcdFx0ZGlzdCArPSBzZWdEaXN0O1xyXG5cclxuICBcdFx0XHRpZiAoZGlzdCA+IGhhbGZEaXN0KSB7XHJcbiAgXHRcdFx0XHRyYXRpbyA9IChkaXN0IC0gaGFsZkRpc3QpIC8gc2VnRGlzdDtcclxuICBcdFx0XHRcdGNlbnRlciA9IFtcclxuICBcdFx0XHRcdFx0cDIueCAtIHJhdGlvICogKHAyLnggLSBwMS54KSxcclxuICBcdFx0XHRcdFx0cDIueSAtIHJhdGlvICogKHAyLnkgLSBwMS55KVxyXG4gIFx0XHRcdFx0XTtcclxuICBcdFx0XHRcdGJyZWFrO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIGNycy51bnByb2plY3QodG9Qb2ludChjZW50ZXIpKTtcclxuICB9XG5cbiAgdmFyIExpbmVVdGlsID0ge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBzaW1wbGlmeTogc2ltcGxpZnksXG4gICAgcG9pbnRUb1NlZ21lbnREaXN0YW5jZTogcG9pbnRUb1NlZ21lbnREaXN0YW5jZSxcbiAgICBjbG9zZXN0UG9pbnRPblNlZ21lbnQ6IGNsb3Nlc3RQb2ludE9uU2VnbWVudCxcbiAgICBjbGlwU2VnbWVudDogY2xpcFNlZ21lbnQsXG4gICAgX2dldEVkZ2VJbnRlcnNlY3Rpb246IF9nZXRFZGdlSW50ZXJzZWN0aW9uLFxuICAgIF9nZXRCaXRDb2RlOiBfZ2V0Qml0Q29kZSxcbiAgICBfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQ6IF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudCxcbiAgICBpc0ZsYXQ6IGlzRmxhdCxcbiAgICBfZmxhdDogX2ZsYXQsXG4gICAgcG9seWxpbmVDZW50ZXI6IHBvbHlsaW5lQ2VudGVyXG4gIH07XG5cbiAgLypcclxuICAgKiBAbmFtZXNwYWNlIFBvbHlVdGlsXHJcbiAgICogVmFyaW91cyB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgcG9seWdvbiBnZW9tZXRyaWVzLlxyXG4gICAqL1xyXG5cclxuICAvKiBAZnVuY3Rpb24gY2xpcFBvbHlnb24ocG9pbnRzOiBQb2ludFtdLCBib3VuZHM6IEJvdW5kcywgcm91bmQ/OiBCb29sZWFuKTogUG9pbnRbXVxyXG4gICAqIENsaXBzIHRoZSBwb2x5Z29uIGdlb21ldHJ5IGRlZmluZWQgYnkgdGhlIGdpdmVuIGBwb2ludHNgIGJ5IHRoZSBnaXZlbiBib3VuZHMgKHVzaW5nIHRoZSBbU3V0aGVybGFuZC1Ib2RnbWFuIGFsZ29yaXRobV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3V0aGVybGFuZCVFMiU4MCU5M0hvZGdtYW5fYWxnb3JpdGhtKSkuXHJcbiAgICogVXNlZCBieSBMZWFmbGV0IHRvIG9ubHkgc2hvdyBwb2x5Z29uIHBvaW50cyB0aGF0IGFyZSBvbiB0aGUgc2NyZWVuIG9yIG5lYXIsIGluY3JlYXNpbmdcclxuICAgKiBwZXJmb3JtYW5jZS4gTm90ZSB0aGF0IHBvbHlnb24gcG9pbnRzIG5lZWRzIGRpZmZlcmVudCBhbGdvcml0aG0gZm9yIGNsaXBwaW5nXHJcbiAgICogdGhhbiBwb2x5bGluZSwgc28gdGhlcmUncyBhIHNlcGFyYXRlIG1ldGhvZCBmb3IgaXQuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gY2xpcFBvbHlnb24ocG9pbnRzLCBib3VuZHMsIHJvdW5kKSB7XHJcbiAgXHR2YXIgY2xpcHBlZFBvaW50cyxcclxuICBcdCAgICBlZGdlcyA9IFsxLCA0LCAyLCA4XSxcclxuICBcdCAgICBpLCBqLCBrLFxyXG4gIFx0ICAgIGEsIGIsXHJcbiAgXHQgICAgbGVuLCBlZGdlLCBwO1xyXG5cclxuICBcdGZvciAoaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRwb2ludHNbaV0uX2NvZGUgPSBfZ2V0Qml0Q29kZShwb2ludHNbaV0sIGJvdW5kcyk7XHJcbiAgXHR9XHJcblxyXG4gIFx0Ly8gZm9yIGVhY2ggZWRnZSAobGVmdCwgYm90dG9tLCByaWdodCwgdG9wKVxyXG4gIFx0Zm9yIChrID0gMDsgayA8IDQ7IGsrKykge1xyXG4gIFx0XHRlZGdlID0gZWRnZXNba107XHJcbiAgXHRcdGNsaXBwZWRQb2ludHMgPSBbXTtcclxuXHJcbiAgXHRcdGZvciAoaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGgsIGogPSBsZW4gLSAxOyBpIDwgbGVuOyBqID0gaSsrKSB7XHJcbiAgXHRcdFx0YSA9IHBvaW50c1tpXTtcclxuICBcdFx0XHRiID0gcG9pbnRzW2pdO1xyXG5cclxuICBcdFx0XHQvLyBpZiBhIGlzIGluc2lkZSB0aGUgY2xpcCB3aW5kb3dcclxuICBcdFx0XHRpZiAoIShhLl9jb2RlICYgZWRnZSkpIHtcclxuICBcdFx0XHRcdC8vIGlmIGIgaXMgb3V0c2lkZSB0aGUgY2xpcCB3aW5kb3cgKGEtPmIgZ29lcyBvdXQgb2Ygc2NyZWVuKVxyXG4gIFx0XHRcdFx0aWYgKGIuX2NvZGUgJiBlZGdlKSB7XHJcbiAgXHRcdFx0XHRcdHAgPSBfZ2V0RWRnZUludGVyc2VjdGlvbihiLCBhLCBlZGdlLCBib3VuZHMsIHJvdW5kKTtcclxuICBcdFx0XHRcdFx0cC5fY29kZSA9IF9nZXRCaXRDb2RlKHAsIGJvdW5kcyk7XHJcbiAgXHRcdFx0XHRcdGNsaXBwZWRQb2ludHMucHVzaChwKTtcclxuICBcdFx0XHRcdH1cclxuICBcdFx0XHRcdGNsaXBwZWRQb2ludHMucHVzaChhKTtcclxuXHJcbiAgXHRcdFx0Ly8gZWxzZSBpZiBiIGlzIGluc2lkZSB0aGUgY2xpcCB3aW5kb3cgKGEtPmIgZW50ZXJzIHRoZSBzY3JlZW4pXHJcbiAgXHRcdFx0fSBlbHNlIGlmICghKGIuX2NvZGUgJiBlZGdlKSkge1xyXG4gIFx0XHRcdFx0cCA9IF9nZXRFZGdlSW50ZXJzZWN0aW9uKGIsIGEsIGVkZ2UsIGJvdW5kcywgcm91bmQpO1xyXG4gIFx0XHRcdFx0cC5fY29kZSA9IF9nZXRCaXRDb2RlKHAsIGJvdW5kcyk7XHJcbiAgXHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2gocCk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcbiAgXHRcdHBvaW50cyA9IGNsaXBwZWRQb2ludHM7XHJcbiAgXHR9XHJcblxyXG4gIFx0cmV0dXJuIHBvaW50cztcclxuICB9XHJcblxyXG4gIC8qIEBmdW5jdGlvbiBwb2x5Z29uQ2VudGVyKGxhdGxuZ3M6IExhdExuZ1tdIGNyczogQ1JTKTogTGF0TG5nXHJcbiAgICogUmV0dXJucyB0aGUgY2VudGVyIChbY2VudHJvaWRdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2VudHJvaWQpKSBvZiB0aGUgcGFzc2VkIExhdExuZ3MgKGZpcnN0IHJpbmcpIGZyb20gYSBwb2x5Z29uLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHBvbHlnb25DZW50ZXIobGF0bG5ncywgY3JzKSB7XHJcbiAgXHR2YXIgaSwgaiwgcDEsIHAyLCBmLCBhcmVhLCB4LCB5LCBjZW50ZXI7XHJcblxyXG4gIFx0aWYgKCFsYXRsbmdzIHx8IGxhdGxuZ3MubGVuZ3RoID09PSAwKSB7XHJcbiAgXHRcdHRocm93IG5ldyBFcnJvcignbGF0bG5ncyBub3QgcGFzc2VkJyk7XHJcbiAgXHR9XHJcblxyXG4gIFx0aWYgKCFpc0ZsYXQobGF0bG5ncykpIHtcclxuICBcdFx0Y29uc29sZS53YXJuKCdsYXRsbmdzIGFyZSBub3QgZmxhdCEgT25seSB0aGUgZmlyc3QgcmluZyB3aWxsIGJlIHVzZWQnKTtcclxuICBcdFx0bGF0bG5ncyA9IGxhdGxuZ3NbMF07XHJcbiAgXHR9XHJcblxyXG4gIFx0dmFyIHBvaW50cyA9IFtdO1xyXG4gIFx0Zm9yICh2YXIgayBpbiBsYXRsbmdzKSB7XHJcbiAgXHRcdHBvaW50cy5wdXNoKGNycy5wcm9qZWN0KHRvTGF0TG5nKGxhdGxuZ3Nba10pKSk7XHJcbiAgXHR9XHJcblxyXG4gIFx0dmFyIGxlbiA9IHBvaW50cy5sZW5ndGg7XHJcbiAgXHRhcmVhID0geCA9IHkgPSAwO1xyXG5cclxuICBcdC8vIHBvbHlnb24gY2VudHJvaWQgYWxnb3JpdGhtO1xyXG4gIFx0Zm9yIChpID0gMCwgaiA9IGxlbiAtIDE7IGkgPCBsZW47IGogPSBpKyspIHtcclxuICBcdFx0cDEgPSBwb2ludHNbaV07XHJcbiAgXHRcdHAyID0gcG9pbnRzW2pdO1xyXG5cclxuICBcdFx0ZiA9IHAxLnkgKiBwMi54IC0gcDIueSAqIHAxLng7XHJcbiAgXHRcdHggKz0gKHAxLnggKyBwMi54KSAqIGY7XHJcbiAgXHRcdHkgKz0gKHAxLnkgKyBwMi55KSAqIGY7XHJcbiAgXHRcdGFyZWEgKz0gZiAqIDM7XHJcbiAgXHR9XHJcblxyXG4gIFx0aWYgKGFyZWEgPT09IDApIHtcclxuICBcdFx0Ly8gUG9seWdvbiBpcyBzbyBzbWFsbCB0aGF0IGFsbCBwb2ludHMgYXJlIG9uIHNhbWUgcGl4ZWwuXHJcbiAgXHRcdGNlbnRlciA9IHBvaW50c1swXTtcclxuICBcdH0gZWxzZSB7XHJcbiAgXHRcdGNlbnRlciA9IFt4IC8gYXJlYSwgeSAvIGFyZWFdO1xyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIGNycy51bnByb2plY3QodG9Qb2ludChjZW50ZXIpKTtcclxuICB9XG5cbiAgdmFyIFBvbHlVdGlsID0ge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBjbGlwUG9seWdvbjogY2xpcFBvbHlnb24sXG4gICAgcG9seWdvbkNlbnRlcjogcG9seWdvbkNlbnRlclxuICB9O1xuXG4gIC8qXHJcbiAgICogQG5hbWVzcGFjZSBQcm9qZWN0aW9uXHJcbiAgICogQHNlY3Rpb25cclxuICAgKiBMZWFmbGV0IGNvbWVzIHdpdGggYSBzZXQgb2YgYWxyZWFkeSBkZWZpbmVkIFByb2plY3Rpb25zIG91dCBvZiB0aGUgYm94OlxyXG4gICAqXHJcbiAgICogQHByb2plY3Rpb24gTC5Qcm9qZWN0aW9uLkxvbkxhdFxyXG4gICAqXHJcbiAgICogRXF1aXJlY3Rhbmd1bGFyLCBvciBQbGF0ZSBDYXJyZWUgcHJvamVjdGlvbiDigJQgdGhlIG1vc3Qgc2ltcGxlIHByb2plY3Rpb24sXHJcbiAgICogbW9zdGx5IHVzZWQgYnkgR0lTIGVudGh1c2lhc3RzLiBEaXJlY3RseSBtYXBzIGB4YCBhcyBsb25naXR1ZGUsIGFuZCBgeWAgYXNcclxuICAgKiBsYXRpdHVkZS4gQWxzbyBzdWl0YWJsZSBmb3IgZmxhdCB3b3JsZHMsIGUuZy4gZ2FtZSBtYXBzLiBVc2VkIGJ5IHRoZVxyXG4gICAqIGBFUFNHOjQzMjZgIGFuZCBgU2ltcGxlYCBDUlMuXHJcbiAgICovXHJcblxyXG4gIHZhciBMb25MYXQgPSB7XHJcbiAgXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcbiAgXHRcdHJldHVybiBuZXcgUG9pbnQobGF0bG5nLmxuZywgbGF0bG5nLmxhdCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgXHRcdHJldHVybiBuZXcgTGF0TG5nKHBvaW50LnksIHBvaW50LngpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRib3VuZHM6IG5ldyBCb3VuZHMoWy0xODAsIC05MF0sIFsxODAsIDkwXSlcclxuICB9O1xuXG4gIC8qXHJcbiAgICogQG5hbWVzcGFjZSBQcm9qZWN0aW9uXHJcbiAgICogQHByb2plY3Rpb24gTC5Qcm9qZWN0aW9uLk1lcmNhdG9yXHJcbiAgICpcclxuICAgKiBFbGxpcHRpY2FsIE1lcmNhdG9yIHByb2plY3Rpb24g4oCUIG1vcmUgY29tcGxleCB0aGFuIFNwaGVyaWNhbCBNZXJjYXRvci4gQXNzdW1lcyB0aGF0IEVhcnRoIGlzIGFuIGVsbGlwc29pZC4gVXNlZCBieSB0aGUgRVBTRzozMzk1IENSUy5cclxuICAgKi9cclxuXHJcbiAgdmFyIE1lcmNhdG9yID0ge1xyXG4gIFx0UjogNjM3ODEzNyxcclxuICBcdFJfTUlOT1I6IDYzNTY3NTIuMzE0MjQ1MTc5LFxyXG5cclxuICBcdGJvdW5kczogbmV3IEJvdW5kcyhbLTIwMDM3NTA4LjM0Mjc5LCAtMTU0OTY1NzAuNzM5NzJdLCBbMjAwMzc1MDguMzQyNzksIDE4NzY0NjU2LjIzMTM4XSksXHJcblxyXG4gIFx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG4gIFx0XHR2YXIgZCA9IE1hdGguUEkgLyAxODAsXHJcbiAgXHRcdCAgICByID0gdGhpcy5SLFxyXG4gIFx0XHQgICAgeSA9IGxhdGxuZy5sYXQgKiBkLFxyXG4gIFx0XHQgICAgdG1wID0gdGhpcy5SX01JTk9SIC8gcixcclxuICBcdFx0ICAgIGUgPSBNYXRoLnNxcnQoMSAtIHRtcCAqIHRtcCksXHJcbiAgXHRcdCAgICBjb24gPSBlICogTWF0aC5zaW4oeSk7XHJcblxyXG4gIFx0XHR2YXIgdHMgPSBNYXRoLnRhbihNYXRoLlBJIC8gNCAtIHkgLyAyKSAvIE1hdGgucG93KCgxIC0gY29uKSAvICgxICsgY29uKSwgZSAvIDIpO1xyXG4gIFx0XHR5ID0gLXIgKiBNYXRoLmxvZyhNYXRoLm1heCh0cywgMUUtMTApKTtcclxuXHJcbiAgXHRcdHJldHVybiBuZXcgUG9pbnQobGF0bG5nLmxuZyAqIGQgKiByLCB5KTtcclxuICBcdH0sXHJcblxyXG4gIFx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuICBcdFx0dmFyIGQgPSAxODAgLyBNYXRoLlBJLFxyXG4gIFx0XHQgICAgciA9IHRoaXMuUixcclxuICBcdFx0ICAgIHRtcCA9IHRoaXMuUl9NSU5PUiAvIHIsXHJcbiAgXHRcdCAgICBlID0gTWF0aC5zcXJ0KDEgLSB0bXAgKiB0bXApLFxyXG4gIFx0XHQgICAgdHMgPSBNYXRoLmV4cCgtcG9pbnQueSAvIHIpLFxyXG4gIFx0XHQgICAgcGhpID0gTWF0aC5QSSAvIDIgLSAyICogTWF0aC5hdGFuKHRzKTtcclxuXHJcbiAgXHRcdGZvciAodmFyIGkgPSAwLCBkcGhpID0gMC4xLCBjb247IGkgPCAxNSAmJiBNYXRoLmFicyhkcGhpKSA+IDFlLTc7IGkrKykge1xyXG4gIFx0XHRcdGNvbiA9IGUgKiBNYXRoLnNpbihwaGkpO1xyXG4gIFx0XHRcdGNvbiA9IE1hdGgucG93KCgxIC0gY29uKSAvICgxICsgY29uKSwgZSAvIDIpO1xyXG4gIFx0XHRcdGRwaGkgPSBNYXRoLlBJIC8gMiAtIDIgKiBNYXRoLmF0YW4odHMgKiBjb24pIC0gcGhpO1xyXG4gIFx0XHRcdHBoaSArPSBkcGhpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gbmV3IExhdExuZyhwaGkgKiBkLCBwb2ludC54ICogZCAvIHIpO1xyXG4gIFx0fVxyXG4gIH07XG5cbiAgLypcbiAgICogQGNsYXNzIFByb2plY3Rpb25cblxuICAgKiBBbiBvYmplY3Qgd2l0aCBtZXRob2RzIGZvciBwcm9qZWN0aW5nIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBvZiB0aGUgd29ybGQgb250b1xuICAgKiBhIGZsYXQgc3VyZmFjZSAoYW5kIGJhY2spLiBTZWUgW01hcCBwcm9qZWN0aW9uXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NYXBfcHJvamVjdGlvbikuXG5cbiAgICogQHByb3BlcnR5IGJvdW5kczogQm91bmRzXG4gICAqIFRoZSBib3VuZHMgKHNwZWNpZmllZCBpbiBDUlMgdW5pdHMpIHdoZXJlIHRoZSBwcm9qZWN0aW9uIGlzIHZhbGlkXG5cbiAgICogQG1ldGhvZCBwcm9qZWN0KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcbiAgICogUHJvamVjdHMgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIGludG8gYSAyRCBwb2ludC5cbiAgICogT25seSBhY2NlcHRzIGFjdHVhbCBgTC5MYXRMbmdgIGluc3RhbmNlcywgbm90IGFycmF5cy5cblxuICAgKiBAbWV0aG9kIHVucHJvamVjdChwb2ludDogUG9pbnQpOiBMYXRMbmdcbiAgICogVGhlIGludmVyc2Ugb2YgYHByb2plY3RgLiBQcm9qZWN0cyBhIDJEIHBvaW50IGludG8gYSBnZW9ncmFwaGljYWwgbG9jYXRpb24uXG4gICAqIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuUG9pbnRgIGluc3RhbmNlcywgbm90IGFycmF5cy5cblxuICAgKiBOb3RlIHRoYXQgdGhlIHByb2plY3Rpb24gaW5zdGFuY2VzIGRvIG5vdCBpbmhlcml0IGZyb20gTGVhZmxldCdzIGBDbGFzc2Agb2JqZWN0LFxuICAgKiBhbmQgY2FuJ3QgYmUgaW5zdGFudGlhdGVkLiBBbHNvLCBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gdGhlbSxcbiAgICogYW5kIG1ldGhvZHMgY2FuJ3QgYmUgYWRkZWQgdG8gdGhlbSB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXG5cbiAgICovXG5cbiAgdmFyIGluZGV4ID0ge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBMb25MYXQ6IExvbkxhdCxcbiAgICBNZXJjYXRvcjogTWVyY2F0b3IsXG4gICAgU3BoZXJpY2FsTWVyY2F0b3I6IFNwaGVyaWNhbE1lcmNhdG9yXG4gIH07XG5cbiAgLypcclxuICAgKiBAbmFtZXNwYWNlIENSU1xyXG4gICAqIEBjcnMgTC5DUlMuRVBTRzMzOTVcclxuICAgKlxyXG4gICAqIFJhcmVseSB1c2VkIGJ5IHNvbWUgY29tbWVyY2lhbCB0aWxlIHByb3ZpZGVycy4gVXNlcyBFbGxpcHRpY2FsIE1lcmNhdG9yIHByb2plY3Rpb24uXHJcbiAgICovXHJcbiAgdmFyIEVQU0czMzk1ID0gZXh0ZW5kKHt9LCBFYXJ0aCwge1xyXG4gIFx0Y29kZTogJ0VQU0c6MzM5NScsXHJcbiAgXHRwcm9qZWN0aW9uOiBNZXJjYXRvcixcclxuXHJcbiAgXHR0cmFuc2Zvcm1hdGlvbjogKGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIHNjYWxlID0gMC41IC8gKE1hdGguUEkgKiBNZXJjYXRvci5SKTtcclxuICBcdFx0cmV0dXJuIHRvVHJhbnNmb3JtYXRpb24oc2NhbGUsIDAuNSwgLXNjYWxlLCAwLjUpO1xyXG4gIFx0fSgpKVxyXG4gIH0pO1xuXG4gIC8qXHJcbiAgICogQG5hbWVzcGFjZSBDUlNcclxuICAgKiBAY3JzIEwuQ1JTLkVQU0c0MzI2XHJcbiAgICpcclxuICAgKiBBIGNvbW1vbiBDUlMgYW1vbmcgR0lTIGVudGh1c2lhc3RzLiBVc2VzIHNpbXBsZSBFcXVpcmVjdGFuZ3VsYXIgcHJvamVjdGlvbi5cclxuICAgKlxyXG4gICAqIExlYWZsZXQgMS4wLnggY29tcGxpZXMgd2l0aCB0aGUgW1RNUyBjb29yZGluYXRlIHNjaGVtZSBmb3IgRVBTRzo0MzI2XShodHRwczovL3dpa2kub3NnZW8ub3JnL3dpa2kvVGlsZV9NYXBfU2VydmljZV9TcGVjaWZpY2F0aW9uI2dsb2JhbC1nZW9kZXRpYyksXHJcbiAgICogd2hpY2ggaXMgYSBicmVha2luZyBjaGFuZ2UgZnJvbSAwLjcueCBiZWhhdmlvdXIuICBJZiB5b3UgYXJlIHVzaW5nIGEgYFRpbGVMYXllcmBcclxuICAgKiB3aXRoIHRoaXMgQ1JTLCBlbnN1cmUgdGhhdCB0aGVyZSBhcmUgdHdvIDI1NngyNTYgcGl4ZWwgdGlsZXMgY292ZXJpbmcgdGhlXHJcbiAgICogd2hvbGUgZWFydGggYXQgem9vbSBsZXZlbCB6ZXJvLCBhbmQgdGhhdCB0aGUgdGlsZSBjb29yZGluYXRlIG9yaWdpbiBpcyAoLTE4MCwrOTApLFxyXG4gICAqIG9yICgtMTgwLC05MCkgZm9yIGBUaWxlTGF5ZXJgcyB3aXRoIFt0aGUgYHRtc2Agb3B0aW9uXSgjdGlsZWxheWVyLXRtcykgc2V0LlxyXG4gICAqL1xyXG5cclxuICB2YXIgRVBTRzQzMjYgPSBleHRlbmQoe30sIEVhcnRoLCB7XHJcbiAgXHRjb2RlOiAnRVBTRzo0MzI2JyxcclxuICBcdHByb2plY3Rpb246IExvbkxhdCxcclxuICBcdHRyYW5zZm9ybWF0aW9uOiB0b1RyYW5zZm9ybWF0aW9uKDEgLyAxODAsIDEsIC0xIC8gMTgwLCAwLjUpXHJcbiAgfSk7XG5cbiAgLypcbiAgICogQG5hbWVzcGFjZSBDUlNcbiAgICogQGNycyBMLkNSUy5TaW1wbGVcbiAgICpcbiAgICogQSBzaW1wbGUgQ1JTIHRoYXQgbWFwcyBsb25naXR1ZGUgYW5kIGxhdGl0dWRlIGludG8gYHhgIGFuZCBgeWAgZGlyZWN0bHkuXG4gICAqIE1heSBiZSB1c2VkIGZvciBtYXBzIG9mIGZsYXQgc3VyZmFjZXMgKGUuZy4gZ2FtZSBtYXBzKS4gTm90ZSB0aGF0IHRoZSBgeWBcbiAgICogYXhpcyBzaG91bGQgc3RpbGwgYmUgaW52ZXJ0ZWQgKGdvaW5nIGZyb20gYm90dG9tIHRvIHRvcCkuIGBkaXN0YW5jZSgpYCByZXR1cm5zXG4gICAqIHNpbXBsZSBldWNsaWRlYW4gZGlzdGFuY2UuXG4gICAqL1xuXG4gIHZhciBTaW1wbGUgPSBleHRlbmQoe30sIENSUywge1xuICBcdHByb2plY3Rpb246IExvbkxhdCxcbiAgXHR0cmFuc2Zvcm1hdGlvbjogdG9UcmFuc2Zvcm1hdGlvbigxLCAwLCAtMSwgMCksXG5cbiAgXHRzY2FsZTogZnVuY3Rpb24gKHpvb20pIHtcbiAgXHRcdHJldHVybiBNYXRoLnBvdygyLCB6b29tKTtcbiAgXHR9LFxuXG4gIFx0em9vbTogZnVuY3Rpb24gKHNjYWxlKSB7XG4gIFx0XHRyZXR1cm4gTWF0aC5sb2coc2NhbGUpIC8gTWF0aC5MTjI7XG4gIFx0fSxcblxuICBcdGRpc3RhbmNlOiBmdW5jdGlvbiAobGF0bG5nMSwgbGF0bG5nMikge1xuICBcdFx0dmFyIGR4ID0gbGF0bG5nMi5sbmcgLSBsYXRsbmcxLmxuZyxcbiAgXHRcdCAgICBkeSA9IGxhdGxuZzIubGF0IC0gbGF0bG5nMS5sYXQ7XG5cbiAgXHRcdHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICBcdH0sXG5cbiAgXHRpbmZpbml0ZTogdHJ1ZVxuICB9KTtcblxuICBDUlMuRWFydGggPSBFYXJ0aDtcbiAgQ1JTLkVQU0czMzk1ID0gRVBTRzMzOTU7XG4gIENSUy5FUFNHMzg1NyA9IEVQU0czODU3O1xuICBDUlMuRVBTRzkwMDkxMyA9IEVQU0c5MDA5MTM7XG4gIENSUy5FUFNHNDMyNiA9IEVQU0c0MzI2O1xuICBDUlMuU2ltcGxlID0gU2ltcGxlO1xuXG4gIC8qXG4gICAqIEBjbGFzcyBMYXllclxuICAgKiBAaW5oZXJpdHMgRXZlbnRlZFxuICAgKiBAYWthIEwuTGF5ZXJcbiAgICogQGFrYSBJTGF5ZXJcbiAgICpcbiAgICogQSBzZXQgb2YgbWV0aG9kcyBmcm9tIHRoZSBMYXllciBiYXNlIGNsYXNzIHRoYXQgYWxsIExlYWZsZXQgbGF5ZXJzIHVzZS5cbiAgICogSW5oZXJpdHMgYWxsIG1ldGhvZHMsIG9wdGlvbnMgYW5kIGV2ZW50cyBmcm9tIGBMLkV2ZW50ZWRgLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB2YXIgbGF5ZXIgPSBMLm1hcmtlcihsYXRsbmcpLmFkZFRvKG1hcCk7XG4gICAqIGxheWVyLmFkZFRvKG1hcCk7XG4gICAqIGxheWVyLnJlbW92ZSgpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQGV2ZW50IGFkZDogRXZlbnRcbiAgICogRmlyZWQgYWZ0ZXIgdGhlIGxheWVyIGlzIGFkZGVkIHRvIGEgbWFwXG4gICAqXG4gICAqIEBldmVudCByZW1vdmU6IEV2ZW50XG4gICAqIEZpcmVkIGFmdGVyIHRoZSBsYXllciBpcyByZW1vdmVkIGZyb20gYSBtYXBcbiAgICovXG5cblxuICB2YXIgTGF5ZXIgPSBFdmVudGVkLmV4dGVuZCh7XG5cbiAgXHQvLyBDbGFzc2VzIGV4dGVuZGluZyBgTC5MYXllcmAgd2lsbCBpbmhlcml0IHRoZSBmb2xsb3dpbmcgb3B0aW9uczpcbiAgXHRvcHRpb25zOiB7XG4gIFx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICdvdmVybGF5UGFuZSdcbiAgXHRcdC8vIEJ5IGRlZmF1bHQgdGhlIGxheWVyIHdpbGwgYmUgYWRkZWQgdG8gdGhlIG1hcCdzIFtvdmVybGF5IHBhbmVdKCNtYXAtb3ZlcmxheXBhbmUpLiBPdmVycmlkaW5nIHRoaXMgb3B0aW9uIHdpbGwgY2F1c2UgdGhlIGxheWVyIHRvIGJlIHBsYWNlZCBvbiBhbm90aGVyIHBhbmUgYnkgZGVmYXVsdC5cbiAgXHRcdHBhbmU6ICdvdmVybGF5UGFuZScsXG5cbiAgXHRcdC8vIEBvcHRpb24gYXR0cmlidXRpb246IFN0cmluZyA9IG51bGxcbiAgXHRcdC8vIFN0cmluZyB0byBiZSBzaG93biBpbiB0aGUgYXR0cmlidXRpb24gY29udHJvbCwgZS5nLiBcIsKpIE9wZW5TdHJlZXRNYXAgY29udHJpYnV0b3JzXCIuIEl0IGRlc2NyaWJlcyB0aGUgbGF5ZXIgZGF0YSBhbmQgaXMgb2Z0ZW4gYSBsZWdhbCBvYmxpZ2F0aW9uIHRvd2FyZHMgY29weXJpZ2h0IGhvbGRlcnMgYW5kIHRpbGUgcHJvdmlkZXJzLlxuICBcdFx0YXR0cmlidXRpb246IG51bGwsXG5cbiAgXHRcdGJ1YmJsaW5nTW91c2VFdmVudHM6IHRydWVcbiAgXHR9LFxuXG4gIFx0LyogQHNlY3Rpb25cbiAgXHQgKiBDbGFzc2VzIGV4dGVuZGluZyBgTC5MYXllcmAgd2lsbCBpbmhlcml0IHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcbiAgXHQgKlxuICBcdCAqIEBtZXRob2QgYWRkVG8obWFwOiBNYXB8TGF5ZXJHcm91cCk6IHRoaXNcbiAgXHQgKiBBZGRzIHRoZSBsYXllciB0byB0aGUgZ2l2ZW4gbWFwIG9yIGxheWVyIGdyb3VwLlxuICBcdCAqL1xuICBcdGFkZFRvOiBmdW5jdGlvbiAobWFwKSB7XG4gIFx0XHRtYXAuYWRkTGF5ZXIodGhpcyk7XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCByZW1vdmU6IHRoaXNcbiAgXHQvLyBSZW1vdmVzIHRoZSBsYXllciBmcm9tIHRoZSBtYXAgaXQgaXMgY3VycmVudGx5IGFjdGl2ZSBvbi5cbiAgXHRyZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLnJlbW92ZUZyb20odGhpcy5fbWFwIHx8IHRoaXMuX21hcFRvQWRkKTtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCByZW1vdmVGcm9tKG1hcDogTWFwKTogdGhpc1xuICBcdC8vIFJlbW92ZXMgdGhlIGxheWVyIGZyb20gdGhlIGdpdmVuIG1hcFxuICBcdC8vXG4gIFx0Ly8gQGFsdGVybmF0aXZlXG4gIFx0Ly8gQG1ldGhvZCByZW1vdmVGcm9tKGdyb3VwOiBMYXllckdyb3VwKTogdGhpc1xuICBcdC8vIFJlbW92ZXMgdGhlIGxheWVyIGZyb20gdGhlIGdpdmVuIGBMYXllckdyb3VwYFxuICBcdHJlbW92ZUZyb206IGZ1bmN0aW9uIChvYmopIHtcbiAgXHRcdGlmIChvYmopIHtcbiAgXHRcdFx0b2JqLnJlbW92ZUxheWVyKHRoaXMpO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgZ2V0UGFuZShuYW1lPyA6IFN0cmluZyk6IEhUTUxFbGVtZW50XG4gIFx0Ly8gUmV0dXJucyB0aGUgYEhUTUxFbGVtZW50YCByZXByZXNlbnRpbmcgdGhlIG5hbWVkIHBhbmUgb24gdGhlIG1hcC4gSWYgYG5hbWVgIGlzIG9taXR0ZWQsIHJldHVybnMgdGhlIHBhbmUgZm9yIHRoaXMgbGF5ZXIuXG4gIFx0Z2V0UGFuZTogZnVuY3Rpb24gKG5hbWUpIHtcbiAgXHRcdHJldHVybiB0aGlzLl9tYXAuZ2V0UGFuZShuYW1lID8gKHRoaXMub3B0aW9uc1tuYW1lXSB8fCBuYW1lKSA6IHRoaXMub3B0aW9ucy5wYW5lKTtcbiAgXHR9LFxuXG4gIFx0YWRkSW50ZXJhY3RpdmVUYXJnZXQ6IGZ1bmN0aW9uICh0YXJnZXRFbCkge1xuICBcdFx0dGhpcy5fbWFwLl90YXJnZXRzW3N0YW1wKHRhcmdldEVsKV0gPSB0aGlzO1xuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdHJlbW92ZUludGVyYWN0aXZlVGFyZ2V0OiBmdW5jdGlvbiAodGFyZ2V0RWwpIHtcbiAgXHRcdGRlbGV0ZSB0aGlzLl9tYXAuX3RhcmdldHNbc3RhbXAodGFyZ2V0RWwpXTtcbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGdldEF0dHJpYnV0aW9uOiBTdHJpbmdcbiAgXHQvLyBVc2VkIGJ5IHRoZSBgYXR0cmlidXRpb24gY29udHJvbGAsIHJldHVybnMgdGhlIFthdHRyaWJ1dGlvbiBvcHRpb25dKCNncmlkbGF5ZXItYXR0cmlidXRpb24pLlxuICBcdGdldEF0dHJpYnV0aW9uOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmF0dHJpYnV0aW9uO1xuICBcdH0sXG5cbiAgXHRfbGF5ZXJBZGQ6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHR2YXIgbWFwID0gZS50YXJnZXQ7XG5cbiAgXHRcdC8vIGNoZWNrIGluIGNhc2UgbGF5ZXIgZ2V0cyBhZGRlZCBhbmQgdGhlbiByZW1vdmVkIGJlZm9yZSB0aGUgbWFwIGlzIHJlYWR5XG4gIFx0XHRpZiAoIW1hcC5oYXNMYXllcih0aGlzKSkgeyByZXR1cm47IH1cblxuICBcdFx0dGhpcy5fbWFwID0gbWFwO1xuICBcdFx0dGhpcy5fem9vbUFuaW1hdGVkID0gbWFwLl96b29tQW5pbWF0ZWQ7XG5cbiAgXHRcdGlmICh0aGlzLmdldEV2ZW50cykge1xuICBcdFx0XHR2YXIgZXZlbnRzID0gdGhpcy5nZXRFdmVudHMoKTtcbiAgXHRcdFx0bWFwLm9uKGV2ZW50cywgdGhpcyk7XG4gIFx0XHRcdHRoaXMub25jZSgncmVtb3ZlJywgZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdG1hcC5vZmYoZXZlbnRzLCB0aGlzKTtcbiAgXHRcdFx0fSwgdGhpcyk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMub25BZGQobWFwKTtcblxuICBcdFx0dGhpcy5maXJlKCdhZGQnKTtcbiAgXHRcdG1hcC5maXJlKCdsYXllcmFkZCcsIHtsYXllcjogdGhpc30pO1xuICBcdH1cbiAgfSk7XG5cbiAgLyogQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcbiAgICogQHVuaW5oZXJpdGFibGVcbiAgICpcbiAgICogRXZlcnkgbGF5ZXIgc2hvdWxkIGV4dGVuZCBmcm9tIGBMLkxheWVyYCBhbmQgKHJlLSlpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBtZXRob2RzLlxuICAgKlxuICAgKiBAbWV0aG9kIG9uQWRkKG1hcDogTWFwKTogdGhpc1xuICAgKiBTaG91bGQgY29udGFpbiBjb2RlIHRoYXQgY3JlYXRlcyBET00gZWxlbWVudHMgZm9yIHRoZSBsYXllciwgYWRkcyB0aGVtIHRvIGBtYXAgcGFuZXNgIHdoZXJlIHRoZXkgc2hvdWxkIGJlbG9uZyBhbmQgcHV0cyBsaXN0ZW5lcnMgb24gcmVsZXZhbnQgbWFwIGV2ZW50cy4gQ2FsbGVkIG9uIFtgbWFwLmFkZExheWVyKGxheWVyKWBdKCNtYXAtYWRkbGF5ZXIpLlxuICAgKlxuICAgKiBAbWV0aG9kIG9uUmVtb3ZlKG1hcDogTWFwKTogdGhpc1xuICAgKiBTaG91bGQgY29udGFpbiBhbGwgY2xlYW4gdXAgY29kZSB0aGF0IHJlbW92ZXMgdGhlIGxheWVyJ3MgZWxlbWVudHMgZnJvbSB0aGUgRE9NIGFuZCByZW1vdmVzIGxpc3RlbmVycyBwcmV2aW91c2x5IGFkZGVkIGluIFtgb25BZGRgXSgjbGF5ZXItb25hZGQpLiBDYWxsZWQgb24gW2BtYXAucmVtb3ZlTGF5ZXIobGF5ZXIpYF0oI21hcC1yZW1vdmVsYXllcikuXG4gICAqXG4gICAqIEBtZXRob2QgZ2V0RXZlbnRzKCk6IE9iamVjdFxuICAgKiBUaGlzIG9wdGlvbmFsIG1ldGhvZCBzaG91bGQgcmV0dXJuIGFuIG9iamVjdCBsaWtlIGB7IHZpZXdyZXNldDogdGhpcy5fcmVzZXQgfWAgZm9yIFtgYWRkRXZlbnRMaXN0ZW5lcmBdKCNldmVudGVkLWFkZGV2ZW50bGlzdGVuZXIpLiBUaGUgZXZlbnQgaGFuZGxlcnMgaW4gdGhpcyBvYmplY3Qgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGFkZGVkIGFuZCByZW1vdmVkIGZyb20gdGhlIG1hcCB3aXRoIHlvdXIgbGF5ZXIuXG4gICAqXG4gICAqIEBtZXRob2QgZ2V0QXR0cmlidXRpb24oKTogU3RyaW5nXG4gICAqIFRoaXMgb3B0aW9uYWwgbWV0aG9kIHNob3VsZCByZXR1cm4gYSBzdHJpbmcgY29udGFpbmluZyBIVE1MIHRvIGJlIHNob3duIG9uIHRoZSBgQXR0cmlidXRpb24gY29udHJvbGAgd2hlbmV2ZXIgdGhlIGxheWVyIGlzIHZpc2libGUuXG4gICAqXG4gICAqIEBtZXRob2QgYmVmb3JlQWRkKG1hcDogTWFwKTogdGhpc1xuICAgKiBPcHRpb25hbCBtZXRob2QuIENhbGxlZCBvbiBbYG1hcC5hZGRMYXllcihsYXllcilgXSgjbWFwLWFkZGxheWVyKSwgYmVmb3JlIHRoZSBsYXllciBpcyBhZGRlZCB0byB0aGUgbWFwLCBiZWZvcmUgZXZlbnRzIGFyZSBpbml0aWFsaXplZCwgd2l0aG91dCB3YWl0aW5nIHVudGlsIHRoZSBtYXAgaXMgaW4gYSB1c2FibGUgc3RhdGUuIFVzZSBmb3IgZWFybHkgaW5pdGlhbGl6YXRpb24gb25seS5cbiAgICovXG5cblxuICAvKiBAbmFtZXNwYWNlIE1hcFxuICAgKiBAc2VjdGlvbiBMYXllciBldmVudHNcbiAgICpcbiAgICogQGV2ZW50IGxheWVyYWRkOiBMYXllckV2ZW50XG4gICAqIEZpcmVkIHdoZW4gYSBuZXcgbGF5ZXIgaXMgYWRkZWQgdG8gdGhlIG1hcC5cbiAgICpcbiAgICogQGV2ZW50IGxheWVycmVtb3ZlOiBMYXllckV2ZW50XG4gICAqIEZpcmVkIHdoZW4gc29tZSBsYXllciBpcyByZW1vdmVkIGZyb20gdGhlIG1hcFxuICAgKlxuICAgKiBAc2VjdGlvbiBNZXRob2RzIGZvciBMYXllcnMgYW5kIENvbnRyb2xzXG4gICAqL1xuICBNYXAuaW5jbHVkZSh7XG4gIFx0Ly8gQG1ldGhvZCBhZGRMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXG4gIFx0Ly8gQWRkcyB0aGUgZ2l2ZW4gbGF5ZXIgdG8gdGhlIG1hcFxuICBcdGFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdGlmICghbGF5ZXIuX2xheWVyQWRkKSB7XG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcignVGhlIHByb3ZpZGVkIG9iamVjdCBpcyBub3QgYSBMYXllci4nKTtcbiAgXHRcdH1cblxuICBcdFx0dmFyIGlkID0gc3RhbXAobGF5ZXIpO1xuICBcdFx0aWYgKHRoaXMuX2xheWVyc1tpZF0pIHsgcmV0dXJuIHRoaXM7IH1cbiAgXHRcdHRoaXMuX2xheWVyc1tpZF0gPSBsYXllcjtcblxuICBcdFx0bGF5ZXIuX21hcFRvQWRkID0gdGhpcztcblxuICBcdFx0aWYgKGxheWVyLmJlZm9yZUFkZCkge1xuICBcdFx0XHRsYXllci5iZWZvcmVBZGQodGhpcyk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMud2hlblJlYWR5KGxheWVyLl9sYXllckFkZCwgbGF5ZXIpO1xuXG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXG4gIFx0Ly8gUmVtb3ZlcyB0aGUgZ2l2ZW4gbGF5ZXIgZnJvbSB0aGUgbWFwLlxuICBcdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHZhciBpZCA9IHN0YW1wKGxheWVyKTtcblxuICBcdFx0aWYgKCF0aGlzLl9sYXllcnNbaWRdKSB7IHJldHVybiB0aGlzOyB9XG5cbiAgXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcbiAgXHRcdFx0bGF5ZXIub25SZW1vdmUodGhpcyk7XG4gIFx0XHR9XG5cbiAgXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbaWRdO1xuXG4gIFx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XG4gIFx0XHRcdHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7bGF5ZXI6IGxheWVyfSk7XG4gIFx0XHRcdGxheWVyLmZpcmUoJ3JlbW92ZScpO1xuICBcdFx0fVxuXG4gIFx0XHRsYXllci5fbWFwID0gbGF5ZXIuX21hcFRvQWRkID0gbnVsbDtcblxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgaGFzTGF5ZXIobGF5ZXI6IExheWVyKTogQm9vbGVhblxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBsYXllciBpcyBjdXJyZW50bHkgYWRkZWQgdG8gdGhlIG1hcFxuICBcdGhhc0xheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHJldHVybiBzdGFtcChsYXllcikgaW4gdGhpcy5fbGF5ZXJzO1xuICBcdH0sXG5cbiAgXHQvKiBAbWV0aG9kIGVhY2hMYXllcihmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXG4gIFx0ICogSXRlcmF0ZXMgb3ZlciB0aGUgbGF5ZXJzIG9mIHRoZSBtYXAsIG9wdGlvbmFsbHkgc3BlY2lmeWluZyBjb250ZXh0IG9mIHRoZSBpdGVyYXRvciBmdW5jdGlvbi5cbiAgXHQgKiBgYGBcbiAgXHQgKiBtYXAuZWFjaExheWVyKGZ1bmN0aW9uKGxheWVyKXtcbiAgXHQgKiAgICAgbGF5ZXIuYmluZFBvcHVwKCdIZWxsbycpO1xuICBcdCAqIH0pO1xuICBcdCAqIGBgYFxuICBcdCAqL1xuICBcdGVhY2hMYXllcjogZnVuY3Rpb24gKG1ldGhvZCwgY29udGV4dCkge1xuICBcdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sYXllcnMpIHtcbiAgXHRcdFx0bWV0aG9kLmNhbGwoY29udGV4dCwgdGhpcy5fbGF5ZXJzW2ldKTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHRfYWRkTGF5ZXJzOiBmdW5jdGlvbiAobGF5ZXJzKSB7XG4gIFx0XHRsYXllcnMgPSBsYXllcnMgPyAoaXNBcnJheShsYXllcnMpID8gbGF5ZXJzIDogW2xheWVyc10pIDogW107XG5cbiAgXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXllcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0dGhpcy5hZGRMYXllcihsYXllcnNbaV0pO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfYWRkWm9vbUxpbWl0OiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdGlmICghaXNOYU4obGF5ZXIub3B0aW9ucy5tYXhab29tKSB8fCAhaXNOYU4obGF5ZXIub3B0aW9ucy5taW5ab29tKSkge1xuICBcdFx0XHR0aGlzLl96b29tQm91bmRMYXllcnNbc3RhbXAobGF5ZXIpXSA9IGxheWVyO1xuICBcdFx0XHR0aGlzLl91cGRhdGVab29tTGV2ZWxzKCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9yZW1vdmVab29tTGltaXQ6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dmFyIGlkID0gc3RhbXAobGF5ZXIpO1xuXG4gIFx0XHRpZiAodGhpcy5fem9vbUJvdW5kTGF5ZXJzW2lkXSkge1xuICBcdFx0XHRkZWxldGUgdGhpcy5fem9vbUJvdW5kTGF5ZXJzW2lkXTtcbiAgXHRcdFx0dGhpcy5fdXBkYXRlWm9vbUxldmVscygpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfdXBkYXRlWm9vbUxldmVsczogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIG1pblpvb20gPSBJbmZpbml0eSxcbiAgXHRcdCAgICBtYXhab29tID0gLUluZmluaXR5LFxuICBcdFx0ICAgIG9sZFpvb21TcGFuID0gdGhpcy5fZ2V0Wm9vbVNwYW4oKTtcblxuICBcdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl96b29tQm91bmRMYXllcnMpIHtcbiAgXHRcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLl96b29tQm91bmRMYXllcnNbaV0ub3B0aW9ucztcblxuICBcdFx0XHRtaW5ab29tID0gb3B0aW9ucy5taW5ab29tID09PSB1bmRlZmluZWQgPyBtaW5ab29tIDogTWF0aC5taW4obWluWm9vbSwgb3B0aW9ucy5taW5ab29tKTtcbiAgXHRcdFx0bWF4Wm9vbSA9IG9wdGlvbnMubWF4Wm9vbSA9PT0gdW5kZWZpbmVkID8gbWF4Wm9vbSA6IE1hdGgubWF4KG1heFpvb20sIG9wdGlvbnMubWF4Wm9vbSk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX2xheWVyc01heFpvb20gPSBtYXhab29tID09PSAtSW5maW5pdHkgPyB1bmRlZmluZWQgOiBtYXhab29tO1xuICBcdFx0dGhpcy5fbGF5ZXJzTWluWm9vbSA9IG1pblpvb20gPT09IEluZmluaXR5ID8gdW5kZWZpbmVkIDogbWluWm9vbTtcblxuICBcdFx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcbiAgXHRcdC8vIEBldmVudCB6b29tbGV2ZWxzY2hhbmdlOiBFdmVudFxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbnVtYmVyIG9mIHpvb21sZXZlbHMgb24gdGhlIG1hcCBpcyBjaGFuZ2VkIGR1ZVxuICBcdFx0Ly8gdG8gYWRkaW5nIG9yIHJlbW92aW5nIGEgbGF5ZXIuXG4gIFx0XHRpZiAob2xkWm9vbVNwYW4gIT09IHRoaXMuX2dldFpvb21TcGFuKCkpIHtcbiAgXHRcdFx0dGhpcy5maXJlKCd6b29tbGV2ZWxzY2hhbmdlJyk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMubWF4Wm9vbSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX2xheWVyc01heFpvb20gJiYgdGhpcy5nZXRab29tKCkgPiB0aGlzLl9sYXllcnNNYXhab29tKSB7XG4gIFx0XHRcdHRoaXMuc2V0Wm9vbSh0aGlzLl9sYXllcnNNYXhab29tKTtcbiAgXHRcdH1cbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMubWluWm9vbSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX2xheWVyc01pblpvb20gJiYgdGhpcy5nZXRab29tKCkgPCB0aGlzLl9sYXllcnNNaW5ab29tKSB7XG4gIFx0XHRcdHRoaXMuc2V0Wm9vbSh0aGlzLl9sYXllcnNNaW5ab29tKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH0pO1xuXG4gIC8qXHJcbiAgICogQGNsYXNzIExheWVyR3JvdXBcclxuICAgKiBAYWthIEwuTGF5ZXJHcm91cFxyXG4gICAqIEBpbmhlcml0cyBJbnRlcmFjdGl2ZSBsYXllclxyXG4gICAqXHJcbiAgICogVXNlZCB0byBncm91cCBzZXZlcmFsIGxheWVycyBhbmQgaGFuZGxlIHRoZW0gYXMgb25lLiBJZiB5b3UgYWRkIGl0IHRvIHRoZSBtYXAsXHJcbiAgICogYW55IGxheWVycyBhZGRlZCBvciByZW1vdmVkIGZyb20gdGhlIGdyb3VwIHdpbGwgYmUgYWRkZWQvcmVtb3ZlZCBvbiB0aGUgbWFwIGFzXHJcbiAgICogd2VsbC4gRXh0ZW5kcyBgTGF5ZXJgLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogTC5sYXllckdyb3VwKFttYXJrZXIxLCBtYXJrZXIyXSlcclxuICAgKiBcdC5hZGRMYXllcihwb2x5bGluZSlcclxuICAgKiBcdC5hZGRUbyhtYXApO1xyXG4gICAqIGBgYFxyXG4gICAqL1xyXG5cclxuICB2YXIgTGF5ZXJHcm91cCA9IExheWVyLmV4dGVuZCh7XHJcblxyXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxheWVycywgb3B0aW9ucykge1xyXG4gIFx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuICBcdFx0dGhpcy5fbGF5ZXJzID0ge307XHJcblxyXG4gIFx0XHR2YXIgaSwgbGVuO1xyXG5cclxuICBcdFx0aWYgKGxheWVycykge1xyXG4gIFx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRcdFx0dGhpcy5hZGRMYXllcihsYXllcnNbaV0pO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGFkZExheWVyKGxheWVyOiBMYXllcik6IHRoaXNcclxuICBcdC8vIEFkZHMgdGhlIGdpdmVuIGxheWVyIHRvIHRoZSBncm91cC5cclxuICBcdGFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuICBcdFx0dmFyIGlkID0gdGhpcy5nZXRMYXllcklkKGxheWVyKTtcclxuXHJcbiAgXHRcdHRoaXMuX2xheWVyc1tpZF0gPSBsYXllcjtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcclxuICBcdFx0XHR0aGlzLl9tYXAuYWRkTGF5ZXIobGF5ZXIpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXHJcbiAgXHQvLyBSZW1vdmVzIHRoZSBnaXZlbiBsYXllciBmcm9tIHRoZSBncm91cC5cclxuICBcdC8vIEBhbHRlcm5hdGl2ZVxyXG4gIFx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihpZDogTnVtYmVyKTogdGhpc1xyXG4gIFx0Ly8gUmVtb3ZlcyB0aGUgbGF5ZXIgd2l0aCB0aGUgZ2l2ZW4gaW50ZXJuYWwgSUQgZnJvbSB0aGUgZ3JvdXAuXHJcbiAgXHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAgXHRcdHZhciBpZCA9IGxheWVyIGluIHRoaXMuX2xheWVycyA/IGxheWVyIDogdGhpcy5nZXRMYXllcklkKGxheWVyKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9tYXAgJiYgdGhpcy5fbGF5ZXJzW2lkXSkge1xyXG4gIFx0XHRcdHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9sYXllcnNbaWRdKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tpZF07XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBoYXNMYXllcihsYXllcjogTGF5ZXIpOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gbGF5ZXIgaXMgY3VycmVudGx5IGFkZGVkIHRvIHRoZSBncm91cC5cclxuICBcdC8vIEBhbHRlcm5hdGl2ZVxyXG4gIFx0Ly8gQG1ldGhvZCBoYXNMYXllcihpZDogTnVtYmVyKTogQm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGludGVybmFsIElEIGlzIGN1cnJlbnRseSBhZGRlZCB0byB0aGUgZ3JvdXAuXHJcbiAgXHRoYXNMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAgXHRcdHZhciBsYXllcklkID0gdHlwZW9mIGxheWVyID09PSAnbnVtYmVyJyA/IGxheWVyIDogdGhpcy5nZXRMYXllcklkKGxheWVyKTtcclxuICBcdFx0cmV0dXJuIGxheWVySWQgaW4gdGhpcy5fbGF5ZXJzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGNsZWFyTGF5ZXJzKCk6IHRoaXNcclxuICBcdC8vIFJlbW92ZXMgYWxsIHRoZSBsYXllcnMgZnJvbSB0aGUgZ3JvdXAuXHJcbiAgXHRjbGVhckxheWVyczogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5lYWNoTGF5ZXIodGhpcy5yZW1vdmVMYXllciwgdGhpcyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgaW52b2tlKG1ldGhvZE5hbWU6IFN0cmluZywg4oCmKTogdGhpc1xyXG4gIFx0Ly8gQ2FsbHMgYG1ldGhvZE5hbWVgIG9uIGV2ZXJ5IGxheWVyIGNvbnRhaW5lZCBpbiB0aGlzIGdyb3VwLCBwYXNzaW5nIGFueVxyXG4gIFx0Ly8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzLiBIYXMgbm8gZWZmZWN0IGlmIHRoZSBsYXllcnMgY29udGFpbmVkIGRvIG5vdFxyXG4gIFx0Ly8gaW1wbGVtZW50IGBtZXRob2ROYW1lYC5cclxuICBcdGludm9rZTogZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcclxuICBcdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxyXG4gIFx0XHQgICAgaSwgbGF5ZXI7XHJcblxyXG4gIFx0XHRmb3IgKGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcbiAgXHRcdFx0bGF5ZXIgPSB0aGlzLl9sYXllcnNbaV07XHJcblxyXG4gIFx0XHRcdGlmIChsYXllclttZXRob2ROYW1lXSkge1xyXG4gIFx0XHRcdFx0bGF5ZXJbbWV0aG9kTmFtZV0uYXBwbHkobGF5ZXIsIGFyZ3MpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgXHRcdHRoaXMuZWFjaExheWVyKG1hcC5hZGRMYXllciwgbWFwKTtcclxuICBcdH0sXHJcblxyXG4gIFx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0dGhpcy5lYWNoTGF5ZXIobWFwLnJlbW92ZUxheWVyLCBtYXApO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGVhY2hMYXllcihmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbiAgXHQvLyBJdGVyYXRlcyBvdmVyIHRoZSBsYXllcnMgb2YgdGhlIGdyb3VwLCBvcHRpb25hbGx5IHNwZWNpZnlpbmcgY29udGV4dCBvZiB0aGUgaXRlcmF0b3IgZnVuY3Rpb24uXHJcbiAgXHQvLyBgYGBqc1xyXG4gIFx0Ly8gZ3JvdXAuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG4gIFx0Ly8gXHRsYXllci5iaW5kUG9wdXAoJ0hlbGxvJyk7XHJcbiAgXHQvLyB9KTtcclxuICBcdC8vIGBgYFxyXG4gIFx0ZWFjaExheWVyOiBmdW5jdGlvbiAobWV0aG9kLCBjb250ZXh0KSB7XHJcbiAgXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcbiAgXHRcdFx0bWV0aG9kLmNhbGwoY29udGV4dCwgdGhpcy5fbGF5ZXJzW2ldKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRMYXllcihpZDogTnVtYmVyKTogTGF5ZXJcclxuICBcdC8vIFJldHVybnMgdGhlIGxheWVyIHdpdGggdGhlIGdpdmVuIGludGVybmFsIElELlxyXG4gIFx0Z2V0TGF5ZXI6IGZ1bmN0aW9uIChpZCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fbGF5ZXJzW2lkXTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRMYXllcnMoKTogTGF5ZXJbXVxyXG4gIFx0Ly8gUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgdGhlIGxheWVycyBhZGRlZCB0byB0aGUgZ3JvdXAuXHJcbiAgXHRnZXRMYXllcnM6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIGxheWVycyA9IFtdO1xyXG4gIFx0XHR0aGlzLmVhY2hMYXllcihsYXllcnMucHVzaCwgbGF5ZXJzKTtcclxuICBcdFx0cmV0dXJuIGxheWVycztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRaSW5kZXgoekluZGV4OiBOdW1iZXIpOiB0aGlzXHJcbiAgXHQvLyBDYWxscyBgc2V0WkluZGV4YCBvbiBldmVyeSBsYXllciBjb250YWluZWQgaW4gdGhpcyBncm91cCwgcGFzc2luZyB0aGUgei1pbmRleC5cclxuICBcdHNldFpJbmRleDogZnVuY3Rpb24gKHpJbmRleCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ3NldFpJbmRleCcsIHpJbmRleCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0TGF5ZXJJZChsYXllcjogTGF5ZXIpOiBOdW1iZXJcclxuICBcdC8vIFJldHVybnMgdGhlIGludGVybmFsIElEIGZvciBhIGxheWVyXHJcbiAgXHRnZXRMYXllcklkOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuICBcdFx0cmV0dXJuIHN0YW1wKGxheWVyKTtcclxuICBcdH1cclxuICB9KTtcclxuXHJcblxyXG4gIC8vIEBmYWN0b3J5IEwubGF5ZXJHcm91cChsYXllcnM/OiBMYXllcltdLCBvcHRpb25zPzogT2JqZWN0KVxyXG4gIC8vIENyZWF0ZSBhIGxheWVyIGdyb3VwLCBvcHRpb25hbGx5IGdpdmVuIGFuIGluaXRpYWwgc2V0IG9mIGxheWVycyBhbmQgYW4gYG9wdGlvbnNgIG9iamVjdC5cclxuICB2YXIgbGF5ZXJHcm91cCA9IGZ1bmN0aW9uIChsYXllcnMsIG9wdGlvbnMpIHtcclxuICBcdHJldHVybiBuZXcgTGF5ZXJHcm91cChsYXllcnMsIG9wdGlvbnMpO1xyXG4gIH07XG5cbiAgLypcclxuICAgKiBAY2xhc3MgRmVhdHVyZUdyb3VwXHJcbiAgICogQGFrYSBMLkZlYXR1cmVHcm91cFxyXG4gICAqIEBpbmhlcml0cyBMYXllckdyb3VwXHJcbiAgICpcclxuICAgKiBFeHRlbmRlZCBgTGF5ZXJHcm91cGAgdGhhdCBtYWtlcyBpdCBlYXNpZXIgdG8gZG8gdGhlIHNhbWUgdGhpbmcgdG8gYWxsIGl0cyBtZW1iZXIgbGF5ZXJzOlxyXG4gICAqICAqIFtgYmluZFBvcHVwYF0oI2xheWVyLWJpbmRwb3B1cCkgYmluZHMgYSBwb3B1cCB0byBhbGwgb2YgdGhlIGxheWVycyBhdCBvbmNlIChsaWtld2lzZSB3aXRoIFtgYmluZFRvb2x0aXBgXSgjbGF5ZXItYmluZHRvb2x0aXApKVxyXG4gICAqICAqIEV2ZW50cyBhcmUgcHJvcGFnYXRlZCB0byB0aGUgYEZlYXR1cmVHcm91cGAsIHNvIGlmIHRoZSBncm91cCBoYXMgYW4gZXZlbnRcclxuICAgKiBoYW5kbGVyLCBpdCB3aWxsIGhhbmRsZSBldmVudHMgZnJvbSBhbnkgb2YgdGhlIGxheWVycy4gVGhpcyBpbmNsdWRlcyBtb3VzZSBldmVudHNcclxuICAgKiBhbmQgY3VzdG9tIGV2ZW50cy5cclxuICAgKiAgKiBIYXMgYGxheWVyYWRkYCBhbmQgYGxheWVycmVtb3ZlYCBldmVudHNcclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIEwuZmVhdHVyZUdyb3VwKFttYXJrZXIxLCBtYXJrZXIyLCBwb2x5bGluZV0pXHJcbiAgICogXHQuYmluZFBvcHVwKCdIZWxsbyB3b3JsZCEnKVxyXG4gICAqIFx0Lm9uKCdjbGljaycsIGZ1bmN0aW9uKCkgeyBhbGVydCgnQ2xpY2tlZCBvbiBhIG1lbWJlciBvZiB0aGUgZ3JvdXAhJyk7IH0pXHJcbiAgICogXHQuYWRkVG8obWFwKTtcclxuICAgKiBgYGBcclxuICAgKi9cclxuXHJcbiAgdmFyIEZlYXR1cmVHcm91cCA9IExheWVyR3JvdXAuZXh0ZW5kKHtcclxuXHJcbiAgXHRhZGRMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAgXHRcdGlmICh0aGlzLmhhc0xheWVyKGxheWVyKSkge1xyXG4gIFx0XHRcdHJldHVybiB0aGlzO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRsYXllci5hZGRFdmVudFBhcmVudCh0aGlzKTtcclxuXHJcbiAgXHRcdExheWVyR3JvdXAucHJvdG90eXBlLmFkZExheWVyLmNhbGwodGhpcywgbGF5ZXIpO1xyXG5cclxuICBcdFx0Ly8gQGV2ZW50IGxheWVyYWRkOiBMYXllckV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gYSBsYXllciBpcyBhZGRlZCB0byB0aGlzIGBGZWF0dXJlR3JvdXBgXHJcbiAgXHRcdHJldHVybiB0aGlzLmZpcmUoJ2xheWVyYWRkJywge2xheWVyOiBsYXllcn0pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAgXHRcdGlmICghdGhpcy5oYXNMYXllcihsYXllcikpIHtcclxuICBcdFx0XHRyZXR1cm4gdGhpcztcclxuICBcdFx0fVxyXG4gIFx0XHRpZiAobGF5ZXIgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcbiAgXHRcdFx0bGF5ZXIgPSB0aGlzLl9sYXllcnNbbGF5ZXJdO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRsYXllci5yZW1vdmVFdmVudFBhcmVudCh0aGlzKTtcclxuXHJcbiAgXHRcdExheWVyR3JvdXAucHJvdG90eXBlLnJlbW92ZUxheWVyLmNhbGwodGhpcywgbGF5ZXIpO1xyXG5cclxuICBcdFx0Ly8gQGV2ZW50IGxheWVycmVtb3ZlOiBMYXllckV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gYSBsYXllciBpcyByZW1vdmVkIGZyb20gdGhpcyBgRmVhdHVyZUdyb3VwYFxyXG4gIFx0XHRyZXR1cm4gdGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHtsYXllcjogbGF5ZXJ9KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRTdHlsZShzdHlsZTogUGF0aCBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gU2V0cyB0aGUgZ2l2ZW4gcGF0aCBvcHRpb25zIHRvIGVhY2ggbGF5ZXIgb2YgdGhlIGdyb3VwIHRoYXQgaGFzIGEgYHNldFN0eWxlYCBtZXRob2QuXHJcbiAgXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmludm9rZSgnc2V0U3R5bGUnLCBzdHlsZSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250KCk6IHRoaXNcclxuICBcdC8vIEJyaW5ncyB0aGUgbGF5ZXIgZ3JvdXAgdG8gdGhlIHRvcCBvZiBhbGwgb3RoZXIgbGF5ZXJzXHJcbiAgXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdicmluZ1RvRnJvbnQnKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjaygpOiB0aGlzXHJcbiAgXHQvLyBCcmluZ3MgdGhlIGxheWVyIGdyb3VwIHRvIHRoZSBiYWNrIG9mIGFsbCBvdGhlciBsYXllcnNcclxuICBcdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmludm9rZSgnYnJpbmdUb0JhY2snKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBMYXRMbmdCb3VuZHMgb2YgdGhlIEZlYXR1cmUgR3JvdXAgKGNyZWF0ZWQgZnJvbSBib3VuZHMgYW5kIGNvb3JkaW5hdGVzIG9mIGl0cyBjaGlsZHJlbikuXHJcbiAgXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIGJvdW5kcyA9IG5ldyBMYXRMbmdCb3VuZHMoKTtcclxuXHJcbiAgXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xyXG4gIFx0XHRcdHZhciBsYXllciA9IHRoaXMuX2xheWVyc1tpZF07XHJcbiAgXHRcdFx0Ym91bmRzLmV4dGVuZChsYXllci5nZXRCb3VuZHMgPyBsYXllci5nZXRCb3VuZHMoKSA6IGxheWVyLmdldExhdExuZygpKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gYm91bmRzO1xyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuICAvLyBAZmFjdG9yeSBMLmZlYXR1cmVHcm91cChsYXllcnM/OiBMYXllcltdLCBvcHRpb25zPzogT2JqZWN0KVxyXG4gIC8vIENyZWF0ZSBhIGZlYXR1cmUgZ3JvdXAsIG9wdGlvbmFsbHkgZ2l2ZW4gYW4gaW5pdGlhbCBzZXQgb2YgbGF5ZXJzIGFuZCBhbiBgb3B0aW9uc2Agb2JqZWN0LlxyXG4gIHZhciBmZWF0dXJlR3JvdXAgPSBmdW5jdGlvbiAobGF5ZXJzLCBvcHRpb25zKSB7XHJcbiAgXHRyZXR1cm4gbmV3IEZlYXR1cmVHcm91cChsYXllcnMsIG9wdGlvbnMpO1xyXG4gIH07XG5cbiAgLypcclxuICAgKiBAY2xhc3MgSWNvblxyXG4gICAqIEBha2EgTC5JY29uXHJcbiAgICpcclxuICAgKiBSZXByZXNlbnRzIGFuIGljb24gdG8gcHJvdmlkZSB3aGVuIGNyZWF0aW5nIGEgbWFya2VyLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogdmFyIG15SWNvbiA9IEwuaWNvbih7XHJcbiAgICogICAgIGljb25Vcmw6ICdteS1pY29uLnBuZycsXHJcbiAgICogICAgIGljb25SZXRpbmFVcmw6ICdteS1pY29uQDJ4LnBuZycsXHJcbiAgICogICAgIGljb25TaXplOiBbMzgsIDk1XSxcclxuICAgKiAgICAgaWNvbkFuY2hvcjogWzIyLCA5NF0sXHJcbiAgICogICAgIHBvcHVwQW5jaG9yOiBbLTMsIC03Nl0sXHJcbiAgICogICAgIHNoYWRvd1VybDogJ215LWljb24tc2hhZG93LnBuZycsXHJcbiAgICogICAgIHNoYWRvd1JldGluYVVybDogJ215LWljb24tc2hhZG93QDJ4LnBuZycsXHJcbiAgICogICAgIHNoYWRvd1NpemU6IFs2OCwgOTVdLFxyXG4gICAqICAgICBzaGFkb3dBbmNob3I6IFsyMiwgOTRdXHJcbiAgICogfSk7XHJcbiAgICpcclxuICAgKiBMLm1hcmtlcihbNTAuNTA1LCAzMC41N10sIHtpY29uOiBteUljb259KS5hZGRUbyhtYXApO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogYEwuSWNvbi5EZWZhdWx0YCBleHRlbmRzIGBMLkljb25gIGFuZCBpcyB0aGUgYmx1ZSBpY29uIExlYWZsZXQgdXNlcyBmb3IgbWFya2VycyBieSBkZWZhdWx0LlxyXG4gICAqXHJcbiAgICovXHJcblxyXG4gIHZhciBJY29uID0gQ2xhc3MuZXh0ZW5kKHtcclxuXHJcbiAgXHQvKiBAc2VjdGlvblxyXG4gIFx0ICogQGFrYSBJY29uIG9wdGlvbnNcclxuICBcdCAqXHJcbiAgXHQgKiBAb3B0aW9uIGljb25Vcmw6IFN0cmluZyA9IG51bGxcclxuICBcdCAqICoqKHJlcXVpcmVkKSoqIFRoZSBVUkwgdG8gdGhlIGljb24gaW1hZ2UgKGFic29sdXRlIG9yIHJlbGF0aXZlIHRvIHlvdXIgc2NyaXB0IHBhdGgpLlxyXG4gIFx0ICpcclxuICBcdCAqIEBvcHRpb24gaWNvblJldGluYVVybDogU3RyaW5nID0gbnVsbFxyXG4gIFx0ICogVGhlIFVSTCB0byBhIHJldGluYSBzaXplZCB2ZXJzaW9uIG9mIHRoZSBpY29uIGltYWdlIChhYnNvbHV0ZSBvciByZWxhdGl2ZSB0byB5b3VyXHJcbiAgXHQgKiBzY3JpcHQgcGF0aCkuIFVzZWQgZm9yIFJldGluYSBzY3JlZW4gZGV2aWNlcy5cclxuICBcdCAqXHJcbiAgXHQgKiBAb3B0aW9uIGljb25TaXplOiBQb2ludCA9IG51bGxcclxuICBcdCAqIFNpemUgb2YgdGhlIGljb24gaW1hZ2UgaW4gcGl4ZWxzLlxyXG4gIFx0ICpcclxuICBcdCAqIEBvcHRpb24gaWNvbkFuY2hvcjogUG9pbnQgPSBudWxsXHJcbiAgXHQgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIFwidGlwXCIgb2YgdGhlIGljb24gKHJlbGF0aXZlIHRvIGl0cyB0b3AgbGVmdCBjb3JuZXIpLiBUaGUgaWNvblxyXG4gIFx0ICogd2lsbCBiZSBhbGlnbmVkIHNvIHRoYXQgdGhpcyBwb2ludCBpcyBhdCB0aGUgbWFya2VyJ3MgZ2VvZ3JhcGhpY2FsIGxvY2F0aW9uLiBDZW50ZXJlZFxyXG4gIFx0ICogYnkgZGVmYXVsdCBpZiBzaXplIGlzIHNwZWNpZmllZCwgYWxzbyBjYW4gYmUgc2V0IGluIENTUyB3aXRoIG5lZ2F0aXZlIG1hcmdpbnMuXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiBwb3B1cEFuY2hvcjogUG9pbnQgPSBbMCwgMF1cclxuICBcdCAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnQgZnJvbSB3aGljaCBwb3B1cHMgd2lsbCBcIm9wZW5cIiwgcmVsYXRpdmUgdG8gdGhlIGljb24gYW5jaG9yLlxyXG4gIFx0ICpcclxuICBcdCAqIEBvcHRpb24gdG9vbHRpcEFuY2hvcjogUG9pbnQgPSBbMCwgMF1cclxuICBcdCAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnQgZnJvbSB3aGljaCB0b29sdGlwcyB3aWxsIFwib3BlblwiLCByZWxhdGl2ZSB0byB0aGUgaWNvbiBhbmNob3IuXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiBzaGFkb3dVcmw6IFN0cmluZyA9IG51bGxcclxuICBcdCAqIFRoZSBVUkwgdG8gdGhlIGljb24gc2hhZG93IGltYWdlLiBJZiBub3Qgc3BlY2lmaWVkLCBubyBzaGFkb3cgaW1hZ2Ugd2lsbCBiZSBjcmVhdGVkLlxyXG4gIFx0ICpcclxuICBcdCAqIEBvcHRpb24gc2hhZG93UmV0aW5hVXJsOiBTdHJpbmcgPSBudWxsXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiBzaGFkb3dTaXplOiBQb2ludCA9IG51bGxcclxuICBcdCAqIFNpemUgb2YgdGhlIHNoYWRvdyBpbWFnZSBpbiBwaXhlbHMuXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiBzaGFkb3dBbmNob3I6IFBvaW50ID0gbnVsbFxyXG4gIFx0ICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBcInRpcFwiIG9mIHRoZSBzaGFkb3cgKHJlbGF0aXZlIHRvIGl0cyB0b3AgbGVmdCBjb3JuZXIpICh0aGUgc2FtZVxyXG4gIFx0ICogYXMgaWNvbkFuY2hvciBpZiBub3Qgc3BlY2lmaWVkKS5cclxuICBcdCAqXHJcbiAgXHQgKiBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuICBcdCAqIEEgY3VzdG9tIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIGJvdGggaWNvbiBhbmQgc2hhZG93IGltYWdlcy4gRW1wdHkgYnkgZGVmYXVsdC5cclxuICBcdCAqL1xyXG5cclxuICBcdG9wdGlvbnM6IHtcclxuICBcdFx0cG9wdXBBbmNob3I6IFswLCAwXSxcclxuICBcdFx0dG9vbHRpcEFuY2hvcjogWzAsIDBdLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBjcm9zc09yaWdpbjogQm9vbGVhbnxTdHJpbmcgPSBmYWxzZVxyXG4gIFx0XHQvLyBXaGV0aGVyIHRoZSBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgd2lsbCBiZSBhZGRlZCB0byB0aGUgdGlsZXMuXHJcbiAgXHRcdC8vIElmIGEgU3RyaW5nIGlzIHByb3ZpZGVkLCBhbGwgdGlsZXMgd2lsbCBoYXZlIHRoZWlyIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSBzZXQgdG8gdGhlIFN0cmluZyBwcm92aWRlZC4gVGhpcyBpcyBuZWVkZWQgaWYgeW91IHdhbnQgdG8gYWNjZXNzIHRpbGUgcGl4ZWwgZGF0YS5cclxuICBcdFx0Ly8gUmVmZXIgdG8gW0NPUlMgU2V0dGluZ3NdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQ09SU19zZXR0aW5nc19hdHRyaWJ1dGVzKSBmb3IgdmFsaWQgU3RyaW5nIHZhbHVlcy5cclxuICBcdFx0Y3Jvc3NPcmlnaW46IGZhbHNlXHJcbiAgXHR9LFxyXG5cclxuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgY3JlYXRlSWNvbihvbGRJY29uPzogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG4gIFx0Ly8gQ2FsbGVkIGludGVybmFsbHkgd2hlbiB0aGUgaWNvbiBoYXMgdG8gYmUgc2hvd24sIHJldHVybnMgYSBgPGltZz5gIEhUTUwgZWxlbWVudFxyXG4gIFx0Ly8gc3R5bGVkIGFjY29yZGluZyB0byB0aGUgb3B0aW9ucy5cclxuICBcdGNyZWF0ZUljb246IGZ1bmN0aW9uIChvbGRJY29uKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9jcmVhdGVJY29uKCdpY29uJywgb2xkSWNvbik7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgY3JlYXRlU2hhZG93KG9sZEljb24/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcbiAgXHQvLyBBcyBgY3JlYXRlSWNvbmAsIGJ1dCBmb3IgdGhlIHNoYWRvdyBiZW5lYXRoIGl0LlxyXG4gIFx0Y3JlYXRlU2hhZG93OiBmdW5jdGlvbiAob2xkSWNvbikge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fY3JlYXRlSWNvbignc2hhZG93Jywgb2xkSWNvbik7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9jcmVhdGVJY29uOiBmdW5jdGlvbiAobmFtZSwgb2xkSWNvbikge1xyXG4gIFx0XHR2YXIgc3JjID0gdGhpcy5fZ2V0SWNvblVybChuYW1lKTtcclxuXHJcbiAgXHRcdGlmICghc3JjKSB7XHJcbiAgXHRcdFx0aWYgKG5hbWUgPT09ICdpY29uJykge1xyXG4gIFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdpY29uVXJsIG5vdCBzZXQgaW4gSWNvbiBvcHRpb25zIChzZWUgdGhlIGRvY3MpLicpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0XHRyZXR1cm4gbnVsbDtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIGltZyA9IHRoaXMuX2NyZWF0ZUltZyhzcmMsIG9sZEljb24gJiYgb2xkSWNvbi50YWdOYW1lID09PSAnSU1HJyA/IG9sZEljb24gOiBudWxsKTtcclxuICBcdFx0dGhpcy5fc2V0SWNvblN0eWxlcyhpbWcsIG5hbWUpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiB8fCB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09ICcnKSB7XHJcbiAgXHRcdFx0aW1nLmNyb3NzT3JpZ2luID0gdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luID09PSB0cnVlID8gJycgOiB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiBpbWc7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9zZXRJY29uU3R5bGVzOiBmdW5jdGlvbiAoaW1nLCBuYW1lKSB7XHJcbiAgXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG4gIFx0XHR2YXIgc2l6ZU9wdGlvbiA9IG9wdGlvbnNbbmFtZSArICdTaXplJ107XHJcblxyXG4gIFx0XHRpZiAodHlwZW9mIHNpemVPcHRpb24gPT09ICdudW1iZXInKSB7XHJcbiAgXHRcdFx0c2l6ZU9wdGlvbiA9IFtzaXplT3B0aW9uLCBzaXplT3B0aW9uXTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIHNpemUgPSB0b1BvaW50KHNpemVPcHRpb24pLFxyXG4gIFx0XHQgICAgYW5jaG9yID0gdG9Qb2ludChuYW1lID09PSAnc2hhZG93JyAmJiBvcHRpb25zLnNoYWRvd0FuY2hvciB8fCBvcHRpb25zLmljb25BbmNob3IgfHxcclxuICBcdFx0ICAgICAgICAgICAgc2l6ZSAmJiBzaXplLmRpdmlkZUJ5KDIsIHRydWUpKTtcclxuXHJcbiAgXHRcdGltZy5jbGFzc05hbWUgPSAnbGVhZmxldC1tYXJrZXItJyArIG5hbWUgKyAnICcgKyAob3B0aW9ucy5jbGFzc05hbWUgfHwgJycpO1xyXG5cclxuICBcdFx0aWYgKGFuY2hvcikge1xyXG4gIFx0XHRcdGltZy5zdHlsZS5tYXJnaW5MZWZ0ID0gKC1hbmNob3IueCkgKyAncHgnO1xyXG4gIFx0XHRcdGltZy5zdHlsZS5tYXJnaW5Ub3AgID0gKC1hbmNob3IueSkgKyAncHgnO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAoc2l6ZSkge1xyXG4gIFx0XHRcdGltZy5zdHlsZS53aWR0aCAgPSBzaXplLnggKyAncHgnO1xyXG4gIFx0XHRcdGltZy5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF9jcmVhdGVJbWc6IGZ1bmN0aW9uIChzcmMsIGVsKSB7XHJcbiAgXHRcdGVsID0gZWwgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XHJcbiAgXHRcdGVsLnNyYyA9IHNyYztcclxuICBcdFx0cmV0dXJuIGVsO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfZ2V0SWNvblVybDogZnVuY3Rpb24gKG5hbWUpIHtcclxuICBcdFx0cmV0dXJuIEJyb3dzZXIucmV0aW5hICYmIHRoaXMub3B0aW9uc1tuYW1lICsgJ1JldGluYVVybCddIHx8IHRoaXMub3B0aW9uc1tuYW1lICsgJ1VybCddO1xyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuXHJcbiAgLy8gQGZhY3RvcnkgTC5pY29uKG9wdGlvbnM6IEljb24gb3B0aW9ucylcclxuICAvLyBDcmVhdGVzIGFuIGljb24gaW5zdGFuY2Ugd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cclxuICBmdW5jdGlvbiBpY29uKG9wdGlvbnMpIHtcclxuICBcdHJldHVybiBuZXcgSWNvbihvcHRpb25zKTtcclxuICB9XG5cbiAgLypcbiAgICogQG1pbmljbGFzcyBJY29uLkRlZmF1bHQgKEljb24pXG4gICAqIEBha2EgTC5JY29uLkRlZmF1bHRcbiAgICogQHNlY3Rpb25cbiAgICpcbiAgICogQSB0cml2aWFsIHN1YmNsYXNzIG9mIGBJY29uYCwgcmVwcmVzZW50cyB0aGUgaWNvbiB0byB1c2UgaW4gYE1hcmtlcmBzIHdoZW5cbiAgICogbm8gaWNvbiBpcyBzcGVjaWZpZWQuIFBvaW50cyB0byB0aGUgYmx1ZSBtYXJrZXIgaW1hZ2UgZGlzdHJpYnV0ZWQgd2l0aCBMZWFmbGV0XG4gICAqIHJlbGVhc2VzLlxuICAgKlxuICAgKiBJbiBvcmRlciB0byBjdXN0b21pemUgdGhlIGRlZmF1bHQgaWNvbiwganVzdCBjaGFuZ2UgdGhlIHByb3BlcnRpZXMgb2YgYEwuSWNvbi5EZWZhdWx0LnByb3RvdHlwZS5vcHRpb25zYFxuICAgKiAod2hpY2ggaXMgYSBzZXQgb2YgYEljb24gb3B0aW9uc2ApLlxuICAgKlxuICAgKiBJZiB5b3Ugd2FudCB0byBfY29tcGxldGVseV8gcmVwbGFjZSB0aGUgZGVmYXVsdCBpY29uLCBvdmVycmlkZSB0aGVcbiAgICogYEwuTWFya2VyLnByb3RvdHlwZS5vcHRpb25zLmljb25gIHdpdGggeW91ciBvd24gaWNvbiBpbnN0ZWFkLlxuICAgKi9cblxuICB2YXIgSWNvbkRlZmF1bHQgPSBJY29uLmV4dGVuZCh7XG5cbiAgXHRvcHRpb25zOiB7XG4gIFx0XHRpY29uVXJsOiAgICAgICAnbWFya2VyLWljb24ucG5nJyxcbiAgXHRcdGljb25SZXRpbmFVcmw6ICdtYXJrZXItaWNvbi0yeC5wbmcnLFxuICBcdFx0c2hhZG93VXJsOiAgICAgJ21hcmtlci1zaGFkb3cucG5nJyxcbiAgXHRcdGljb25TaXplOiAgICBbMjUsIDQxXSxcbiAgXHRcdGljb25BbmNob3I6ICBbMTIsIDQxXSxcbiAgXHRcdHBvcHVwQW5jaG9yOiBbMSwgLTM0XSxcbiAgXHRcdHRvb2x0aXBBbmNob3I6IFsxNiwgLTI4XSxcbiAgXHRcdHNoYWRvd1NpemU6ICBbNDEsIDQxXVxuICBcdH0sXG5cbiAgXHRfZ2V0SWNvblVybDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgXHRcdGlmICh0eXBlb2YgSWNvbkRlZmF1bHQuaW1hZ2VQYXRoICE9PSAnc3RyaW5nJykge1x0Ly8gRGVwcmVjYXRlZCwgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgb25seVxuICBcdFx0XHRJY29uRGVmYXVsdC5pbWFnZVBhdGggPSB0aGlzLl9kZXRlY3RJY29uUGF0aCgpO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBAb3B0aW9uIGltYWdlUGF0aDogU3RyaW5nXG4gIFx0XHQvLyBgSWNvbi5EZWZhdWx0YCB3aWxsIHRyeSB0byBhdXRvLWRldGVjdCB0aGUgbG9jYXRpb24gb2YgdGhlXG4gIFx0XHQvLyBibHVlIGljb24gaW1hZ2VzLiBJZiB5b3UgYXJlIHBsYWNpbmcgdGhlc2UgaW1hZ2VzIGluIGEgbm9uLXN0YW5kYXJkXG4gIFx0XHQvLyB3YXksIHNldCB0aGlzIG9wdGlvbiB0byBwb2ludCB0byB0aGUgcmlnaHQgcGF0aC5cbiAgXHRcdHJldHVybiAodGhpcy5vcHRpb25zLmltYWdlUGF0aCB8fCBJY29uRGVmYXVsdC5pbWFnZVBhdGgpICsgSWNvbi5wcm90b3R5cGUuX2dldEljb25VcmwuY2FsbCh0aGlzLCBuYW1lKTtcbiAgXHR9LFxuXG4gIFx0X3N0cmlwVXJsOiBmdW5jdGlvbiAocGF0aCkge1x0Ly8gc2VwYXJhdGUgZnVuY3Rpb24gdG8gdXNlIGluIHRlc3RzXG4gIFx0XHR2YXIgc3RyaXAgPSBmdW5jdGlvbiAoc3RyLCByZSwgaWR4KSB7XG4gIFx0XHRcdHZhciBtYXRjaCA9IHJlLmV4ZWMoc3RyKTtcbiAgXHRcdFx0cmV0dXJuIG1hdGNoICYmIG1hdGNoW2lkeF07XG4gIFx0XHR9O1xuICBcdFx0cGF0aCA9IHN0cmlwKHBhdGgsIC9edXJsXFwoKFsnXCJdKT8oLispXFwxXFwpJC8sIDIpO1xuICBcdFx0cmV0dXJuIHBhdGggJiYgc3RyaXAocGF0aCwgL14oLiopbWFya2VyLWljb25cXC5wbmckLywgMSk7XG4gIFx0fSxcblxuICBcdF9kZXRlY3RJY29uUGF0aDogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGVsID0gY3JlYXRlJDEoJ2RpdicsICAnbGVhZmxldC1kZWZhdWx0LWljb24tcGF0aCcsIGRvY3VtZW50LmJvZHkpO1xuICBcdFx0dmFyIHBhdGggPSBnZXRTdHlsZShlbCwgJ2JhY2tncm91bmQtaW1hZ2UnKSB8fFxuICBcdFx0ICAgICAgICAgICBnZXRTdHlsZShlbCwgJ2JhY2tncm91bmRJbWFnZScpO1x0Ly8gSUU4XG5cbiAgXHRcdGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZWwpO1xuICBcdFx0cGF0aCA9IHRoaXMuX3N0cmlwVXJsKHBhdGgpO1xuICBcdFx0aWYgKHBhdGgpIHsgcmV0dXJuIHBhdGg7IH1cbiAgXHRcdHZhciBsaW5rID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbGlua1tocmVmJD1cImxlYWZsZXQuY3NzXCJdJyk7XG4gIFx0XHRpZiAoIWxpbmspIHsgcmV0dXJuICcnOyB9XG4gIFx0XHRyZXR1cm4gbGluay5ocmVmLnN1YnN0cmluZygwLCBsaW5rLmhyZWYubGVuZ3RoIC0gJ2xlYWZsZXQuY3NzJy5sZW5ndGggLSAxKTtcbiAgXHR9XG4gIH0pO1xuXG4gIC8qXG4gICAqIEwuSGFuZGxlci5NYXJrZXJEcmFnIGlzIHVzZWQgaW50ZXJuYWxseSBieSBMLk1hcmtlciB0byBtYWtlIHRoZSBtYXJrZXJzIGRyYWdnYWJsZS5cbiAgICovXG5cblxuICAvKiBAbmFtZXNwYWNlIE1hcmtlclxuICAgKiBAc2VjdGlvbiBJbnRlcmFjdGlvbiBoYW5kbGVyc1xuICAgKlxuICAgKiBJbnRlcmFjdGlvbiBoYW5kbGVycyBhcmUgcHJvcGVydGllcyBvZiBhIG1hcmtlciBpbnN0YW5jZSB0aGF0IGFsbG93IHlvdSB0byBjb250cm9sIGludGVyYWN0aW9uIGJlaGF2aW9yIGluIHJ1bnRpbWUsIGVuYWJsaW5nIG9yIGRpc2FibGluZyBjZXJ0YWluIGZlYXR1cmVzIHN1Y2ggYXMgZHJhZ2dpbmcgKHNlZSBgSGFuZGxlcmAgbWV0aG9kcykuIEV4YW1wbGU6XG4gICAqXG4gICAqIGBgYGpzXG4gICAqIG1hcmtlci5kcmFnZ2luZy5kaXNhYmxlKCk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcHJvcGVydHkgZHJhZ2dpbmc6IEhhbmRsZXJcbiAgICogTWFya2VyIGRyYWdnaW5nIGhhbmRsZXIgKGJ5IGJvdGggbW91c2UgYW5kIHRvdWNoKS4gT25seSB2YWxpZCB3aGVuIHRoZSBtYXJrZXIgaXMgb24gdGhlIG1hcCAoT3RoZXJ3aXNlIHNldCBbYG1hcmtlci5vcHRpb25zLmRyYWdnYWJsZWBdKCNtYXJrZXItZHJhZ2dhYmxlKSkuXG4gICAqL1xuXG4gIHZhciBNYXJrZXJEcmFnID0gSGFuZGxlci5leHRlbmQoe1xuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXJrZXIpIHtcbiAgXHRcdHRoaXMuX21hcmtlciA9IG1hcmtlcjtcbiAgXHR9LFxuXG4gIFx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBpY29uID0gdGhpcy5fbWFya2VyLl9pY29uO1xuXG4gIFx0XHRpZiAoIXRoaXMuX2RyYWdnYWJsZSkge1xuICBcdFx0XHR0aGlzLl9kcmFnZ2FibGUgPSBuZXcgRHJhZ2dhYmxlKGljb24sIGljb24sIHRydWUpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl9kcmFnZ2FibGUub24oe1xuICBcdFx0XHRkcmFnc3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuICBcdFx0XHRwcmVkcmFnOiB0aGlzLl9vblByZURyYWcsXG4gIFx0XHRcdGRyYWc6IHRoaXMuX29uRHJhZyxcbiAgXHRcdFx0ZHJhZ2VuZDogdGhpcy5fb25EcmFnRW5kXG4gIFx0XHR9LCB0aGlzKS5lbmFibGUoKTtcblxuICBcdFx0YWRkQ2xhc3MoaWNvbiwgJ2xlYWZsZXQtbWFya2VyLWRyYWdnYWJsZScpO1xuICBcdH0sXG5cbiAgXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5fZHJhZ2dhYmxlLm9mZih7XG4gIFx0XHRcdGRyYWdzdGFydDogdGhpcy5fb25EcmFnU3RhcnQsXG4gIFx0XHRcdHByZWRyYWc6IHRoaXMuX29uUHJlRHJhZyxcbiAgXHRcdFx0ZHJhZzogdGhpcy5fb25EcmFnLFxuICBcdFx0XHRkcmFnZW5kOiB0aGlzLl9vbkRyYWdFbmRcbiAgXHRcdH0sIHRoaXMpLmRpc2FibGUoKTtcblxuICBcdFx0aWYgKHRoaXMuX21hcmtlci5faWNvbikge1xuICBcdFx0XHRyZW1vdmVDbGFzcyh0aGlzLl9tYXJrZXIuX2ljb24sICdsZWFmbGV0LW1hcmtlci1kcmFnZ2FibGUnKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0bW92ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLl9kcmFnZ2FibGUgJiYgdGhpcy5fZHJhZ2dhYmxlLl9tb3ZlZDtcbiAgXHR9LFxuXG4gIFx0X2FkanVzdFBhbjogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdHZhciBtYXJrZXIgPSB0aGlzLl9tYXJrZXIsXG4gIFx0XHQgICAgbWFwID0gbWFya2VyLl9tYXAsXG4gIFx0XHQgICAgc3BlZWQgPSB0aGlzLl9tYXJrZXIub3B0aW9ucy5hdXRvUGFuU3BlZWQsXG4gIFx0XHQgICAgcGFkZGluZyA9IHRoaXMuX21hcmtlci5vcHRpb25zLmF1dG9QYW5QYWRkaW5nLFxuICBcdFx0ICAgIGljb25Qb3MgPSBnZXRQb3NpdGlvbihtYXJrZXIuX2ljb24pLFxuICBcdFx0ICAgIGJvdW5kcyA9IG1hcC5nZXRQaXhlbEJvdW5kcygpLFxuICBcdFx0ICAgIG9yaWdpbiA9IG1hcC5nZXRQaXhlbE9yaWdpbigpO1xuXG4gIFx0XHR2YXIgcGFuQm91bmRzID0gdG9Cb3VuZHMoXG4gIFx0XHRcdGJvdW5kcy5taW4uX3N1YnRyYWN0KG9yaWdpbikuYWRkKHBhZGRpbmcpLFxuICBcdFx0XHRib3VuZHMubWF4Ll9zdWJ0cmFjdChvcmlnaW4pLnN1YnRyYWN0KHBhZGRpbmcpXG4gIFx0XHQpO1xuXG4gIFx0XHRpZiAoIXBhbkJvdW5kcy5jb250YWlucyhpY29uUG9zKSkge1xuICBcdFx0XHQvLyBDb21wdXRlIGluY3JlbWVudGFsIG1vdmVtZW50XG4gIFx0XHRcdHZhciBtb3ZlbWVudCA9IHRvUG9pbnQoXG4gIFx0XHRcdFx0KE1hdGgubWF4KHBhbkJvdW5kcy5tYXgueCwgaWNvblBvcy54KSAtIHBhbkJvdW5kcy5tYXgueCkgLyAoYm91bmRzLm1heC54IC0gcGFuQm91bmRzLm1heC54KSAtXG4gIFx0XHRcdFx0KE1hdGgubWluKHBhbkJvdW5kcy5taW4ueCwgaWNvblBvcy54KSAtIHBhbkJvdW5kcy5taW4ueCkgLyAoYm91bmRzLm1pbi54IC0gcGFuQm91bmRzLm1pbi54KSxcblxuICBcdFx0XHRcdChNYXRoLm1heChwYW5Cb3VuZHMubWF4LnksIGljb25Qb3MueSkgLSBwYW5Cb3VuZHMubWF4LnkpIC8gKGJvdW5kcy5tYXgueSAtIHBhbkJvdW5kcy5tYXgueSkgLVxuICBcdFx0XHRcdChNYXRoLm1pbihwYW5Cb3VuZHMubWluLnksIGljb25Qb3MueSkgLSBwYW5Cb3VuZHMubWluLnkpIC8gKGJvdW5kcy5taW4ueSAtIHBhbkJvdW5kcy5taW4ueSlcbiAgXHRcdFx0KS5tdWx0aXBseUJ5KHNwZWVkKTtcblxuICBcdFx0XHRtYXAucGFuQnkobW92ZW1lbnQsIHthbmltYXRlOiBmYWxzZX0pO1xuXG4gIFx0XHRcdHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLl9hZGQobW92ZW1lbnQpO1xuICBcdFx0XHR0aGlzLl9kcmFnZ2FibGUuX3N0YXJ0UG9zLl9hZGQobW92ZW1lbnQpO1xuXG4gIFx0XHRcdHNldFBvc2l0aW9uKG1hcmtlci5faWNvbiwgdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MpO1xuICBcdFx0XHR0aGlzLl9vbkRyYWcoZSk7XG5cbiAgXHRcdFx0dGhpcy5fcGFuUmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUodGhpcy5fYWRqdXN0UGFuLmJpbmQodGhpcywgZSkpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfb25EcmFnU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdC8vIEBzZWN0aW9uIERyYWdnaW5nIGV2ZW50c1xuICBcdFx0Ly8gQGV2ZW50IGRyYWdzdGFydDogRXZlbnRcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGRyYWdnaW5nIHRoZSBtYXJrZXIuXG5cbiAgXHRcdC8vIEBldmVudCBtb3Zlc3RhcnQ6IEV2ZW50XG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgc3RhcnRzIG1vdmluZyAoYmVjYXVzZSBvZiBkcmFnZ2luZykuXG5cbiAgXHRcdHRoaXMuX29sZExhdExuZyA9IHRoaXMuX21hcmtlci5nZXRMYXRMbmcoKTtcblxuICBcdFx0Ly8gV2hlbiB1c2luZyBFUzYgaW1wb3J0cyBpdCBjb3VsZCBub3QgYmUgc2V0IHdoZW4gYFBvcHVwYCB3YXMgbm90IGltcG9ydGVkIGFzIHdlbGxcbiAgXHRcdHRoaXMuX21hcmtlci5jbG9zZVBvcHVwICYmIHRoaXMuX21hcmtlci5jbG9zZVBvcHVwKCk7XG5cbiAgXHRcdHRoaXMuX21hcmtlclxuICBcdFx0XHQuZmlyZSgnbW92ZXN0YXJ0JylcbiAgXHRcdFx0LmZpcmUoJ2RyYWdzdGFydCcpO1xuICBcdH0sXG5cbiAgXHRfb25QcmVEcmFnOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0aWYgKHRoaXMuX21hcmtlci5vcHRpb25zLmF1dG9QYW4pIHtcbiAgXHRcdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX3BhblJlcXVlc3QpO1xuICBcdFx0XHR0aGlzLl9wYW5SZXF1ZXN0ID0gcmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9hZGp1c3RQYW4uYmluZCh0aGlzLCBlKSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9vbkRyYWc6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHR2YXIgbWFya2VyID0gdGhpcy5fbWFya2VyLFxuICBcdFx0ICAgIHNoYWRvdyA9IG1hcmtlci5fc2hhZG93LFxuICBcdFx0ICAgIGljb25Qb3MgPSBnZXRQb3NpdGlvbihtYXJrZXIuX2ljb24pLFxuICBcdFx0ICAgIGxhdGxuZyA9IG1hcmtlci5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhpY29uUG9zKTtcblxuICBcdFx0Ly8gdXBkYXRlIHNoYWRvdyBwb3NpdGlvblxuICBcdFx0aWYgKHNoYWRvdykge1xuICBcdFx0XHRzZXRQb3NpdGlvbihzaGFkb3csIGljb25Qb3MpO1xuICBcdFx0fVxuXG4gIFx0XHRtYXJrZXIuX2xhdGxuZyA9IGxhdGxuZztcbiAgXHRcdGUubGF0bG5nID0gbGF0bG5nO1xuICBcdFx0ZS5vbGRMYXRMbmcgPSB0aGlzLl9vbGRMYXRMbmc7XG5cbiAgXHRcdC8vIEBldmVudCBkcmFnOiBFdmVudFxuICBcdFx0Ly8gRmlyZWQgcmVwZWF0ZWRseSB3aGlsZSB0aGUgdXNlciBkcmFncyB0aGUgbWFya2VyLlxuICBcdFx0bWFya2VyXG4gIFx0XHQgICAgLmZpcmUoJ21vdmUnLCBlKVxuICBcdFx0ICAgIC5maXJlKCdkcmFnJywgZSk7XG4gIFx0fSxcblxuICBcdF9vbkRyYWdFbmQ6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHQvLyBAZXZlbnQgZHJhZ2VuZDogRHJhZ0VuZEV2ZW50XG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHN0b3BzIGRyYWdnaW5nIHRoZSBtYXJrZXIuXG5cbiAgXHRcdCBjYW5jZWxBbmltRnJhbWUodGhpcy5fcGFuUmVxdWVzdCk7XG5cbiAgXHRcdC8vIEBldmVudCBtb3ZlZW5kOiBFdmVudFxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFya2VyIHN0b3BzIG1vdmluZyAoYmVjYXVzZSBvZiBkcmFnZ2luZykuXG4gIFx0XHRkZWxldGUgdGhpcy5fb2xkTGF0TG5nO1xuICBcdFx0dGhpcy5fbWFya2VyXG4gIFx0XHQgICAgLmZpcmUoJ21vdmVlbmQnKVxuICBcdFx0ICAgIC5maXJlKCdkcmFnZW5kJywgZSk7XG4gIFx0fVxuICB9KTtcblxuICAvKlxyXG4gICAqIEBjbGFzcyBNYXJrZXJcclxuICAgKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcclxuICAgKiBAYWthIEwuTWFya2VyXHJcbiAgICogTC5NYXJrZXIgaXMgdXNlZCB0byBkaXNwbGF5IGNsaWNrYWJsZS9kcmFnZ2FibGUgaWNvbnMgb24gdGhlIG1hcC4gRXh0ZW5kcyBgTGF5ZXJgLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogTC5tYXJrZXIoWzUwLjUsIDMwLjVdKS5hZGRUbyhtYXApO1xyXG4gICAqIGBgYFxyXG4gICAqL1xyXG5cclxuICB2YXIgTWFya2VyID0gTGF5ZXIuZXh0ZW5kKHtcclxuXHJcbiAgXHQvLyBAc2VjdGlvblxyXG4gIFx0Ly8gQGFrYSBNYXJrZXIgb3B0aW9uc1xyXG4gIFx0b3B0aW9uczoge1xyXG4gIFx0XHQvLyBAb3B0aW9uIGljb246IEljb24gPSAqXHJcbiAgXHRcdC8vIEljb24gaW5zdGFuY2UgdG8gdXNlIGZvciByZW5kZXJpbmcgdGhlIG1hcmtlci5cclxuICBcdFx0Ly8gU2VlIFtJY29uIGRvY3VtZW50YXRpb25dKCNMLkljb24pIGZvciBkZXRhaWxzIG9uIGhvdyB0byBjdXN0b21pemUgdGhlIG1hcmtlciBpY29uLlxyXG4gIFx0XHQvLyBJZiBub3Qgc3BlY2lmaWVkLCBhIGNvbW1vbiBpbnN0YW5jZSBvZiBgTC5JY29uLkRlZmF1bHRgIGlzIHVzZWQuXHJcbiAgXHRcdGljb246IG5ldyBJY29uRGVmYXVsdCgpLFxyXG5cclxuICBcdFx0Ly8gT3B0aW9uIGluaGVyaXRlZCBmcm9tIFwiSW50ZXJhY3RpdmUgbGF5ZXJcIiBhYnN0cmFjdCBjbGFzc1xyXG4gIFx0XHRpbnRlcmFjdGl2ZTogdHJ1ZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24ga2V5Ym9hcmQ6IEJvb2xlYW4gPSB0cnVlXHJcbiAgXHRcdC8vIFdoZXRoZXIgdGhlIG1hcmtlciBjYW4gYmUgdGFiYmVkIHRvIHdpdGggYSBrZXlib2FyZCBhbmQgY2xpY2tlZCBieSBwcmVzc2luZyBlbnRlci5cclxuICBcdFx0a2V5Ym9hcmQ6IHRydWUsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHRpdGxlOiBTdHJpbmcgPSAnJ1xyXG4gIFx0XHQvLyBUZXh0IGZvciB0aGUgYnJvd3NlciB0b29sdGlwIHRoYXQgYXBwZWFyIG9uIG1hcmtlciBob3ZlciAobm8gdG9vbHRpcCBieSBkZWZhdWx0KS5cclxuICBcdFx0Ly8gW1VzZWZ1bCBmb3IgYWNjZXNzaWJpbGl0eV0oaHR0cHM6Ly9sZWFmbGV0anMuY29tL2V4YW1wbGVzL2FjY2Vzc2liaWxpdHkvI21hcmtlcnMtbXVzdC1iZS1sYWJlbGxlZCkuXHJcbiAgXHRcdHRpdGxlOiAnJyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gYWx0OiBTdHJpbmcgPSAnTWFya2VyJ1xyXG4gIFx0XHQvLyBUZXh0IGZvciB0aGUgYGFsdGAgYXR0cmlidXRlIG9mIHRoZSBpY29uIGltYWdlLlxyXG4gIFx0XHQvLyBbVXNlZnVsIGZvciBhY2Nlc3NpYmlsaXR5XShodHRwczovL2xlYWZsZXRqcy5jb20vZXhhbXBsZXMvYWNjZXNzaWJpbGl0eS8jbWFya2Vycy1tdXN0LWJlLWxhYmVsbGVkKS5cclxuICBcdFx0YWx0OiAnTWFya2VyJyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gekluZGV4T2Zmc2V0OiBOdW1iZXIgPSAwXHJcbiAgXHRcdC8vIEJ5IGRlZmF1bHQsIG1hcmtlciBpbWFnZXMgekluZGV4IGlzIHNldCBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIGl0cyBsYXRpdHVkZS4gVXNlIHRoaXMgb3B0aW9uIGlmIHlvdSB3YW50IHRvIHB1dCB0aGUgbWFya2VyIG9uIHRvcCBvZiBhbGwgb3RoZXJzIChvciBiZWxvdyksIHNwZWNpZnlpbmcgYSBoaWdoIHZhbHVlIGxpa2UgYDEwMDBgIChvciBoaWdoIG5lZ2F0aXZlIHZhbHVlLCByZXNwZWN0aXZlbHkpLlxyXG4gIFx0XHR6SW5kZXhPZmZzZXQ6IDAsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxyXG4gIFx0XHQvLyBUaGUgb3BhY2l0eSBvZiB0aGUgbWFya2VyLlxyXG4gIFx0XHRvcGFjaXR5OiAxLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiByaXNlT25Ib3ZlcjogQm9vbGVhbiA9IGZhbHNlXHJcbiAgXHRcdC8vIElmIGB0cnVlYCwgdGhlIG1hcmtlciB3aWxsIGdldCBvbiB0b3Agb2Ygb3RoZXJzIHdoZW4geW91IGhvdmVyIHRoZSBtb3VzZSBvdmVyIGl0LlxyXG4gIFx0XHRyaXNlT25Ib3ZlcjogZmFsc2UsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHJpc2VPZmZzZXQ6IE51bWJlciA9IDI1MFxyXG4gIFx0XHQvLyBUaGUgei1pbmRleCBvZmZzZXQgdXNlZCBmb3IgdGhlIGByaXNlT25Ib3ZlcmAgZmVhdHVyZS5cclxuICBcdFx0cmlzZU9mZnNldDogMjUwLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAnbWFya2VyUGFuZSdcclxuICBcdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgbWFya2VycyBpY29uIHdpbGwgYmUgYWRkZWQuXHJcbiAgXHRcdHBhbmU6ICdtYXJrZXJQYW5lJyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gc2hhZG93UGFuZTogU3RyaW5nID0gJ3NoYWRvd1BhbmUnXHJcbiAgXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIG1hcmtlcnMgc2hhZG93IHdpbGwgYmUgYWRkZWQuXHJcbiAgXHRcdHNoYWRvd1BhbmU6ICdzaGFkb3dQYW5lJyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gYnViYmxpbmdNb3VzZUV2ZW50czogQm9vbGVhbiA9IGZhbHNlXHJcbiAgXHRcdC8vIFdoZW4gYHRydWVgLCBhIG1vdXNlIGV2ZW50IG9uIHRoaXMgbWFya2VyIHdpbGwgdHJpZ2dlciB0aGUgc2FtZSBldmVudCBvbiB0aGUgbWFwXHJcbiAgXHRcdC8vICh1bmxlc3MgW2BMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbmBdKCNkb21ldmVudC1zdG9wcHJvcGFnYXRpb24pIGlzIHVzZWQpLlxyXG4gIFx0XHRidWJibGluZ01vdXNlRXZlbnRzOiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gYXV0b1Bhbk9uRm9jdXM6IEJvb2xlYW4gPSB0cnVlXHJcbiAgXHRcdC8vIFdoZW4gYHRydWVgLCB0aGUgbWFwIHdpbGwgcGFuIHdoZW5ldmVyIHRoZSBtYXJrZXIgaXMgZm9jdXNlZCAodmlhXHJcbiAgXHRcdC8vIGUuZy4gcHJlc3NpbmcgYHRhYmAgb24gdGhlIGtleWJvYXJkKSB0byBlbnN1cmUgdGhlIG1hcmtlciBpc1xyXG4gIFx0XHQvLyB2aXNpYmxlIHdpdGhpbiB0aGUgbWFwJ3MgYm91bmRzXHJcbiAgXHRcdGF1dG9QYW5PbkZvY3VzOiB0cnVlLFxyXG5cclxuICBcdFx0Ly8gQHNlY3Rpb24gRHJhZ2dhYmxlIG1hcmtlciBvcHRpb25zXHJcbiAgXHRcdC8vIEBvcHRpb24gZHJhZ2dhYmxlOiBCb29sZWFuID0gZmFsc2VcclxuICBcdFx0Ly8gV2hldGhlciB0aGUgbWFya2VyIGlzIGRyYWdnYWJsZSB3aXRoIG1vdXNlL3RvdWNoIG9yIG5vdC5cclxuICBcdFx0ZHJhZ2dhYmxlOiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gYXV0b1BhbjogQm9vbGVhbiA9IGZhbHNlXHJcbiAgXHRcdC8vIFdoZXRoZXIgdG8gcGFuIHRoZSBtYXAgd2hlbiBkcmFnZ2luZyB0aGlzIG1hcmtlciBuZWFyIGl0cyBlZGdlIG9yIG5vdC5cclxuICBcdFx0YXV0b1BhbjogZmFsc2UsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGF1dG9QYW5QYWRkaW5nOiBQb2ludCA9IFBvaW50KDUwLCA1MClcclxuICBcdFx0Ly8gRGlzdGFuY2UgKGluIHBpeGVscyB0byB0aGUgbGVmdC9yaWdodCBhbmQgdG8gdGhlIHRvcC9ib3R0b20pIG9mIHRoZVxyXG4gIFx0XHQvLyBtYXAgZWRnZSB0byBzdGFydCBwYW5uaW5nIHRoZSBtYXAuXHJcbiAgXHRcdGF1dG9QYW5QYWRkaW5nOiBbNTAsIDUwXSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gYXV0b1BhblNwZWVkOiBOdW1iZXIgPSAxMFxyXG4gIFx0XHQvLyBOdW1iZXIgb2YgcGl4ZWxzIHRoZSBtYXAgc2hvdWxkIHBhbiBieS5cclxuICBcdFx0YXV0b1BhblNwZWVkOiAxMFxyXG4gIFx0fSxcclxuXHJcbiAgXHQvKiBAc2VjdGlvblxyXG4gIFx0ICpcclxuICBcdCAqIEluIGFkZGl0aW9uIHRvIFtzaGFyZWQgbGF5ZXIgbWV0aG9kc10oI0xheWVyKSBsaWtlIGBhZGRUbygpYCBhbmQgYHJlbW92ZSgpYCBhbmQgW3BvcHVwIG1ldGhvZHNdKCNQb3B1cCkgbGlrZSBiaW5kUG9wdXAoKSB5b3UgY2FuIGFsc28gdXNlIHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcclxuICBcdCAqL1xyXG5cclxuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcclxuICBcdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuICBcdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcclxuICBcdH0sXHJcblxyXG4gIFx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0dGhpcy5fem9vbUFuaW1hdGVkID0gdGhpcy5fem9vbUFuaW1hdGVkICYmIG1hcC5vcHRpb25zLm1hcmtlclpvb21BbmltYXRpb247XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcbiAgXHRcdFx0bWFwLm9uKCd6b29tYW5pbScsIHRoaXMuX2FuaW1hdGVab29tLCB0aGlzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5faW5pdEljb24oKTtcclxuICBcdFx0dGhpcy51cGRhdGUoKTtcclxuICBcdH0sXHJcblxyXG4gIFx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0aWYgKHRoaXMuZHJhZ2dpbmcgJiYgdGhpcy5kcmFnZ2luZy5lbmFibGVkKCkpIHtcclxuICBcdFx0XHR0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlID0gdHJ1ZTtcclxuICBcdFx0XHR0aGlzLmRyYWdnaW5nLnJlbW92ZUhvb2tzKCk7XHJcbiAgXHRcdH1cclxuICBcdFx0ZGVsZXRlIHRoaXMuZHJhZ2dpbmc7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcbiAgXHRcdFx0bWFwLm9mZignem9vbWFuaW0nLCB0aGlzLl9hbmltYXRlWm9vbSwgdGhpcyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX3JlbW92ZUljb24oKTtcclxuICBcdFx0dGhpcy5fcmVtb3ZlU2hhZG93KCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4ge1xyXG4gIFx0XHRcdHpvb206IHRoaXMudXBkYXRlLFxyXG4gIFx0XHRcdHZpZXdyZXNldDogdGhpcy51cGRhdGVcclxuICBcdFx0fTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRMYXRMbmc6IExhdExuZ1xyXG4gIFx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCBnZW9ncmFwaGljYWwgcG9zaXRpb24gb2YgdGhlIG1hcmtlci5cclxuICBcdGdldExhdExuZzogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fbGF0bG5nO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldExhdExuZyhsYXRsbmc6IExhdExuZyk6IHRoaXNcclxuICBcdC8vIENoYW5nZXMgdGhlIG1hcmtlciBwb3NpdGlvbiB0byB0aGUgZ2l2ZW4gcG9pbnQuXHJcbiAgXHRzZXRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuICBcdFx0dmFyIG9sZExhdExuZyA9IHRoaXMuX2xhdGxuZztcclxuICBcdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcclxuICBcdFx0dGhpcy51cGRhdGUoKTtcclxuXHJcbiAgXHRcdC8vIEBldmVudCBtb3ZlOiBFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgaXMgbW92ZWQgdmlhIFtgc2V0TGF0TG5nYF0oI21hcmtlci1zZXRsYXRsbmcpIG9yIGJ5IFtkcmFnZ2luZ10oI21hcmtlci1kcmFnZ2luZykuIE9sZCBhbmQgbmV3IGNvb3JkaW5hdGVzIGFyZSBpbmNsdWRlZCBpbiBldmVudCBhcmd1bWVudHMgYXMgYG9sZExhdExuZ2AsIGBsYXRsbmdgLlxyXG4gIFx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlJywge29sZExhdExuZzogb2xkTGF0TG5nLCBsYXRsbmc6IHRoaXMuX2xhdGxuZ30pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldFpJbmRleE9mZnNldChvZmZzZXQ6IE51bWJlcik6IHRoaXNcclxuICBcdC8vIENoYW5nZXMgdGhlIFt6SW5kZXggb2Zmc2V0XSgjbWFya2VyLXppbmRleG9mZnNldCkgb2YgdGhlIG1hcmtlci5cclxuICBcdHNldFpJbmRleE9mZnNldDogZnVuY3Rpb24gKG9mZnNldCkge1xyXG4gIFx0XHR0aGlzLm9wdGlvbnMuekluZGV4T2Zmc2V0ID0gb2Zmc2V0O1xyXG4gIFx0XHRyZXR1cm4gdGhpcy51cGRhdGUoKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRJY29uOiBJY29uXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IGljb24gdXNlZCBieSB0aGUgbWFya2VyXHJcbiAgXHRnZXRJY29uOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuaWNvbjtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRJY29uKGljb246IEljb24pOiB0aGlzXHJcbiAgXHQvLyBDaGFuZ2VzIHRoZSBtYXJrZXIgaWNvbi5cclxuICBcdHNldEljb246IGZ1bmN0aW9uIChpY29uKSB7XHJcblxyXG4gIFx0XHR0aGlzLm9wdGlvbnMuaWNvbiA9IGljb247XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XHJcbiAgXHRcdFx0dGhpcy5faW5pdEljb24oKTtcclxuICBcdFx0XHR0aGlzLnVwZGF0ZSgpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuICBcdFx0XHR0aGlzLmJpbmRQb3B1cCh0aGlzLl9wb3B1cCwgdGhpcy5fcG9wdXAub3B0aW9ucyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRnZXRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9pY29uO1xyXG4gIFx0fSxcclxuXHJcbiAgXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9pY29uICYmIHRoaXMuX21hcCkge1xyXG4gIFx0XHRcdHZhciBwb3MgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZykucm91bmQoKTtcclxuICBcdFx0XHR0aGlzLl9zZXRQb3MocG9zKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9pbml0SWNvbjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcclxuICBcdFx0ICAgIGNsYXNzVG9BZGQgPSAnbGVhZmxldC16b29tLScgKyAodGhpcy5fem9vbUFuaW1hdGVkID8gJ2FuaW1hdGVkJyA6ICdoaWRlJyk7XHJcblxyXG4gIFx0XHR2YXIgaWNvbiA9IG9wdGlvbnMuaWNvbi5jcmVhdGVJY29uKHRoaXMuX2ljb24pLFxyXG4gIFx0XHQgICAgYWRkSWNvbiA9IGZhbHNlO1xyXG5cclxuICBcdFx0Ly8gaWYgd2UncmUgbm90IHJldXNpbmcgdGhlIGljb24sIHJlbW92ZSB0aGUgb2xkIG9uZSBhbmQgaW5pdCBuZXcgb25lXHJcbiAgXHRcdGlmIChpY29uICE9PSB0aGlzLl9pY29uKSB7XHJcbiAgXHRcdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuICBcdFx0XHRcdHRoaXMuX3JlbW92ZUljb24oKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0YWRkSWNvbiA9IHRydWU7XHJcblxyXG4gIFx0XHRcdGlmIChvcHRpb25zLnRpdGxlKSB7XHJcbiAgXHRcdFx0XHRpY29uLnRpdGxlID0gb3B0aW9ucy50aXRsZTtcclxuICBcdFx0XHR9XHJcblxyXG4gIFx0XHRcdGlmIChpY29uLnRhZ05hbWUgPT09ICdJTUcnKSB7XHJcbiAgXHRcdFx0XHRpY29uLmFsdCA9IG9wdGlvbnMuYWx0IHx8ICcnO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0YWRkQ2xhc3MoaWNvbiwgY2xhc3NUb0FkZCk7XHJcblxyXG4gIFx0XHRpZiAob3B0aW9ucy5rZXlib2FyZCkge1xyXG4gIFx0XHRcdGljb24udGFiSW5kZXggPSAnMCc7XHJcbiAgXHRcdFx0aWNvbi5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnYnV0dG9uJyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2ljb24gPSBpY29uO1xyXG5cclxuICBcdFx0aWYgKG9wdGlvbnMucmlzZU9uSG92ZXIpIHtcclxuICBcdFx0XHR0aGlzLm9uKHtcclxuICBcdFx0XHRcdG1vdXNlb3ZlcjogdGhpcy5fYnJpbmdUb0Zyb250LFxyXG4gIFx0XHRcdFx0bW91c2VvdXQ6IHRoaXMuX3Jlc2V0WkluZGV4XHJcbiAgXHRcdFx0fSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuYXV0b1Bhbk9uRm9jdXMpIHtcclxuICBcdFx0XHRvbihpY29uLCAnZm9jdXMnLCB0aGlzLl9wYW5PbkZvY3VzLCB0aGlzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIG5ld1NoYWRvdyA9IG9wdGlvbnMuaWNvbi5jcmVhdGVTaGFkb3codGhpcy5fc2hhZG93KSxcclxuICBcdFx0ICAgIGFkZFNoYWRvdyA9IGZhbHNlO1xyXG5cclxuICBcdFx0aWYgKG5ld1NoYWRvdyAhPT0gdGhpcy5fc2hhZG93KSB7XHJcbiAgXHRcdFx0dGhpcy5fcmVtb3ZlU2hhZG93KCk7XHJcbiAgXHRcdFx0YWRkU2hhZG93ID0gdHJ1ZTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKG5ld1NoYWRvdykge1xyXG4gIFx0XHRcdGFkZENsYXNzKG5ld1NoYWRvdywgY2xhc3NUb0FkZCk7XHJcbiAgXHRcdFx0bmV3U2hhZG93LmFsdCA9ICcnO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHRoaXMuX3NoYWRvdyA9IG5ld1NoYWRvdztcclxuXHJcblxyXG4gIFx0XHRpZiAob3B0aW9ucy5vcGFjaXR5IDwgMSkge1xyXG4gIFx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuICBcdFx0fVxyXG5cclxuXHJcbiAgXHRcdGlmIChhZGRJY29uKSB7XHJcbiAgXHRcdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5faWNvbik7XHJcbiAgXHRcdH1cclxuICBcdFx0dGhpcy5faW5pdEludGVyYWN0aW9uKCk7XHJcbiAgXHRcdGlmIChuZXdTaGFkb3cgJiYgYWRkU2hhZG93KSB7XHJcbiAgXHRcdFx0dGhpcy5nZXRQYW5lKG9wdGlvbnMuc2hhZG93UGFuZSkuYXBwZW5kQ2hpbGQodGhpcy5fc2hhZG93KTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfcmVtb3ZlSWNvbjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLnJpc2VPbkhvdmVyKSB7XHJcbiAgXHRcdFx0dGhpcy5vZmYoe1xyXG4gIFx0XHRcdFx0bW91c2VvdmVyOiB0aGlzLl9icmluZ1RvRnJvbnQsXHJcbiAgXHRcdFx0XHRtb3VzZW91dDogdGhpcy5fcmVzZXRaSW5kZXhcclxuICBcdFx0XHR9KTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5hdXRvUGFuT25Gb2N1cykge1xyXG4gIFx0XHRcdG9mZih0aGlzLl9pY29uLCAnZm9jdXMnLCB0aGlzLl9wYW5PbkZvY3VzLCB0aGlzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmVtb3ZlKHRoaXMuX2ljb24pO1xyXG4gIFx0XHR0aGlzLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2ljb24pO1xyXG5cclxuICBcdFx0dGhpcy5faWNvbiA9IG51bGw7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9yZW1vdmVTaGFkb3c6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKHRoaXMuX3NoYWRvdykge1xyXG4gIFx0XHRcdHJlbW92ZSh0aGlzLl9zaGFkb3cpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHRoaXMuX3NoYWRvdyA9IG51bGw7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9zZXRQb3M6IGZ1bmN0aW9uIChwb3MpIHtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9pY29uKSB7XHJcbiAgXHRcdFx0c2V0UG9zaXRpb24odGhpcy5faWNvbiwgcG9zKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKHRoaXMuX3NoYWRvdykge1xyXG4gIFx0XHRcdHNldFBvc2l0aW9uKHRoaXMuX3NoYWRvdywgcG9zKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fekluZGV4ID0gcG9zLnkgKyB0aGlzLm9wdGlvbnMuekluZGV4T2Zmc2V0O1xyXG5cclxuICBcdFx0dGhpcy5fcmVzZXRaSW5kZXgoKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3VwZGF0ZVpJbmRleDogZnVuY3Rpb24gKG9mZnNldCkge1xyXG4gIFx0XHRpZiAodGhpcy5faWNvbikge1xyXG4gIFx0XHRcdHRoaXMuX2ljb24uc3R5bGUuekluZGV4ID0gdGhpcy5fekluZGV4ICsgb2Zmc2V0O1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKG9wdCkge1xyXG4gIFx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLCBvcHQuem9vbSwgb3B0LmNlbnRlcikucm91bmQoKTtcclxuXHJcbiAgXHRcdHRoaXMuX3NldFBvcyhwb3MpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfaW5pdEludGVyYWN0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gIFx0XHRpZiAoIXRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdGFkZENsYXNzKHRoaXMuX2ljb24sICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XHJcblxyXG4gIFx0XHR0aGlzLmFkZEludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2ljb24pO1xyXG5cclxuICBcdFx0aWYgKE1hcmtlckRyYWcpIHtcclxuICBcdFx0XHR2YXIgZHJhZ2dhYmxlID0gdGhpcy5vcHRpb25zLmRyYWdnYWJsZTtcclxuICBcdFx0XHRpZiAodGhpcy5kcmFnZ2luZykge1xyXG4gIFx0XHRcdFx0ZHJhZ2dhYmxlID0gdGhpcy5kcmFnZ2luZy5lbmFibGVkKCk7XHJcbiAgXHRcdFx0XHR0aGlzLmRyYWdnaW5nLmRpc2FibGUoKTtcclxuICBcdFx0XHR9XHJcblxyXG4gIFx0XHRcdHRoaXMuZHJhZ2dpbmcgPSBuZXcgTWFya2VyRHJhZyh0aGlzKTtcclxuXHJcbiAgXHRcdFx0aWYgKGRyYWdnYWJsZSkge1xyXG4gIFx0XHRcdFx0dGhpcy5kcmFnZ2luZy5lbmFibGUoKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRPcGFjaXR5KG9wYWNpdHk6IE51bWJlcik6IHRoaXNcclxuICBcdC8vIENoYW5nZXMgdGhlIG9wYWNpdHkgb2YgdGhlIG1hcmtlci5cclxuICBcdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XHJcbiAgXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcclxuICBcdFx0aWYgKHRoaXMuX21hcCkge1xyXG4gIFx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdF91cGRhdGVPcGFjaXR5OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBvcGFjaXR5ID0gdGhpcy5vcHRpb25zLm9wYWNpdHk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5faWNvbikge1xyXG4gIFx0XHRcdHNldE9wYWNpdHkodGhpcy5faWNvbiwgb3BhY2l0eSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICh0aGlzLl9zaGFkb3cpIHtcclxuICBcdFx0XHRzZXRPcGFjaXR5KHRoaXMuX3NoYWRvdywgb3BhY2l0eSk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X2JyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR0aGlzLl91cGRhdGVaSW5kZXgodGhpcy5vcHRpb25zLnJpc2VPZmZzZXQpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfcmVzZXRaSW5kZXg6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dGhpcy5fdXBkYXRlWkluZGV4KDApO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfcGFuT25Gb2N1czogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xyXG4gIFx0XHRpZiAoIW1hcCkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdHZhciBpY29uT3B0cyA9IHRoaXMub3B0aW9ucy5pY29uLm9wdGlvbnM7XHJcbiAgXHRcdHZhciBzaXplID0gaWNvbk9wdHMuaWNvblNpemUgPyB0b1BvaW50KGljb25PcHRzLmljb25TaXplKSA6IHRvUG9pbnQoMCwgMCk7XHJcbiAgXHRcdHZhciBhbmNob3IgPSBpY29uT3B0cy5pY29uQW5jaG9yID8gdG9Qb2ludChpY29uT3B0cy5pY29uQW5jaG9yKSA6IHRvUG9pbnQoMCwgMCk7XHJcblxyXG4gIFx0XHRtYXAucGFuSW5zaWRlKHRoaXMuX2xhdGxuZywge1xyXG4gIFx0XHRcdHBhZGRpbmdUb3BMZWZ0OiBhbmNob3IsXHJcbiAgXHRcdFx0cGFkZGluZ0JvdHRvbVJpZ2h0OiBzaXplLnN1YnRyYWN0KGFuY2hvcilcclxuICBcdFx0fSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9nZXRQb3B1cEFuY2hvcjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmljb24ub3B0aW9ucy5wb3B1cEFuY2hvcjtcclxuICBcdH0sXHJcblxyXG4gIFx0X2dldFRvb2x0aXBBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5pY29uLm9wdGlvbnMudG9vbHRpcEFuY2hvcjtcclxuICBcdH1cclxuICB9KTtcclxuXHJcblxyXG4gIC8vIGZhY3RvcnkgTC5tYXJrZXIobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/IDogTWFya2VyIG9wdGlvbnMpXHJcblxyXG4gIC8vIEBmYWN0b3J5IEwubWFya2VyKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPyA6IE1hcmtlciBvcHRpb25zKVxyXG4gIC8vIEluc3RhbnRpYXRlcyBhIE1hcmtlciBvYmplY3QgZ2l2ZW4gYSBnZW9ncmFwaGljYWwgcG9pbnQgYW5kIG9wdGlvbmFsbHkgYW4gb3B0aW9ucyBvYmplY3QuXHJcbiAgZnVuY3Rpb24gbWFya2VyKGxhdGxuZywgb3B0aW9ucykge1xyXG4gIFx0cmV0dXJuIG5ldyBNYXJrZXIobGF0bG5nLCBvcHRpb25zKTtcclxuICB9XG5cbiAgLypcbiAgICogQGNsYXNzIFBhdGhcbiAgICogQGFrYSBMLlBhdGhcbiAgICogQGluaGVyaXRzIEludGVyYWN0aXZlIGxheWVyXG4gICAqXG4gICAqIEFuIGFic3RyYWN0IGNsYXNzIHRoYXQgY29udGFpbnMgb3B0aW9ucyBhbmQgY29uc3RhbnRzIHNoYXJlZCBiZXR3ZWVuIHZlY3RvclxuICAgKiBvdmVybGF5cyAoUG9seWdvbiwgUG9seWxpbmUsIENpcmNsZSkuIERvIG5vdCB1c2UgaXQgZGlyZWN0bHkuIEV4dGVuZHMgYExheWVyYC5cbiAgICovXG5cbiAgdmFyIFBhdGggPSBMYXllci5leHRlbmQoe1xuXG4gIFx0Ly8gQHNlY3Rpb25cbiAgXHQvLyBAYWthIFBhdGggb3B0aW9uc1xuICBcdG9wdGlvbnM6IHtcbiAgXHRcdC8vIEBvcHRpb24gc3Ryb2tlOiBCb29sZWFuID0gdHJ1ZVxuICBcdFx0Ly8gV2hldGhlciB0byBkcmF3IHN0cm9rZSBhbG9uZyB0aGUgcGF0aC4gU2V0IGl0IHRvIGBmYWxzZWAgdG8gZGlzYWJsZSBib3JkZXJzIG9uIHBvbHlnb25zIG9yIGNpcmNsZXMuXG4gIFx0XHRzdHJva2U6IHRydWUsXG5cbiAgXHRcdC8vIEBvcHRpb24gY29sb3I6IFN0cmluZyA9ICcjMzM4OGZmJ1xuICBcdFx0Ly8gU3Ryb2tlIGNvbG9yXG4gIFx0XHRjb2xvcjogJyMzMzg4ZmYnLFxuXG4gIFx0XHQvLyBAb3B0aW9uIHdlaWdodDogTnVtYmVyID0gM1xuICBcdFx0Ly8gU3Ryb2tlIHdpZHRoIGluIHBpeGVsc1xuICBcdFx0d2VpZ2h0OiAzLFxuXG4gIFx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxuICBcdFx0Ly8gU3Ryb2tlIG9wYWNpdHlcbiAgXHRcdG9wYWNpdHk6IDEsXG5cbiAgXHRcdC8vIEBvcHRpb24gbGluZUNhcDogU3RyaW5nPSAncm91bmQnXG4gIFx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgW3NoYXBlIHRvIGJlIHVzZWQgYXQgdGhlIGVuZF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtbGluZWNhcCkgb2YgdGhlIHN0cm9rZS5cbiAgXHRcdGxpbmVDYXA6ICdyb3VuZCcsXG5cbiAgXHRcdC8vIEBvcHRpb24gbGluZUpvaW46IFN0cmluZyA9ICdyb3VuZCdcbiAgXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyBbc2hhcGUgdG8gYmUgdXNlZCBhdCB0aGUgY29ybmVyc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtbGluZWpvaW4pIG9mIHRoZSBzdHJva2UuXG4gIFx0XHRsaW5lSm9pbjogJ3JvdW5kJyxcblxuICBcdFx0Ly8gQG9wdGlvbiBkYXNoQXJyYXk6IFN0cmluZyA9IG51bGxcbiAgXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyB0aGUgc3Ryb2tlIFtkYXNoIHBhdHRlcm5dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc3Ryb2tlLWRhc2hhcnJheSkuIERvZXNuJ3Qgd29yayBvbiBgQ2FudmFzYC1wb3dlcmVkIGxheWVycyBpbiBbc29tZSBvbGQgYnJvd3NlcnNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvc2V0TGluZURhc2gjQnJvd3Nlcl9jb21wYXRpYmlsaXR5KS5cbiAgXHRcdGRhc2hBcnJheTogbnVsbCxcblxuICBcdFx0Ly8gQG9wdGlvbiBkYXNoT2Zmc2V0OiBTdHJpbmcgPSBudWxsXG4gIFx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgdGhlIFtkaXN0YW5jZSBpbnRvIHRoZSBkYXNoIHBhdHRlcm4gdG8gc3RhcnQgdGhlIGRhc2hdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc3Ryb2tlLWRhc2hvZmZzZXQpLiBEb2Vzbid0IHdvcmsgb24gYENhbnZhc2AtcG93ZXJlZCBsYXllcnMgaW4gW3NvbWUgb2xkIGJyb3dzZXJzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL3NldExpbmVEYXNoI0Jyb3dzZXJfY29tcGF0aWJpbGl0eSkuXG4gIFx0XHRkYXNoT2Zmc2V0OiBudWxsLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGZpbGw6IEJvb2xlYW4gPSBkZXBlbmRzXG4gIFx0XHQvLyBXaGV0aGVyIHRvIGZpbGwgdGhlIHBhdGggd2l0aCBjb2xvci4gU2V0IGl0IHRvIGBmYWxzZWAgdG8gZGlzYWJsZSBmaWxsaW5nIG9uIHBvbHlnb25zIG9yIGNpcmNsZXMuXG4gIFx0XHRmaWxsOiBmYWxzZSxcblxuICBcdFx0Ly8gQG9wdGlvbiBmaWxsQ29sb3I6IFN0cmluZyA9ICpcbiAgXHRcdC8vIEZpbGwgY29sb3IuIERlZmF1bHRzIHRvIHRoZSB2YWx1ZSBvZiB0aGUgW2Bjb2xvcmBdKCNwYXRoLWNvbG9yKSBvcHRpb25cbiAgXHRcdGZpbGxDb2xvcjogbnVsbCxcblxuICBcdFx0Ly8gQG9wdGlvbiBmaWxsT3BhY2l0eTogTnVtYmVyID0gMC4yXG4gIFx0XHQvLyBGaWxsIG9wYWNpdHkuXG4gIFx0XHRmaWxsT3BhY2l0eTogMC4yLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGZpbGxSdWxlOiBTdHJpbmcgPSAnZXZlbm9kZCdcbiAgXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyBbaG93IHRoZSBpbnNpZGUgb2YgYSBzaGFwZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9maWxsLXJ1bGUpIGlzIGRldGVybWluZWQuXG4gIFx0XHRmaWxsUnVsZTogJ2V2ZW5vZGQnLFxuXG4gIFx0XHQvLyBjbGFzc05hbWU6ICcnLFxuXG4gIFx0XHQvLyBPcHRpb24gaW5oZXJpdGVkIGZyb20gXCJJbnRlcmFjdGl2ZSBsYXllclwiIGFic3RyYWN0IGNsYXNzXG4gIFx0XHRpbnRlcmFjdGl2ZTogdHJ1ZSxcblxuICBcdFx0Ly8gQG9wdGlvbiBidWJibGluZ01vdXNlRXZlbnRzOiBCb29sZWFuID0gdHJ1ZVxuICBcdFx0Ly8gV2hlbiBgdHJ1ZWAsIGEgbW91c2UgZXZlbnQgb24gdGhpcyBwYXRoIHdpbGwgdHJpZ2dlciB0aGUgc2FtZSBldmVudCBvbiB0aGUgbWFwXG4gIFx0XHQvLyAodW5sZXNzIFtgTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb25gXSgjZG9tZXZlbnQtc3RvcHByb3BhZ2F0aW9uKSBpcyB1c2VkKS5cbiAgXHRcdGJ1YmJsaW5nTW91c2VFdmVudHM6IHRydWVcbiAgXHR9LFxuXG4gIFx0YmVmb3JlQWRkOiBmdW5jdGlvbiAobWFwKSB7XG4gIFx0XHQvLyBSZW5kZXJlciBpcyBzZXQgaGVyZSBiZWNhdXNlIHdlIG5lZWQgdG8gY2FsbCByZW5kZXJlci5nZXRFdmVudHNcbiAgXHRcdC8vIGJlZm9yZSB0aGlzLmdldEV2ZW50cy5cbiAgXHRcdHRoaXMuX3JlbmRlcmVyID0gbWFwLmdldFJlbmRlcmVyKHRoaXMpO1xuICBcdH0sXG5cbiAgXHRvbkFkZDogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5fcmVuZGVyZXIuX2luaXRQYXRoKHRoaXMpO1xuICBcdFx0dGhpcy5fcmVzZXQoKTtcbiAgXHRcdHRoaXMuX3JlbmRlcmVyLl9hZGRQYXRoKHRoaXMpO1xuICBcdH0sXG5cbiAgXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5fcmVuZGVyZXIuX3JlbW92ZVBhdGgodGhpcyk7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgcmVkcmF3KCk6IHRoaXNcbiAgXHQvLyBSZWRyYXdzIHRoZSBsYXllci4gU29tZXRpbWVzIHVzZWZ1bCBhZnRlciB5b3UgY2hhbmdlZCB0aGUgY29vcmRpbmF0ZXMgdGhhdCB0aGUgcGF0aCB1c2VzLlxuICBcdHJlZHJhdzogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX21hcCkge1xuICBcdFx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlUGF0aCh0aGlzKTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHNldFN0eWxlKHN0eWxlOiBQYXRoIG9wdGlvbnMpOiB0aGlzXG4gIFx0Ly8gQ2hhbmdlcyB0aGUgYXBwZWFyYW5jZSBvZiBhIFBhdGggYmFzZWQgb24gdGhlIG9wdGlvbnMgaW4gdGhlIGBQYXRoIG9wdGlvbnNgIG9iamVjdC5cbiAgXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XG4gIFx0XHRzZXRPcHRpb25zKHRoaXMsIHN0eWxlKTtcbiAgXHRcdGlmICh0aGlzLl9yZW5kZXJlcikge1xuICBcdFx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlU3R5bGUodGhpcyk7XG4gIFx0XHRcdGlmICh0aGlzLm9wdGlvbnMuc3Ryb2tlICYmIHN0eWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzdHlsZSwgJ3dlaWdodCcpKSB7XG4gIFx0XHRcdFx0dGhpcy5fdXBkYXRlQm91bmRzKCk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udCgpOiB0aGlzXG4gIFx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgdG9wIG9mIGFsbCBwYXRoIGxheWVycy5cbiAgXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9yZW5kZXJlcikge1xuICBcdFx0XHR0aGlzLl9yZW5kZXJlci5fYnJpbmdUb0Zyb250KHRoaXMpO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgYnJpbmdUb0JhY2soKTogdGhpc1xuICBcdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIGJvdHRvbSBvZiBhbGwgcGF0aCBsYXllcnMuXG4gIFx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9yZW5kZXJlcikge1xuICBcdFx0XHR0aGlzLl9yZW5kZXJlci5fYnJpbmdUb0JhY2sodGhpcyk7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Z2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuX3BhdGg7XG4gIFx0fSxcblxuICBcdF9yZXNldDogZnVuY3Rpb24gKCkge1xuICBcdFx0Ly8gZGVmaW5lZCBpbiBjaGlsZCBjbGFzc2VzXG4gIFx0XHR0aGlzLl9wcm9qZWN0KCk7XG4gIFx0XHR0aGlzLl91cGRhdGUoKTtcbiAgXHR9LFxuXG4gIFx0X2NsaWNrVG9sZXJhbmNlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHQvLyB1c2VkIHdoZW4gZG9pbmcgaGl0IGRldGVjdGlvbiBmb3IgQ2FudmFzIGxheWVyc1xuICBcdFx0cmV0dXJuICh0aGlzLm9wdGlvbnMuc3Ryb2tlID8gdGhpcy5vcHRpb25zLndlaWdodCAvIDIgOiAwKSArXG4gIFx0XHQgICh0aGlzLl9yZW5kZXJlci5vcHRpb25zLnRvbGVyYW5jZSB8fCAwKTtcbiAgXHR9XG4gIH0pO1xuXG4gIC8qXG4gICAqIEBjbGFzcyBDaXJjbGVNYXJrZXJcbiAgICogQGFrYSBMLkNpcmNsZU1hcmtlclxuICAgKiBAaW5oZXJpdHMgUGF0aFxuICAgKlxuICAgKiBBIGNpcmNsZSBvZiBhIGZpeGVkIHNpemUgd2l0aCByYWRpdXMgc3BlY2lmaWVkIGluIHBpeGVscy4gRXh0ZW5kcyBgUGF0aGAuXG4gICAqL1xuXG4gIHZhciBDaXJjbGVNYXJrZXIgPSBQYXRoLmV4dGVuZCh7XG5cbiAgXHQvLyBAc2VjdGlvblxuICBcdC8vIEBha2EgQ2lyY2xlTWFya2VyIG9wdGlvbnNcbiAgXHRvcHRpb25zOiB7XG4gIFx0XHRmaWxsOiB0cnVlLFxuXG4gIFx0XHQvLyBAb3B0aW9uIHJhZGl1czogTnVtYmVyID0gMTBcbiAgXHRcdC8vIFJhZGl1cyBvZiB0aGUgY2lyY2xlIG1hcmtlciwgaW4gcGl4ZWxzXG4gIFx0XHRyYWRpdXM6IDEwXG4gIFx0fSxcblxuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcbiAgXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gIFx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xuICBcdFx0dGhpcy5fcmFkaXVzID0gdGhpcy5vcHRpb25zLnJhZGl1cztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBzZXRMYXRMbmcobGF0TG5nOiBMYXRMbmcpOiB0aGlzXG4gIFx0Ly8gU2V0cyB0aGUgcG9zaXRpb24gb2YgYSBjaXJjbGUgbWFya2VyIHRvIGEgbmV3IGxvY2F0aW9uLlxuICBcdHNldExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xuICBcdFx0dmFyIG9sZExhdExuZyA9IHRoaXMuX2xhdGxuZztcbiAgXHRcdHRoaXMuX2xhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XG4gIFx0XHR0aGlzLnJlZHJhdygpO1xuXG4gIFx0XHQvLyBAZXZlbnQgbW92ZTogRXZlbnRcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcmtlciBpcyBtb3ZlZCB2aWEgW2BzZXRMYXRMbmdgXSgjY2lyY2xlbWFya2VyLXNldGxhdGxuZykuIE9sZCBhbmQgbmV3IGNvb3JkaW5hdGVzIGFyZSBpbmNsdWRlZCBpbiBldmVudCBhcmd1bWVudHMgYXMgYG9sZExhdExuZ2AsIGBsYXRsbmdgLlxuICBcdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZScsIHtvbGRMYXRMbmc6IG9sZExhdExuZywgbGF0bG5nOiB0aGlzLl9sYXRsbmd9KTtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBnZXRMYXRMbmcoKTogTGF0TG5nXG4gIFx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCBnZW9ncmFwaGljYWwgcG9zaXRpb24gb2YgdGhlIGNpcmNsZSBtYXJrZXJcbiAgXHRnZXRMYXRMbmc6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLl9sYXRsbmc7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2Qgc2V0UmFkaXVzKHJhZGl1czogTnVtYmVyKTogdGhpc1xuICBcdC8vIFNldHMgdGhlIHJhZGl1cyBvZiBhIGNpcmNsZSBtYXJrZXIuIFVuaXRzIGFyZSBpbiBwaXhlbHMuXG4gIFx0c2V0UmFkaXVzOiBmdW5jdGlvbiAocmFkaXVzKSB7XG4gIFx0XHR0aGlzLm9wdGlvbnMucmFkaXVzID0gdGhpcy5fcmFkaXVzID0gcmFkaXVzO1xuICBcdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgZ2V0UmFkaXVzKCk6IE51bWJlclxuICBcdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgcmFkaXVzIG9mIHRoZSBjaXJjbGVcbiAgXHRnZXRSYWRpdXM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLl9yYWRpdXM7XG4gIFx0fSxcblxuICBcdHNldFN0eWxlIDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHRcdHZhciByYWRpdXMgPSBvcHRpb25zICYmIG9wdGlvbnMucmFkaXVzIHx8IHRoaXMuX3JhZGl1cztcbiAgXHRcdFBhdGgucHJvdG90eXBlLnNldFN0eWxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFx0XHR0aGlzLnNldFJhZGl1cyhyYWRpdXMpO1xuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdF9wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9wb2ludCA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKTtcbiAgXHRcdHRoaXMuX3VwZGF0ZUJvdW5kcygpO1xuICBcdH0sXG5cbiAgXHRfdXBkYXRlQm91bmRzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgciA9IHRoaXMuX3JhZGl1cyxcbiAgXHRcdCAgICByMiA9IHRoaXMuX3JhZGl1c1kgfHwgcixcbiAgXHRcdCAgICB3ID0gdGhpcy5fY2xpY2tUb2xlcmFuY2UoKSxcbiAgXHRcdCAgICBwID0gW3IgKyB3LCByMiArIHddO1xuICBcdFx0dGhpcy5fcHhCb3VuZHMgPSBuZXcgQm91bmRzKHRoaXMuX3BvaW50LnN1YnRyYWN0KHApLCB0aGlzLl9wb2ludC5hZGQocCkpO1xuICBcdH0sXG5cbiAgXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XG4gIFx0XHRcdHRoaXMuX3VwZGF0ZVBhdGgoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVDaXJjbGUodGhpcyk7XG4gIFx0fSxcblxuICBcdF9lbXB0eTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuX3JhZGl1cyAmJiAhdGhpcy5fcmVuZGVyZXIuX2JvdW5kcy5pbnRlcnNlY3RzKHRoaXMuX3B4Qm91bmRzKTtcbiAgXHR9LFxuXG4gIFx0Ly8gTmVlZGVkIGJ5IHRoZSBgQ2FudmFzYCByZW5kZXJlciBmb3IgaW50ZXJhY3Rpdml0eVxuICBcdF9jb250YWluc1BvaW50OiBmdW5jdGlvbiAocCkge1xuICBcdFx0cmV0dXJuIHAuZGlzdGFuY2VUbyh0aGlzLl9wb2ludCkgPD0gdGhpcy5fcmFkaXVzICsgdGhpcy5fY2xpY2tUb2xlcmFuY2UoKTtcbiAgXHR9XG4gIH0pO1xuXG5cbiAgLy8gQGZhY3RvcnkgTC5jaXJjbGVNYXJrZXIobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBDaXJjbGVNYXJrZXIgb3B0aW9ucylcbiAgLy8gSW5zdGFudGlhdGVzIGEgY2lyY2xlIG1hcmtlciBvYmplY3QgZ2l2ZW4gYSBnZW9ncmFwaGljYWwgcG9pbnQsIGFuZCBhbiBvcHRpb25hbCBvcHRpb25zIG9iamVjdC5cbiAgZnVuY3Rpb24gY2lyY2xlTWFya2VyKGxhdGxuZywgb3B0aW9ucykge1xuICBcdHJldHVybiBuZXcgQ2lyY2xlTWFya2VyKGxhdGxuZywgb3B0aW9ucyk7XG4gIH1cblxuICAvKlxuICAgKiBAY2xhc3MgQ2lyY2xlXG4gICAqIEBha2EgTC5DaXJjbGVcbiAgICogQGluaGVyaXRzIENpcmNsZU1hcmtlclxuICAgKlxuICAgKiBBIGNsYXNzIGZvciBkcmF3aW5nIGNpcmNsZSBvdmVybGF5cyBvbiBhIG1hcC4gRXh0ZW5kcyBgQ2lyY2xlTWFya2VyYC5cbiAgICpcbiAgICogSXQncyBhbiBhcHByb3hpbWF0aW9uIGFuZCBzdGFydHMgdG8gZGl2ZXJnZSBmcm9tIGEgcmVhbCBjaXJjbGUgY2xvc2VyIHRvIHBvbGVzIChkdWUgdG8gcHJvamVjdGlvbiBkaXN0b3J0aW9uKS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogYGBganNcbiAgICogTC5jaXJjbGUoWzUwLjUsIDMwLjVdLCB7cmFkaXVzOiAyMDB9KS5hZGRUbyhtYXApO1xuICAgKiBgYGBcbiAgICovXG5cbiAgdmFyIENpcmNsZSA9IENpcmNsZU1hcmtlci5leHRlbmQoe1xuXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucywgbGVnYWN5T3B0aW9ucykge1xuICBcdFx0aWYgKHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJykge1xuICBcdFx0XHQvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIDAuNy54IGZhY3RvcnkgKGxhdGxuZywgcmFkaXVzLCBvcHRpb25zPylcbiAgXHRcdFx0b3B0aW9ucyA9IGV4dGVuZCh7fSwgbGVnYWN5T3B0aW9ucywge3JhZGl1czogb3B0aW9uc30pO1xuICBcdFx0fVxuICBcdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgXHRcdHRoaXMuX2xhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XG5cbiAgXHRcdGlmIChpc05hTih0aGlzLm9wdGlvbnMucmFkaXVzKSkgeyB0aHJvdyBuZXcgRXJyb3IoJ0NpcmNsZSByYWRpdXMgY2Fubm90IGJlIE5hTicpOyB9XG5cbiAgXHRcdC8vIEBzZWN0aW9uXG4gIFx0XHQvLyBAYWthIENpcmNsZSBvcHRpb25zXG4gIFx0XHQvLyBAb3B0aW9uIHJhZGl1czogTnVtYmVyOyBSYWRpdXMgb2YgdGhlIGNpcmNsZSwgaW4gbWV0ZXJzLlxuICBcdFx0dGhpcy5fbVJhZGl1cyA9IHRoaXMub3B0aW9ucy5yYWRpdXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2Qgc2V0UmFkaXVzKHJhZGl1czogTnVtYmVyKTogdGhpc1xuICBcdC8vIFNldHMgdGhlIHJhZGl1cyBvZiBhIGNpcmNsZS4gVW5pdHMgYXJlIGluIG1ldGVycy5cbiAgXHRzZXRSYWRpdXM6IGZ1bmN0aW9uIChyYWRpdXMpIHtcbiAgXHRcdHRoaXMuX21SYWRpdXMgPSByYWRpdXM7XG4gIFx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBnZXRSYWRpdXMoKTogTnVtYmVyXG4gIFx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCByYWRpdXMgb2YgYSBjaXJjbGUuIFVuaXRzIGFyZSBpbiBtZXRlcnMuXG4gIFx0Z2V0UmFkaXVzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fbVJhZGl1cztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXG4gIFx0Ly8gUmV0dXJucyB0aGUgYExhdExuZ0JvdW5kc2Agb2YgdGhlIHBhdGguXG4gIFx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgaGFsZiA9IFt0aGlzLl9yYWRpdXMsIHRoaXMuX3JhZGl1c1kgfHwgdGhpcy5fcmFkaXVzXTtcblxuICBcdFx0cmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMoXG4gIFx0XHRcdHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcodGhpcy5fcG9pbnQuc3VidHJhY3QoaGFsZikpLFxuICBcdFx0XHR0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMuX3BvaW50LmFkZChoYWxmKSkpO1xuICBcdH0sXG5cbiAgXHRzZXRTdHlsZTogUGF0aC5wcm90b3R5cGUuc2V0U3R5bGUsXG5cbiAgXHRfcHJvamVjdDogZnVuY3Rpb24gKCkge1xuXG4gIFx0XHR2YXIgbG5nID0gdGhpcy5fbGF0bG5nLmxuZyxcbiAgXHRcdCAgICBsYXQgPSB0aGlzLl9sYXRsbmcubGF0LFxuICBcdFx0ICAgIG1hcCA9IHRoaXMuX21hcCxcbiAgXHRcdCAgICBjcnMgPSBtYXAub3B0aW9ucy5jcnM7XG5cbiAgXHRcdGlmIChjcnMuZGlzdGFuY2UgPT09IEVhcnRoLmRpc3RhbmNlKSB7XG4gIFx0XHRcdHZhciBkID0gTWF0aC5QSSAvIDE4MCxcbiAgXHRcdFx0ICAgIGxhdFIgPSAodGhpcy5fbVJhZGl1cyAvIEVhcnRoLlIpIC8gZCxcbiAgXHRcdFx0ICAgIHRvcCA9IG1hcC5wcm9qZWN0KFtsYXQgKyBsYXRSLCBsbmddKSxcbiAgXHRcdFx0ICAgIGJvdHRvbSA9IG1hcC5wcm9qZWN0KFtsYXQgLSBsYXRSLCBsbmddKSxcbiAgXHRcdFx0ICAgIHAgPSB0b3AuYWRkKGJvdHRvbSkuZGl2aWRlQnkoMiksXG4gIFx0XHRcdCAgICBsYXQyID0gbWFwLnVucHJvamVjdChwKS5sYXQsXG4gIFx0XHRcdCAgICBsbmdSID0gTWF0aC5hY29zKChNYXRoLmNvcyhsYXRSICogZCkgLSBNYXRoLnNpbihsYXQgKiBkKSAqIE1hdGguc2luKGxhdDIgKiBkKSkgL1xuICBcdFx0XHQgICAgICAgICAgICAoTWF0aC5jb3MobGF0ICogZCkgKiBNYXRoLmNvcyhsYXQyICogZCkpKSAvIGQ7XG5cbiAgXHRcdFx0aWYgKGlzTmFOKGxuZ1IpIHx8IGxuZ1IgPT09IDApIHtcbiAgXHRcdFx0XHRsbmdSID0gbGF0UiAvIE1hdGguY29zKE1hdGguUEkgLyAxODAgKiBsYXQpOyAvLyBGYWxsYmFjayBmb3IgZWRnZSBjYXNlLCAjMjQyNVxuICBcdFx0XHR9XG5cbiAgXHRcdFx0dGhpcy5fcG9pbnQgPSBwLnN1YnRyYWN0KG1hcC5nZXRQaXhlbE9yaWdpbigpKTtcbiAgXHRcdFx0dGhpcy5fcmFkaXVzID0gaXNOYU4obG5nUikgPyAwIDogcC54IC0gbWFwLnByb2plY3QoW2xhdDIsIGxuZyAtIGxuZ1JdKS54O1xuICBcdFx0XHR0aGlzLl9yYWRpdXNZID0gcC55IC0gdG9wLnk7XG5cbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHZhciBsYXRsbmcyID0gY3JzLnVucHJvamVjdChjcnMucHJvamVjdCh0aGlzLl9sYXRsbmcpLnN1YnRyYWN0KFt0aGlzLl9tUmFkaXVzLCAwXSkpO1xuXG4gIFx0XHRcdHRoaXMuX3BvaW50ID0gbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpO1xuICBcdFx0XHR0aGlzLl9yYWRpdXMgPSB0aGlzLl9wb2ludC54IC0gbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmcyKS54O1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl91cGRhdGVCb3VuZHMoKTtcbiAgXHR9XG4gIH0pO1xuXG4gIC8vIEBmYWN0b3J5IEwuY2lyY2xlKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogQ2lyY2xlIG9wdGlvbnMpXG4gIC8vIEluc3RhbnRpYXRlcyBhIGNpcmNsZSBvYmplY3QgZ2l2ZW4gYSBnZW9ncmFwaGljYWwgcG9pbnQsIGFuZCBhbiBvcHRpb25zIG9iamVjdFxuICAvLyB3aGljaCBjb250YWlucyB0aGUgY2lyY2xlIHJhZGl1cy5cbiAgLy8gQGFsdGVybmF0aXZlXG4gIC8vIEBmYWN0b3J5IEwuY2lyY2xlKGxhdGxuZzogTGF0TG5nLCByYWRpdXM6IE51bWJlciwgb3B0aW9ucz86IENpcmNsZSBvcHRpb25zKVxuICAvLyBPYnNvbGV0ZSB3YXkgb2YgaW5zdGFudGlhdGluZyBhIGNpcmNsZSwgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCAwLjcueCBjb2RlLlxuICAvLyBEbyBub3QgdXNlIGluIG5ldyBhcHBsaWNhdGlvbnMgb3IgcGx1Z2lucy5cbiAgZnVuY3Rpb24gY2lyY2xlKGxhdGxuZywgb3B0aW9ucywgbGVnYWN5T3B0aW9ucykge1xuICBcdHJldHVybiBuZXcgQ2lyY2xlKGxhdGxuZywgb3B0aW9ucywgbGVnYWN5T3B0aW9ucyk7XG4gIH1cblxuICAvKlxuICAgKiBAY2xhc3MgUG9seWxpbmVcbiAgICogQGFrYSBMLlBvbHlsaW5lXG4gICAqIEBpbmhlcml0cyBQYXRoXG4gICAqXG4gICAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgcG9seWxpbmUgb3ZlcmxheXMgb24gYSBtYXAuIEV4dGVuZHMgYFBhdGhgLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGBqc1xuICAgKiAvLyBjcmVhdGUgYSByZWQgcG9seWxpbmUgZnJvbSBhbiBhcnJheSBvZiBMYXRMbmcgcG9pbnRzXG4gICAqIHZhciBsYXRsbmdzID0gW1xuICAgKiBcdFs0NS41MSwgLTEyMi42OF0sXG4gICAqIFx0WzM3Ljc3LCAtMTIyLjQzXSxcbiAgICogXHRbMzQuMDQsIC0xMTguMl1cbiAgICogXTtcbiAgICpcbiAgICogdmFyIHBvbHlsaW5lID0gTC5wb2x5bGluZShsYXRsbmdzLCB7Y29sb3I6ICdyZWQnfSkuYWRkVG8obWFwKTtcbiAgICpcbiAgICogLy8gem9vbSB0aGUgbWFwIHRvIHRoZSBwb2x5bGluZVxuICAgKiBtYXAuZml0Qm91bmRzKHBvbHlsaW5lLmdldEJvdW5kcygpKTtcbiAgICogYGBgXG4gICAqXG4gICAqIFlvdSBjYW4gYWxzbyBwYXNzIGEgbXVsdGktZGltZW5zaW9uYWwgYXJyYXkgdG8gcmVwcmVzZW50IGEgYE11bHRpUG9seWxpbmVgIHNoYXBlOlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiAvLyBjcmVhdGUgYSByZWQgcG9seWxpbmUgZnJvbSBhbiBhcnJheSBvZiBhcnJheXMgb2YgTGF0TG5nIHBvaW50c1xuICAgKiB2YXIgbGF0bG5ncyA9IFtcbiAgICogXHRbWzQ1LjUxLCAtMTIyLjY4XSxcbiAgICogXHQgWzM3Ljc3LCAtMTIyLjQzXSxcbiAgICogXHQgWzM0LjA0LCAtMTE4LjJdXSxcbiAgICogXHRbWzQwLjc4LCAtNzMuOTFdLFxuICAgKiBcdCBbNDEuODMsIC04Ny42Ml0sXG4gICAqIFx0IFszMi43NiwgLTk2LjcyXV1cbiAgICogXTtcbiAgICogYGBgXG4gICAqL1xuXG5cbiAgdmFyIFBvbHlsaW5lID0gUGF0aC5leHRlbmQoe1xuXG4gIFx0Ly8gQHNlY3Rpb25cbiAgXHQvLyBAYWthIFBvbHlsaW5lIG9wdGlvbnNcbiAgXHRvcHRpb25zOiB7XG4gIFx0XHQvLyBAb3B0aW9uIHNtb290aEZhY3RvcjogTnVtYmVyID0gMS4wXG4gIFx0XHQvLyBIb3cgbXVjaCB0byBzaW1wbGlmeSB0aGUgcG9seWxpbmUgb24gZWFjaCB6b29tIGxldmVsLiBNb3JlIG1lYW5zXG4gIFx0XHQvLyBiZXR0ZXIgcGVyZm9ybWFuY2UgYW5kIHNtb290aGVyIGxvb2ssIGFuZCBsZXNzIG1lYW5zIG1vcmUgYWNjdXJhdGUgcmVwcmVzZW50YXRpb24uXG4gIFx0XHRzbW9vdGhGYWN0b3I6IDEuMCxcblxuICBcdFx0Ly8gQG9wdGlvbiBub0NsaXA6IEJvb2xlYW4gPSBmYWxzZVxuICBcdFx0Ly8gRGlzYWJsZSBwb2x5bGluZSBjbGlwcGluZy5cbiAgXHRcdG5vQ2xpcDogZmFsc2VcbiAgXHR9LFxuXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZ3MsIG9wdGlvbnMpIHtcbiAgXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gIFx0XHR0aGlzLl9zZXRMYXRMbmdzKGxhdGxuZ3MpO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGdldExhdExuZ3MoKTogTGF0TG5nW11cbiAgXHQvLyBSZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBwb2ludHMgaW4gdGhlIHBhdGgsIG9yIG5lc3RlZCBhcnJheXMgb2YgcG9pbnRzIGluIGNhc2Ugb2YgbXVsdGktcG9seWxpbmUuXG4gIFx0Z2V0TGF0TG5nczogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuX2xhdGxuZ3M7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2Qgc2V0TGF0TG5ncyhsYXRsbmdzOiBMYXRMbmdbXSk6IHRoaXNcbiAgXHQvLyBSZXBsYWNlcyBhbGwgdGhlIHBvaW50cyBpbiB0aGUgcG9seWxpbmUgd2l0aCB0aGUgZ2l2ZW4gYXJyYXkgb2YgZ2VvZ3JhcGhpY2FsIHBvaW50cy5cbiAgXHRzZXRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuICBcdFx0dGhpcy5fc2V0TGF0TG5ncyhsYXRsbmdzKTtcbiAgXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGlzRW1wdHkoKTogQm9vbGVhblxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBQb2x5bGluZSBoYXMgbm8gTGF0TG5ncy5cbiAgXHRpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gIXRoaXMuX2xhdGxuZ3MubGVuZ3RoO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGNsb3Nlc3RMYXllclBvaW50KHA6IFBvaW50KTogUG9pbnRcbiAgXHQvLyBSZXR1cm5zIHRoZSBwb2ludCBjbG9zZXN0IHRvIGBwYCBvbiB0aGUgUG9seWxpbmUuXG4gIFx0Y2xvc2VzdExheWVyUG9pbnQ6IGZ1bmN0aW9uIChwKSB7XG4gIFx0XHR2YXIgbWluRGlzdGFuY2UgPSBJbmZpbml0eSxcbiAgXHRcdCAgICBtaW5Qb2ludCA9IG51bGwsXG4gIFx0XHQgICAgY2xvc2VzdCA9IF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudCxcbiAgXHRcdCAgICBwMSwgcDI7XG5cbiAgXHRcdGZvciAodmFyIGogPSAwLCBqTGVuID0gdGhpcy5fcGFydHMubGVuZ3RoOyBqIDwgakxlbjsgaisrKSB7XG4gIFx0XHRcdHZhciBwb2ludHMgPSB0aGlzLl9wYXJ0c1tqXTtcblxuICBcdFx0XHRmb3IgKHZhciBpID0gMSwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gIFx0XHRcdFx0cDEgPSBwb2ludHNbaSAtIDFdO1xuICBcdFx0XHRcdHAyID0gcG9pbnRzW2ldO1xuXG4gIFx0XHRcdFx0dmFyIHNxRGlzdCA9IGNsb3Nlc3QocCwgcDEsIHAyLCB0cnVlKTtcblxuICBcdFx0XHRcdGlmIChzcURpc3QgPCBtaW5EaXN0YW5jZSkge1xuICBcdFx0XHRcdFx0bWluRGlzdGFuY2UgPSBzcURpc3Q7XG4gIFx0XHRcdFx0XHRtaW5Qb2ludCA9IGNsb3Nlc3QocCwgcDEsIHAyKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHRcdGlmIChtaW5Qb2ludCkge1xuICBcdFx0XHRtaW5Qb2ludC5kaXN0YW5jZSA9IE1hdGguc3FydChtaW5EaXN0YW5jZSk7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gbWluUG9pbnQ7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xuICBcdC8vIFJldHVybnMgdGhlIGNlbnRlciAoW2NlbnRyb2lkXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DZW50cm9pZCkpIG9mIHRoZSBwb2x5bGluZS5cbiAgXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdC8vIHRocm93cyBlcnJvciB3aGVuIG5vdCB5ZXQgYWRkZWQgdG8gbWFwIGFzIHRoaXMgY2VudGVyIGNhbGN1bGF0aW9uIHJlcXVpcmVzIHByb2plY3RlZCBjb29yZGluYXRlc1xuICBcdFx0aWYgKCF0aGlzLl9tYXApIHtcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNdXN0IGFkZCBsYXllciB0byBtYXAgYmVmb3JlIHVzaW5nIGdldENlbnRlcigpJyk7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gcG9seWxpbmVDZW50ZXIodGhpcy5fZGVmYXVsdFNoYXBlKCksIHRoaXMuX21hcC5vcHRpb25zLmNycyk7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xuICBcdC8vIFJldHVybnMgdGhlIGBMYXRMbmdCb3VuZHNgIG9mIHRoZSBwYXRoLlxuICBcdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuX2JvdW5kcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBhZGRMYXRMbmcobGF0bG5nOiBMYXRMbmcsIGxhdGxuZ3M/OiBMYXRMbmdbXSk6IHRoaXNcbiAgXHQvLyBBZGRzIGEgZ2l2ZW4gcG9pbnQgdG8gdGhlIHBvbHlsaW5lLiBCeSBkZWZhdWx0LCBhZGRzIHRvIHRoZSBmaXJzdCByaW5nIG9mXG4gIFx0Ly8gdGhlIHBvbHlsaW5lIGluIGNhc2Ugb2YgYSBtdWx0aS1wb2x5bGluZSwgYnV0IGNhbiBiZSBvdmVycmlkZGVuIGJ5IHBhc3NpbmdcbiAgXHQvLyBhIHNwZWNpZmljIHJpbmcgYXMgYSBMYXRMbmcgYXJyYXkgKHRoYXQgeW91IGNhbiBlYXJsaWVyIGFjY2VzcyB3aXRoIFtgZ2V0TGF0TG5nc2BdKCNwb2x5bGluZS1nZXRsYXRsbmdzKSkuXG4gIFx0YWRkTGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nLCBsYXRsbmdzKSB7XG4gIFx0XHRsYXRsbmdzID0gbGF0bG5ncyB8fCB0aGlzLl9kZWZhdWx0U2hhcGUoKTtcbiAgXHRcdGxhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XG4gIFx0XHRsYXRsbmdzLnB1c2gobGF0bG5nKTtcbiAgXHRcdHRoaXMuX2JvdW5kcy5leHRlbmQobGF0bG5nKTtcbiAgXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuICBcdH0sXG5cbiAgXHRfc2V0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcbiAgXHRcdHRoaXMuX2JvdW5kcyA9IG5ldyBMYXRMbmdCb3VuZHMoKTtcbiAgXHRcdHRoaXMuX2xhdGxuZ3MgPSB0aGlzLl9jb252ZXJ0TGF0TG5ncyhsYXRsbmdzKTtcbiAgXHR9LFxuXG4gIFx0X2RlZmF1bHRTaGFwZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIGlzRmxhdCh0aGlzLl9sYXRsbmdzKSA/IHRoaXMuX2xhdGxuZ3MgOiB0aGlzLl9sYXRsbmdzWzBdO1xuICBcdH0sXG5cbiAgXHQvLyByZWN1cnNpdmVseSBjb252ZXJ0IGxhdGxuZ3MgaW5wdXQgaW50byBhY3R1YWwgTGF0TG5nIGluc3RhbmNlczsgY2FsY3VsYXRlIGJvdW5kcyBhbG9uZyB0aGUgd2F5XG4gIFx0X2NvbnZlcnRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuICBcdFx0dmFyIHJlc3VsdCA9IFtdLFxuICBcdFx0ICAgIGZsYXQgPSBpc0ZsYXQobGF0bG5ncyk7XG5cbiAgXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXRsbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gIFx0XHRcdGlmIChmbGF0KSB7XG4gIFx0XHRcdFx0cmVzdWx0W2ldID0gdG9MYXRMbmcobGF0bG5nc1tpXSk7XG4gIFx0XHRcdFx0dGhpcy5fYm91bmRzLmV4dGVuZChyZXN1bHRbaV0pO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdHJlc3VsdFtpXSA9IHRoaXMuX2NvbnZlcnRMYXRMbmdzKGxhdGxuZ3NbaV0pO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiByZXN1bHQ7XG4gIFx0fSxcblxuICBcdF9wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgcHhCb3VuZHMgPSBuZXcgQm91bmRzKCk7XG4gIFx0XHR0aGlzLl9yaW5ncyA9IFtdO1xuICBcdFx0dGhpcy5fcHJvamVjdExhdGxuZ3ModGhpcy5fbGF0bG5ncywgdGhpcy5fcmluZ3MsIHB4Qm91bmRzKTtcblxuICBcdFx0aWYgKHRoaXMuX2JvdW5kcy5pc1ZhbGlkKCkgJiYgcHhCb3VuZHMuaXNWYWxpZCgpKSB7XG4gIFx0XHRcdHRoaXMuX3Jhd1B4Qm91bmRzID0gcHhCb3VuZHM7XG4gIFx0XHRcdHRoaXMuX3VwZGF0ZUJvdW5kcygpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfdXBkYXRlQm91bmRzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgdyA9IHRoaXMuX2NsaWNrVG9sZXJhbmNlKCksXG4gIFx0XHQgICAgcCA9IG5ldyBQb2ludCh3LCB3KTtcblxuICBcdFx0aWYgKCF0aGlzLl9yYXdQeEJvdW5kcykge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX3B4Qm91bmRzID0gbmV3IEJvdW5kcyhbXG4gIFx0XHRcdHRoaXMuX3Jhd1B4Qm91bmRzLm1pbi5zdWJ0cmFjdChwKSxcbiAgXHRcdFx0dGhpcy5fcmF3UHhCb3VuZHMubWF4LmFkZChwKVxuICBcdFx0XSk7XG4gIFx0fSxcblxuICBcdC8vIHJlY3Vyc2l2ZWx5IHR1cm5zIGxhdGxuZ3MgaW50byBhIHNldCBvZiByaW5ncyB3aXRoIHByb2plY3RlZCBjb29yZGluYXRlc1xuICBcdF9wcm9qZWN0TGF0bG5nczogZnVuY3Rpb24gKGxhdGxuZ3MsIHJlc3VsdCwgcHJvamVjdGVkQm91bmRzKSB7XG4gIFx0XHR2YXIgZmxhdCA9IGxhdGxuZ3NbMF0gaW5zdGFuY2VvZiBMYXRMbmcsXG4gIFx0XHQgICAgbGVuID0gbGF0bG5ncy5sZW5ndGgsXG4gIFx0XHQgICAgaSwgcmluZztcblxuICBcdFx0aWYgKGZsYXQpIHtcbiAgXHRcdFx0cmluZyA9IFtdO1xuICBcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0XHRyaW5nW2ldID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmdzW2ldKTtcbiAgXHRcdFx0XHRwcm9qZWN0ZWRCb3VuZHMuZXh0ZW5kKHJpbmdbaV0pO1xuICBcdFx0XHR9XG4gIFx0XHRcdHJlc3VsdC5wdXNoKHJpbmcpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gIFx0XHRcdFx0dGhpcy5fcHJvamVjdExhdGxuZ3MobGF0bG5nc1tpXSwgcmVzdWx0LCBwcm9qZWN0ZWRCb3VuZHMpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdC8vIGNsaXAgcG9seWxpbmUgYnkgcmVuZGVyZXIgYm91bmRzIHNvIHRoYXQgd2UgaGF2ZSBsZXNzIHRvIHJlbmRlciBmb3IgcGVyZm9ybWFuY2VcbiAgXHRfY2xpcFBvaW50czogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGJvdW5kcyA9IHRoaXMuX3JlbmRlcmVyLl9ib3VuZHM7XG5cbiAgXHRcdHRoaXMuX3BhcnRzID0gW107XG4gIFx0XHRpZiAoIXRoaXMuX3B4Qm91bmRzIHx8ICF0aGlzLl9weEJvdW5kcy5pbnRlcnNlY3RzKGJvdW5kcykpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLm5vQ2xpcCkge1xuICBcdFx0XHR0aGlzLl9wYXJ0cyA9IHRoaXMuX3JpbmdzO1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHZhciBwYXJ0cyA9IHRoaXMuX3BhcnRzLFxuICBcdFx0ICAgIGksIGosIGssIGxlbiwgbGVuMiwgc2VnbWVudCwgcG9pbnRzO1xuXG4gIFx0XHRmb3IgKGkgPSAwLCBrID0gMCwgbGVuID0gdGhpcy5fcmluZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0cG9pbnRzID0gdGhpcy5fcmluZ3NbaV07XG5cbiAgXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBvaW50cy5sZW5ndGg7IGogPCBsZW4yIC0gMTsgaisrKSB7XG4gIFx0XHRcdFx0c2VnbWVudCA9IGNsaXBTZWdtZW50KHBvaW50c1tqXSwgcG9pbnRzW2ogKyAxXSwgYm91bmRzLCBqLCB0cnVlKTtcblxuICBcdFx0XHRcdGlmICghc2VnbWVudCkgeyBjb250aW51ZTsgfVxuXG4gIFx0XHRcdFx0cGFydHNba10gPSBwYXJ0c1trXSB8fCBbXTtcbiAgXHRcdFx0XHRwYXJ0c1trXS5wdXNoKHNlZ21lbnRbMF0pO1xuXG4gIFx0XHRcdFx0Ly8gaWYgc2VnbWVudCBnb2VzIG91dCBvZiBzY3JlZW4sIG9yIGl0J3MgdGhlIGxhc3Qgb25lLCBpdCdzIHRoZSBlbmQgb2YgdGhlIGxpbmUgcGFydFxuICBcdFx0XHRcdGlmICgoc2VnbWVudFsxXSAhPT0gcG9pbnRzW2ogKyAxXSkgfHwgKGogPT09IGxlbjIgLSAyKSkge1xuICBcdFx0XHRcdFx0cGFydHNba10ucHVzaChzZWdtZW50WzFdKTtcbiAgXHRcdFx0XHRcdGsrKztcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0Ly8gc2ltcGxpZnkgZWFjaCBjbGlwcGVkIHBhcnQgb2YgdGhlIHBvbHlsaW5lIGZvciBwZXJmb3JtYW5jZVxuICBcdF9zaW1wbGlmeVBvaW50czogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIHBhcnRzID0gdGhpcy5fcGFydHMsXG4gIFx0XHQgICAgdG9sZXJhbmNlID0gdGhpcy5vcHRpb25zLnNtb290aEZhY3RvcjtcblxuICBcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gIFx0XHRcdHBhcnRzW2ldID0gc2ltcGxpZnkocGFydHNbaV0sIHRvbGVyYW5jZSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxuXG4gIFx0XHR0aGlzLl9jbGlwUG9pbnRzKCk7XG4gIFx0XHR0aGlzLl9zaW1wbGlmeVBvaW50cygpO1xuICBcdFx0dGhpcy5fdXBkYXRlUGF0aCgpO1xuICBcdH0sXG5cbiAgXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVBvbHkodGhpcyk7XG4gIFx0fSxcblxuICBcdC8vIE5lZWRlZCBieSB0aGUgYENhbnZhc2AgcmVuZGVyZXIgZm9yIGludGVyYWN0aXZpdHlcbiAgXHRfY29udGFpbnNQb2ludDogZnVuY3Rpb24gKHAsIGNsb3NlZCkge1xuICBcdFx0dmFyIGksIGosIGssIGxlbiwgbGVuMiwgcGFydCxcbiAgXHRcdCAgICB3ID0gdGhpcy5fY2xpY2tUb2xlcmFuY2UoKTtcblxuICBcdFx0aWYgKCF0aGlzLl9weEJvdW5kcyB8fCAhdGhpcy5fcHhCb3VuZHMuY29udGFpbnMocCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgXHRcdC8vIGhpdCBkZXRlY3Rpb24gZm9yIHBvbHlsaW5lc1xuICBcdFx0Zm9yIChpID0gMCwgbGVuID0gdGhpcy5fcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0cGFydCA9IHRoaXMuX3BhcnRzW2ldO1xuXG4gIFx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwYXJ0Lmxlbmd0aCwgayA9IGxlbjIgLSAxOyBqIDwgbGVuMjsgayA9IGorKykge1xuICBcdFx0XHRcdGlmICghY2xvc2VkICYmIChqID09PSAwKSkgeyBjb250aW51ZTsgfVxuXG4gIFx0XHRcdFx0aWYgKHBvaW50VG9TZWdtZW50RGlzdGFuY2UocCwgcGFydFtrXSwgcGFydFtqXSkgPD0gdykge1xuICBcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0fVxuICB9KTtcblxuICAvLyBAZmFjdG9yeSBMLnBvbHlsaW5lKGxhdGxuZ3M6IExhdExuZ1tdLCBvcHRpb25zPzogUG9seWxpbmUgb3B0aW9ucylcbiAgLy8gSW5zdGFudGlhdGVzIGEgcG9seWxpbmUgb2JqZWN0IGdpdmVuIGFuIGFycmF5IG9mIGdlb2dyYXBoaWNhbCBwb2ludHMgYW5kXG4gIC8vIG9wdGlvbmFsbHkgYW4gb3B0aW9ucyBvYmplY3QuIFlvdSBjYW4gY3JlYXRlIGEgYFBvbHlsaW5lYCBvYmplY3Qgd2l0aFxuICAvLyBtdWx0aXBsZSBzZXBhcmF0ZSBsaW5lcyAoYE11bHRpUG9seWxpbmVgKSBieSBwYXNzaW5nIGFuIGFycmF5IG9mIGFycmF5c1xuICAvLyBvZiBnZW9ncmFwaGljIHBvaW50cy5cbiAgZnVuY3Rpb24gcG9seWxpbmUobGF0bG5ncywgb3B0aW9ucykge1xuICBcdHJldHVybiBuZXcgUG9seWxpbmUobGF0bG5ncywgb3B0aW9ucyk7XG4gIH1cblxuICAvLyBSZXRyb2NvbXBhdC4gQWxsb3cgcGx1Z2lucyB0byBzdXBwb3J0IExlYWZsZXQgdmVyc2lvbnMgYmVmb3JlIGFuZCBhZnRlciAxLjEuXG4gIFBvbHlsaW5lLl9mbGF0ID0gX2ZsYXQ7XG5cbiAgLypcbiAgICogQGNsYXNzIFBvbHlnb25cbiAgICogQGFrYSBMLlBvbHlnb25cbiAgICogQGluaGVyaXRzIFBvbHlsaW5lXG4gICAqXG4gICAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgcG9seWdvbiBvdmVybGF5cyBvbiBhIG1hcC4gRXh0ZW5kcyBgUG9seWxpbmVgLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgcG9pbnRzIHlvdSBwYXNzIHdoZW4gY3JlYXRpbmcgYSBwb2x5Z29uIHNob3VsZG4ndCBoYXZlIGFuIGFkZGl0aW9uYWwgbGFzdCBwb2ludCBlcXVhbCB0byB0aGUgZmlyc3Qgb25lIOKAlCBpdCdzIGJldHRlciB0byBmaWx0ZXIgb3V0IHN1Y2ggcG9pbnRzLlxuICAgKlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGBqc1xuICAgKiAvLyBjcmVhdGUgYSByZWQgcG9seWdvbiBmcm9tIGFuIGFycmF5IG9mIExhdExuZyBwb2ludHNcbiAgICogdmFyIGxhdGxuZ3MgPSBbWzM3LCAtMTA5LjA1XSxbNDEsIC0xMDkuMDNdLFs0MSwgLTEwMi4wNV0sWzM3LCAtMTAyLjA0XV07XG4gICAqXG4gICAqIHZhciBwb2x5Z29uID0gTC5wb2x5Z29uKGxhdGxuZ3MsIHtjb2xvcjogJ3JlZCd9KS5hZGRUbyhtYXApO1xuICAgKlxuICAgKiAvLyB6b29tIHRoZSBtYXAgdG8gdGhlIHBvbHlnb25cbiAgICogbWFwLmZpdEJvdW5kcyhwb2x5Z29uLmdldEJvdW5kcygpKTtcbiAgICogYGBgXG4gICAqXG4gICAqIFlvdSBjYW4gYWxzbyBwYXNzIGFuIGFycmF5IG9mIGFycmF5cyBvZiBsYXRsbmdzLCB3aXRoIHRoZSBmaXJzdCBhcnJheSByZXByZXNlbnRpbmcgdGhlIG91dGVyIHNoYXBlIGFuZCB0aGUgb3RoZXIgYXJyYXlzIHJlcHJlc2VudGluZyBob2xlcyBpbiB0aGUgb3V0ZXIgc2hhcGU6XG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHZhciBsYXRsbmdzID0gW1xuICAgKiAgIFtbMzcsIC0xMDkuMDVdLFs0MSwgLTEwOS4wM10sWzQxLCAtMTAyLjA1XSxbMzcsIC0xMDIuMDRdXSwgLy8gb3V0ZXIgcmluZ1xuICAgKiAgIFtbMzcuMjksIC0xMDguNThdLFs0MC43MSwgLTEwOC41OF0sWzQwLjcxLCAtMTAyLjUwXSxbMzcuMjksIC0xMDIuNTBdXSAvLyBob2xlXG4gICAqIF07XG4gICAqIGBgYFxuICAgKlxuICAgKiBBZGRpdGlvbmFsbHksIHlvdSBjYW4gcGFzcyBhIG11bHRpLWRpbWVuc2lvbmFsIGFycmF5IHRvIHJlcHJlc2VudCBhIE11bHRpUG9seWdvbiBzaGFwZS5cbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIGxhdGxuZ3MgPSBbXG4gICAqICAgWyAvLyBmaXJzdCBwb2x5Z29uXG4gICAqICAgICBbWzM3LCAtMTA5LjA1XSxbNDEsIC0xMDkuMDNdLFs0MSwgLTEwMi4wNV0sWzM3LCAtMTAyLjA0XV0sIC8vIG91dGVyIHJpbmdcbiAgICogICAgIFtbMzcuMjksIC0xMDguNThdLFs0MC43MSwgLTEwOC41OF0sWzQwLjcxLCAtMTAyLjUwXSxbMzcuMjksIC0xMDIuNTBdXSAvLyBob2xlXG4gICAqICAgXSxcbiAgICogICBbIC8vIHNlY29uZCBwb2x5Z29uXG4gICAqICAgICBbWzQxLCAtMTExLjAzXSxbNDUsIC0xMTEuMDRdLFs0NSwgLTEwNC4wNV0sWzQxLCAtMTA0LjA1XV1cbiAgICogICBdXG4gICAqIF07XG4gICAqIGBgYFxuICAgKi9cblxuICB2YXIgUG9seWdvbiA9IFBvbHlsaW5lLmV4dGVuZCh7XG5cbiAgXHRvcHRpb25zOiB7XG4gIFx0XHRmaWxsOiB0cnVlXG4gIFx0fSxcblxuICBcdGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiAhdGhpcy5fbGF0bG5ncy5sZW5ndGggfHwgIXRoaXMuX2xhdGxuZ3NbMF0ubGVuZ3RoO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGdldENlbnRlcigpOiBMYXRMbmdcbiAgXHQvLyBSZXR1cm5zIHRoZSBjZW50ZXIgKFtjZW50cm9pZF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DZW50cm9pZCkpIG9mIHRoZSBQb2x5Z29uLlxuICBcdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0Ly8gdGhyb3dzIGVycm9yIHdoZW4gbm90IHlldCBhZGRlZCB0byBtYXAgYXMgdGhpcyBjZW50ZXIgY2FsY3VsYXRpb24gcmVxdWlyZXMgcHJvamVjdGVkIGNvb3JkaW5hdGVzXG4gIFx0XHRpZiAoIXRoaXMuX21hcCkge1xuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ011c3QgYWRkIGxheWVyIHRvIG1hcCBiZWZvcmUgdXNpbmcgZ2V0Q2VudGVyKCknKTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiBwb2x5Z29uQ2VudGVyKHRoaXMuX2RlZmF1bHRTaGFwZSgpLCB0aGlzLl9tYXAub3B0aW9ucy5jcnMpO1xuICBcdH0sXG5cbiAgXHRfY29udmVydExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG4gIFx0XHR2YXIgcmVzdWx0ID0gUG9seWxpbmUucHJvdG90eXBlLl9jb252ZXJ0TGF0TG5ncy5jYWxsKHRoaXMsIGxhdGxuZ3MpLFxuICBcdFx0ICAgIGxlbiA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgXHRcdC8vIHJlbW92ZSBsYXN0IHBvaW50IGlmIGl0IGVxdWFscyBmaXJzdCBvbmVcbiAgXHRcdGlmIChsZW4gPj0gMiAmJiByZXN1bHRbMF0gaW5zdGFuY2VvZiBMYXRMbmcgJiYgcmVzdWx0WzBdLmVxdWFscyhyZXN1bHRbbGVuIC0gMV0pKSB7XG4gIFx0XHRcdHJlc3VsdC5wb3AoKTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiByZXN1bHQ7XG4gIFx0fSxcblxuICBcdF9zZXRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuICBcdFx0UG9seWxpbmUucHJvdG90eXBlLl9zZXRMYXRMbmdzLmNhbGwodGhpcywgbGF0bG5ncyk7XG4gIFx0XHRpZiAoaXNGbGF0KHRoaXMuX2xhdGxuZ3MpKSB7XG4gIFx0XHRcdHRoaXMuX2xhdGxuZ3MgPSBbdGhpcy5fbGF0bG5nc107XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9kZWZhdWx0U2hhcGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiBpc0ZsYXQodGhpcy5fbGF0bG5nc1swXSkgPyB0aGlzLl9sYXRsbmdzWzBdIDogdGhpcy5fbGF0bG5nc1swXVswXTtcbiAgXHR9LFxuXG4gIFx0X2NsaXBQb2ludHM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdC8vIHBvbHlnb25zIG5lZWQgYSBkaWZmZXJlbnQgY2xpcHBpbmcgYWxnb3JpdGhtIHNvIHdlIHJlZGVmaW5lIHRoYXRcblxuICBcdFx0dmFyIGJvdW5kcyA9IHRoaXMuX3JlbmRlcmVyLl9ib3VuZHMsXG4gIFx0XHQgICAgdyA9IHRoaXMub3B0aW9ucy53ZWlnaHQsXG4gIFx0XHQgICAgcCA9IG5ldyBQb2ludCh3LCB3KTtcblxuICBcdFx0Ly8gaW5jcmVhc2UgY2xpcCBwYWRkaW5nIGJ5IHN0cm9rZSB3aWR0aCB0byBhdm9pZCBzdHJva2Ugb24gY2xpcCBlZGdlc1xuICBcdFx0Ym91bmRzID0gbmV3IEJvdW5kcyhib3VuZHMubWluLnN1YnRyYWN0KHApLCBib3VuZHMubWF4LmFkZChwKSk7XG5cbiAgXHRcdHRoaXMuX3BhcnRzID0gW107XG4gIFx0XHRpZiAoIXRoaXMuX3B4Qm91bmRzIHx8ICF0aGlzLl9weEJvdW5kcy5pbnRlcnNlY3RzKGJvdW5kcykpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLm5vQ2xpcCkge1xuICBcdFx0XHR0aGlzLl9wYXJ0cyA9IHRoaXMuX3JpbmdzO1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9yaW5ncy5sZW5ndGgsIGNsaXBwZWQ7IGkgPCBsZW47IGkrKykge1xuICBcdFx0XHRjbGlwcGVkID0gY2xpcFBvbHlnb24odGhpcy5fcmluZ3NbaV0sIGJvdW5kcywgdHJ1ZSk7XG4gIFx0XHRcdGlmIChjbGlwcGVkLmxlbmd0aCkge1xuICBcdFx0XHRcdHRoaXMuX3BhcnRzLnB1c2goY2xpcHBlZCk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVQb2x5KHRoaXMsIHRydWUpO1xuICBcdH0sXG5cbiAgXHQvLyBOZWVkZWQgYnkgdGhlIGBDYW52YXNgIHJlbmRlcmVyIGZvciBpbnRlcmFjdGl2aXR5XG4gIFx0X2NvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uIChwKSB7XG4gIFx0XHR2YXIgaW5zaWRlID0gZmFsc2UsXG4gIFx0XHQgICAgcGFydCwgcDEsIHAyLCBpLCBqLCBrLCBsZW4sIGxlbjI7XG5cbiAgXHRcdGlmICghdGhpcy5fcHhCb3VuZHMgfHwgIXRoaXMuX3B4Qm91bmRzLmNvbnRhaW5zKHApKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIFx0XHQvLyByYXkgY2FzdGluZyBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBpZiBwb2ludCBpcyBpbiBwb2x5Z29uXG4gIFx0XHRmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9wYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICBcdFx0XHRwYXJ0ID0gdGhpcy5fcGFydHNbaV07XG5cbiAgXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBhcnQubGVuZ3RoLCBrID0gbGVuMiAtIDE7IGogPCBsZW4yOyBrID0gaisrKSB7XG4gIFx0XHRcdFx0cDEgPSBwYXJ0W2pdO1xuICBcdFx0XHRcdHAyID0gcGFydFtrXTtcblxuICBcdFx0XHRcdGlmICgoKHAxLnkgPiBwLnkpICE9PSAocDIueSA+IHAueSkpICYmIChwLnggPCAocDIueCAtIHAxLngpICogKHAueSAtIHAxLnkpIC8gKHAyLnkgLSBwMS55KSArIHAxLngpKSB7XG4gIFx0XHRcdFx0XHRpbnNpZGUgPSAhaW5zaWRlO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHQvLyBhbHNvIGNoZWNrIGlmIGl0J3Mgb24gcG9seWdvbiBzdHJva2VcbiAgXHRcdHJldHVybiBpbnNpZGUgfHwgUG9seWxpbmUucHJvdG90eXBlLl9jb250YWluc1BvaW50LmNhbGwodGhpcywgcCwgdHJ1ZSk7XG4gIFx0fVxuXG4gIH0pO1xuXG5cbiAgLy8gQGZhY3RvcnkgTC5wb2x5Z29uKGxhdGxuZ3M6IExhdExuZ1tdLCBvcHRpb25zPzogUG9seWxpbmUgb3B0aW9ucylcbiAgZnVuY3Rpb24gcG9seWdvbihsYXRsbmdzLCBvcHRpb25zKSB7XG4gIFx0cmV0dXJuIG5ldyBQb2x5Z29uKGxhdGxuZ3MsIG9wdGlvbnMpO1xuICB9XG5cbiAgLypcclxuICAgKiBAY2xhc3MgR2VvSlNPTlxyXG4gICAqIEBha2EgTC5HZW9KU09OXHJcbiAgICogQGluaGVyaXRzIEZlYXR1cmVHcm91cFxyXG4gICAqXHJcbiAgICogUmVwcmVzZW50cyBhIEdlb0pTT04gb2JqZWN0IG9yIGFuIGFycmF5IG9mIEdlb0pTT04gb2JqZWN0cy4gQWxsb3dzIHlvdSB0byBwYXJzZVxyXG4gICAqIEdlb0pTT04gZGF0YSBhbmQgZGlzcGxheSBpdCBvbiB0aGUgbWFwLiBFeHRlbmRzIGBGZWF0dXJlR3JvdXBgLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogTC5nZW9KU09OKGRhdGEsIHtcclxuICAgKiBcdHN0eWxlOiBmdW5jdGlvbiAoZmVhdHVyZSkge1xyXG4gICAqIFx0XHRyZXR1cm4ge2NvbG9yOiBmZWF0dXJlLnByb3BlcnRpZXMuY29sb3J9O1xyXG4gICAqIFx0fVxyXG4gICAqIH0pLmJpbmRQb3B1cChmdW5jdGlvbiAobGF5ZXIpIHtcclxuICAgKiBcdHJldHVybiBsYXllci5mZWF0dXJlLnByb3BlcnRpZXMuZGVzY3JpcHRpb247XHJcbiAgICogfSkuYWRkVG8obWFwKTtcclxuICAgKiBgYGBcclxuICAgKi9cclxuXHJcbiAgdmFyIEdlb0pTT04gPSBGZWF0dXJlR3JvdXAuZXh0ZW5kKHtcclxuXHJcbiAgXHQvKiBAc2VjdGlvblxyXG4gIFx0ICogQGFrYSBHZW9KU09OIG9wdGlvbnNcclxuICBcdCAqXHJcbiAgXHQgKiBAb3B0aW9uIHBvaW50VG9MYXllcjogRnVuY3Rpb24gPSAqXHJcbiAgXHQgKiBBIGBGdW5jdGlvbmAgZGVmaW5pbmcgaG93IEdlb0pTT04gcG9pbnRzIHNwYXduIExlYWZsZXQgbGF5ZXJzLiBJdCBpcyBpbnRlcm5hbGx5XHJcbiAgXHQgKiBjYWxsZWQgd2hlbiBkYXRhIGlzIGFkZGVkLCBwYXNzaW5nIHRoZSBHZW9KU09OIHBvaW50IGZlYXR1cmUgYW5kIGl0cyBgTGF0TG5nYC5cclxuICBcdCAqIFRoZSBkZWZhdWx0IGlzIHRvIHNwYXduIGEgZGVmYXVsdCBgTWFya2VyYDpcclxuICBcdCAqIGBgYGpzXHJcbiAgXHQgKiBmdW5jdGlvbihnZW9Kc29uUG9pbnQsIGxhdGxuZykge1xyXG4gIFx0ICogXHRyZXR1cm4gTC5tYXJrZXIobGF0bG5nKTtcclxuICBcdCAqIH1cclxuICBcdCAqIGBgYFxyXG4gIFx0ICpcclxuICBcdCAqIEBvcHRpb24gc3R5bGU6IEZ1bmN0aW9uID0gKlxyXG4gIFx0ICogQSBgRnVuY3Rpb25gIGRlZmluaW5nIHRoZSBgUGF0aCBvcHRpb25zYCBmb3Igc3R5bGluZyBHZW9KU09OIGxpbmVzIGFuZCBwb2x5Z29ucyxcclxuICBcdCAqIGNhbGxlZCBpbnRlcm5hbGx5IHdoZW4gZGF0YSBpcyBhZGRlZC5cclxuICBcdCAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRvIG5vdCBvdmVycmlkZSBhbnkgZGVmYXVsdHM6XHJcbiAgXHQgKiBgYGBqc1xyXG4gIFx0ICogZnVuY3Rpb24gKGdlb0pzb25GZWF0dXJlKSB7XHJcbiAgXHQgKiBcdHJldHVybiB7fVxyXG4gIFx0ICogfVxyXG4gIFx0ICogYGBgXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiBvbkVhY2hGZWF0dXJlOiBGdW5jdGlvbiA9ICpcclxuICBcdCAqIEEgYEZ1bmN0aW9uYCB0aGF0IHdpbGwgYmUgY2FsbGVkIG9uY2UgZm9yIGVhY2ggY3JlYXRlZCBgRmVhdHVyZWAsIGFmdGVyIGl0IGhhc1xyXG4gIFx0ICogYmVlbiBjcmVhdGVkIGFuZCBzdHlsZWQuIFVzZWZ1bCBmb3IgYXR0YWNoaW5nIGV2ZW50cyBhbmQgcG9wdXBzIHRvIGZlYXR1cmVzLlxyXG4gIFx0ICogVGhlIGRlZmF1bHQgaXMgdG8gZG8gbm90aGluZyB3aXRoIHRoZSBuZXdseSBjcmVhdGVkIGxheWVyczpcclxuICBcdCAqIGBgYGpzXHJcbiAgXHQgKiBmdW5jdGlvbiAoZmVhdHVyZSwgbGF5ZXIpIHt9XHJcbiAgXHQgKiBgYGBcclxuICBcdCAqXHJcbiAgXHQgKiBAb3B0aW9uIGZpbHRlcjogRnVuY3Rpb24gPSAqXHJcbiAgXHQgKiBBIGBGdW5jdGlvbmAgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZGVjaWRlIHdoZXRoZXIgdG8gaW5jbHVkZSBhIGZlYXR1cmUgb3Igbm90LlxyXG4gIFx0ICogVGhlIGRlZmF1bHQgaXMgdG8gaW5jbHVkZSBhbGwgZmVhdHVyZXM6XHJcbiAgXHQgKiBgYGBqc1xyXG4gIFx0ICogZnVuY3Rpb24gKGdlb0pzb25GZWF0dXJlKSB7XHJcbiAgXHQgKiBcdHJldHVybiB0cnVlO1xyXG4gIFx0ICogfVxyXG4gIFx0ICogYGBgXHJcbiAgXHQgKiBOb3RlOiBkeW5hbWljYWxseSBjaGFuZ2luZyB0aGUgYGZpbHRlcmAgb3B0aW9uIHdpbGwgaGF2ZSBlZmZlY3Qgb25seSBvbiBuZXdseVxyXG4gIFx0ICogYWRkZWQgZGF0YS4gSXQgd2lsbCBfbm90XyByZS1ldmFsdWF0ZSBhbHJlYWR5IGluY2x1ZGVkIGZlYXR1cmVzLlxyXG4gIFx0ICpcclxuICBcdCAqIEBvcHRpb24gY29vcmRzVG9MYXRMbmc6IEZ1bmN0aW9uID0gKlxyXG4gIFx0ICogQSBgRnVuY3Rpb25gIHRoYXQgd2lsbCBiZSB1c2VkIGZvciBjb252ZXJ0aW5nIEdlb0pTT04gY29vcmRpbmF0ZXMgdG8gYExhdExuZ2BzLlxyXG4gIFx0ICogVGhlIGRlZmF1bHQgaXMgdGhlIGBjb29yZHNUb0xhdExuZ2Agc3RhdGljIG1ldGhvZC5cclxuICBcdCAqXHJcbiAgXHQgKiBAb3B0aW9uIG1hcmtlcnNJbmhlcml0T3B0aW9uczogQm9vbGVhbiA9IGZhbHNlXHJcbiAgXHQgKiBXaGV0aGVyIGRlZmF1bHQgTWFya2VycyBmb3IgXCJQb2ludFwiIHR5cGUgRmVhdHVyZXMgaW5oZXJpdCBmcm9tIGdyb3VwIG9wdGlvbnMuXHJcbiAgXHQgKi9cclxuXHJcbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoZ2VvanNvbiwgb3B0aW9ucykge1xyXG4gIFx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuICBcdFx0dGhpcy5fbGF5ZXJzID0ge307XHJcblxyXG4gIFx0XHRpZiAoZ2VvanNvbikge1xyXG4gIFx0XHRcdHRoaXMuYWRkRGF0YShnZW9qc29uKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGFkZERhdGEoIDxHZW9KU09OPiBkYXRhICk6IHRoaXNcclxuICBcdC8vIEFkZHMgYSBHZW9KU09OIG9iamVjdCB0byB0aGUgbGF5ZXIuXHJcbiAgXHRhZGREYXRhOiBmdW5jdGlvbiAoZ2VvanNvbikge1xyXG4gIFx0XHR2YXIgZmVhdHVyZXMgPSBpc0FycmF5KGdlb2pzb24pID8gZ2VvanNvbiA6IGdlb2pzb24uZmVhdHVyZXMsXHJcbiAgXHRcdCAgICBpLCBsZW4sIGZlYXR1cmU7XHJcblxyXG4gIFx0XHRpZiAoZmVhdHVyZXMpIHtcclxuICBcdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBmZWF0dXJlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRcdFx0Ly8gb25seSBhZGQgdGhpcyBpZiBnZW9tZXRyeSBvciBnZW9tZXRyaWVzIGFyZSBzZXQgYW5kIG5vdCBudWxsXHJcbiAgXHRcdFx0XHRmZWF0dXJlID0gZmVhdHVyZXNbaV07XHJcbiAgXHRcdFx0XHRpZiAoZmVhdHVyZS5nZW9tZXRyaWVzIHx8IGZlYXR1cmUuZ2VvbWV0cnkgfHwgZmVhdHVyZS5mZWF0dXJlcyB8fCBmZWF0dXJlLmNvb3JkaW5hdGVzKSB7XHJcbiAgXHRcdFx0XHRcdHRoaXMuYWRkRGF0YShmZWF0dXJlKTtcclxuICBcdFx0XHRcdH1cclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cclxuICBcdFx0aWYgKG9wdGlvbnMuZmlsdGVyICYmICFvcHRpb25zLmZpbHRlcihnZW9qc29uKSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuICBcdFx0dmFyIGxheWVyID0gZ2VvbWV0cnlUb0xheWVyKGdlb2pzb24sIG9wdGlvbnMpO1xyXG4gIFx0XHRpZiAoIWxheWVyKSB7XHJcbiAgXHRcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHRcdH1cclxuICBcdFx0bGF5ZXIuZmVhdHVyZSA9IGFzRmVhdHVyZShnZW9qc29uKTtcclxuXHJcbiAgXHRcdGxheWVyLmRlZmF1bHRPcHRpb25zID0gbGF5ZXIub3B0aW9ucztcclxuICBcdFx0dGhpcy5yZXNldFN0eWxlKGxheWVyKTtcclxuXHJcbiAgXHRcdGlmIChvcHRpb25zLm9uRWFjaEZlYXR1cmUpIHtcclxuICBcdFx0XHRvcHRpb25zLm9uRWFjaEZlYXR1cmUoZ2VvanNvbiwgbGF5ZXIpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcy5hZGRMYXllcihsYXllcik7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgcmVzZXRTdHlsZSggPFBhdGg+IGxheWVyPyApOiB0aGlzXHJcbiAgXHQvLyBSZXNldHMgdGhlIGdpdmVuIHZlY3RvciBsYXllcidzIHN0eWxlIHRvIHRoZSBvcmlnaW5hbCBHZW9KU09OIHN0eWxlLCB1c2VmdWwgZm9yIHJlc2V0dGluZyBzdHlsZSBhZnRlciBob3ZlciBldmVudHMuXHJcbiAgXHQvLyBJZiBgbGF5ZXJgIGlzIG9taXR0ZWQsIHRoZSBzdHlsZSBvZiBhbGwgZmVhdHVyZXMgaW4gdGhlIGN1cnJlbnQgbGF5ZXIgaXMgcmVzZXQuXHJcbiAgXHRyZXNldFN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuICBcdFx0aWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcclxuICBcdFx0XHRyZXR1cm4gdGhpcy5lYWNoTGF5ZXIodGhpcy5yZXNldFN0eWxlLCB0aGlzKTtcclxuICBcdFx0fVxyXG4gIFx0XHQvLyByZXNldCBhbnkgY3VzdG9tIHN0eWxlc1xyXG4gIFx0XHRsYXllci5vcHRpb25zID0gZXh0ZW5kKHt9LCBsYXllci5kZWZhdWx0T3B0aW9ucyk7XHJcbiAgXHRcdHRoaXMuX3NldExheWVyU3R5bGUobGF5ZXIsIHRoaXMub3B0aW9ucy5zdHlsZSk7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldFN0eWxlKCA8RnVuY3Rpb24+IHN0eWxlICk6IHRoaXNcclxuICBcdC8vIENoYW5nZXMgc3R5bGVzIG9mIEdlb0pTT04gdmVjdG9yIGxheWVycyB3aXRoIHRoZSBnaXZlbiBzdHlsZSBmdW5jdGlvbi5cclxuICBcdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG4gIFx0XHRcdHRoaXMuX3NldExheWVyU3R5bGUobGF5ZXIsIHN0eWxlKTtcclxuICBcdFx0fSwgdGhpcyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9zZXRMYXllclN0eWxlOiBmdW5jdGlvbiAobGF5ZXIsIHN0eWxlKSB7XHJcbiAgXHRcdGlmIChsYXllci5zZXRTdHlsZSkge1xyXG4gIFx0XHRcdGlmICh0eXBlb2Ygc3R5bGUgPT09ICdmdW5jdGlvbicpIHtcclxuICBcdFx0XHRcdHN0eWxlID0gc3R5bGUobGF5ZXIuZmVhdHVyZSk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHRcdGxheWVyLnNldFN0eWxlKHN0eWxlKTtcclxuICBcdFx0fVxyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuICAvLyBAc2VjdGlvblxyXG4gIC8vIFRoZXJlIGFyZSBzZXZlcmFsIHN0YXRpYyBmdW5jdGlvbnMgd2hpY2ggY2FuIGJlIGNhbGxlZCB3aXRob3V0IGluc3RhbnRpYXRpbmcgTC5HZW9KU09OOlxyXG5cclxuICAvLyBAZnVuY3Rpb24gZ2VvbWV0cnlUb0xheWVyKGZlYXR1cmVEYXRhOiBPYmplY3QsIG9wdGlvbnM/OiBHZW9KU09OIG9wdGlvbnMpOiBMYXllclxyXG4gIC8vIENyZWF0ZXMgYSBgTGF5ZXJgIGZyb20gYSBnaXZlbiBHZW9KU09OIGZlYXR1cmUuIENhbiB1c2UgYSBjdXN0b21cclxuICAvLyBbYHBvaW50VG9MYXllcmBdKCNnZW9qc29uLXBvaW50dG9sYXllcikgYW5kL29yIFtgY29vcmRzVG9MYXRMbmdgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZylcclxuICAvLyBmdW5jdGlvbnMgaWYgcHJvdmlkZWQgYXMgb3B0aW9ucy5cclxuICBmdW5jdGlvbiBnZW9tZXRyeVRvTGF5ZXIoZ2VvanNvbiwgb3B0aW9ucykge1xyXG5cclxuICBcdHZhciBnZW9tZXRyeSA9IGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmUnID8gZ2VvanNvbi5nZW9tZXRyeSA6IGdlb2pzb24sXHJcbiAgXHQgICAgY29vcmRzID0gZ2VvbWV0cnkgPyBnZW9tZXRyeS5jb29yZGluYXRlcyA6IG51bGwsXHJcbiAgXHQgICAgbGF5ZXJzID0gW10sXHJcbiAgXHQgICAgcG9pbnRUb0xheWVyID0gb3B0aW9ucyAmJiBvcHRpb25zLnBvaW50VG9MYXllcixcclxuICBcdCAgICBfY29vcmRzVG9MYXRMbmcgPSBvcHRpb25zICYmIG9wdGlvbnMuY29vcmRzVG9MYXRMbmcgfHwgY29vcmRzVG9MYXRMbmcsXHJcbiAgXHQgICAgbGF0bG5nLCBsYXRsbmdzLCBpLCBsZW47XHJcblxyXG4gIFx0aWYgKCFjb29yZHMgJiYgIWdlb21ldHJ5KSB7XHJcbiAgXHRcdHJldHVybiBudWxsO1xyXG4gIFx0fVxyXG5cclxuICBcdHN3aXRjaCAoZ2VvbWV0cnkudHlwZSkge1xyXG4gIFx0Y2FzZSAnUG9pbnQnOlxyXG4gIFx0XHRsYXRsbmcgPSBfY29vcmRzVG9MYXRMbmcoY29vcmRzKTtcclxuICBcdFx0cmV0dXJuIF9wb2ludFRvTGF5ZXIocG9pbnRUb0xheWVyLCBnZW9qc29uLCBsYXRsbmcsIG9wdGlvbnMpO1xyXG5cclxuICBcdGNhc2UgJ011bHRpUG9pbnQnOlxyXG4gIFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb29yZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0XHRsYXRsbmcgPSBfY29vcmRzVG9MYXRMbmcoY29vcmRzW2ldKTtcclxuICBcdFx0XHRsYXllcnMucHVzaChfcG9pbnRUb0xheWVyKHBvaW50VG9MYXllciwgZ2VvanNvbiwgbGF0bG5nLCBvcHRpb25zKSk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIG5ldyBGZWF0dXJlR3JvdXAobGF5ZXJzKTtcclxuXHJcbiAgXHRjYXNlICdMaW5lU3RyaW5nJzpcclxuICBcdGNhc2UgJ011bHRpTGluZVN0cmluZyc6XHJcbiAgXHRcdGxhdGxuZ3MgPSBjb29yZHNUb0xhdExuZ3MoY29vcmRzLCBnZW9tZXRyeS50eXBlID09PSAnTGluZVN0cmluZycgPyAwIDogMSwgX2Nvb3Jkc1RvTGF0TG5nKTtcclxuICBcdFx0cmV0dXJuIG5ldyBQb2x5bGluZShsYXRsbmdzLCBvcHRpb25zKTtcclxuXHJcbiAgXHRjYXNlICdQb2x5Z29uJzpcclxuICBcdGNhc2UgJ011bHRpUG9seWdvbic6XHJcbiAgXHRcdGxhdGxuZ3MgPSBjb29yZHNUb0xhdExuZ3MoY29vcmRzLCBnZW9tZXRyeS50eXBlID09PSAnUG9seWdvbicgPyAxIDogMiwgX2Nvb3Jkc1RvTGF0TG5nKTtcclxuICBcdFx0cmV0dXJuIG5ldyBQb2x5Z29uKGxhdGxuZ3MsIG9wdGlvbnMpO1xyXG5cclxuICBcdGNhc2UgJ0dlb21ldHJ5Q29sbGVjdGlvbic6XHJcbiAgXHRcdGZvciAoaSA9IDAsIGxlbiA9IGdlb21ldHJ5Lmdlb21ldHJpZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0XHR2YXIgZ2VvTGF5ZXIgPSBnZW9tZXRyeVRvTGF5ZXIoe1xyXG4gIFx0XHRcdFx0Z2VvbWV0cnk6IGdlb21ldHJ5Lmdlb21ldHJpZXNbaV0sXHJcbiAgXHRcdFx0XHR0eXBlOiAnRmVhdHVyZScsXHJcbiAgXHRcdFx0XHRwcm9wZXJ0aWVzOiBnZW9qc29uLnByb3BlcnRpZXNcclxuICBcdFx0XHR9LCBvcHRpb25zKTtcclxuXHJcbiAgXHRcdFx0aWYgKGdlb0xheWVyKSB7XHJcbiAgXHRcdFx0XHRsYXllcnMucHVzaChnZW9MYXllcik7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiBuZXcgRmVhdHVyZUdyb3VwKGxheWVycyk7XHJcblxyXG4gIFx0Y2FzZSAnRmVhdHVyZUNvbGxlY3Rpb24nOlxyXG4gIFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBnZW9tZXRyeS5mZWF0dXJlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRcdHZhciBmZWF0dXJlTGF5ZXIgPSBnZW9tZXRyeVRvTGF5ZXIoZ2VvbWV0cnkuZmVhdHVyZXNbaV0sIG9wdGlvbnMpO1xyXG5cclxuICBcdFx0XHRpZiAoZmVhdHVyZUxheWVyKSB7XHJcbiAgXHRcdFx0XHRsYXllcnMucHVzaChmZWF0dXJlTGF5ZXIpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gbmV3IEZlYXR1cmVHcm91cChsYXllcnMpO1xyXG5cclxuICBcdGRlZmF1bHQ6XHJcbiAgXHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBHZW9KU09OIG9iamVjdC4nKTtcclxuICBcdH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIF9wb2ludFRvTGF5ZXIocG9pbnRUb0xheWVyRm4sIGdlb2pzb24sIGxhdGxuZywgb3B0aW9ucykge1xyXG4gIFx0cmV0dXJuIHBvaW50VG9MYXllckZuID9cclxuICBcdFx0cG9pbnRUb0xheWVyRm4oZ2VvanNvbiwgbGF0bG5nKSA6XHJcbiAgXHRcdG5ldyBNYXJrZXIobGF0bG5nLCBvcHRpb25zICYmIG9wdGlvbnMubWFya2Vyc0luaGVyaXRPcHRpb25zICYmIG9wdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGNvb3Jkc1RvTGF0TG5nKGNvb3JkczogQXJyYXkpOiBMYXRMbmdcclxuICAvLyBDcmVhdGVzIGEgYExhdExuZ2Agb2JqZWN0IGZyb20gYW4gYXJyYXkgb2YgMiBudW1iZXJzIChsb25naXR1ZGUsIGxhdGl0dWRlKVxyXG4gIC8vIG9yIDMgbnVtYmVycyAobG9uZ2l0dWRlLCBsYXRpdHVkZSwgYWx0aXR1ZGUpIHVzZWQgaW4gR2VvSlNPTiBmb3IgcG9pbnRzLlxyXG4gIGZ1bmN0aW9uIGNvb3Jkc1RvTGF0TG5nKGNvb3Jkcykge1xyXG4gIFx0cmV0dXJuIG5ldyBMYXRMbmcoY29vcmRzWzFdLCBjb29yZHNbMF0sIGNvb3Jkc1syXSk7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gY29vcmRzVG9MYXRMbmdzKGNvb3JkczogQXJyYXksIGxldmVsc0RlZXA/OiBOdW1iZXIsIGNvb3Jkc1RvTGF0TG5nPzogRnVuY3Rpb24pOiBBcnJheVxyXG4gIC8vIENyZWF0ZXMgYSBtdWx0aWRpbWVuc2lvbmFsIGFycmF5IG9mIGBMYXRMbmdgcyBmcm9tIGEgR2VvSlNPTiBjb29yZGluYXRlcyBhcnJheS5cclxuICAvLyBgbGV2ZWxzRGVlcGAgc3BlY2lmaWVzIHRoZSBuZXN0aW5nIGxldmVsICgwIGlzIGZvciBhbiBhcnJheSBvZiBwb2ludHMsIDEgZm9yIGFuIGFycmF5IG9mIGFycmF5cyBvZiBwb2ludHMsIGV0Yy4sIDAgYnkgZGVmYXVsdCkuXHJcbiAgLy8gQ2FuIHVzZSBhIGN1c3RvbSBbYGNvb3Jkc1RvTGF0TG5nYF0oI2dlb2pzb24tY29vcmRzdG9sYXRsbmcpIGZ1bmN0aW9uLlxyXG4gIGZ1bmN0aW9uIGNvb3Jkc1RvTGF0TG5ncyhjb29yZHMsIGxldmVsc0RlZXAsIF9jb29yZHNUb0xhdExuZykge1xyXG4gIFx0dmFyIGxhdGxuZ3MgPSBbXTtcclxuXHJcbiAgXHRmb3IgKHZhciBpID0gMCwgbGVuID0gY29vcmRzLmxlbmd0aCwgbGF0bG5nOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0bGF0bG5nID0gbGV2ZWxzRGVlcCA/XHJcbiAgXHRcdFx0Y29vcmRzVG9MYXRMbmdzKGNvb3Jkc1tpXSwgbGV2ZWxzRGVlcCAtIDEsIF9jb29yZHNUb0xhdExuZykgOlxyXG4gIFx0XHRcdChfY29vcmRzVG9MYXRMbmcgfHwgY29vcmRzVG9MYXRMbmcpKGNvb3Jkc1tpXSk7XHJcblxyXG4gIFx0XHRsYXRsbmdzLnB1c2gobGF0bG5nKTtcclxuICBcdH1cclxuXHJcbiAgXHRyZXR1cm4gbGF0bG5ncztcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBsYXRMbmdUb0Nvb3JkcyhsYXRsbmc6IExhdExuZywgcHJlY2lzaW9uPzogTnVtYmVyfGZhbHNlKTogQXJyYXlcclxuICAvLyBSZXZlcnNlIG9mIFtgY29vcmRzVG9MYXRMbmdgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZylcclxuICAvLyBDb29yZGluYXRlcyB2YWx1ZXMgYXJlIHJvdW5kZWQgd2l0aCBbYGZvcm1hdE51bWBdKCN1dGlsLWZvcm1hdG51bSkgZnVuY3Rpb24uXHJcbiAgZnVuY3Rpb24gbGF0TG5nVG9Db29yZHMobGF0bG5nLCBwcmVjaXNpb24pIHtcclxuICBcdGxhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XHJcbiAgXHRyZXR1cm4gbGF0bG5nLmFsdCAhPT0gdW5kZWZpbmVkID9cclxuICBcdFx0W2Zvcm1hdE51bShsYXRsbmcubG5nLCBwcmVjaXNpb24pLCBmb3JtYXROdW0obGF0bG5nLmxhdCwgcHJlY2lzaW9uKSwgZm9ybWF0TnVtKGxhdGxuZy5hbHQsIHByZWNpc2lvbildIDpcclxuICBcdFx0W2Zvcm1hdE51bShsYXRsbmcubG5nLCBwcmVjaXNpb24pLCBmb3JtYXROdW0obGF0bG5nLmxhdCwgcHJlY2lzaW9uKV07XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gbGF0TG5nc1RvQ29vcmRzKGxhdGxuZ3M6IEFycmF5LCBsZXZlbHNEZWVwPzogTnVtYmVyLCBjbG9zZWQ/OiBCb29sZWFuLCBwcmVjaXNpb24/OiBOdW1iZXJ8ZmFsc2UpOiBBcnJheVxyXG4gIC8vIFJldmVyc2Ugb2YgW2Bjb29yZHNUb0xhdExuZ3NgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZ3MpXHJcbiAgLy8gYGNsb3NlZGAgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBmaXJzdCBwb2ludCBzaG91bGQgYmUgYXBwZW5kZWQgdG8gdGhlIGVuZCBvZiB0aGUgYXJyYXkgdG8gY2xvc2UgdGhlIGZlYXR1cmUsIG9ubHkgdXNlZCB3aGVuIGBsZXZlbHNEZWVwYCBpcyAwLiBGYWxzZSBieSBkZWZhdWx0LlxyXG4gIC8vIENvb3JkaW5hdGVzIHZhbHVlcyBhcmUgcm91bmRlZCB3aXRoIFtgZm9ybWF0TnVtYF0oI3V0aWwtZm9ybWF0bnVtKSBmdW5jdGlvbi5cclxuICBmdW5jdGlvbiBsYXRMbmdzVG9Db29yZHMobGF0bG5ncywgbGV2ZWxzRGVlcCwgY2xvc2VkLCBwcmVjaXNpb24pIHtcclxuICBcdHZhciBjb29yZHMgPSBbXTtcclxuXHJcbiAgXHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF0bG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHQvLyBDaGVjayBmb3IgZmxhdCBhcnJheXMgcmVxdWlyZWQgdG8gZW5zdXJlIHVuYmFsYW5jZWQgYXJyYXlzIGFyZSBjb3JyZWN0bHkgY29udmVydGVkIGluIHJlY3Vyc2lvblxyXG4gIFx0XHRjb29yZHMucHVzaChsZXZlbHNEZWVwID9cclxuICBcdFx0XHRsYXRMbmdzVG9Db29yZHMobGF0bG5nc1tpXSwgaXNGbGF0KGxhdGxuZ3NbaV0pID8gMCA6IGxldmVsc0RlZXAgLSAxLCBjbG9zZWQsIHByZWNpc2lvbikgOlxyXG4gIFx0XHRcdGxhdExuZ1RvQ29vcmRzKGxhdGxuZ3NbaV0sIHByZWNpc2lvbikpO1xyXG4gIFx0fVxyXG5cclxuICBcdGlmICghbGV2ZWxzRGVlcCAmJiBjbG9zZWQpIHtcclxuICBcdFx0Y29vcmRzLnB1c2goY29vcmRzWzBdLnNsaWNlKCkpO1xyXG4gIFx0fVxyXG5cclxuICBcdHJldHVybiBjb29yZHM7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRGZWF0dXJlKGxheWVyLCBuZXdHZW9tZXRyeSkge1xyXG4gIFx0cmV0dXJuIGxheWVyLmZlYXR1cmUgP1xyXG4gIFx0XHRleHRlbmQoe30sIGxheWVyLmZlYXR1cmUsIHtnZW9tZXRyeTogbmV3R2VvbWV0cnl9KSA6XHJcbiAgXHRcdGFzRmVhdHVyZShuZXdHZW9tZXRyeSk7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gYXNGZWF0dXJlKGdlb2pzb246IE9iamVjdCk6IE9iamVjdFxyXG4gIC8vIE5vcm1hbGl6ZSBHZW9KU09OIGdlb21ldHJpZXMvZmVhdHVyZXMgaW50byBHZW9KU09OIGZlYXR1cmVzLlxyXG4gIGZ1bmN0aW9uIGFzRmVhdHVyZShnZW9qc29uKSB7XHJcbiAgXHRpZiAoZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZScgfHwgZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZUNvbGxlY3Rpb24nKSB7XHJcbiAgXHRcdHJldHVybiBnZW9qc29uO1xyXG4gIFx0fVxyXG5cclxuICBcdHJldHVybiB7XHJcbiAgXHRcdHR5cGU6ICdGZWF0dXJlJyxcclxuICBcdFx0cHJvcGVydGllczoge30sXHJcbiAgXHRcdGdlb21ldHJ5OiBnZW9qc29uXHJcbiAgXHR9O1xyXG4gIH1cclxuXHJcbiAgdmFyIFBvaW50VG9HZW9KU09OID0ge1xyXG4gIFx0dG9HZW9KU09OOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcbiAgXHRcdHJldHVybiBnZXRGZWF0dXJlKHRoaXMsIHtcclxuICBcdFx0XHR0eXBlOiAnUG9pbnQnLFxyXG4gIFx0XHRcdGNvb3JkaW5hdGVzOiBsYXRMbmdUb0Nvb3Jkcyh0aGlzLmdldExhdExuZygpLCBwcmVjaXNpb24pXHJcbiAgXHRcdH0pO1xyXG4gIFx0fVxyXG4gIH07XHJcblxyXG4gIC8vIEBuYW1lc3BhY2UgTWFya2VyXHJcbiAgLy8gQHNlY3Rpb24gT3RoZXIgbWV0aG9kc1xyXG4gIC8vIEBtZXRob2QgdG9HZW9KU09OKHByZWNpc2lvbj86IE51bWJlcnxmYWxzZSk6IE9iamVjdFxyXG4gIC8vIENvb3JkaW5hdGVzIHZhbHVlcyBhcmUgcm91bmRlZCB3aXRoIFtgZm9ybWF0TnVtYF0oI3V0aWwtZm9ybWF0bnVtKSBmdW5jdGlvbiB3aXRoIGdpdmVuIGBwcmVjaXNpb25gLlxyXG4gIC8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWFya2VyIChhcyBhIEdlb0pTT04gYFBvaW50YCBGZWF0dXJlKS5cclxuICBNYXJrZXIuaW5jbHVkZShQb2ludFRvR2VvSlNPTik7XHJcblxyXG4gIC8vIEBuYW1lc3BhY2UgQ2lyY2xlTWFya2VyXHJcbiAgLy8gQG1ldGhvZCB0b0dlb0pTT04ocHJlY2lzaW9uPzogTnVtYmVyfGZhbHNlKTogT2JqZWN0XHJcbiAgLy8gQ29vcmRpbmF0ZXMgdmFsdWVzIGFyZSByb3VuZGVkIHdpdGggW2Bmb3JtYXROdW1gXSgjdXRpbC1mb3JtYXRudW0pIGZ1bmN0aW9uIHdpdGggZ2l2ZW4gYHByZWNpc2lvbmAuXHJcbiAgLy8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjaXJjbGUgbWFya2VyIChhcyBhIEdlb0pTT04gYFBvaW50YCBGZWF0dXJlKS5cclxuICBDaXJjbGUuaW5jbHVkZShQb2ludFRvR2VvSlNPTik7XHJcbiAgQ2lyY2xlTWFya2VyLmluY2x1ZGUoUG9pbnRUb0dlb0pTT04pO1xyXG5cclxuXHJcbiAgLy8gQG5hbWVzcGFjZSBQb2x5bGluZVxyXG4gIC8vIEBtZXRob2QgdG9HZW9KU09OKHByZWNpc2lvbj86IE51bWJlcnxmYWxzZSk6IE9iamVjdFxyXG4gIC8vIENvb3JkaW5hdGVzIHZhbHVlcyBhcmUgcm91bmRlZCB3aXRoIFtgZm9ybWF0TnVtYF0oI3V0aWwtZm9ybWF0bnVtKSBmdW5jdGlvbiB3aXRoIGdpdmVuIGBwcmVjaXNpb25gLlxyXG4gIC8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9seWxpbmUgKGFzIGEgR2VvSlNPTiBgTGluZVN0cmluZ2Agb3IgYE11bHRpTGluZVN0cmluZ2AgRmVhdHVyZSkuXHJcbiAgUG9seWxpbmUuaW5jbHVkZSh7XHJcbiAgXHR0b0dlb0pTT046IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuICBcdFx0dmFyIG11bHRpID0gIWlzRmxhdCh0aGlzLl9sYXRsbmdzKTtcclxuXHJcbiAgXHRcdHZhciBjb29yZHMgPSBsYXRMbmdzVG9Db29yZHModGhpcy5fbGF0bG5ncywgbXVsdGkgPyAxIDogMCwgZmFsc2UsIHByZWNpc2lvbik7XHJcblxyXG4gIFx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcbiAgXHRcdFx0dHlwZTogKG11bHRpID8gJ011bHRpJyA6ICcnKSArICdMaW5lU3RyaW5nJyxcclxuICBcdFx0XHRjb29yZGluYXRlczogY29vcmRzXHJcbiAgXHRcdH0pO1xyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuICAvLyBAbmFtZXNwYWNlIFBvbHlnb25cclxuICAvLyBAbWV0aG9kIHRvR2VvSlNPTihwcmVjaXNpb24/OiBOdW1iZXJ8ZmFsc2UpOiBPYmplY3RcclxuICAvLyBDb29yZGluYXRlcyB2YWx1ZXMgYXJlIHJvdW5kZWQgd2l0aCBbYGZvcm1hdE51bWBdKCN1dGlsLWZvcm1hdG51bSkgZnVuY3Rpb24gd2l0aCBnaXZlbiBgcHJlY2lzaW9uYC5cclxuICAvLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBvbHlnb24gKGFzIGEgR2VvSlNPTiBgUG9seWdvbmAgb3IgYE11bHRpUG9seWdvbmAgRmVhdHVyZSkuXHJcbiAgUG9seWdvbi5pbmNsdWRlKHtcclxuICBcdHRvR2VvSlNPTjogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG4gIFx0XHR2YXIgaG9sZXMgPSAhaXNGbGF0KHRoaXMuX2xhdGxuZ3MpLFxyXG4gIFx0XHQgICAgbXVsdGkgPSBob2xlcyAmJiAhaXNGbGF0KHRoaXMuX2xhdGxuZ3NbMF0pO1xyXG5cclxuICBcdFx0dmFyIGNvb3JkcyA9IGxhdExuZ3NUb0Nvb3Jkcyh0aGlzLl9sYXRsbmdzLCBtdWx0aSA/IDIgOiBob2xlcyA/IDEgOiAwLCB0cnVlLCBwcmVjaXNpb24pO1xyXG5cclxuICBcdFx0aWYgKCFob2xlcykge1xyXG4gIFx0XHRcdGNvb3JkcyA9IFtjb29yZHNdO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcbiAgXHRcdFx0dHlwZTogKG11bHRpID8gJ011bHRpJyA6ICcnKSArICdQb2x5Z29uJyxcclxuICBcdFx0XHRjb29yZGluYXRlczogY29vcmRzXHJcbiAgXHRcdH0pO1xyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuXHJcbiAgLy8gQG5hbWVzcGFjZSBMYXllckdyb3VwXHJcbiAgTGF5ZXJHcm91cC5pbmNsdWRlKHtcclxuICBcdHRvTXVsdGlQb2ludDogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG4gIFx0XHR2YXIgY29vcmRzID0gW107XHJcblxyXG4gIFx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuICBcdFx0XHRjb29yZHMucHVzaChsYXllci50b0dlb0pTT04ocHJlY2lzaW9uKS5nZW9tZXRyeS5jb29yZGluYXRlcyk7XHJcbiAgXHRcdH0pO1xyXG5cclxuICBcdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG4gIFx0XHRcdHR5cGU6ICdNdWx0aVBvaW50JyxcclxuICBcdFx0XHRjb29yZGluYXRlczogY29vcmRzXHJcbiAgXHRcdH0pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHRvR2VvSlNPTihwcmVjaXNpb24/OiBOdW1iZXJ8ZmFsc2UpOiBPYmplY3RcclxuICBcdC8vIENvb3JkaW5hdGVzIHZhbHVlcyBhcmUgcm91bmRlZCB3aXRoIFtgZm9ybWF0TnVtYF0oI3V0aWwtZm9ybWF0bnVtKSBmdW5jdGlvbiB3aXRoIGdpdmVuIGBwcmVjaXNpb25gLlxyXG4gIFx0Ly8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBsYXllciBncm91cCAoYXMgYSBHZW9KU09OIGBGZWF0dXJlQ29sbGVjdGlvbmAsIGBHZW9tZXRyeUNvbGxlY3Rpb25gLCBvciBgTXVsdGlQb2ludGApLlxyXG4gIFx0dG9HZW9KU09OOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblxyXG4gIFx0XHR2YXIgdHlwZSA9IHRoaXMuZmVhdHVyZSAmJiB0aGlzLmZlYXR1cmUuZ2VvbWV0cnkgJiYgdGhpcy5mZWF0dXJlLmdlb21ldHJ5LnR5cGU7XHJcblxyXG4gIFx0XHRpZiAodHlwZSA9PT0gJ011bHRpUG9pbnQnKSB7XHJcbiAgXHRcdFx0cmV0dXJuIHRoaXMudG9NdWx0aVBvaW50KHByZWNpc2lvbik7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBpc0dlb21ldHJ5Q29sbGVjdGlvbiA9IHR5cGUgPT09ICdHZW9tZXRyeUNvbGxlY3Rpb24nLFxyXG4gIFx0XHQgICAganNvbnMgPSBbXTtcclxuXHJcbiAgXHRcdHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG4gIFx0XHRcdGlmIChsYXllci50b0dlb0pTT04pIHtcclxuICBcdFx0XHRcdHZhciBqc29uID0gbGF5ZXIudG9HZW9KU09OKHByZWNpc2lvbik7XHJcbiAgXHRcdFx0XHRpZiAoaXNHZW9tZXRyeUNvbGxlY3Rpb24pIHtcclxuICBcdFx0XHRcdFx0anNvbnMucHVzaChqc29uLmdlb21ldHJ5KTtcclxuICBcdFx0XHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0XHRcdHZhciBmZWF0dXJlID0gYXNGZWF0dXJlKGpzb24pO1xyXG4gIFx0XHRcdFx0XHQvLyBTcXVhc2ggbmVzdGVkIGZlYXR1cmUgY29sbGVjdGlvbnNcclxuICBcdFx0XHRcdFx0aWYgKGZlYXR1cmUudHlwZSA9PT0gJ0ZlYXR1cmVDb2xsZWN0aW9uJykge1xyXG4gIFx0XHRcdFx0XHRcdGpzb25zLnB1c2guYXBwbHkoanNvbnMsIGZlYXR1cmUuZmVhdHVyZXMpO1xyXG4gIFx0XHRcdFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdFx0XHRcdGpzb25zLnB1c2goZmVhdHVyZSk7XHJcbiAgXHRcdFx0XHRcdH1cclxuICBcdFx0XHRcdH1cclxuICBcdFx0XHR9XHJcbiAgXHRcdH0pO1xyXG5cclxuICBcdFx0aWYgKGlzR2VvbWV0cnlDb2xsZWN0aW9uKSB7XHJcbiAgXHRcdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG4gIFx0XHRcdFx0Z2VvbWV0cmllczoganNvbnMsXHJcbiAgXHRcdFx0XHR0eXBlOiAnR2VvbWV0cnlDb2xsZWN0aW9uJ1xyXG4gIFx0XHRcdH0pO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4ge1xyXG4gIFx0XHRcdHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXHJcbiAgXHRcdFx0ZmVhdHVyZXM6IGpzb25zXHJcbiAgXHRcdH07XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG4gIC8vIEBuYW1lc3BhY2UgR2VvSlNPTlxyXG4gIC8vIEBmYWN0b3J5IEwuZ2VvSlNPTihnZW9qc29uPzogT2JqZWN0LCBvcHRpb25zPzogR2VvSlNPTiBvcHRpb25zKVxyXG4gIC8vIENyZWF0ZXMgYSBHZW9KU09OIGxheWVyLiBPcHRpb25hbGx5IGFjY2VwdHMgYW4gb2JqZWN0IGluXHJcbiAgLy8gW0dlb0pTT04gZm9ybWF0XShodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzk0NikgdG8gZGlzcGxheSBvbiB0aGUgbWFwXHJcbiAgLy8gKHlvdSBjYW4gYWx0ZXJuYXRpdmVseSBhZGQgaXQgbGF0ZXIgd2l0aCBgYWRkRGF0YWAgbWV0aG9kKSBhbmQgYW4gYG9wdGlvbnNgIG9iamVjdC5cclxuICBmdW5jdGlvbiBnZW9KU09OKGdlb2pzb24sIG9wdGlvbnMpIHtcclxuICBcdHJldHVybiBuZXcgR2VvSlNPTihnZW9qc29uLCBvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXHJcbiAgdmFyIGdlb0pzb24gPSBnZW9KU09OO1xuXG4gIC8qXHJcbiAgICogQGNsYXNzIEltYWdlT3ZlcmxheVxyXG4gICAqIEBha2EgTC5JbWFnZU92ZXJsYXlcclxuICAgKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcclxuICAgKlxyXG4gICAqIFVzZWQgdG8gbG9hZCBhbmQgZGlzcGxheSBhIHNpbmdsZSBpbWFnZSBvdmVyIHNwZWNpZmljIGJvdW5kcyBvZiB0aGUgbWFwLiBFeHRlbmRzIGBMYXllcmAuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB2YXIgaW1hZ2VVcmwgPSAnaHR0cHM6Ly9tYXBzLmxpYi51dGV4YXMuZWR1L21hcHMvaGlzdG9yaWNhbC9uZXdhcmtfbmpfMTkyMi5qcGcnLFxyXG4gICAqIFx0aW1hZ2VCb3VuZHMgPSBbWzQwLjcxMjIxNiwgLTc0LjIyNjU1XSwgWzQwLjc3Mzk0MSwgLTc0LjEyNTQ0XV07XHJcbiAgICogTC5pbWFnZU92ZXJsYXkoaW1hZ2VVcmwsIGltYWdlQm91bmRzKS5hZGRUbyhtYXApO1xyXG4gICAqIGBgYFxyXG4gICAqL1xyXG5cclxuICB2YXIgSW1hZ2VPdmVybGF5ID0gTGF5ZXIuZXh0ZW5kKHtcclxuXHJcbiAgXHQvLyBAc2VjdGlvblxyXG4gIFx0Ly8gQGFrYSBJbWFnZU92ZXJsYXkgb3B0aW9uc1xyXG4gIFx0b3B0aW9uczoge1xyXG4gIFx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxyXG4gIFx0XHQvLyBUaGUgb3BhY2l0eSBvZiB0aGUgaW1hZ2Ugb3ZlcmxheS5cclxuICBcdFx0b3BhY2l0eTogMSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gYWx0OiBTdHJpbmcgPSAnJ1xyXG4gIFx0XHQvLyBUZXh0IGZvciB0aGUgYGFsdGAgYXR0cmlidXRlIG9mIHRoZSBpbWFnZSAodXNlZnVsIGZvciBhY2Nlc3NpYmlsaXR5KS5cclxuICBcdFx0YWx0OiAnJyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gaW50ZXJhY3RpdmU6IEJvb2xlYW4gPSBmYWxzZVxyXG4gIFx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBpbWFnZSBvdmVybGF5IHdpbGwgZW1pdCBbbW91c2UgZXZlbnRzXSgjaW50ZXJhY3RpdmUtbGF5ZXIpIHdoZW4gY2xpY2tlZCBvciBob3ZlcmVkLlxyXG4gIFx0XHRpbnRlcmFjdGl2ZTogZmFsc2UsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGNyb3NzT3JpZ2luOiBCb29sZWFufFN0cmluZyA9IGZhbHNlXHJcbiAgXHRcdC8vIFdoZXRoZXIgdGhlIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBpbWFnZS5cclxuICBcdFx0Ly8gSWYgYSBTdHJpbmcgaXMgcHJvdmlkZWQsIHRoZSBpbWFnZSB3aWxsIGhhdmUgaXRzIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSBzZXQgdG8gdGhlIFN0cmluZyBwcm92aWRlZC4gVGhpcyBpcyBuZWVkZWQgaWYgeW91IHdhbnQgdG8gYWNjZXNzIGltYWdlIHBpeGVsIGRhdGEuXHJcbiAgXHRcdC8vIFJlZmVyIHRvIFtDT1JTIFNldHRpbmdzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0NPUlNfc2V0dGluZ3NfYXR0cmlidXRlcykgZm9yIHZhbGlkIFN0cmluZyB2YWx1ZXMuXHJcbiAgXHRcdGNyb3NzT3JpZ2luOiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gZXJyb3JPdmVybGF5VXJsOiBTdHJpbmcgPSAnJ1xyXG4gIFx0XHQvLyBVUkwgdG8gdGhlIG92ZXJsYXkgaW1hZ2UgdG8gc2hvdyBpbiBwbGFjZSBvZiB0aGUgb3ZlcmxheSB0aGF0IGZhaWxlZCB0byBsb2FkLlxyXG4gIFx0XHRlcnJvck92ZXJsYXlVcmw6ICcnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiB6SW5kZXg6IE51bWJlciA9IDFcclxuICBcdFx0Ly8gVGhlIGV4cGxpY2l0IFt6SW5kZXhdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0NTUy9DU1NfUG9zaXRpb25pbmcvVW5kZXJzdGFuZGluZ196X2luZGV4KSBvZiB0aGUgb3ZlcmxheSBsYXllci5cclxuICBcdFx0ekluZGV4OiAxLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXHJcbiAgXHRcdC8vIEEgY3VzdG9tIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSBpbWFnZS4gRW1wdHkgYnkgZGVmYXVsdC5cclxuICBcdFx0Y2xhc3NOYW1lOiAnJ1xyXG4gIFx0fSxcclxuXHJcbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAodXJsLCBib3VuZHMsIG9wdGlvbnMpIHsgLy8gKFN0cmluZywgTGF0TG5nQm91bmRzLCBPYmplY3QpXHJcbiAgXHRcdHRoaXMuX3VybCA9IHVybDtcclxuICBcdFx0dGhpcy5fYm91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcbiAgXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uQWRkOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICghdGhpcy5faW1hZ2UpIHtcclxuICBcdFx0XHR0aGlzLl9pbml0SW1hZ2UoKTtcclxuXHJcbiAgXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5vcGFjaXR5IDwgMSkge1xyXG4gIFx0XHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xyXG4gIFx0XHRcdGFkZENsYXNzKHRoaXMuX2ltYWdlLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xyXG4gIFx0XHRcdHRoaXMuYWRkSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faW1hZ2UpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9pbWFnZSk7XHJcbiAgXHRcdHRoaXMuX3Jlc2V0KCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJlbW92ZSh0aGlzLl9pbWFnZSk7XHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcclxuICBcdFx0XHR0aGlzLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2ltYWdlKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldE9wYWNpdHkob3BhY2l0eTogTnVtYmVyKTogdGhpc1xyXG4gIFx0Ly8gU2V0cyB0aGUgb3BhY2l0eSBvZiB0aGUgb3ZlcmxheS5cclxuICBcdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XHJcbiAgXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9pbWFnZSkge1xyXG4gIFx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZU9wdHMpIHtcclxuICBcdFx0aWYgKHN0eWxlT3B0cy5vcGFjaXR5KSB7XHJcbiAgXHRcdFx0dGhpcy5zZXRPcGFjaXR5KHN0eWxlT3B0cy5vcGFjaXR5KTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQoKTogdGhpc1xyXG4gIFx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgdG9wIG9mIGFsbCBvdmVybGF5cy5cclxuICBcdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XHJcbiAgXHRcdFx0dG9Gcm9udCh0aGlzLl9pbWFnZSk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgYnJpbmdUb0JhY2soKTogdGhpc1xyXG4gIFx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgYm90dG9tIG9mIGFsbCBvdmVybGF5cy5cclxuICBcdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcclxuICBcdFx0XHR0b0JhY2sodGhpcy5faW1hZ2UpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldFVybCh1cmw6IFN0cmluZyk6IHRoaXNcclxuICBcdC8vIENoYW5nZXMgdGhlIFVSTCBvZiB0aGUgaW1hZ2UuXHJcbiAgXHRzZXRVcmw6IGZ1bmN0aW9uICh1cmwpIHtcclxuICBcdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2ltYWdlKSB7XHJcbiAgXHRcdFx0dGhpcy5faW1hZ2Uuc3JjID0gdXJsO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldEJvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcyk6IHRoaXNcclxuICBcdC8vIFVwZGF0ZSB0aGUgYm91bmRzIHRoYXQgdGhpcyBJbWFnZU92ZXJsYXkgY292ZXJzXHJcbiAgXHRzZXRCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuICBcdFx0dGhpcy5fYm91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcclxuICBcdFx0XHR0aGlzLl9yZXNldCgpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIGV2ZW50cyA9IHtcclxuICBcdFx0XHR6b29tOiB0aGlzLl9yZXNldCxcclxuICBcdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0XHJcbiAgXHRcdH07XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcbiAgXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fYW5pbWF0ZVpvb207XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiBldmVudHM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0WkluZGV4KHZhbHVlOiBOdW1iZXIpOiB0aGlzXHJcbiAgXHQvLyBDaGFuZ2VzIHRoZSBbekluZGV4XSgjaW1hZ2VvdmVybGF5LXppbmRleCkgb2YgdGhlIGltYWdlIG92ZXJsYXkuXHJcbiAgXHRzZXRaSW5kZXg6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gIFx0XHR0aGlzLm9wdGlvbnMuekluZGV4ID0gdmFsdWU7XHJcbiAgXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXHJcbiAgXHQvLyBHZXQgdGhlIGJvdW5kcyB0aGF0IHRoaXMgSW1hZ2VPdmVybGF5IGNvdmVyc1xyXG4gIFx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9ib3VuZHM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0RWxlbWVudCgpOiBIVE1MRWxlbWVudFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgW2BIVE1MSW1hZ2VFbGVtZW50YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0hUTUxJbWFnZUVsZW1lbnQpXHJcbiAgXHQvLyB1c2VkIGJ5IHRoaXMgb3ZlcmxheS5cclxuICBcdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX2ltYWdlO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfaW5pdEltYWdlOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciB3YXNFbGVtZW50U3VwcGxpZWQgPSB0aGlzLl91cmwudGFnTmFtZSA9PT0gJ0lNRyc7XHJcbiAgXHRcdHZhciBpbWcgPSB0aGlzLl9pbWFnZSA9IHdhc0VsZW1lbnRTdXBwbGllZCA/IHRoaXMuX3VybCA6IGNyZWF0ZSQxKCdpbWcnKTtcclxuXHJcbiAgXHRcdGFkZENsYXNzKGltZywgJ2xlYWZsZXQtaW1hZ2UtbGF5ZXInKTtcclxuICBcdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkgeyBhZGRDbGFzcyhpbWcsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTsgfVxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSkgeyBhZGRDbGFzcyhpbWcsIHRoaXMub3B0aW9ucy5jbGFzc05hbWUpOyB9XHJcblxyXG4gIFx0XHRpbWcub25zZWxlY3RzdGFydCA9IGZhbHNlRm47XHJcbiAgXHRcdGltZy5vbm1vdXNlbW92ZSA9IGZhbHNlRm47XHJcblxyXG4gIFx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgSW1hZ2VPdmVybGF5IGxheWVyIGhhcyBsb2FkZWQgaXRzIGltYWdlXHJcbiAgXHRcdGltZy5vbmxvYWQgPSBiaW5kKHRoaXMuZmlyZSwgdGhpcywgJ2xvYWQnKTtcclxuICBcdFx0aW1nLm9uZXJyb3IgPSBiaW5kKHRoaXMuX292ZXJsYXlPbkVycm9yLCB0aGlzLCAnZXJyb3InKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gfHwgdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luID09PSAnJykge1xyXG4gIFx0XHRcdGltZy5jcm9zc09yaWdpbiA9IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gdHJ1ZSA/ICcnIDogdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLnpJbmRleCkge1xyXG4gIFx0XHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAod2FzRWxlbWVudFN1cHBsaWVkKSB7XHJcbiAgXHRcdFx0dGhpcy5fdXJsID0gaW1nLnNyYztcclxuICBcdFx0XHRyZXR1cm47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGltZy5zcmMgPSB0aGlzLl91cmw7XHJcbiAgXHRcdGltZy5hbHQgPSB0aGlzLm9wdGlvbnMuYWx0O1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdHZhciBzY2FsZSA9IHRoaXMuX21hcC5nZXRab29tU2NhbGUoZS56b29tKSxcclxuICBcdFx0ICAgIG9mZnNldCA9IHRoaXMuX21hcC5fbGF0TG5nQm91bmRzVG9OZXdMYXllckJvdW5kcyh0aGlzLl9ib3VuZHMsIGUuem9vbSwgZS5jZW50ZXIpLm1pbjtcclxuXHJcbiAgXHRcdHNldFRyYW5zZm9ybSh0aGlzLl9pbWFnZSwgb2Zmc2V0LCBzY2FsZSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9yZXNldDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgaW1hZ2UgPSB0aGlzLl9pbWFnZSxcclxuICBcdFx0ICAgIGJvdW5kcyA9IG5ldyBCb3VuZHMoXHJcbiAgXHRcdCAgICAgICAgdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9ib3VuZHMuZ2V0Tm9ydGhXZXN0KCkpLFxyXG4gIFx0XHQgICAgICAgIHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fYm91bmRzLmdldFNvdXRoRWFzdCgpKSksXHJcbiAgXHRcdCAgICBzaXplID0gYm91bmRzLmdldFNpemUoKTtcclxuXHJcbiAgXHRcdHNldFBvc2l0aW9uKGltYWdlLCBib3VuZHMubWluKTtcclxuXHJcbiAgXHRcdGltYWdlLnN0eWxlLndpZHRoICA9IHNpemUueCArICdweCc7XHJcbiAgXHRcdGltYWdlLnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XHJcbiAgXHR9LFxyXG5cclxuICBcdF91cGRhdGVPcGFjaXR5OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHNldE9wYWNpdHkodGhpcy5faW1hZ2UsIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3VwZGF0ZVpJbmRleDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAodGhpcy5faW1hZ2UgJiYgdGhpcy5vcHRpb25zLnpJbmRleCAhPT0gdW5kZWZpbmVkICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IG51bGwpIHtcclxuICBcdFx0XHR0aGlzLl9pbWFnZS5zdHlsZS56SW5kZXggPSB0aGlzLm9wdGlvbnMuekluZGV4O1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF9vdmVybGF5T25FcnJvcjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHQvLyBAZXZlbnQgZXJyb3I6IEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIEltYWdlT3ZlcmxheSBsYXllciBmYWlscyB0byBsb2FkIGl0cyBpbWFnZVxyXG4gIFx0XHR0aGlzLmZpcmUoJ2Vycm9yJyk7XHJcblxyXG4gIFx0XHR2YXIgZXJyb3JVcmwgPSB0aGlzLm9wdGlvbnMuZXJyb3JPdmVybGF5VXJsO1xyXG4gIFx0XHRpZiAoZXJyb3JVcmwgJiYgdGhpcy5fdXJsICE9PSBlcnJvclVybCkge1xyXG4gIFx0XHRcdHRoaXMuX3VybCA9IGVycm9yVXJsO1xyXG4gIFx0XHRcdHRoaXMuX2ltYWdlLnNyYyA9IGVycm9yVXJsO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xyXG4gIFx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIG9mIHRoZSBJbWFnZU92ZXJsYXkuXHJcbiAgXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX2JvdW5kcy5nZXRDZW50ZXIoKTtcclxuICBcdH1cclxuICB9KTtcclxuXHJcbiAgLy8gQGZhY3RvcnkgTC5pbWFnZU92ZXJsYXkoaW1hZ2VVcmw6IFN0cmluZywgYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBJbWFnZU92ZXJsYXkgb3B0aW9ucylcclxuICAvLyBJbnN0YW50aWF0ZXMgYW4gaW1hZ2Ugb3ZlcmxheSBvYmplY3QgZ2l2ZW4gdGhlIFVSTCBvZiB0aGUgaW1hZ2UgYW5kIHRoZVxyXG4gIC8vIGdlb2dyYXBoaWNhbCBib3VuZHMgaXQgaXMgdGllZCB0by5cclxuICB2YXIgaW1hZ2VPdmVybGF5ID0gZnVuY3Rpb24gKHVybCwgYm91bmRzLCBvcHRpb25zKSB7XHJcbiAgXHRyZXR1cm4gbmV3IEltYWdlT3ZlcmxheSh1cmwsIGJvdW5kcywgb3B0aW9ucyk7XHJcbiAgfTtcblxuICAvKlxyXG4gICAqIEBjbGFzcyBWaWRlb092ZXJsYXlcclxuICAgKiBAYWthIEwuVmlkZW9PdmVybGF5XHJcbiAgICogQGluaGVyaXRzIEltYWdlT3ZlcmxheVxyXG4gICAqXHJcbiAgICogVXNlZCB0byBsb2FkIGFuZCBkaXNwbGF5IGEgdmlkZW8gcGxheWVyIG92ZXIgc3BlY2lmaWMgYm91bmRzIG9mIHRoZSBtYXAuIEV4dGVuZHMgYEltYWdlT3ZlcmxheWAuXHJcbiAgICpcclxuICAgKiBBIHZpZGVvIG92ZXJsYXkgdXNlcyB0aGUgW2A8dmlkZW8+YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSFRNTC9FbGVtZW50L3ZpZGVvKVxyXG4gICAqIEhUTUw1IGVsZW1lbnQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB2YXIgdmlkZW9VcmwgPSAnaHR0cHM6Ly93d3cubWFwYm94LmNvbS9iaXRlcy8wMDE4OC9wYXRyaWNpYV9uYXNhLndlYm0nLFxyXG4gICAqIFx0dmlkZW9Cb3VuZHMgPSBbWyAzMiwgLTEzMF0sIFsgMTMsIC0xMDBdXTtcclxuICAgKiBMLnZpZGVvT3ZlcmxheSh2aWRlb1VybCwgdmlkZW9Cb3VuZHMgKS5hZGRUbyhtYXApO1xyXG4gICAqIGBgYFxyXG4gICAqL1xyXG5cclxuICB2YXIgVmlkZW9PdmVybGF5ID0gSW1hZ2VPdmVybGF5LmV4dGVuZCh7XHJcblxyXG4gIFx0Ly8gQHNlY3Rpb25cclxuICBcdC8vIEBha2EgVmlkZW9PdmVybGF5IG9wdGlvbnNcclxuICBcdG9wdGlvbnM6IHtcclxuICBcdFx0Ly8gQG9wdGlvbiBhdXRvcGxheTogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gV2hldGhlciB0aGUgdmlkZW8gc3RhcnRzIHBsYXlpbmcgYXV0b21hdGljYWxseSB3aGVuIGxvYWRlZC5cclxuICBcdFx0Ly8gT24gc29tZSBicm93c2VycyBhdXRvcGxheSB3aWxsIG9ubHkgd29yayB3aXRoIGBtdXRlZDogdHJ1ZWBcclxuICBcdFx0YXV0b3BsYXk6IHRydWUsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGxvb3A6IEJvb2xlYW4gPSB0cnVlXHJcbiAgXHRcdC8vIFdoZXRoZXIgdGhlIHZpZGVvIHdpbGwgbG9vcCBiYWNrIHRvIHRoZSBiZWdpbm5pbmcgd2hlbiBwbGF5ZWQuXHJcbiAgXHRcdGxvb3A6IHRydWUsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGtlZXBBc3BlY3RSYXRpbzogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gV2hldGhlciB0aGUgdmlkZW8gd2lsbCBzYXZlIGFzcGVjdCByYXRpbyBhZnRlciB0aGUgcHJvamVjdGlvbi5cclxuICBcdFx0Ly8gUmVsZXZhbnQgZm9yIHN1cHBvcnRlZCBicm93c2Vycy4gU2VlIFticm93c2VyIGNvbXBhdGliaWxpdHldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9vYmplY3QtZml0KVxyXG4gIFx0XHRrZWVwQXNwZWN0UmF0aW86IHRydWUsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIG11dGVkOiBCb29sZWFuID0gZmFsc2VcclxuICBcdFx0Ly8gV2hldGhlciB0aGUgdmlkZW8gc3RhcnRzIG9uIG11dGUgd2hlbiBsb2FkZWQuXHJcbiAgXHRcdG11dGVkOiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gcGxheXNJbmxpbmU6IEJvb2xlYW4gPSB0cnVlXHJcbiAgXHRcdC8vIE1vYmlsZSBicm93c2VycyB3aWxsIHBsYXkgdGhlIHZpZGVvIHJpZ2h0IHdoZXJlIGl0IGlzIGluc3RlYWQgb2Ygb3BlbiBpdCB1cCBpbiBmdWxsc2NyZWVuIG1vZGUuXHJcbiAgXHRcdHBsYXlzSW5saW5lOiB0cnVlXHJcbiAgXHR9LFxyXG5cclxuICBcdF9pbml0SW1hZ2U6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIHdhc0VsZW1lbnRTdXBwbGllZCA9IHRoaXMuX3VybC50YWdOYW1lID09PSAnVklERU8nO1xyXG4gIFx0XHR2YXIgdmlkID0gdGhpcy5faW1hZ2UgPSB3YXNFbGVtZW50U3VwcGxpZWQgPyB0aGlzLl91cmwgOiBjcmVhdGUkMSgndmlkZW8nKTtcclxuXHJcbiAgXHRcdGFkZENsYXNzKHZpZCwgJ2xlYWZsZXQtaW1hZ2UtbGF5ZXInKTtcclxuICBcdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkgeyBhZGRDbGFzcyh2aWQsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTsgfVxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSkgeyBhZGRDbGFzcyh2aWQsIHRoaXMub3B0aW9ucy5jbGFzc05hbWUpOyB9XHJcblxyXG4gIFx0XHR2aWQub25zZWxlY3RzdGFydCA9IGZhbHNlRm47XHJcbiAgXHRcdHZpZC5vbm1vdXNlbW92ZSA9IGZhbHNlRm47XHJcblxyXG4gIFx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdmlkZW8gaGFzIGZpbmlzaGVkIGxvYWRpbmcgdGhlIGZpcnN0IGZyYW1lXHJcbiAgXHRcdHZpZC5vbmxvYWRlZGRhdGEgPSBiaW5kKHRoaXMuZmlyZSwgdGhpcywgJ2xvYWQnKTtcclxuXHJcbiAgXHRcdGlmICh3YXNFbGVtZW50U3VwcGxpZWQpIHtcclxuICBcdFx0XHR2YXIgc291cmNlRWxlbWVudHMgPSB2aWQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NvdXJjZScpO1xyXG4gIFx0XHRcdHZhciBzb3VyY2VzID0gW107XHJcbiAgXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBzb3VyY2VFbGVtZW50cy5sZW5ndGg7IGorKykge1xyXG4gIFx0XHRcdFx0c291cmNlcy5wdXNoKHNvdXJjZUVsZW1lbnRzW2pdLnNyYyk7XHJcbiAgXHRcdFx0fVxyXG5cclxuICBcdFx0XHR0aGlzLl91cmwgPSAoc291cmNlRWxlbWVudHMubGVuZ3RoID4gMCkgPyBzb3VyY2VzIDogW3ZpZC5zcmNdO1xyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKCFpc0FycmF5KHRoaXMuX3VybCkpIHsgdGhpcy5fdXJsID0gW3RoaXMuX3VybF07IH1cclxuXHJcbiAgXHRcdGlmICghdGhpcy5vcHRpb25zLmtlZXBBc3BlY3RSYXRpbyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmlkLnN0eWxlLCAnb2JqZWN0Rml0JykpIHtcclxuICBcdFx0XHR2aWQuc3R5bGVbJ29iamVjdEZpdCddID0gJ2ZpbGwnO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHZpZC5hdXRvcGxheSA9ICEhdGhpcy5vcHRpb25zLmF1dG9wbGF5O1xyXG4gIFx0XHR2aWQubG9vcCA9ICEhdGhpcy5vcHRpb25zLmxvb3A7XHJcbiAgXHRcdHZpZC5tdXRlZCA9ICEhdGhpcy5vcHRpb25zLm11dGVkO1xyXG4gIFx0XHR2aWQucGxheXNJbmxpbmUgPSAhIXRoaXMub3B0aW9ucy5wbGF5c0lubGluZTtcclxuICBcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl91cmwubGVuZ3RoOyBpKyspIHtcclxuICBcdFx0XHR2YXIgc291cmNlID0gY3JlYXRlJDEoJ3NvdXJjZScpO1xyXG4gIFx0XHRcdHNvdXJjZS5zcmMgPSB0aGlzLl91cmxbaV07XHJcbiAgXHRcdFx0dmlkLmFwcGVuZENoaWxkKHNvdXJjZSk7XHJcbiAgXHRcdH1cclxuICBcdH1cclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldEVsZW1lbnQoKTogSFRNTFZpZGVvRWxlbWVudFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgW2BIVE1MVmlkZW9FbGVtZW50YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0hUTUxWaWRlb0VsZW1lbnQpXHJcbiAgXHQvLyB1c2VkIGJ5IHRoaXMgb3ZlcmxheS5cclxuICB9KTtcclxuXHJcblxyXG4gIC8vIEBmYWN0b3J5IEwudmlkZW9PdmVybGF5KHZpZGVvOiBTdHJpbmd8QXJyYXl8SFRNTFZpZGVvRWxlbWVudCwgYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBWaWRlb092ZXJsYXkgb3B0aW9ucylcclxuICAvLyBJbnN0YW50aWF0ZXMgYW4gaW1hZ2Ugb3ZlcmxheSBvYmplY3QgZ2l2ZW4gdGhlIFVSTCBvZiB0aGUgdmlkZW8gKG9yIGFycmF5IG9mIFVSTHMsIG9yIGV2ZW4gYSB2aWRlbyBlbGVtZW50KSBhbmQgdGhlXHJcbiAgLy8gZ2VvZ3JhcGhpY2FsIGJvdW5kcyBpdCBpcyB0aWVkIHRvLlxyXG5cclxuICBmdW5jdGlvbiB2aWRlb092ZXJsYXkodmlkZW8sIGJvdW5kcywgb3B0aW9ucykge1xyXG4gIFx0cmV0dXJuIG5ldyBWaWRlb092ZXJsYXkodmlkZW8sIGJvdW5kcywgb3B0aW9ucyk7XHJcbiAgfVxuXG4gIC8qXG4gICAqIEBjbGFzcyBTVkdPdmVybGF5XG4gICAqIEBha2EgTC5TVkdPdmVybGF5XG4gICAqIEBpbmhlcml0cyBJbWFnZU92ZXJsYXlcbiAgICpcbiAgICogVXNlZCB0byBsb2FkLCBkaXNwbGF5IGFuZCBwcm92aWRlIERPTSBhY2Nlc3MgdG8gYW4gU1ZHIGZpbGUgb3ZlciBzcGVjaWZpYyBib3VuZHMgb2YgdGhlIG1hcC4gRXh0ZW5kcyBgSW1hZ2VPdmVybGF5YC5cbiAgICpcbiAgICogQW4gU1ZHIG92ZXJsYXkgdXNlcyB0aGUgW2A8c3ZnPmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9FbGVtZW50L3N2ZykgZWxlbWVudC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIHN2Z0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInN2Z1wiKTtcbiAgICogc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3htbG5zJywgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiKTtcbiAgICogc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCBcIjAgMCAyMDAgMjAwXCIpO1xuICAgKiBzdmdFbGVtZW50LmlubmVySFRNTCA9ICc8cmVjdCB3aWR0aD1cIjIwMFwiIGhlaWdodD1cIjIwMFwiLz48cmVjdCB4PVwiNzVcIiB5PVwiMjNcIiB3aWR0aD1cIjUwXCIgaGVpZ2h0PVwiNTBcIiBzdHlsZT1cImZpbGw6cmVkXCIvPjxyZWN0IHg9XCI3NVwiIHk9XCIxMjNcIiB3aWR0aD1cIjUwXCIgaGVpZ2h0PVwiNTBcIiBzdHlsZT1cImZpbGw6IzAwMTNmZlwiLz4nO1xuICAgKiB2YXIgc3ZnRWxlbWVudEJvdW5kcyA9IFsgWyAzMiwgLTEzMCBdLCBbIDEzLCAtMTAwIF0gXTtcbiAgICogTC5zdmdPdmVybGF5KHN2Z0VsZW1lbnQsIHN2Z0VsZW1lbnRCb3VuZHMpLmFkZFRvKG1hcCk7XG4gICAqIGBgYFxuICAgKi9cblxuICB2YXIgU1ZHT3ZlcmxheSA9IEltYWdlT3ZlcmxheS5leHRlbmQoe1xuICBcdF9pbml0SW1hZ2U6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBlbCA9IHRoaXMuX2ltYWdlID0gdGhpcy5fdXJsO1xuXG4gIFx0XHRhZGRDbGFzcyhlbCwgJ2xlYWZsZXQtaW1hZ2UtbGF5ZXInKTtcbiAgXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHsgYWRkQ2xhc3MoZWwsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTsgfVxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUpIHsgYWRkQ2xhc3MoZWwsIHRoaXMub3B0aW9ucy5jbGFzc05hbWUpOyB9XG5cbiAgXHRcdGVsLm9uc2VsZWN0c3RhcnQgPSBmYWxzZUZuO1xuICBcdFx0ZWwub25tb3VzZW1vdmUgPSBmYWxzZUZuO1xuICBcdH1cblxuICBcdC8vIEBtZXRob2QgZ2V0RWxlbWVudCgpOiBTVkdFbGVtZW50XG4gIFx0Ly8gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgW2BTVkdFbGVtZW50YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1NWR0VsZW1lbnQpXG4gIFx0Ly8gdXNlZCBieSB0aGlzIG92ZXJsYXkuXG4gIH0pO1xuXG5cbiAgLy8gQGZhY3RvcnkgTC5zdmdPdmVybGF5KHN2ZzogU3RyaW5nfFNWR0VsZW1lbnQsIGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogU1ZHT3ZlcmxheSBvcHRpb25zKVxuICAvLyBJbnN0YW50aWF0ZXMgYW4gaW1hZ2Ugb3ZlcmxheSBvYmplY3QgZ2l2ZW4gYW4gU1ZHIGVsZW1lbnQgYW5kIHRoZSBnZW9ncmFwaGljYWwgYm91bmRzIGl0IGlzIHRpZWQgdG8uXG4gIC8vIEEgdmlld0JveCBhdHRyaWJ1dGUgaXMgcmVxdWlyZWQgb24gdGhlIFNWRyBlbGVtZW50IHRvIHpvb20gaW4gYW5kIG91dCBwcm9wZXJseS5cblxuICBmdW5jdGlvbiBzdmdPdmVybGF5KGVsLCBib3VuZHMsIG9wdGlvbnMpIHtcbiAgXHRyZXR1cm4gbmV3IFNWR092ZXJsYXkoZWwsIGJvdW5kcywgb3B0aW9ucyk7XG4gIH1cblxuICAvKlxyXG4gICAqIEBjbGFzcyBEaXZPdmVybGF5XHJcbiAgICogQGluaGVyaXRzIEludGVyYWN0aXZlIGxheWVyXHJcbiAgICogQGFrYSBMLkRpdk92ZXJsYXlcclxuICAgKiBCYXNlIG1vZGVsIGZvciBMLlBvcHVwIGFuZCBMLlRvb2x0aXAuIEluaGVyaXQgZnJvbSBpdCBmb3IgY3VzdG9tIG92ZXJsYXlzIGxpa2UgcGx1Z2lucy5cclxuICAgKi9cclxuXHJcbiAgLy8gQG5hbWVzcGFjZSBEaXZPdmVybGF5XHJcbiAgdmFyIERpdk92ZXJsYXkgPSBMYXllci5leHRlbmQoe1xyXG5cclxuICBcdC8vIEBzZWN0aW9uXHJcbiAgXHQvLyBAYWthIERpdk92ZXJsYXkgb3B0aW9uc1xyXG4gIFx0b3B0aW9uczoge1xyXG4gIFx0XHQvLyBAb3B0aW9uIGludGVyYWN0aXZlOiBCb29sZWFuID0gZmFsc2VcclxuICBcdFx0Ly8gSWYgdHJ1ZSwgdGhlIHBvcHVwL3Rvb2x0aXAgd2lsbCBsaXN0ZW4gdG8gdGhlIG1vdXNlIGV2ZW50cy5cclxuICBcdFx0aW50ZXJhY3RpdmU6IGZhbHNlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBvZmZzZXQ6IFBvaW50ID0gUG9pbnQoMCwgMClcclxuICBcdFx0Ly8gVGhlIG9mZnNldCBvZiB0aGUgb3ZlcmxheSBwb3NpdGlvbi5cclxuICBcdFx0b2Zmc2V0OiBbMCwgMF0sXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuICBcdFx0Ly8gQSBjdXN0b20gQ1NTIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSBvdmVybGF5LlxyXG4gIFx0XHRjbGFzc05hbWU6ICcnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSB1bmRlZmluZWRcclxuICBcdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgb3ZlcmxheSB3aWxsIGJlIGFkZGVkLlxyXG4gIFx0XHRwYW5lOiB1bmRlZmluZWQsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxGdW5jdGlvbiA9ICcnXHJcbiAgXHRcdC8vIFNldHMgdGhlIEhUTUwgY29udGVudCBvZiB0aGUgb3ZlcmxheSB3aGlsZSBpbml0aWFsaXppbmcuIElmIGEgZnVuY3Rpb24gaXMgcGFzc2VkIHRoZSBzb3VyY2UgbGF5ZXIgd2lsbCBiZVxyXG4gIFx0XHQvLyBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uLiBUaGUgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIGBTdHJpbmdgIG9yIGBIVE1MRWxlbWVudGAgdG8gYmUgdXNlZCBpbiB0aGUgb3ZlcmxheS5cclxuICBcdFx0Y29udGVudDogJydcclxuICBcdH0sXHJcblxyXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xyXG4gIFx0XHRpZiAob3B0aW9ucyAmJiAob3B0aW9ucyBpbnN0YW5jZW9mIExhdExuZyB8fCBpc0FycmF5KG9wdGlvbnMpKSkge1xyXG4gIFx0XHRcdHRoaXMuX2xhdGxuZyA9IHRvTGF0TG5nKG9wdGlvbnMpO1xyXG4gIFx0XHRcdHNldE9wdGlvbnModGhpcywgc291cmNlKTtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG4gIFx0XHRcdHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcclxuICBcdFx0fVxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLmNvbnRlbnQpIHtcclxuICBcdFx0XHR0aGlzLl9jb250ZW50ID0gdGhpcy5vcHRpb25zLmNvbnRlbnQ7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBvcGVuT24obWFwOiBNYXApOiB0aGlzXHJcbiAgXHQvLyBBZGRzIHRoZSBvdmVybGF5IHRvIHRoZSBtYXAuXHJcbiAgXHQvLyBBbHRlcm5hdGl2ZSB0byBgbWFwLm9wZW5Qb3B1cChwb3B1cClgL2Aub3BlblRvb2x0aXAodG9vbHRpcClgLlxyXG4gIFx0b3Blbk9uOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgXHRcdG1hcCA9IGFyZ3VtZW50cy5sZW5ndGggPyBtYXAgOiB0aGlzLl9zb3VyY2UuX21hcDsgLy8gZXhwZXJpbWVudGFsLCBub3QgdGhlIHBhcnQgb2YgcHVibGljIGFwaVxyXG4gIFx0XHRpZiAoIW1hcC5oYXNMYXllcih0aGlzKSkge1xyXG4gIFx0XHRcdG1hcC5hZGRMYXllcih0aGlzKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjbG9zZSgpOiB0aGlzXHJcbiAgXHQvLyBDbG9zZXMgdGhlIG92ZXJsYXkuXHJcbiAgXHQvLyBBbHRlcm5hdGl2ZSB0byBgbWFwLmNsb3NlUG9wdXAocG9wdXApYC9gLmNsb3NlVG9vbHRpcCh0b29sdGlwKWBcclxuICBcdC8vIGFuZCBgbGF5ZXIuY2xvc2VQb3B1cCgpYC9gLmNsb3NlVG9vbHRpcCgpYC5cclxuICBcdGNsb3NlOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcclxuICBcdFx0XHR0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcyk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgdG9nZ2xlKGxheWVyPzogTGF5ZXIpOiB0aGlzXHJcbiAgXHQvLyBPcGVucyBvciBjbG9zZXMgdGhlIG92ZXJsYXkgYm91bmQgdG8gbGF5ZXIgZGVwZW5kaW5nIG9uIGl0cyBjdXJyZW50IHN0YXRlLlxyXG4gIFx0Ly8gQXJndW1lbnQgbWF5IGJlIG9taXR0ZWQgb25seSBmb3Igb3ZlcmxheSBib3VuZCB0byBsYXllci5cclxuICBcdC8vIEFsdGVybmF0aXZlIHRvIGBsYXllci50b2dnbGVQb3B1cCgpYC9gLnRvZ2dsZVRvb2x0aXAoKWAuXHJcbiAgXHR0b2dnbGU6IGZ1bmN0aW9uIChsYXllcikge1xyXG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XHJcbiAgXHRcdFx0dGhpcy5jbG9zZSgpO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgXHRcdFx0XHR0aGlzLl9zb3VyY2UgPSBsYXllcjtcclxuICBcdFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdFx0bGF5ZXIgPSB0aGlzLl9zb3VyY2U7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHRcdHRoaXMuX3ByZXBhcmVPcGVuKCk7XHJcblxyXG4gIFx0XHRcdC8vIG9wZW4gdGhlIG92ZXJsYXkgb24gdGhlIG1hcFxyXG4gIFx0XHRcdHRoaXMub3Blbk9uKGxheWVyLl9tYXApO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG4gIFx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSBtYXAuX3pvb21BbmltYXRlZDtcclxuXHJcbiAgXHRcdGlmICghdGhpcy5fY29udGFpbmVyKSB7XHJcbiAgXHRcdFx0dGhpcy5faW5pdExheW91dCgpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAobWFwLl9mYWRlQW5pbWF0ZWQpIHtcclxuICBcdFx0XHRzZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgMCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGNsZWFyVGltZW91dCh0aGlzLl9yZW1vdmVUaW1lb3V0KTtcclxuICBcdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcclxuICBcdFx0dGhpcy51cGRhdGUoKTtcclxuXHJcbiAgXHRcdGlmIChtYXAuX2ZhZGVBbmltYXRlZCkge1xyXG4gIFx0XHRcdHNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCAxKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5icmluZ1RvRnJvbnQoKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcclxuICBcdFx0XHRhZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XHJcbiAgXHRcdFx0dGhpcy5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9jb250YWluZXIpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgXHRcdGlmIChtYXAuX2ZhZGVBbmltYXRlZCkge1xyXG4gIFx0XHRcdHNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCAwKTtcclxuICBcdFx0XHR0aGlzLl9yZW1vdmVUaW1lb3V0ID0gc2V0VGltZW91dChiaW5kKHJlbW92ZSwgdW5kZWZpbmVkLCB0aGlzLl9jb250YWluZXIpLCAyMDApO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdHJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLmludGVyYWN0aXZlKSB7XHJcbiAgXHRcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xyXG4gIFx0XHRcdHRoaXMucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5fY29udGFpbmVyKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbmFtZXNwYWNlIERpdk92ZXJsYXlcclxuICBcdC8vIEBtZXRob2QgZ2V0TGF0TG5nOiBMYXRMbmdcclxuICBcdC8vIFJldHVybnMgdGhlIGdlb2dyYXBoaWNhbCBwb2ludCBvZiB0aGUgb3ZlcmxheS5cclxuICBcdGdldExhdExuZzogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fbGF0bG5nO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldExhdExuZyhsYXRsbmc6IExhdExuZyk6IHRoaXNcclxuICBcdC8vIFNldHMgdGhlIGdlb2dyYXBoaWNhbCBwb2ludCB3aGVyZSB0aGUgb3ZlcmxheSB3aWxsIG9wZW4uXHJcbiAgXHRzZXRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuICBcdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcclxuICBcdFx0aWYgKHRoaXMuX21hcCkge1xyXG4gIFx0XHRcdHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XHJcbiAgXHRcdFx0dGhpcy5fYWRqdXN0UGFuKCk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Q29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBjb250ZW50IG9mIHRoZSBvdmVybGF5LlxyXG4gIFx0Z2V0Q29udGVudDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fY29udGVudDtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRDb250ZW50KGh0bWxDb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8RnVuY3Rpb24pOiB0aGlzXHJcbiAgXHQvLyBTZXRzIHRoZSBIVE1MIGNvbnRlbnQgb2YgdGhlIG92ZXJsYXkuIElmIGEgZnVuY3Rpb24gaXMgcGFzc2VkIHRoZSBzb3VyY2UgbGF5ZXIgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uLlxyXG4gIFx0Ly8gVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBgU3RyaW5nYCBvciBgSFRNTEVsZW1lbnRgIHRvIGJlIHVzZWQgaW4gdGhlIG92ZXJsYXkuXHJcbiAgXHRzZXRDb250ZW50OiBmdW5jdGlvbiAoY29udGVudCkge1xyXG4gIFx0XHR0aGlzLl9jb250ZW50ID0gY29udGVudDtcclxuICBcdFx0dGhpcy51cGRhdGUoKTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0RWxlbWVudDogU3RyaW5nfEhUTUxFbGVtZW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBIVE1MIGNvbnRhaW5lciBvZiB0aGUgb3ZlcmxheS5cclxuICBcdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB1cGRhdGU6IG51bGxcclxuICBcdC8vIFVwZGF0ZXMgdGhlIG92ZXJsYXkgY29udGVudCwgbGF5b3V0IGFuZCBwb3NpdGlvbi4gVXNlZnVsIGZvciB1cGRhdGluZyB0aGUgb3ZlcmxheSBhZnRlciBzb21ldGhpbmcgaW5zaWRlIGNoYW5nZWQsIGUuZy4gaW1hZ2UgbG9hZGVkLlxyXG4gIFx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcclxuXHJcbiAgXHRcdHRoaXMuX3VwZGF0ZUNvbnRlbnQoKTtcclxuICBcdFx0dGhpcy5fdXBkYXRlTGF5b3V0KCk7XHJcbiAgXHRcdHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XHJcblxyXG4gIFx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICcnO1xyXG5cclxuICBcdFx0dGhpcy5fYWRqdXN0UGFuKCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgZXZlbnRzID0ge1xyXG4gIFx0XHRcdHpvb206IHRoaXMuX3VwZGF0ZVBvc2l0aW9uLFxyXG4gIFx0XHRcdHZpZXdyZXNldDogdGhpcy5fdXBkYXRlUG9zaXRpb25cclxuICBcdFx0fTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuICBcdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9hbmltYXRlWm9vbTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gZXZlbnRzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGlzT3BlbjogQm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgd2hlbiB0aGUgb3ZlcmxheSBpcyB2aXNpYmxlIG9uIHRoZSBtYXAuXHJcbiAgXHRpc09wZW46IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuICEhdGhpcy5fbWFwICYmIHRoaXMuX21hcC5oYXNMYXllcih0aGlzKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQ6IHRoaXNcclxuICBcdC8vIEJyaW5ncyB0aGlzIG92ZXJsYXkgaW4gZnJvbnQgb2Ygb3RoZXIgb3ZlcmxheXMgKGluIHRoZSBzYW1lIG1hcCBwYW5lKS5cclxuICBcdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XHJcbiAgXHRcdFx0dG9Gcm9udCh0aGlzLl9jb250YWluZXIpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrOiB0aGlzXHJcbiAgXHQvLyBCcmluZ3MgdGhpcyBvdmVybGF5IHRvIHRoZSBiYWNrIG9mIG90aGVyIG92ZXJsYXlzIChpbiB0aGUgc2FtZSBtYXAgcGFuZSkuXHJcbiAgXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XHJcbiAgXHRcdFx0dG9CYWNrKHRoaXMuX2NvbnRhaW5lcik7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIHByZXBhcmUgYm91bmQgb3ZlcmxheSB0byBvcGVuOiB1cGRhdGUgbGF0bG5nIHBvcyAvIGNvbnRlbnQgc291cmNlIChmb3IgRmVhdHVyZUdyb3VwKVxyXG4gIFx0X3ByZXBhcmVPcGVuOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcbiAgXHRcdHZhciBzb3VyY2UgPSB0aGlzLl9zb3VyY2U7XHJcbiAgXHRcdGlmICghc291cmNlLl9tYXApIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4gIFx0XHRpZiAoc291cmNlIGluc3RhbmNlb2YgRmVhdHVyZUdyb3VwKSB7XHJcbiAgXHRcdFx0c291cmNlID0gbnVsbDtcclxuICBcdFx0XHR2YXIgbGF5ZXJzID0gdGhpcy5fc291cmNlLl9sYXllcnM7XHJcbiAgXHRcdFx0Zm9yICh2YXIgaWQgaW4gbGF5ZXJzKSB7XHJcbiAgXHRcdFx0XHRpZiAobGF5ZXJzW2lkXS5fbWFwKSB7XHJcbiAgXHRcdFx0XHRcdHNvdXJjZSA9IGxheWVyc1tpZF07XHJcbiAgXHRcdFx0XHRcdGJyZWFrO1xyXG4gIFx0XHRcdFx0fVxyXG4gIFx0XHRcdH1cclxuICBcdFx0XHRpZiAoIXNvdXJjZSkgeyByZXR1cm4gZmFsc2U7IH0gLy8gVW5hYmxlIHRvIGdldCBzb3VyY2UgbGF5ZXIuXHJcblxyXG4gIFx0XHRcdC8vIHNldCBvdmVybGF5IHNvdXJjZSB0byB0aGlzIGxheWVyXHJcbiAgXHRcdFx0dGhpcy5fc291cmNlID0gc291cmNlO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAoIWxhdGxuZykge1xyXG4gIFx0XHRcdGlmIChzb3VyY2UuZ2V0Q2VudGVyKSB7XHJcbiAgXHRcdFx0XHRsYXRsbmcgPSBzb3VyY2UuZ2V0Q2VudGVyKCk7XHJcbiAgXHRcdFx0fSBlbHNlIGlmIChzb3VyY2UuZ2V0TGF0TG5nKSB7XHJcbiAgXHRcdFx0XHRsYXRsbmcgPSBzb3VyY2UuZ2V0TGF0TG5nKCk7XHJcbiAgXHRcdFx0fSBlbHNlIGlmIChzb3VyY2UuZ2V0Qm91bmRzKSB7XHJcbiAgXHRcdFx0XHRsYXRsbmcgPSBzb3VyY2UuZ2V0Qm91bmRzKCkuZ2V0Q2VudGVyKCk7XHJcbiAgXHRcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGdldCBzb3VyY2UgbGF5ZXIgTGF0TG5nLicpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG4gIFx0XHR0aGlzLnNldExhdExuZyhsYXRsbmcpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX21hcCkge1xyXG4gIFx0XHRcdC8vIHVwZGF0ZSB0aGUgb3ZlcmxheSAoY29udGVudCwgbGF5b3V0LCBldGMuLi4pXHJcbiAgXHRcdFx0dGhpcy51cGRhdGUoKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRydWU7XHJcbiAgXHR9LFxyXG5cclxuICBcdF91cGRhdGVDb250ZW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fY29udGVudCkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdHZhciBub2RlID0gdGhpcy5fY29udGVudE5vZGU7XHJcbiAgXHRcdHZhciBjb250ZW50ID0gKHR5cGVvZiB0aGlzLl9jb250ZW50ID09PSAnZnVuY3Rpb24nKSA/IHRoaXMuX2NvbnRlbnQodGhpcy5fc291cmNlIHx8IHRoaXMpIDogdGhpcy5fY29udGVudDtcclxuXHJcbiAgXHRcdGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcclxuICBcdFx0XHRub2RlLmlubmVySFRNTCA9IGNvbnRlbnQ7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0d2hpbGUgKG5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XHJcbiAgXHRcdFx0XHRub2RlLnJlbW92ZUNoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQoY29udGVudCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIEBuYW1lc3BhY2UgRGl2T3ZlcmxheVxyXG4gIFx0XHQvLyBAc2VjdGlvbiBEaXZPdmVybGF5IGV2ZW50c1xyXG4gIFx0XHQvLyBAZXZlbnQgY29udGVudHVwZGF0ZTogRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgY29udGVudCBvZiB0aGUgb3ZlcmxheSBpcyB1cGRhdGVkXHJcbiAgXHRcdHRoaXMuZmlyZSgnY29udGVudHVwZGF0ZScpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpLFxyXG4gIFx0XHQgICAgb2Zmc2V0ID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMub2Zmc2V0KSxcclxuICBcdFx0ICAgIGFuY2hvciA9IHRoaXMuX2dldEFuY2hvcigpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG4gIFx0XHRcdHNldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lciwgcG9zLmFkZChhbmNob3IpKTtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRvZmZzZXQgPSBvZmZzZXQuYWRkKHBvcykuYWRkKGFuY2hvcik7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBib3R0b20gPSB0aGlzLl9jb250YWluZXJCb3R0b20gPSAtb2Zmc2V0LnksXHJcbiAgXHRcdCAgICBsZWZ0ID0gdGhpcy5fY29udGFpbmVyTGVmdCA9IC1NYXRoLnJvdW5kKHRoaXMuX2NvbnRhaW5lcldpZHRoIC8gMikgKyBvZmZzZXQueDtcclxuXHJcbiAgXHRcdC8vIGJvdHRvbSBwb3NpdGlvbiB0aGUgb3ZlcmxheSBpbiBjYXNlIHRoZSBoZWlnaHQgb2YgdGhlIG92ZXJsYXkgY2hhbmdlcyAoaW1hZ2VzIGxvYWRpbmcgZXRjKVxyXG4gIFx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUuYm90dG9tID0gYm90dG9tICsgJ3B4JztcclxuICBcdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLmxlZnQgPSBsZWZ0ICsgJ3B4JztcclxuICBcdH0sXHJcblxyXG4gIFx0X2dldEFuY2hvcjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gWzAsIDBdO1xyXG4gIFx0fVxyXG5cclxuICB9KTtcclxuXHJcbiAgTWFwLmluY2x1ZGUoe1xyXG4gIFx0X2luaXRPdmVybGF5OiBmdW5jdGlvbiAoT3ZlcmxheUNsYXNzLCBjb250ZW50LCBsYXRsbmcsIG9wdGlvbnMpIHtcclxuICBcdFx0dmFyIG92ZXJsYXkgPSBjb250ZW50O1xyXG4gIFx0XHRpZiAoIShvdmVybGF5IGluc3RhbmNlb2YgT3ZlcmxheUNsYXNzKSkge1xyXG4gIFx0XHRcdG92ZXJsYXkgPSBuZXcgT3ZlcmxheUNsYXNzKG9wdGlvbnMpLnNldENvbnRlbnQoY29udGVudCk7XHJcbiAgXHRcdH1cclxuICBcdFx0aWYgKGxhdGxuZykge1xyXG4gIFx0XHRcdG92ZXJsYXkuc2V0TGF0TG5nKGxhdGxuZyk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIG92ZXJsYXk7XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG5cclxuICBMYXllci5pbmNsdWRlKHtcclxuICBcdF9pbml0T3ZlcmxheTogZnVuY3Rpb24gKE92ZXJsYXlDbGFzcywgb2xkLCBjb250ZW50LCBvcHRpb25zKSB7XHJcbiAgXHRcdHZhciBvdmVybGF5ID0gY29udGVudDtcclxuICBcdFx0aWYgKG92ZXJsYXkgaW5zdGFuY2VvZiBPdmVybGF5Q2xhc3MpIHtcclxuICBcdFx0XHRzZXRPcHRpb25zKG92ZXJsYXksIG9wdGlvbnMpO1xyXG4gIFx0XHRcdG92ZXJsYXkuX3NvdXJjZSA9IHRoaXM7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0b3ZlcmxheSA9IChvbGQgJiYgIW9wdGlvbnMpID8gb2xkIDogbmV3IE92ZXJsYXlDbGFzcyhvcHRpb25zLCB0aGlzKTtcclxuICBcdFx0XHRvdmVybGF5LnNldENvbnRlbnQoY29udGVudCk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIG92ZXJsYXk7XHJcbiAgXHR9XHJcbiAgfSk7XG5cbiAgLypcclxuICAgKiBAY2xhc3MgUG9wdXBcclxuICAgKiBAaW5oZXJpdHMgRGl2T3ZlcmxheVxyXG4gICAqIEBha2EgTC5Qb3B1cFxyXG4gICAqIFVzZWQgdG8gb3BlbiBwb3B1cHMgaW4gY2VydGFpbiBwbGFjZXMgb2YgdGhlIG1hcC4gVXNlIFtNYXAub3BlblBvcHVwXSgjbWFwLW9wZW5wb3B1cCkgdG9cclxuICAgKiBvcGVuIHBvcHVwcyB3aGlsZSBtYWtpbmcgc3VyZSB0aGF0IG9ubHkgb25lIHBvcHVwIGlzIG9wZW4gYXQgb25lIHRpbWVcclxuICAgKiAocmVjb21tZW5kZWQgZm9yIHVzYWJpbGl0eSksIG9yIHVzZSBbTWFwLmFkZExheWVyXSgjbWFwLWFkZGxheWVyKSB0byBvcGVuIGFzIG1hbnkgYXMgeW91IHdhbnQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogSWYgeW91IHdhbnQgdG8ganVzdCBiaW5kIGEgcG9wdXAgdG8gbWFya2VyIGNsaWNrIGFuZCB0aGVuIG9wZW4gaXQsIGl0J3MgcmVhbGx5IGVhc3k6XHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIG1hcmtlci5iaW5kUG9wdXAocG9wdXBDb250ZW50KS5vcGVuUG9wdXAoKTtcclxuICAgKiBgYGBcclxuICAgKiBQYXRoIG92ZXJsYXlzIGxpa2UgcG9seWxpbmVzIGFsc28gaGF2ZSBhIGBiaW5kUG9wdXBgIG1ldGhvZC5cclxuICAgKlxyXG4gICAqIEEgcG9wdXAgY2FuIGJlIGFsc28gc3RhbmRhbG9uZTpcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogdmFyIHBvcHVwID0gTC5wb3B1cCgpXHJcbiAgICogXHQuc2V0TGF0TG5nKGxhdGxuZylcclxuICAgKiBcdC5zZXRDb250ZW50KCc8cD5IZWxsbyB3b3JsZCE8YnIgLz5UaGlzIGlzIGEgbmljZSBwb3B1cC48L3A+JylcclxuICAgKiBcdC5vcGVuT24obWFwKTtcclxuICAgKiBgYGBcclxuICAgKiBvclxyXG4gICAqIGBgYGpzXHJcbiAgICogdmFyIHBvcHVwID0gTC5wb3B1cChsYXRsbmcsIHtjb250ZW50OiAnPHA+SGVsbG8gd29ybGQhPGJyIC8+VGhpcyBpcyBhIG5pY2UgcG9wdXAuPC9wPicpXHJcbiAgICogXHQub3Blbk9uKG1hcCk7XHJcbiAgICogYGBgXHJcbiAgICovXHJcblxyXG5cclxuICAvLyBAbmFtZXNwYWNlIFBvcHVwXHJcbiAgdmFyIFBvcHVwID0gRGl2T3ZlcmxheS5leHRlbmQoe1xyXG5cclxuICBcdC8vIEBzZWN0aW9uXHJcbiAgXHQvLyBAYWthIFBvcHVwIG9wdGlvbnNcclxuICBcdG9wdGlvbnM6IHtcclxuICBcdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAncG9wdXBQYW5lJ1xyXG4gIFx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSBwb3B1cCB3aWxsIGJlIGFkZGVkLlxyXG4gIFx0XHRwYW5lOiAncG9wdXBQYW5lJyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gb2Zmc2V0OiBQb2ludCA9IFBvaW50KDAsIDcpXHJcbiAgXHRcdC8vIFRoZSBvZmZzZXQgb2YgdGhlIHBvcHVwIHBvc2l0aW9uLlxyXG4gIFx0XHRvZmZzZXQ6IFswLCA3XSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gbWF4V2lkdGg6IE51bWJlciA9IDMwMFxyXG4gIFx0XHQvLyBNYXggd2lkdGggb2YgdGhlIHBvcHVwLCBpbiBwaXhlbHMuXHJcbiAgXHRcdG1heFdpZHRoOiAzMDAsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIG1pbldpZHRoOiBOdW1iZXIgPSA1MFxyXG4gIFx0XHQvLyBNaW4gd2lkdGggb2YgdGhlIHBvcHVwLCBpbiBwaXhlbHMuXHJcbiAgXHRcdG1pbldpZHRoOiA1MCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gbWF4SGVpZ2h0OiBOdW1iZXIgPSBudWxsXHJcbiAgXHRcdC8vIElmIHNldCwgY3JlYXRlcyBhIHNjcm9sbGFibGUgY29udGFpbmVyIG9mIHRoZSBnaXZlbiBoZWlnaHRcclxuICBcdFx0Ly8gaW5zaWRlIGEgcG9wdXAgaWYgaXRzIGNvbnRlbnQgZXhjZWVkcyBpdC5cclxuICBcdFx0Ly8gVGhlIHNjcm9sbGFibGUgY29udGFpbmVyIGNhbiBiZSBzdHlsZWQgdXNpbmcgdGhlXHJcbiAgXHRcdC8vIGBsZWFmbGV0LXBvcHVwLXNjcm9sbGVkYCBDU1MgY2xhc3Mgc2VsZWN0b3IuXHJcbiAgXHRcdG1heEhlaWdodDogbnVsbCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gYXV0b1BhbjogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gU2V0IGl0IHRvIGBmYWxzZWAgaWYgeW91IGRvbid0IHdhbnQgdGhlIG1hcCB0byBkbyBwYW5uaW5nIGFuaW1hdGlvblxyXG4gIFx0XHQvLyB0byBmaXQgdGhlIG9wZW5lZCBwb3B1cC5cclxuICBcdFx0YXV0b1BhbjogdHJ1ZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gYXV0b1BhblBhZGRpbmdUb3BMZWZ0OiBQb2ludCA9IG51bGxcclxuICBcdFx0Ly8gVGhlIG1hcmdpbiBiZXR3ZWVuIHRoZSBwb3B1cCBhbmQgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgbWFwXHJcbiAgXHRcdC8vIHZpZXcgYWZ0ZXIgYXV0b3Bhbm5pbmcgd2FzIHBlcmZvcm1lZC5cclxuICBcdFx0YXV0b1BhblBhZGRpbmdUb3BMZWZ0OiBudWxsLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBhdXRvUGFuUGFkZGluZ0JvdHRvbVJpZ2h0OiBQb2ludCA9IG51bGxcclxuICBcdFx0Ly8gVGhlIG1hcmdpbiBiZXR3ZWVuIHRoZSBwb3B1cCBhbmQgdGhlIGJvdHRvbSByaWdodCBjb3JuZXIgb2YgdGhlIG1hcFxyXG4gIFx0XHQvLyB2aWV3IGFmdGVyIGF1dG9wYW5uaW5nIHdhcyBwZXJmb3JtZWQuXHJcbiAgXHRcdGF1dG9QYW5QYWRkaW5nQm90dG9tUmlnaHQ6IG51bGwsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGF1dG9QYW5QYWRkaW5nOiBQb2ludCA9IFBvaW50KDUsIDUpXHJcbiAgXHRcdC8vIEVxdWl2YWxlbnQgb2Ygc2V0dGluZyBib3RoIHRvcCBsZWZ0IGFuZCBib3R0b20gcmlnaHQgYXV0b3BhbiBwYWRkaW5nIHRvIHRoZSBzYW1lIHZhbHVlLlxyXG4gIFx0XHRhdXRvUGFuUGFkZGluZzogWzUsIDVdLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBrZWVwSW5WaWV3OiBCb29sZWFuID0gZmFsc2VcclxuICBcdFx0Ly8gU2V0IGl0IHRvIGB0cnVlYCBpZiB5b3Ugd2FudCB0byBwcmV2ZW50IHVzZXJzIGZyb20gcGFubmluZyB0aGUgcG9wdXBcclxuICBcdFx0Ly8gb2ZmIG9mIHRoZSBzY3JlZW4gd2hpbGUgaXQgaXMgb3Blbi5cclxuICBcdFx0a2VlcEluVmlldzogZmFsc2UsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGNsb3NlQnV0dG9uOiBCb29sZWFuID0gdHJ1ZVxyXG4gIFx0XHQvLyBDb250cm9scyB0aGUgcHJlc2VuY2Ugb2YgYSBjbG9zZSBidXR0b24gaW4gdGhlIHBvcHVwLlxyXG4gIFx0XHRjbG9zZUJ1dHRvbjogdHJ1ZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gYXV0b0Nsb3NlOiBCb29sZWFuID0gdHJ1ZVxyXG4gIFx0XHQvLyBTZXQgaXQgdG8gYGZhbHNlYCBpZiB5b3Ugd2FudCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZlxyXG4gIFx0XHQvLyB0aGUgcG9wdXAgY2xvc2luZyB3aGVuIGFub3RoZXIgcG9wdXAgaXMgb3BlbmVkLlxyXG4gIFx0XHRhdXRvQ2xvc2U6IHRydWUsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGNsb3NlT25Fc2NhcGVLZXk6IEJvb2xlYW4gPSB0cnVlXHJcbiAgXHRcdC8vIFNldCBpdCB0byBgZmFsc2VgIGlmIHlvdSB3YW50IHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mXHJcbiAgXHRcdC8vIHRoZSBFU0Mga2V5IGZvciBjbG9zaW5nIG9mIHRoZSBwb3B1cC5cclxuICBcdFx0Y2xvc2VPbkVzY2FwZUtleTogdHJ1ZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gY2xvc2VPbkNsaWNrOiBCb29sZWFuID0gKlxyXG4gIFx0XHQvLyBTZXQgaXQgaWYgeW91IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgdGhlIHBvcHVwIGNsb3Npbmcgd2hlbiB1c2VyIGNsaWNrc1xyXG4gIFx0XHQvLyBvbiB0aGUgbWFwLiBEZWZhdWx0cyB0byB0aGUgbWFwJ3MgW2BjbG9zZVBvcHVwT25DbGlja2BdKCNtYXAtY2xvc2Vwb3B1cG9uY2xpY2spIG9wdGlvbi5cclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xyXG4gIFx0XHQvLyBBIGN1c3RvbSBDU1MgY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gdGhlIHBvcHVwLlxyXG4gIFx0XHRjbGFzc05hbWU6ICcnXHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBuYW1lc3BhY2UgUG9wdXBcclxuICBcdC8vIEBtZXRob2Qgb3Blbk9uKG1hcDogTWFwKTogdGhpc1xyXG4gIFx0Ly8gQWx0ZXJuYXRpdmUgdG8gYG1hcC5vcGVuUG9wdXAocG9wdXApYC5cclxuICBcdC8vIEFkZHMgdGhlIHBvcHVwIHRvIHRoZSBtYXAgYW5kIGNsb3NlcyB0aGUgcHJldmlvdXMgb25lLlxyXG4gIFx0b3Blbk9uOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgXHRcdG1hcCA9IGFyZ3VtZW50cy5sZW5ndGggPyBtYXAgOiB0aGlzLl9zb3VyY2UuX21hcDsgLy8gZXhwZXJpbWVudGFsLCBub3QgdGhlIHBhcnQgb2YgcHVibGljIGFwaVxyXG5cclxuICBcdFx0aWYgKCFtYXAuaGFzTGF5ZXIodGhpcykgJiYgbWFwLl9wb3B1cCAmJiBtYXAuX3BvcHVwLm9wdGlvbnMuYXV0b0Nsb3NlKSB7XHJcbiAgXHRcdFx0bWFwLnJlbW92ZUxheWVyKG1hcC5fcG9wdXApO1xyXG4gIFx0XHR9XHJcbiAgXHRcdG1hcC5fcG9wdXAgPSB0aGlzO1xyXG5cclxuICBcdFx0cmV0dXJuIERpdk92ZXJsYXkucHJvdG90eXBlLm9wZW5Pbi5jYWxsKHRoaXMsIG1hcCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgXHRcdERpdk92ZXJsYXkucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcclxuXHJcbiAgXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcbiAgXHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG4gIFx0XHQvLyBAZXZlbnQgcG9wdXBvcGVuOiBQb3B1cEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBpcyBvcGVuZWQgaW4gdGhlIG1hcFxyXG4gIFx0XHRtYXAuZmlyZSgncG9wdXBvcGVuJywge3BvcHVwOiB0aGlzfSk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fc291cmNlKSB7XHJcbiAgXHRcdFx0Ly8gQG5hbWVzcGFjZSBMYXllclxyXG4gIFx0XHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG4gIFx0XHRcdC8vIEBldmVudCBwb3B1cG9wZW46IFBvcHVwRXZlbnRcclxuICBcdFx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBvcGVuZWRcclxuICBcdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgncG9wdXBvcGVuJywge3BvcHVwOiB0aGlzfSwgdHJ1ZSk7XHJcbiAgXHRcdFx0Ly8gRm9yIG5vbi1wYXRoIGxheWVycywgd2UgdG9nZ2xlIHRoZSBwb3B1cCB3aGVuIGNsaWNraW5nXHJcbiAgXHRcdFx0Ly8gYWdhaW4gdGhlIGxheWVyLCBzbyBwcmV2ZW50IHRoZSBtYXAgdG8gcmVvcGVuIGl0LlxyXG4gIFx0XHRcdGlmICghKHRoaXMuX3NvdXJjZSBpbnN0YW5jZW9mIFBhdGgpKSB7XHJcbiAgXHRcdFx0XHR0aGlzLl9zb3VyY2Uub24oJ3ByZWNsaWNrJywgc3RvcFByb3BhZ2F0aW9uKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0RGl2T3ZlcmxheS5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLCBtYXApO1xyXG5cclxuICBcdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuICBcdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcbiAgXHRcdC8vIEBldmVudCBwb3B1cGNsb3NlOiBQb3B1cEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBpbiB0aGUgbWFwIGlzIGNsb3NlZFxyXG4gIFx0XHRtYXAuZmlyZSgncG9wdXBjbG9zZScsIHtwb3B1cDogdGhpc30pO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xyXG4gIFx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcclxuICBcdFx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuICBcdFx0XHQvLyBAZXZlbnQgcG9wdXBjbG9zZTogUG9wdXBFdmVudFxyXG4gIFx0XHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGNsb3NlZFxyXG4gIFx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCdwb3B1cGNsb3NlJywge3BvcHVwOiB0aGlzfSwgdHJ1ZSk7XHJcbiAgXHRcdFx0aWYgKCEodGhpcy5fc291cmNlIGluc3RhbmNlb2YgUGF0aCkpIHtcclxuICBcdFx0XHRcdHRoaXMuX3NvdXJjZS5vZmYoJ3ByZWNsaWNrJywgc3RvcFByb3BhZ2F0aW9uKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBldmVudHMgPSBEaXZPdmVybGF5LnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrICE9PSB1bmRlZmluZWQgPyB0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrIDogdGhpcy5fbWFwLm9wdGlvbnMuY2xvc2VQb3B1cE9uQ2xpY2spIHtcclxuICBcdFx0XHRldmVudHMucHJlY2xpY2sgPSB0aGlzLmNsb3NlO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLmtlZXBJblZpZXcpIHtcclxuICBcdFx0XHRldmVudHMubW92ZWVuZCA9IHRoaXMuX2FkanVzdFBhbjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIGV2ZW50cztcclxuICBcdH0sXHJcblxyXG4gIFx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIHByZWZpeCA9ICdsZWFmbGV0LXBvcHVwJyxcclxuICBcdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IGNyZWF0ZSQxKCdkaXYnLFxyXG4gIFx0XHRcdHByZWZpeCArICcgJyArICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSArXHJcbiAgXHRcdFx0JyBsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTtcclxuXHJcbiAgXHRcdHZhciB3cmFwcGVyID0gdGhpcy5fd3JhcHBlciA9IGNyZWF0ZSQxKCdkaXYnLCBwcmVmaXggKyAnLWNvbnRlbnQtd3JhcHBlcicsIGNvbnRhaW5lcik7XHJcbiAgXHRcdHRoaXMuX2NvbnRlbnROb2RlID0gY3JlYXRlJDEoJ2RpdicsIHByZWZpeCArICctY29udGVudCcsIHdyYXBwZXIpO1xyXG5cclxuICBcdFx0ZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24oY29udGFpbmVyKTtcclxuICBcdFx0ZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKHRoaXMuX2NvbnRlbnROb2RlKTtcclxuICBcdFx0b24oY29udGFpbmVyLCAnY29udGV4dG1lbnUnLCBzdG9wUHJvcGFnYXRpb24pO1xyXG5cclxuICBcdFx0dGhpcy5fdGlwQ29udGFpbmVyID0gY3JlYXRlJDEoJ2RpdicsIHByZWZpeCArICctdGlwLWNvbnRhaW5lcicsIGNvbnRhaW5lcik7XHJcbiAgXHRcdHRoaXMuX3RpcCA9IGNyZWF0ZSQxKCdkaXYnLCBwcmVmaXggKyAnLXRpcCcsIHRoaXMuX3RpcENvbnRhaW5lcik7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLmNsb3NlQnV0dG9uKSB7XHJcbiAgXHRcdFx0dmFyIGNsb3NlQnV0dG9uID0gdGhpcy5fY2xvc2VCdXR0b24gPSBjcmVhdGUkMSgnYScsIHByZWZpeCArICctY2xvc2UtYnV0dG9uJywgY29udGFpbmVyKTtcclxuICBcdFx0XHRjbG9zZUJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnYnV0dG9uJyk7IC8vIG92ZXJyaWRlcyB0aGUgaW1wbGljaXQgcm9sZT1saW5rIG9mIDxhPiBlbGVtZW50cyAjNzM5OVxyXG4gIFx0XHRcdGNsb3NlQnV0dG9uLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsICdDbG9zZSBwb3B1cCcpO1xyXG4gIFx0XHRcdGNsb3NlQnV0dG9uLmhyZWYgPSAnI2Nsb3NlJztcclxuICBcdFx0XHRjbG9zZUJ1dHRvbi5pbm5lckhUTUwgPSAnPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+JiMyMTU7PC9zcGFuPic7XHJcblxyXG4gIFx0XHRcdG9uKGNsb3NlQnV0dG9uLCAnY2xpY2snLCBmdW5jdGlvbiAoZXYpIHtcclxuICBcdFx0XHRcdHByZXZlbnREZWZhdWx0KGV2KTtcclxuICBcdFx0XHRcdHRoaXMuY2xvc2UoKTtcclxuICBcdFx0XHR9LCB0aGlzKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfdXBkYXRlTGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250ZW50Tm9kZSxcclxuICBcdFx0ICAgIHN0eWxlID0gY29udGFpbmVyLnN0eWxlO1xyXG5cclxuICBcdFx0c3R5bGUud2lkdGggPSAnJztcclxuICBcdFx0c3R5bGUud2hpdGVTcGFjZSA9ICdub3dyYXAnO1xyXG5cclxuICBcdFx0dmFyIHdpZHRoID0gY29udGFpbmVyLm9mZnNldFdpZHRoO1xyXG4gIFx0XHR3aWR0aCA9IE1hdGgubWluKHdpZHRoLCB0aGlzLm9wdGlvbnMubWF4V2lkdGgpO1xyXG4gIFx0XHR3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCB0aGlzLm9wdGlvbnMubWluV2lkdGgpO1xyXG5cclxuICBcdFx0c3R5bGUud2lkdGggPSAod2lkdGggKyAxKSArICdweCc7XHJcbiAgXHRcdHN0eWxlLndoaXRlU3BhY2UgPSAnJztcclxuXHJcbiAgXHRcdHN0eWxlLmhlaWdodCA9ICcnO1xyXG5cclxuICBcdFx0dmFyIGhlaWdodCA9IGNvbnRhaW5lci5vZmZzZXRIZWlnaHQsXHJcbiAgXHRcdCAgICBtYXhIZWlnaHQgPSB0aGlzLm9wdGlvbnMubWF4SGVpZ2h0LFxyXG4gIFx0XHQgICAgc2Nyb2xsZWRDbGFzcyA9ICdsZWFmbGV0LXBvcHVwLXNjcm9sbGVkJztcclxuXHJcbiAgXHRcdGlmIChtYXhIZWlnaHQgJiYgaGVpZ2h0ID4gbWF4SGVpZ2h0KSB7XHJcbiAgXHRcdFx0c3R5bGUuaGVpZ2h0ID0gbWF4SGVpZ2h0ICsgJ3B4JztcclxuICBcdFx0XHRhZGRDbGFzcyhjb250YWluZXIsIHNjcm9sbGVkQ2xhc3MpO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdHJlbW92ZUNsYXNzKGNvbnRhaW5lciwgc2Nyb2xsZWRDbGFzcyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2NvbnRhaW5lcldpZHRoID0gdGhpcy5fY29udGFpbmVyLm9mZnNldFdpZHRoO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsIGUuem9vbSwgZS5jZW50ZXIpLFxyXG4gIFx0XHQgICAgYW5jaG9yID0gdGhpcy5fZ2V0QW5jaG9yKCk7XHJcbiAgXHRcdHNldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lciwgcG9zLmFkZChhbmNob3IpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2FkanVzdFBhbjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAoIXRoaXMub3B0aW9ucy5hdXRvUGFuKSB7IHJldHVybjsgfVxyXG4gIFx0XHRpZiAodGhpcy5fbWFwLl9wYW5BbmltKSB7IHRoaXMuX21hcC5fcGFuQW5pbS5zdG9wKCk7IH1cclxuXHJcbiAgXHRcdC8vIFdlIGNhbiBlbmRsZXNzbHkgcmVjdXJzZSBpZiBrZWVwSW5WaWV3IGlzIHNldCBhbmQgdGhlIHZpZXcgcmVzZXRzLlxyXG4gIFx0XHQvLyBMZXQncyBndWFyZCBhZ2FpbnN0IHRoYXQgYnkgZXhpdGluZyBlYXJseSBpZiB3ZSdyZSByZXNwb25kaW5nIHRvIG91ciBvd24gYXV0b3Bhbi5cclxuICBcdFx0aWYgKHRoaXMuX2F1dG9wYW5uaW5nKSB7XHJcbiAgXHRcdFx0dGhpcy5fYXV0b3Bhbm5pbmcgPSBmYWxzZTtcclxuICBcdFx0XHRyZXR1cm47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXHJcbiAgXHRcdCAgICBtYXJnaW5Cb3R0b20gPSBwYXJzZUludChnZXRTdHlsZSh0aGlzLl9jb250YWluZXIsICdtYXJnaW5Cb3R0b20nKSwgMTApIHx8IDAsXHJcbiAgXHRcdCAgICBjb250YWluZXJIZWlnaHQgPSB0aGlzLl9jb250YWluZXIub2Zmc2V0SGVpZ2h0ICsgbWFyZ2luQm90dG9tLFxyXG4gIFx0XHQgICAgY29udGFpbmVyV2lkdGggPSB0aGlzLl9jb250YWluZXJXaWR0aCxcclxuICBcdFx0ICAgIGxheWVyUG9zID0gbmV3IFBvaW50KHRoaXMuX2NvbnRhaW5lckxlZnQsIC1jb250YWluZXJIZWlnaHQgLSB0aGlzLl9jb250YWluZXJCb3R0b20pO1xyXG5cclxuICBcdFx0bGF5ZXJQb3MuX2FkZChnZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIpKTtcclxuXHJcbiAgXHRcdHZhciBjb250YWluZXJQb3MgPSBtYXAubGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQobGF5ZXJQb3MpLFxyXG4gIFx0XHQgICAgcGFkZGluZyA9IHRvUG9pbnQodGhpcy5vcHRpb25zLmF1dG9QYW5QYWRkaW5nKSxcclxuICBcdFx0ICAgIHBhZGRpbmdUTCA9IHRvUG9pbnQodGhpcy5vcHRpb25zLmF1dG9QYW5QYWRkaW5nVG9wTGVmdCB8fCBwYWRkaW5nKSxcclxuICBcdFx0ICAgIHBhZGRpbmdCUiA9IHRvUG9pbnQodGhpcy5vcHRpb25zLmF1dG9QYW5QYWRkaW5nQm90dG9tUmlnaHQgfHwgcGFkZGluZyksXHJcbiAgXHRcdCAgICBzaXplID0gbWFwLmdldFNpemUoKSxcclxuICBcdFx0ICAgIGR4ID0gMCxcclxuICBcdFx0ICAgIGR5ID0gMDtcclxuXHJcbiAgXHRcdGlmIChjb250YWluZXJQb3MueCArIGNvbnRhaW5lcldpZHRoICsgcGFkZGluZ0JSLnggPiBzaXplLngpIHsgLy8gcmlnaHRcclxuICBcdFx0XHRkeCA9IGNvbnRhaW5lclBvcy54ICsgY29udGFpbmVyV2lkdGggLSBzaXplLnggKyBwYWRkaW5nQlIueDtcclxuICBcdFx0fVxyXG4gIFx0XHRpZiAoY29udGFpbmVyUG9zLnggLSBkeCAtIHBhZGRpbmdUTC54IDwgMCkgeyAvLyBsZWZ0XHJcbiAgXHRcdFx0ZHggPSBjb250YWluZXJQb3MueCAtIHBhZGRpbmdUTC54O1xyXG4gIFx0XHR9XHJcbiAgXHRcdGlmIChjb250YWluZXJQb3MueSArIGNvbnRhaW5lckhlaWdodCArIHBhZGRpbmdCUi55ID4gc2l6ZS55KSB7IC8vIGJvdHRvbVxyXG4gIFx0XHRcdGR5ID0gY29udGFpbmVyUG9zLnkgKyBjb250YWluZXJIZWlnaHQgLSBzaXplLnkgKyBwYWRkaW5nQlIueTtcclxuICBcdFx0fVxyXG4gIFx0XHRpZiAoY29udGFpbmVyUG9zLnkgLSBkeSAtIHBhZGRpbmdUTC55IDwgMCkgeyAvLyB0b3BcclxuICBcdFx0XHRkeSA9IGNvbnRhaW5lclBvcy55IC0gcGFkZGluZ1RMLnk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcbiAgXHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG4gIFx0XHQvLyBAZXZlbnQgYXV0b3BhbnN0YXJ0OiBFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgc3RhcnRzIGF1dG9wYW5uaW5nIHdoZW4gb3BlbmluZyBhIHBvcHVwLlxyXG4gIFx0XHRpZiAoZHggfHwgZHkpIHtcclxuICBcdFx0XHQvLyBUcmFjayB0aGF0IHdlJ3JlIGF1dG9wYW5uaW5nLCBhcyB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgcmUtcmFuIG9uIG1vdmVlbmRcclxuICBcdFx0XHRpZiAodGhpcy5vcHRpb25zLmtlZXBJblZpZXcpIHtcclxuICBcdFx0XHRcdHRoaXMuX2F1dG9wYW5uaW5nID0gdHJ1ZTtcclxuICBcdFx0XHR9XHJcblxyXG4gIFx0XHRcdG1hcFxyXG4gIFx0XHRcdCAgICAuZmlyZSgnYXV0b3BhbnN0YXJ0JylcclxuICBcdFx0XHQgICAgLnBhbkJ5KFtkeCwgZHldKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfZ2V0QW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdC8vIFdoZXJlIHNob3VsZCB3ZSBhbmNob3IgdGhlIHBvcHVwIG9uIHRoZSBzb3VyY2UgbGF5ZXI/XHJcbiAgXHRcdHJldHVybiB0b1BvaW50KHRoaXMuX3NvdXJjZSAmJiB0aGlzLl9zb3VyY2UuX2dldFBvcHVwQW5jaG9yID8gdGhpcy5fc291cmNlLl9nZXRQb3B1cEFuY2hvcigpIDogWzAsIDBdKTtcclxuICBcdH1cclxuXHJcbiAgfSk7XHJcblxyXG4gIC8vIEBuYW1lc3BhY2UgUG9wdXBcclxuICAvLyBAZmFjdG9yeSBMLnBvcHVwKG9wdGlvbnM/OiBQb3B1cCBvcHRpb25zLCBzb3VyY2U/OiBMYXllcilcclxuICAvLyBJbnN0YW50aWF0ZXMgYSBgUG9wdXBgIG9iamVjdCBnaXZlbiBhbiBvcHRpb25hbCBgb3B0aW9uc2Agb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGl0cyBhcHBlYXJhbmNlIGFuZCBsb2NhdGlvbiBhbmQgYW4gb3B0aW9uYWwgYHNvdXJjZWAgb2JqZWN0IHRoYXQgaXMgdXNlZCB0byB0YWcgdGhlIHBvcHVwIHdpdGggYSByZWZlcmVuY2UgdG8gdGhlIExheWVyIHRvIHdoaWNoIGl0IHJlZmVycy5cclxuICAvLyBAYWx0ZXJuYXRpdmVcclxuICAvLyBAZmFjdG9yeSBMLnBvcHVwKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogUG9wdXAgb3B0aW9ucylcclxuICAvLyBJbnN0YW50aWF0ZXMgYSBgUG9wdXBgIG9iamVjdCBnaXZlbiBgbGF0bG5nYCB3aGVyZSB0aGUgcG9wdXAgd2lsbCBvcGVuIGFuZCBhbiBvcHRpb25hbCBgb3B0aW9uc2Agb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGl0cyBhcHBlYXJhbmNlIGFuZCBsb2NhdGlvbi5cclxuICB2YXIgcG9wdXAgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XHJcbiAgXHRyZXR1cm4gbmV3IFBvcHVwKG9wdGlvbnMsIHNvdXJjZSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qIEBuYW1lc3BhY2UgTWFwXHJcbiAgICogQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xyXG4gICAqIEBvcHRpb24gY2xvc2VQb3B1cE9uQ2xpY2s6IEJvb2xlYW4gPSB0cnVlXHJcbiAgICogU2V0IGl0IHRvIGBmYWxzZWAgaWYgeW91IGRvbid0IHdhbnQgcG9wdXBzIHRvIGNsb3NlIHdoZW4gdXNlciBjbGlja3MgdGhlIG1hcC5cclxuICAgKi9cclxuICBNYXAubWVyZ2VPcHRpb25zKHtcclxuICBcdGNsb3NlUG9wdXBPbkNsaWNrOiB0cnVlXHJcbiAgfSk7XHJcblxyXG5cclxuICAvLyBAbmFtZXNwYWNlIE1hcFxyXG4gIC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcclxuICBNYXAuaW5jbHVkZSh7XHJcbiAgXHQvLyBAbWV0aG9kIG9wZW5Qb3B1cChwb3B1cDogUG9wdXApOiB0aGlzXHJcbiAgXHQvLyBPcGVucyB0aGUgc3BlY2lmaWVkIHBvcHVwIHdoaWxlIGNsb3NpbmcgdGhlIHByZXZpb3VzbHkgb3BlbmVkICh0byBtYWtlIHN1cmUgb25seSBvbmUgaXMgb3BlbmVkIGF0IG9uZSB0aW1lIGZvciB1c2FiaWxpdHkpLlxyXG4gIFx0Ly8gQGFsdGVybmF0aXZlXHJcbiAgXHQvLyBAbWV0aG9kIG9wZW5Qb3B1cChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnQsIGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogUG9wdXAgb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIENyZWF0ZXMgYSBwb3B1cCB3aXRoIHRoZSBzcGVjaWZpZWQgY29udGVudCBhbmQgb3B0aW9ucyBhbmQgb3BlbnMgaXQgaW4gdGhlIGdpdmVuIHBvaW50IG9uIGEgbWFwLlxyXG4gIFx0b3BlblBvcHVwOiBmdW5jdGlvbiAocG9wdXAsIGxhdGxuZywgb3B0aW9ucykge1xyXG4gIFx0XHR0aGlzLl9pbml0T3ZlcmxheShQb3B1cCwgcG9wdXAsIGxhdGxuZywgb3B0aW9ucylcclxuICBcdFx0ICAub3Blbk9uKHRoaXMpO1xyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgY2xvc2VQb3B1cChwb3B1cD86IFBvcHVwKTogdGhpc1xyXG4gIFx0Ly8gQ2xvc2VzIHRoZSBwb3B1cCBwcmV2aW91c2x5IG9wZW5lZCB3aXRoIFtvcGVuUG9wdXBdKCNtYXAtb3BlbnBvcHVwKSAob3IgdGhlIGdpdmVuIG9uZSkuXHJcbiAgXHRjbG9zZVBvcHVwOiBmdW5jdGlvbiAocG9wdXApIHtcclxuICBcdFx0cG9wdXAgPSBhcmd1bWVudHMubGVuZ3RoID8gcG9wdXAgOiB0aGlzLl9wb3B1cDtcclxuICBcdFx0aWYgKHBvcHVwKSB7XHJcbiAgXHRcdFx0cG9wdXAuY2xvc2UoKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH1cclxuICB9KTtcclxuXHJcbiAgLypcclxuICAgKiBAbmFtZXNwYWNlIExheWVyXHJcbiAgICogQHNlY3Rpb24gUG9wdXAgbWV0aG9kcyBleGFtcGxlXHJcbiAgICpcclxuICAgKiBBbGwgbGF5ZXJzIHNoYXJlIGEgc2V0IG9mIG1ldGhvZHMgY29udmVuaWVudCBmb3IgYmluZGluZyBwb3B1cHMgdG8gaXQuXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIHZhciBsYXllciA9IEwuUG9seWdvbihsYXRsbmdzKS5iaW5kUG9wdXAoJ0hpIFRoZXJlIScpLmFkZFRvKG1hcCk7XHJcbiAgICogbGF5ZXIub3BlblBvcHVwKCk7XHJcbiAgICogbGF5ZXIuY2xvc2VQb3B1cCgpO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogUG9wdXBzIHdpbGwgYWxzbyBiZSBhdXRvbWF0aWNhbGx5IG9wZW5lZCB3aGVuIHRoZSBsYXllciBpcyBjbGlja2VkIG9uIGFuZCBjbG9zZWQgd2hlbiB0aGUgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIHRoZSBtYXAgb3IgYW5vdGhlciBwb3B1cCBpcyBvcGVuZWQuXHJcbiAgICovXHJcblxyXG4gIC8vIEBzZWN0aW9uIFBvcHVwIG1ldGhvZHNcclxuICBMYXllci5pbmNsdWRlKHtcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGJpbmRQb3B1cChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8RnVuY3Rpb258UG9wdXAsIG9wdGlvbnM/OiBQb3B1cCBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gQmluZHMgYSBwb3B1cCB0byB0aGUgbGF5ZXIgd2l0aCB0aGUgcGFzc2VkIGBjb250ZW50YCBhbmQgc2V0cyB1cCB0aGVcclxuICBcdC8vIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMuIElmIGEgYEZ1bmN0aW9uYCBpcyBwYXNzZWQgaXQgd2lsbCByZWNlaXZlXHJcbiAgXHQvLyB0aGUgbGF5ZXIgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IGFuZCBzaG91bGQgcmV0dXJuIGEgYFN0cmluZ2Agb3IgYEhUTUxFbGVtZW50YC5cclxuICBcdGJpbmRQb3B1cDogZnVuY3Rpb24gKGNvbnRlbnQsIG9wdGlvbnMpIHtcclxuICBcdFx0dGhpcy5fcG9wdXAgPSB0aGlzLl9pbml0T3ZlcmxheShQb3B1cCwgdGhpcy5fcG9wdXAsIGNvbnRlbnQsIG9wdGlvbnMpO1xyXG4gIFx0XHRpZiAoIXRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZCkge1xyXG4gIFx0XHRcdHRoaXMub24oe1xyXG4gIFx0XHRcdFx0Y2xpY2s6IHRoaXMuX29wZW5Qb3B1cCxcclxuICBcdFx0XHRcdGtleXByZXNzOiB0aGlzLl9vbktleVByZXNzLFxyXG4gIFx0XHRcdFx0cmVtb3ZlOiB0aGlzLmNsb3NlUG9wdXAsXHJcbiAgXHRcdFx0XHRtb3ZlOiB0aGlzLl9tb3ZlUG9wdXBcclxuICBcdFx0XHR9KTtcclxuICBcdFx0XHR0aGlzLl9wb3B1cEhhbmRsZXJzQWRkZWQgPSB0cnVlO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB1bmJpbmRQb3B1cCgpOiB0aGlzXHJcbiAgXHQvLyBSZW1vdmVzIHRoZSBwb3B1cCBwcmV2aW91c2x5IGJvdW5kIHdpdGggYGJpbmRQb3B1cGAuXHJcbiAgXHR1bmJpbmRQb3B1cDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuICBcdFx0XHR0aGlzLm9mZih7XHJcbiAgXHRcdFx0XHRjbGljazogdGhpcy5fb3BlblBvcHVwLFxyXG4gIFx0XHRcdFx0a2V5cHJlc3M6IHRoaXMuX29uS2V5UHJlc3MsXHJcbiAgXHRcdFx0XHRyZW1vdmU6IHRoaXMuY2xvc2VQb3B1cCxcclxuICBcdFx0XHRcdG1vdmU6IHRoaXMuX21vdmVQb3B1cFxyXG4gIFx0XHRcdH0pO1xyXG4gIFx0XHRcdHRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZCA9IGZhbHNlO1xyXG4gIFx0XHRcdHRoaXMuX3BvcHVwID0gbnVsbDtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBvcGVuUG9wdXAobGF0bG5nPzogTGF0TG5nKTogdGhpc1xyXG4gIFx0Ly8gT3BlbnMgdGhlIGJvdW5kIHBvcHVwIGF0IHRoZSBzcGVjaWZpZWQgYGxhdGxuZ2Agb3IgYXQgdGhlIGRlZmF1bHQgcG9wdXAgYW5jaG9yIGlmIG5vIGBsYXRsbmdgIGlzIHBhc3NlZC5cclxuICBcdG9wZW5Qb3B1cDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG4gIFx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuICBcdFx0XHRpZiAoISh0aGlzIGluc3RhbmNlb2YgRmVhdHVyZUdyb3VwKSkge1xyXG4gIFx0XHRcdFx0dGhpcy5fcG9wdXAuX3NvdXJjZSA9IHRoaXM7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHRcdGlmICh0aGlzLl9wb3B1cC5fcHJlcGFyZU9wZW4obGF0bG5nIHx8IHRoaXMuX2xhdGxuZykpIHtcclxuICBcdFx0XHRcdC8vIG9wZW4gdGhlIHBvcHVwIG9uIHRoZSBtYXBcclxuICBcdFx0XHRcdHRoaXMuX3BvcHVwLm9wZW5Pbih0aGlzLl9tYXApO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjbG9zZVBvcHVwKCk6IHRoaXNcclxuICBcdC8vIENsb3NlcyB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpZiBpdCBpcyBvcGVuLlxyXG4gIFx0Y2xvc2VQb3B1cDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuICBcdFx0XHR0aGlzLl9wb3B1cC5jbG9zZSgpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHRvZ2dsZVBvcHVwKCk6IHRoaXNcclxuICBcdC8vIE9wZW5zIG9yIGNsb3NlcyB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBkZXBlbmRpbmcgb24gaXRzIGN1cnJlbnQgc3RhdGUuXHJcbiAgXHR0b2dnbGVQb3B1cDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuICBcdFx0XHR0aGlzLl9wb3B1cC50b2dnbGUodGhpcyk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgaXNQb3B1cE9wZW4oKTogYm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgY3VycmVudGx5IG9wZW4uXHJcbiAgXHRpc1BvcHVwT3BlbjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gKHRoaXMuX3BvcHVwID8gdGhpcy5fcG9wdXAuaXNPcGVuKCkgOiBmYWxzZSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0UG9wdXBDb250ZW50KGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxQb3B1cCk6IHRoaXNcclxuICBcdC8vIFNldHMgdGhlIGNvbnRlbnQgb2YgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIuXHJcbiAgXHRzZXRQb3B1cENvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XHJcbiAgXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG4gIFx0XHRcdHRoaXMuX3BvcHVwLnNldENvbnRlbnQoY29udGVudCk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0UG9wdXAoKTogUG9wdXBcclxuICBcdC8vIFJldHVybnMgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIuXHJcbiAgXHRnZXRQb3B1cDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fcG9wdXA7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9vcGVuUG9wdXA6IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fcG9wdXAgfHwgIXRoaXMuX21hcCkge1xyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG4gIFx0XHQvLyBwcmV2ZW50IG1hcCBjbGlja1xyXG4gIFx0XHRzdG9wKGUpO1xyXG5cclxuICBcdFx0dmFyIHRhcmdldCA9IGUubGF5ZXIgfHwgZS50YXJnZXQ7XHJcbiAgXHRcdGlmICh0aGlzLl9wb3B1cC5fc291cmNlID09PSB0YXJnZXQgJiYgISh0YXJnZXQgaW5zdGFuY2VvZiBQYXRoKSkge1xyXG4gIFx0XHRcdC8vIHRyZWF0IGl0IGxpa2UgYSBtYXJrZXIgYW5kIGZpZ3VyZSBvdXRcclxuICBcdFx0XHQvLyBpZiB3ZSBzaG91bGQgdG9nZ2xlIGl0IG9wZW4vY2xvc2VkXHJcbiAgXHRcdFx0aWYgKHRoaXMuX21hcC5oYXNMYXllcih0aGlzLl9wb3B1cCkpIHtcclxuICBcdFx0XHRcdHRoaXMuY2xvc2VQb3B1cCgpO1xyXG4gIFx0XHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0XHR0aGlzLm9wZW5Qb3B1cChlLmxhdGxuZyk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG4gIFx0XHR0aGlzLl9wb3B1cC5fc291cmNlID0gdGFyZ2V0O1xyXG4gIFx0XHR0aGlzLm9wZW5Qb3B1cChlLmxhdGxuZyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9tb3ZlUG9wdXA6IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdHRoaXMuX3BvcHVwLnNldExhdExuZyhlLmxhdGxuZyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9vbktleVByZXNzOiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHRpZiAoZS5vcmlnaW5hbEV2ZW50LmtleUNvZGUgPT09IDEzKSB7XHJcbiAgXHRcdFx0dGhpcy5fb3BlblBvcHVwKGUpO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcbiAgfSk7XG5cbiAgLypcbiAgICogQGNsYXNzIFRvb2x0aXBcbiAgICogQGluaGVyaXRzIERpdk92ZXJsYXlcbiAgICogQGFrYSBMLlRvb2x0aXBcbiAgICogVXNlZCB0byBkaXNwbGF5IHNtYWxsIHRleHRzIG9uIHRvcCBvZiBtYXAgbGF5ZXJzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBJZiB5b3Ugd2FudCB0byBqdXN0IGJpbmQgYSB0b29sdGlwIHRvIG1hcmtlcjpcbiAgICpcbiAgICogYGBganNcbiAgICogbWFya2VyLmJpbmRUb29sdGlwKFwibXkgdG9vbHRpcCB0ZXh0XCIpLm9wZW5Ub29sdGlwKCk7XG4gICAqIGBgYFxuICAgKiBQYXRoIG92ZXJsYXlzIGxpa2UgcG9seWxpbmVzIGFsc28gaGF2ZSBhIGBiaW5kVG9vbHRpcGAgbWV0aG9kLlxuICAgKlxuICAgKiBBIHRvb2x0aXAgY2FuIGJlIGFsc28gc3RhbmRhbG9uZTpcbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIHRvb2x0aXAgPSBMLnRvb2x0aXAoKVxuICAgKiBcdC5zZXRMYXRMbmcobGF0bG5nKVxuICAgKiBcdC5zZXRDb250ZW50KCdIZWxsbyB3b3JsZCE8YnIgLz5UaGlzIGlzIGEgbmljZSB0b29sdGlwLicpXG4gICAqIFx0LmFkZFRvKG1hcCk7XG4gICAqIGBgYFxuICAgKiBvclxuICAgKiBgYGBqc1xuICAgKiB2YXIgdG9vbHRpcCA9IEwudG9vbHRpcChsYXRsbmcsIHtjb250ZW50OiAnSGVsbG8gd29ybGQhPGJyIC8+VGhpcyBpcyBhIG5pY2UgdG9vbHRpcC4nfSlcbiAgICogXHQuYWRkVG8obWFwKTtcbiAgICogYGBgXG4gICAqXG4gICAqXG4gICAqIE5vdGUgYWJvdXQgdG9vbHRpcCBvZmZzZXQuIExlYWZsZXQgdGFrZXMgdHdvIG9wdGlvbnMgaW4gY29uc2lkZXJhdGlvblxuICAgKiBmb3IgY29tcHV0aW5nIHRvb2x0aXAgb2Zmc2V0dGluZzpcbiAgICogLSB0aGUgYG9mZnNldGAgVG9vbHRpcCBvcHRpb246IGl0IGRlZmF1bHRzIHRvIFswLCAwXSwgYW5kIGl0J3Mgc3BlY2lmaWMgdG8gb25lIHRvb2x0aXAuXG4gICAqICAgQWRkIGEgcG9zaXRpdmUgeCBvZmZzZXQgdG8gbW92ZSB0aGUgdG9vbHRpcCB0byB0aGUgcmlnaHQsIGFuZCBhIHBvc2l0aXZlIHkgb2Zmc2V0IHRvXG4gICAqICAgbW92ZSBpdCB0byB0aGUgYm90dG9tLiBOZWdhdGl2ZXMgd2lsbCBtb3ZlIHRvIHRoZSBsZWZ0IGFuZCB0b3AuXG4gICAqIC0gdGhlIGB0b29sdGlwQW5jaG9yYCBJY29uIG9wdGlvbjogdGhpcyB3aWxsIG9ubHkgYmUgY29uc2lkZXJlZCBmb3IgTWFya2VyLiBZb3VcbiAgICogICBzaG91bGQgYWRhcHQgdGhpcyB2YWx1ZSBpZiB5b3UgdXNlIGEgY3VzdG9tIGljb24uXG4gICAqL1xuXG5cbiAgLy8gQG5hbWVzcGFjZSBUb29sdGlwXG4gIHZhciBUb29sdGlwID0gRGl2T3ZlcmxheS5leHRlbmQoe1xuXG4gIFx0Ly8gQHNlY3Rpb25cbiAgXHQvLyBAYWthIFRvb2x0aXAgb3B0aW9uc1xuICBcdG9wdGlvbnM6IHtcbiAgXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ3Rvb2x0aXBQYW5lJ1xuICBcdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgdG9vbHRpcCB3aWxsIGJlIGFkZGVkLlxuICBcdFx0cGFuZTogJ3Rvb2x0aXBQYW5lJyxcblxuICBcdFx0Ly8gQG9wdGlvbiBvZmZzZXQ6IFBvaW50ID0gUG9pbnQoMCwgMClcbiAgXHRcdC8vIE9wdGlvbmFsIG9mZnNldCBvZiB0aGUgdG9vbHRpcCBwb3NpdGlvbi5cbiAgXHRcdG9mZnNldDogWzAsIDBdLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGRpcmVjdGlvbjogU3RyaW5nID0gJ2F1dG8nXG4gIFx0XHQvLyBEaXJlY3Rpb24gd2hlcmUgdG8gb3BlbiB0aGUgdG9vbHRpcC4gUG9zc2libGUgdmFsdWVzIGFyZTogYHJpZ2h0YCwgYGxlZnRgLFxuICBcdFx0Ly8gYHRvcGAsIGBib3R0b21gLCBgY2VudGVyYCwgYGF1dG9gLlxuICBcdFx0Ly8gYGF1dG9gIHdpbGwgZHluYW1pY2FsbHkgc3dpdGNoIGJldHdlZW4gYHJpZ2h0YCBhbmQgYGxlZnRgIGFjY29yZGluZyB0byB0aGUgdG9vbHRpcFxuICBcdFx0Ly8gcG9zaXRpb24gb24gdGhlIG1hcC5cbiAgXHRcdGRpcmVjdGlvbjogJ2F1dG8nLFxuXG4gIFx0XHQvLyBAb3B0aW9uIHBlcm1hbmVudDogQm9vbGVhbiA9IGZhbHNlXG4gIFx0XHQvLyBXaGV0aGVyIHRvIG9wZW4gdGhlIHRvb2x0aXAgcGVybWFuZW50bHkgb3Igb25seSBvbiBtb3VzZW92ZXIuXG4gIFx0XHRwZXJtYW5lbnQ6IGZhbHNlLFxuXG4gIFx0XHQvLyBAb3B0aW9uIHN0aWNreTogQm9vbGVhbiA9IGZhbHNlXG4gIFx0XHQvLyBJZiB0cnVlLCB0aGUgdG9vbHRpcCB3aWxsIGZvbGxvdyB0aGUgbW91c2UgaW5zdGVhZCBvZiBiZWluZyBmaXhlZCBhdCB0aGUgZmVhdHVyZSBjZW50ZXIuXG4gIFx0XHRzdGlja3k6IGZhbHNlLFxuXG4gIFx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDAuOVxuICBcdFx0Ly8gVG9vbHRpcCBjb250YWluZXIgb3BhY2l0eS5cbiAgXHRcdG9wYWNpdHk6IDAuOVxuICBcdH0sXG5cbiAgXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xuICBcdFx0RGl2T3ZlcmxheS5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xuICBcdFx0dGhpcy5zZXRPcGFjaXR5KHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcblxuICBcdFx0Ly8gQG5hbWVzcGFjZSBNYXBcbiAgXHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG4gIFx0XHQvLyBAZXZlbnQgdG9vbHRpcG9wZW46IFRvb2x0aXBFdmVudFxuICBcdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgaXMgb3BlbmVkIGluIHRoZSBtYXAuXG4gIFx0XHRtYXAuZmlyZSgndG9vbHRpcG9wZW4nLCB7dG9vbHRpcDogdGhpc30pO1xuXG4gIFx0XHRpZiAodGhpcy5fc291cmNlKSB7XG4gIFx0XHRcdHRoaXMuYWRkRXZlbnRQYXJlbnQodGhpcy5fc291cmNlKTtcblxuICBcdFx0XHQvLyBAbmFtZXNwYWNlIExheWVyXG4gIFx0XHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG4gIFx0XHRcdC8vIEBldmVudCB0b29sdGlwb3BlbjogVG9vbHRpcEV2ZW50XG4gIFx0XHRcdC8vIEZpcmVkIHdoZW4gYSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgb3BlbmVkLlxuICBcdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgndG9vbHRpcG9wZW4nLCB7dG9vbHRpcDogdGhpc30sIHRydWUpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xuICBcdFx0RGl2T3ZlcmxheS5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLCBtYXApO1xuXG4gIFx0XHQvLyBAbmFtZXNwYWNlIE1hcFxuICBcdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcbiAgXHRcdC8vIEBldmVudCB0b29sdGlwY2xvc2U6IFRvb2x0aXBFdmVudFxuICBcdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgaW4gdGhlIG1hcCBpcyBjbG9zZWQuXG4gIFx0XHRtYXAuZmlyZSgndG9vbHRpcGNsb3NlJywge3Rvb2x0aXA6IHRoaXN9KTtcblxuICBcdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xuICBcdFx0XHR0aGlzLnJlbW92ZUV2ZW50UGFyZW50KHRoaXMuX3NvdXJjZSk7XG5cbiAgXHRcdFx0Ly8gQG5hbWVzcGFjZSBMYXllclxuICBcdFx0XHQvLyBAc2VjdGlvbiBUb29sdGlwIGV2ZW50c1xuICBcdFx0XHQvLyBAZXZlbnQgdG9vbHRpcGNsb3NlOiBUb29sdGlwRXZlbnRcbiAgXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjbG9zZWQuXG4gIFx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCd0b29sdGlwY2xvc2UnLCB7dG9vbHRpcDogdGhpc30sIHRydWUpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBldmVudHMgPSBEaXZPdmVybGF5LnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtcblxuICBcdFx0aWYgKCF0aGlzLm9wdGlvbnMucGVybWFuZW50KSB7XG4gIFx0XHRcdGV2ZW50cy5wcmVjbGljayA9IHRoaXMuY2xvc2U7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBldmVudHM7XG4gIFx0fSxcblxuICBcdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgcHJlZml4ID0gJ2xlYWZsZXQtdG9vbHRpcCcsXG4gIFx0XHQgICAgY2xhc3NOYW1lID0gcHJlZml4ICsgJyAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpICsgJyBsZWFmbGV0LXpvb20tJyArICh0aGlzLl96b29tQW5pbWF0ZWQgPyAnYW5pbWF0ZWQnIDogJ2hpZGUnKTtcblxuICBcdFx0dGhpcy5fY29udGVudE5vZGUgPSB0aGlzLl9jb250YWluZXIgPSBjcmVhdGUkMSgnZGl2JywgY2xhc3NOYW1lKTtcblxuICBcdFx0dGhpcy5fY29udGFpbmVyLnNldEF0dHJpYnV0ZSgncm9sZScsICd0b29sdGlwJyk7XG4gIFx0XHR0aGlzLl9jb250YWluZXIuc2V0QXR0cmlidXRlKCdpZCcsICdsZWFmbGV0LXRvb2x0aXAtJyArIHN0YW1wKHRoaXMpKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZUxheW91dDogZnVuY3Rpb24gKCkge30sXG5cbiAgXHRfYWRqdXN0UGFuOiBmdW5jdGlvbiAoKSB7fSxcblxuICBcdF9zZXRQb3NpdGlvbjogZnVuY3Rpb24gKHBvcykge1xuICBcdFx0dmFyIHN1YlgsIHN1YlksXG4gIFx0XHQgICAgbWFwID0gdGhpcy5fbWFwLFxuICBcdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcixcbiAgXHRcdCAgICBjZW50ZXJQb2ludCA9IG1hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KG1hcC5nZXRDZW50ZXIoKSksXG4gIFx0XHQgICAgdG9vbHRpcFBvaW50ID0gbWFwLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHBvcyksXG4gIFx0XHQgICAgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbixcbiAgXHRcdCAgICB0b29sdGlwV2lkdGggPSBjb250YWluZXIub2Zmc2V0V2lkdGgsXG4gIFx0XHQgICAgdG9vbHRpcEhlaWdodCA9IGNvbnRhaW5lci5vZmZzZXRIZWlnaHQsXG4gIFx0XHQgICAgb2Zmc2V0ID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMub2Zmc2V0KSxcbiAgXHRcdCAgICBhbmNob3IgPSB0aGlzLl9nZXRBbmNob3IoKTtcblxuICBcdFx0aWYgKGRpcmVjdGlvbiA9PT0gJ3RvcCcpIHtcbiAgXHRcdFx0c3ViWCA9IHRvb2x0aXBXaWR0aCAvIDI7XG4gIFx0XHRcdHN1YlkgPSB0b29sdGlwSGVpZ2h0O1xuICBcdFx0fSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdib3R0b20nKSB7XG4gIFx0XHRcdHN1YlggPSB0b29sdGlwV2lkdGggLyAyO1xuICBcdFx0XHRzdWJZID0gMDtcbiAgXHRcdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnY2VudGVyJykge1xuICBcdFx0XHRzdWJYID0gdG9vbHRpcFdpZHRoIC8gMjtcbiAgXHRcdFx0c3ViWSA9IHRvb2x0aXBIZWlnaHQgLyAyO1xuICBcdFx0fSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdyaWdodCcpIHtcbiAgXHRcdFx0c3ViWCA9IDA7XG4gIFx0XHRcdHN1YlkgPSB0b29sdGlwSGVpZ2h0IC8gMjtcbiAgXHRcdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnbGVmdCcpIHtcbiAgXHRcdFx0c3ViWCA9IHRvb2x0aXBXaWR0aDtcbiAgXHRcdFx0c3ViWSA9IHRvb2x0aXBIZWlnaHQgLyAyO1xuICBcdFx0fSBlbHNlIGlmICh0b29sdGlwUG9pbnQueCA8IGNlbnRlclBvaW50LngpIHtcbiAgXHRcdFx0ZGlyZWN0aW9uID0gJ3JpZ2h0JztcbiAgXHRcdFx0c3ViWCA9IDA7XG4gIFx0XHRcdHN1YlkgPSB0b29sdGlwSGVpZ2h0IC8gMjtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGRpcmVjdGlvbiA9ICdsZWZ0JztcbiAgXHRcdFx0c3ViWCA9IHRvb2x0aXBXaWR0aCArIChvZmZzZXQueCArIGFuY2hvci54KSAqIDI7XG4gIFx0XHRcdHN1YlkgPSB0b29sdGlwSGVpZ2h0IC8gMjtcbiAgXHRcdH1cblxuICBcdFx0cG9zID0gcG9zLnN1YnRyYWN0KHRvUG9pbnQoc3ViWCwgc3ViWSwgdHJ1ZSkpLmFkZChvZmZzZXQpLmFkZChhbmNob3IpO1xuXG4gIFx0XHRyZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtcmlnaHQnKTtcbiAgXHRcdHJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC1sZWZ0Jyk7XG4gIFx0XHRyZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtdG9wJyk7XG4gIFx0XHRyZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtYm90dG9tJyk7XG4gIFx0XHRhZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtJyArIGRpcmVjdGlvbik7XG4gIFx0XHRzZXRQb3NpdGlvbihjb250YWluZXIsIHBvcyk7XG4gIFx0fSxcblxuICBcdF91cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKTtcbiAgXHRcdHRoaXMuX3NldFBvc2l0aW9uKHBvcyk7XG4gIFx0fSxcblxuICBcdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XG4gIFx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XG5cbiAgXHRcdGlmICh0aGlzLl9jb250YWluZXIpIHtcbiAgXHRcdFx0c2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIG9wYWNpdHkpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLCBlLnpvb20sIGUuY2VudGVyKTtcbiAgXHRcdHRoaXMuX3NldFBvc2l0aW9uKHBvcyk7XG4gIFx0fSxcblxuICBcdF9nZXRBbmNob3I6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdC8vIFdoZXJlIHNob3VsZCB3ZSBhbmNob3IgdGhlIHRvb2x0aXAgb24gdGhlIHNvdXJjZSBsYXllcj9cbiAgXHRcdHJldHVybiB0b1BvaW50KHRoaXMuX3NvdXJjZSAmJiB0aGlzLl9zb3VyY2UuX2dldFRvb2x0aXBBbmNob3IgJiYgIXRoaXMub3B0aW9ucy5zdGlja3kgPyB0aGlzLl9zb3VyY2UuX2dldFRvb2x0aXBBbmNob3IoKSA6IFswLCAwXSk7XG4gIFx0fVxuXG4gIH0pO1xuXG4gIC8vIEBuYW1lc3BhY2UgVG9vbHRpcFxuICAvLyBAZmFjdG9yeSBMLnRvb2x0aXAob3B0aW9ucz86IFRvb2x0aXAgb3B0aW9ucywgc291cmNlPzogTGF5ZXIpXG4gIC8vIEluc3RhbnRpYXRlcyBhIGBUb29sdGlwYCBvYmplY3QgZ2l2ZW4gYW4gb3B0aW9uYWwgYG9wdGlvbnNgIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBpdHMgYXBwZWFyYW5jZSBhbmQgbG9jYXRpb24gYW5kIGFuIG9wdGlvbmFsIGBzb3VyY2VgIG9iamVjdCB0aGF0IGlzIHVzZWQgdG8gdGFnIHRoZSB0b29sdGlwIHdpdGggYSByZWZlcmVuY2UgdG8gdGhlIExheWVyIHRvIHdoaWNoIGl0IHJlZmVycy5cbiAgLy8gQGFsdGVybmF0aXZlXG4gIC8vIEBmYWN0b3J5IEwudG9vbHRpcChsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFRvb2x0aXAgb3B0aW9ucylcbiAgLy8gSW5zdGFudGlhdGVzIGEgYFRvb2x0aXBgIG9iamVjdCBnaXZlbiBgbGF0bG5nYCB3aGVyZSB0aGUgdG9vbHRpcCB3aWxsIG9wZW4gYW5kIGFuIG9wdGlvbmFsIGBvcHRpb25zYCBvYmplY3QgdGhhdCBkZXNjcmliZXMgaXRzIGFwcGVhcmFuY2UgYW5kIGxvY2F0aW9uLlxuICB2YXIgdG9vbHRpcCA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcbiAgXHRyZXR1cm4gbmV3IFRvb2x0aXAob3B0aW9ucywgc291cmNlKTtcbiAgfTtcblxuICAvLyBAbmFtZXNwYWNlIE1hcFxuICAvLyBAc2VjdGlvbiBNZXRob2RzIGZvciBMYXllcnMgYW5kIENvbnRyb2xzXG4gIE1hcC5pbmNsdWRlKHtcblxuICBcdC8vIEBtZXRob2Qgb3BlblRvb2x0aXAodG9vbHRpcDogVG9vbHRpcCk6IHRoaXNcbiAgXHQvLyBPcGVucyB0aGUgc3BlY2lmaWVkIHRvb2x0aXAuXG4gIFx0Ly8gQGFsdGVybmF0aXZlXG4gIFx0Ly8gQG1ldGhvZCBvcGVuVG9vbHRpcChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnQsIGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogVG9vbHRpcCBvcHRpb25zKTogdGhpc1xuICBcdC8vIENyZWF0ZXMgYSB0b29sdGlwIHdpdGggdGhlIHNwZWNpZmllZCBjb250ZW50IGFuZCBvcHRpb25zIGFuZCBvcGVuIGl0LlxuICBcdG9wZW5Ub29sdGlwOiBmdW5jdGlvbiAodG9vbHRpcCwgbGF0bG5nLCBvcHRpb25zKSB7XG4gIFx0XHR0aGlzLl9pbml0T3ZlcmxheShUb29sdGlwLCB0b29sdGlwLCBsYXRsbmcsIG9wdGlvbnMpXG4gIFx0XHQgIC5vcGVuT24odGhpcyk7XG5cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGNsb3NlVG9vbHRpcCh0b29sdGlwOiBUb29sdGlwKTogdGhpc1xuICBcdC8vIENsb3NlcyB0aGUgdG9vbHRpcCBnaXZlbiBhcyBwYXJhbWV0ZXIuXG4gIFx0Y2xvc2VUb29sdGlwOiBmdW5jdGlvbiAodG9vbHRpcCkge1xuICBcdFx0dG9vbHRpcC5jbG9zZSgpO1xuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fVxuXG4gIH0pO1xuXG4gIC8qXG4gICAqIEBuYW1lc3BhY2UgTGF5ZXJcbiAgICogQHNlY3Rpb24gVG9vbHRpcCBtZXRob2RzIGV4YW1wbGVcbiAgICpcbiAgICogQWxsIGxheWVycyBzaGFyZSBhIHNldCBvZiBtZXRob2RzIGNvbnZlbmllbnQgZm9yIGJpbmRpbmcgdG9vbHRpcHMgdG8gaXQuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHZhciBsYXllciA9IEwuUG9seWdvbihsYXRsbmdzKS5iaW5kVG9vbHRpcCgnSGkgVGhlcmUhJykuYWRkVG8obWFwKTtcbiAgICogbGF5ZXIub3BlblRvb2x0aXAoKTtcbiAgICogbGF5ZXIuY2xvc2VUb29sdGlwKCk7XG4gICAqIGBgYFxuICAgKi9cblxuICAvLyBAc2VjdGlvbiBUb29sdGlwIG1ldGhvZHNcbiAgTGF5ZXIuaW5jbHVkZSh7XG5cbiAgXHQvLyBAbWV0aG9kIGJpbmRUb29sdGlwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxGdW5jdGlvbnxUb29sdGlwLCBvcHRpb25zPzogVG9vbHRpcCBvcHRpb25zKTogdGhpc1xuICBcdC8vIEJpbmRzIGEgdG9vbHRpcCB0byB0aGUgbGF5ZXIgd2l0aCB0aGUgcGFzc2VkIGBjb250ZW50YCBhbmQgc2V0cyB1cCB0aGVcbiAgXHQvLyBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzLiBJZiBhIGBGdW5jdGlvbmAgaXMgcGFzc2VkIGl0IHdpbGwgcmVjZWl2ZVxuICBcdC8vIHRoZSBsYXllciBhcyB0aGUgZmlyc3QgYXJndW1lbnQgYW5kIHNob3VsZCByZXR1cm4gYSBgU3RyaW5nYCBvciBgSFRNTEVsZW1lbnRgLlxuICBcdGJpbmRUb29sdGlwOiBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xuXG4gIFx0XHRpZiAodGhpcy5fdG9vbHRpcCAmJiB0aGlzLmlzVG9vbHRpcE9wZW4oKSkge1xuICBcdFx0XHR0aGlzLnVuYmluZFRvb2x0aXAoKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fdG9vbHRpcCA9IHRoaXMuX2luaXRPdmVybGF5KFRvb2x0aXAsIHRoaXMuX3Rvb2x0aXAsIGNvbnRlbnQsIG9wdGlvbnMpO1xuICBcdFx0dGhpcy5faW5pdFRvb2x0aXBJbnRlcmFjdGlvbnMoKTtcblxuICBcdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5wZXJtYW5lbnQgJiYgdGhpcy5fbWFwICYmIHRoaXMuX21hcC5oYXNMYXllcih0aGlzKSkge1xuICBcdFx0XHR0aGlzLm9wZW5Ub29sdGlwKCk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHVuYmluZFRvb2x0aXAoKTogdGhpc1xuICBcdC8vIFJlbW92ZXMgdGhlIHRvb2x0aXAgcHJldmlvdXNseSBib3VuZCB3aXRoIGBiaW5kVG9vbHRpcGAuXG4gIFx0dW5iaW5kVG9vbHRpcDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcbiAgXHRcdFx0dGhpcy5faW5pdFRvb2x0aXBJbnRlcmFjdGlvbnModHJ1ZSk7XG4gIFx0XHRcdHRoaXMuY2xvc2VUb29sdGlwKCk7XG4gIFx0XHRcdHRoaXMuX3Rvb2x0aXAgPSBudWxsO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdF9pbml0VG9vbHRpcEludGVyYWN0aW9uczogZnVuY3Rpb24gKHJlbW92ZSkge1xuICBcdFx0aWYgKCFyZW1vdmUgJiYgdGhpcy5fdG9vbHRpcEhhbmRsZXJzQWRkZWQpIHsgcmV0dXJuOyB9XG4gIFx0XHR2YXIgb25PZmYgPSByZW1vdmUgPyAnb2ZmJyA6ICdvbicsXG4gIFx0XHQgICAgZXZlbnRzID0ge1xuICBcdFx0XHRyZW1vdmU6IHRoaXMuY2xvc2VUb29sdGlwLFxuICBcdFx0XHRtb3ZlOiB0aGlzLl9tb3ZlVG9vbHRpcFxuICBcdFx0ICAgIH07XG4gIFx0XHRpZiAoIXRoaXMuX3Rvb2x0aXAub3B0aW9ucy5wZXJtYW5lbnQpIHtcbiAgXHRcdFx0ZXZlbnRzLm1vdXNlb3ZlciA9IHRoaXMuX29wZW5Ub29sdGlwO1xuICBcdFx0XHRldmVudHMubW91c2VvdXQgPSB0aGlzLmNsb3NlVG9vbHRpcDtcbiAgXHRcdFx0ZXZlbnRzLmNsaWNrID0gdGhpcy5fb3BlblRvb2x0aXA7XG4gIFx0XHRcdGlmICh0aGlzLl9tYXApIHtcbiAgXHRcdFx0XHR0aGlzLl9hZGRGb2N1c0xpc3RlbmVycygpO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdGV2ZW50cy5hZGQgPSB0aGlzLl9hZGRGb2N1c0xpc3RlbmVycztcbiAgXHRcdFx0fVxuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0ZXZlbnRzLmFkZCA9IHRoaXMuX29wZW5Ub29sdGlwO1xuICBcdFx0fVxuICBcdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5zdGlja3kpIHtcbiAgXHRcdFx0ZXZlbnRzLm1vdXNlbW92ZSA9IHRoaXMuX21vdmVUb29sdGlwO1xuICBcdFx0fVxuICBcdFx0dGhpc1tvbk9mZl0oZXZlbnRzKTtcbiAgXHRcdHRoaXMuX3Rvb2x0aXBIYW5kbGVyc0FkZGVkID0gIXJlbW92ZTtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBvcGVuVG9vbHRpcChsYXRsbmc/OiBMYXRMbmcpOiB0aGlzXG4gIFx0Ly8gT3BlbnMgdGhlIGJvdW5kIHRvb2x0aXAgYXQgdGhlIHNwZWNpZmllZCBgbGF0bG5nYCBvciBhdCB0aGUgZGVmYXVsdCB0b29sdGlwIGFuY2hvciBpZiBubyBgbGF0bG5nYCBpcyBwYXNzZWQuXG4gIFx0b3BlblRvb2x0aXA6IGZ1bmN0aW9uIChsYXRsbmcpIHtcbiAgXHRcdGlmICh0aGlzLl90b29sdGlwKSB7XG4gIFx0XHRcdGlmICghKHRoaXMgaW5zdGFuY2VvZiBGZWF0dXJlR3JvdXApKSB7XG4gIFx0XHRcdFx0dGhpcy5fdG9vbHRpcC5fc291cmNlID0gdGhpcztcbiAgXHRcdFx0fVxuICBcdFx0XHRpZiAodGhpcy5fdG9vbHRpcC5fcHJlcGFyZU9wZW4obGF0bG5nKSkge1xuICBcdFx0XHRcdC8vIG9wZW4gdGhlIHRvb2x0aXAgb24gdGhlIG1hcFxuICBcdFx0XHRcdHRoaXMuX3Rvb2x0aXAub3Blbk9uKHRoaXMuX21hcCk7XG5cbiAgXHRcdFx0XHRpZiAodGhpcy5nZXRFbGVtZW50KSB7XG4gIFx0XHRcdFx0XHR0aGlzLl9zZXRBcmlhRGVzY3JpYmVkQnlPbkxheWVyKHRoaXMpO1xuICBcdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5lYWNoTGF5ZXIpIHtcbiAgXHRcdFx0XHRcdHRoaXMuZWFjaExheWVyKHRoaXMuX3NldEFyaWFEZXNjcmliZWRCeU9uTGF5ZXIsIHRoaXMpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgY2xvc2VUb29sdGlwKCk6IHRoaXNcbiAgXHQvLyBDbG9zZXMgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpZiBpdCBpcyBvcGVuLlxuICBcdGNsb3NlVG9vbHRpcDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcbiAgXHRcdFx0cmV0dXJuIHRoaXMuX3Rvb2x0aXAuY2xvc2UoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCB0b2dnbGVUb29sdGlwKCk6IHRoaXNcbiAgXHQvLyBPcGVucyBvciBjbG9zZXMgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBkZXBlbmRpbmcgb24gaXRzIGN1cnJlbnQgc3RhdGUuXG4gIFx0dG9nZ2xlVG9vbHRpcDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcbiAgXHRcdFx0dGhpcy5fdG9vbHRpcC50b2dnbGUodGhpcyk7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBpc1Rvb2x0aXBPcGVuKCk6IGJvb2xlYW5cbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGN1cnJlbnRseSBvcGVuLlxuICBcdGlzVG9vbHRpcE9wZW46IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLl90b29sdGlwLmlzT3BlbigpO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHNldFRvb2x0aXBDb250ZW50KGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxUb29sdGlwKTogdGhpc1xuICBcdC8vIFNldHMgdGhlIGNvbnRlbnQgb2YgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllci5cbiAgXHRzZXRUb29sdGlwQ29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgXHRcdGlmICh0aGlzLl90b29sdGlwKSB7XG4gIFx0XHRcdHRoaXMuX3Rvb2x0aXAuc2V0Q29udGVudChjb250ZW50KTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGdldFRvb2x0aXAoKTogVG9vbHRpcFxuICBcdC8vIFJldHVybnMgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllci5cbiAgXHRnZXRUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fdG9vbHRpcDtcbiAgXHR9LFxuXG4gIFx0X2FkZEZvY3VzTGlzdGVuZXJzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5nZXRFbGVtZW50KSB7XG4gIFx0XHRcdHRoaXMuX2FkZEZvY3VzTGlzdGVuZXJzT25MYXllcih0aGlzKTtcbiAgXHRcdH0gZWxzZSBpZiAodGhpcy5lYWNoTGF5ZXIpIHtcbiAgXHRcdFx0dGhpcy5lYWNoTGF5ZXIodGhpcy5fYWRkRm9jdXNMaXN0ZW5lcnNPbkxheWVyLCB0aGlzKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X2FkZEZvY3VzTGlzdGVuZXJzT25MYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR2YXIgZWwgPSBsYXllci5nZXRFbGVtZW50KCk7XG4gIFx0XHRpZiAoZWwpIHtcbiAgXHRcdFx0b24oZWwsICdmb2N1cycsIGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0XHR0aGlzLl90b29sdGlwLl9zb3VyY2UgPSBsYXllcjtcbiAgXHRcdFx0XHR0aGlzLm9wZW5Ub29sdGlwKCk7XG4gIFx0XHRcdH0sIHRoaXMpO1xuICBcdFx0XHRvbihlbCwgJ2JsdXInLCB0aGlzLmNsb3NlVG9vbHRpcCwgdGhpcyk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9zZXRBcmlhRGVzY3JpYmVkQnlPbkxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHZhciBlbCA9IGxheWVyLmdldEVsZW1lbnQoKTtcbiAgXHRcdGlmIChlbCkge1xuICBcdFx0XHRlbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknLCB0aGlzLl90b29sdGlwLl9jb250YWluZXIuaWQpO1xuICBcdFx0fVxuICBcdH0sXG5cblxuICBcdF9vcGVuVG9vbHRpcDogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdGlmICghdGhpcy5fdG9vbHRpcCB8fCAhdGhpcy5fbWFwIHx8ICh0aGlzLl9tYXAuZHJhZ2dpbmcgJiYgdGhpcy5fbWFwLmRyYWdnaW5nLm1vdmluZygpKSkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG4gIFx0XHR0aGlzLl90b29sdGlwLl9zb3VyY2UgPSBlLmxheWVyIHx8IGUudGFyZ2V0O1xuXG4gIFx0XHR0aGlzLm9wZW5Ub29sdGlwKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5zdGlja3kgPyBlLmxhdGxuZyA6IHVuZGVmaW5lZCk7XG4gIFx0fSxcblxuICBcdF9tb3ZlVG9vbHRpcDogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdHZhciBsYXRsbmcgPSBlLmxhdGxuZywgY29udGFpbmVyUG9pbnQsIGxheWVyUG9pbnQ7XG4gIFx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLnN0aWNreSAmJiBlLm9yaWdpbmFsRXZlbnQpIHtcbiAgXHRcdFx0Y29udGFpbmVyUG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS5vcmlnaW5hbEV2ZW50KTtcbiAgXHRcdFx0bGF5ZXJQb2ludCA9IHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChjb250YWluZXJQb2ludCk7XG4gIFx0XHRcdGxhdGxuZyA9IHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcobGF5ZXJQb2ludCk7XG4gIFx0XHR9XG4gIFx0XHR0aGlzLl90b29sdGlwLnNldExhdExuZyhsYXRsbmcpO1xuICBcdH1cbiAgfSk7XG5cbiAgLypcbiAgICogQGNsYXNzIERpdkljb25cbiAgICogQGFrYSBMLkRpdkljb25cbiAgICogQGluaGVyaXRzIEljb25cbiAgICpcbiAgICogUmVwcmVzZW50cyBhIGxpZ2h0d2VpZ2h0IGljb24gZm9yIG1hcmtlcnMgdGhhdCB1c2VzIGEgc2ltcGxlIGA8ZGl2PmBcbiAgICogZWxlbWVudCBpbnN0ZWFkIG9mIGFuIGltYWdlLiBJbmhlcml0cyBmcm9tIGBJY29uYCBidXQgaWdub3JlcyB0aGUgYGljb25VcmxgIGFuZCBzaGFkb3cgb3B0aW9ucy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogdmFyIG15SWNvbiA9IEwuZGl2SWNvbih7Y2xhc3NOYW1lOiAnbXktZGl2LWljb24nfSk7XG4gICAqIC8vIHlvdSBjYW4gc2V0IC5teS1kaXYtaWNvbiBzdHlsZXMgaW4gQ1NTXG4gICAqXG4gICAqIEwubWFya2VyKFs1MC41MDUsIDMwLjU3XSwge2ljb246IG15SWNvbn0pLmFkZFRvKG1hcCk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBpdCBoYXMgYSAnbGVhZmxldC1kaXYtaWNvbicgQ1NTIGNsYXNzIGFuZCBpcyBzdHlsZWQgYXMgYSBsaXR0bGUgd2hpdGUgc3F1YXJlIHdpdGggYSBzaGFkb3cuXG4gICAqL1xuXG4gIHZhciBEaXZJY29uID0gSWNvbi5leHRlbmQoe1xuICBcdG9wdGlvbnM6IHtcbiAgXHRcdC8vIEBzZWN0aW9uXG4gIFx0XHQvLyBAYWthIERpdkljb24gb3B0aW9uc1xuICBcdFx0aWNvblNpemU6IFsxMiwgMTJdLCAvLyBhbHNvIGNhbiBiZSBzZXQgdGhyb3VnaCBDU1NcblxuICBcdFx0Ly8gaWNvbkFuY2hvcjogKFBvaW50KSxcbiAgXHRcdC8vIHBvcHVwQW5jaG9yOiAoUG9pbnQpLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGh0bWw6IFN0cmluZ3xIVE1MRWxlbWVudCA9ICcnXG4gIFx0XHQvLyBDdXN0b20gSFRNTCBjb2RlIHRvIHB1dCBpbnNpZGUgdGhlIGRpdiBlbGVtZW50LCBlbXB0eSBieSBkZWZhdWx0LiBBbHRlcm5hdGl2ZWx5LFxuICBcdFx0Ly8gYW4gaW5zdGFuY2Ugb2YgYEhUTUxFbGVtZW50YC5cbiAgXHRcdGh0bWw6IGZhbHNlLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGJnUG9zOiBQb2ludCA9IFswLCAwXVxuICBcdFx0Ly8gT3B0aW9uYWwgcmVsYXRpdmUgcG9zaXRpb24gb2YgdGhlIGJhY2tncm91bmQsIGluIHBpeGVsc1xuICBcdFx0YmdQb3M6IG51bGwsXG5cbiAgXHRcdGNsYXNzTmFtZTogJ2xlYWZsZXQtZGl2LWljb24nXG4gIFx0fSxcblxuICBcdGNyZWF0ZUljb246IGZ1bmN0aW9uIChvbGRJY29uKSB7XG4gIFx0XHR2YXIgZGl2ID0gKG9sZEljb24gJiYgb2xkSWNvbi50YWdOYW1lID09PSAnRElWJykgPyBvbGRJY29uIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gIFx0XHQgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICBcdFx0aWYgKG9wdGlvbnMuaHRtbCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgXHRcdFx0ZW1wdHkoZGl2KTtcbiAgXHRcdFx0ZGl2LmFwcGVuZENoaWxkKG9wdGlvbnMuaHRtbCk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRkaXYuaW5uZXJIVE1MID0gb3B0aW9ucy5odG1sICE9PSBmYWxzZSA/IG9wdGlvbnMuaHRtbCA6ICcnO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAob3B0aW9ucy5iZ1Bvcykge1xuICBcdFx0XHR2YXIgYmdQb3MgPSB0b1BvaW50KG9wdGlvbnMuYmdQb3MpO1xuICBcdFx0XHRkaXYuc3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uID0gKC1iZ1Bvcy54KSArICdweCAnICsgKC1iZ1Bvcy55KSArICdweCc7XG4gIFx0XHR9XG4gIFx0XHR0aGlzLl9zZXRJY29uU3R5bGVzKGRpdiwgJ2ljb24nKTtcblxuICBcdFx0cmV0dXJuIGRpdjtcbiAgXHR9LFxuXG4gIFx0Y3JlYXRlU2hhZG93OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG4gIH0pO1xuXG4gIC8vIEBmYWN0b3J5IEwuZGl2SWNvbihvcHRpb25zOiBEaXZJY29uIG9wdGlvbnMpXG4gIC8vIENyZWF0ZXMgYSBgRGl2SWNvbmAgaW5zdGFuY2Ugd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbiAgZnVuY3Rpb24gZGl2SWNvbihvcHRpb25zKSB7XG4gIFx0cmV0dXJuIG5ldyBEaXZJY29uKG9wdGlvbnMpO1xuICB9XG5cbiAgSWNvbi5EZWZhdWx0ID0gSWNvbkRlZmF1bHQ7XG5cbiAgLypcbiAgICogQGNsYXNzIEdyaWRMYXllclxuICAgKiBAaW5oZXJpdHMgTGF5ZXJcbiAgICogQGFrYSBMLkdyaWRMYXllclxuICAgKlxuICAgKiBHZW5lcmljIGNsYXNzIGZvciBoYW5kbGluZyBhIHRpbGVkIGdyaWQgb2YgSFRNTCBlbGVtZW50cy4gVGhpcyBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgYWxsIHRpbGUgbGF5ZXJzIGFuZCByZXBsYWNlcyBgVGlsZUxheWVyLkNhbnZhc2AuXG4gICAqIEdyaWRMYXllciBjYW4gYmUgZXh0ZW5kZWQgdG8gY3JlYXRlIGEgdGlsZWQgZ3JpZCBvZiBIVE1MIGVsZW1lbnRzIGxpa2UgYDxjYW52YXM+YCwgYDxpbWc+YCBvciBgPGRpdj5gLiBHcmlkTGF5ZXIgd2lsbCBoYW5kbGUgY3JlYXRpbmcgYW5kIGFuaW1hdGluZyB0aGVzZSBET00gZWxlbWVudHMgZm9yIHlvdS5cbiAgICpcbiAgICpcbiAgICogQHNlY3Rpb24gU3luY2hyb25vdXMgdXNhZ2VcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogVG8gY3JlYXRlIGEgY3VzdG9tIGxheWVyLCBleHRlbmQgR3JpZExheWVyIGFuZCBpbXBsZW1lbnQgdGhlIGBjcmVhdGVUaWxlKClgIG1ldGhvZCwgd2hpY2ggd2lsbCBiZSBwYXNzZWQgYSBgUG9pbnRgIG9iamVjdCB3aXRoIHRoZSBgeGAsIGB5YCwgYW5kIGB6YCAoem9vbSBsZXZlbCkgY29vcmRpbmF0ZXMgdG8gZHJhdyB5b3VyIHRpbGUuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHZhciBDYW52YXNMYXllciA9IEwuR3JpZExheWVyLmV4dGVuZCh7XG4gICAqICAgICBjcmVhdGVUaWxlOiBmdW5jdGlvbihjb29yZHMpe1xuICAgKiAgICAgICAgIC8vIGNyZWF0ZSBhIDxjYW52YXM+IGVsZW1lbnQgZm9yIGRyYXdpbmdcbiAgICogICAgICAgICB2YXIgdGlsZSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2NhbnZhcycsICdsZWFmbGV0LXRpbGUnKTtcbiAgICpcbiAgICogICAgICAgICAvLyBzZXR1cCB0aWxlIHdpZHRoIGFuZCBoZWlnaHQgYWNjb3JkaW5nIHRvIHRoZSBvcHRpb25zXG4gICAqICAgICAgICAgdmFyIHNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XG4gICAqICAgICAgICAgdGlsZS53aWR0aCA9IHNpemUueDtcbiAgICogICAgICAgICB0aWxlLmhlaWdodCA9IHNpemUueTtcbiAgICpcbiAgICogICAgICAgICAvLyBnZXQgYSBjYW52YXMgY29udGV4dCBhbmQgZHJhdyBzb21ldGhpbmcgb24gaXQgdXNpbmcgY29vcmRzLngsIGNvb3Jkcy55IGFuZCBjb29yZHMuelxuICAgKiAgICAgICAgIHZhciBjdHggPSB0aWxlLmdldENvbnRleHQoJzJkJyk7XG4gICAqXG4gICAqICAgICAgICAgLy8gcmV0dXJuIHRoZSB0aWxlIHNvIGl0IGNhbiBiZSByZW5kZXJlZCBvbiBzY3JlZW5cbiAgICogICAgICAgICByZXR1cm4gdGlsZTtcbiAgICogICAgIH1cbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAc2VjdGlvbiBBc3luY2hyb25vdXMgdXNhZ2VcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogVGlsZSBjcmVhdGlvbiBjYW4gYWxzbyBiZSBhc3luY2hyb25vdXMsIHRoaXMgaXMgdXNlZnVsIHdoZW4gdXNpbmcgYSB0aGlyZC1wYXJ0eSBkcmF3aW5nIGxpYnJhcnkuIE9uY2UgdGhlIHRpbGUgaXMgZmluaXNoZWQgZHJhd2luZyBpdCBjYW4gYmUgcGFzc2VkIHRvIHRoZSBgZG9uZSgpYCBjYWxsYmFjay5cbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIENhbnZhc0xheWVyID0gTC5HcmlkTGF5ZXIuZXh0ZW5kKHtcbiAgICogICAgIGNyZWF0ZVRpbGU6IGZ1bmN0aW9uKGNvb3JkcywgZG9uZSl7XG4gICAqICAgICAgICAgdmFyIGVycm9yO1xuICAgKlxuICAgKiAgICAgICAgIC8vIGNyZWF0ZSBhIDxjYW52YXM+IGVsZW1lbnQgZm9yIGRyYXdpbmdcbiAgICogICAgICAgICB2YXIgdGlsZSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2NhbnZhcycsICdsZWFmbGV0LXRpbGUnKTtcbiAgICpcbiAgICogICAgICAgICAvLyBzZXR1cCB0aWxlIHdpZHRoIGFuZCBoZWlnaHQgYWNjb3JkaW5nIHRvIHRoZSBvcHRpb25zXG4gICAqICAgICAgICAgdmFyIHNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XG4gICAqICAgICAgICAgdGlsZS53aWR0aCA9IHNpemUueDtcbiAgICogICAgICAgICB0aWxlLmhlaWdodCA9IHNpemUueTtcbiAgICpcbiAgICogICAgICAgICAvLyBkcmF3IHNvbWV0aGluZyBhc3luY2hyb25vdXNseSBhbmQgcGFzcyB0aGUgdGlsZSB0byB0aGUgZG9uZSgpIGNhbGxiYWNrXG4gICAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICogICAgICAgICAgICAgZG9uZShlcnJvciwgdGlsZSk7XG4gICAqICAgICAgICAgfSwgMTAwMCk7XG4gICAqXG4gICAqICAgICAgICAgcmV0dXJuIHRpbGU7XG4gICAqICAgICB9XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHNlY3Rpb25cbiAgICovXG5cblxuICB2YXIgR3JpZExheWVyID0gTGF5ZXIuZXh0ZW5kKHtcblxuICBcdC8vIEBzZWN0aW9uXG4gIFx0Ly8gQGFrYSBHcmlkTGF5ZXIgb3B0aW9uc1xuICBcdG9wdGlvbnM6IHtcbiAgXHRcdC8vIEBvcHRpb24gdGlsZVNpemU6IE51bWJlcnxQb2ludCA9IDI1NlxuICBcdFx0Ly8gV2lkdGggYW5kIGhlaWdodCBvZiB0aWxlcyBpbiB0aGUgZ3JpZC4gVXNlIGEgbnVtYmVyIGlmIHdpZHRoIGFuZCBoZWlnaHQgYXJlIGVxdWFsLCBvciBgTC5wb2ludCh3aWR0aCwgaGVpZ2h0KWAgb3RoZXJ3aXNlLlxuICBcdFx0dGlsZVNpemU6IDI1NixcblxuICBcdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAxLjBcbiAgXHRcdC8vIE9wYWNpdHkgb2YgdGhlIHRpbGVzLiBDYW4gYmUgdXNlZCBpbiB0aGUgYGNyZWF0ZVRpbGUoKWAgZnVuY3Rpb24uXG4gIFx0XHRvcGFjaXR5OiAxLFxuXG4gIFx0XHQvLyBAb3B0aW9uIHVwZGF0ZVdoZW5JZGxlOiBCb29sZWFuID0gKGRlcGVuZHMpXG4gIFx0XHQvLyBMb2FkIG5ldyB0aWxlcyBvbmx5IHdoZW4gcGFubmluZyBlbmRzLlxuICBcdFx0Ly8gYHRydWVgIGJ5IGRlZmF1bHQgb24gbW9iaWxlIGJyb3dzZXJzLCBpbiBvcmRlciB0byBhdm9pZCB0b28gbWFueSByZXF1ZXN0cyBhbmQga2VlcCBzbW9vdGggbmF2aWdhdGlvbi5cbiAgXHRcdC8vIGBmYWxzZWAgb3RoZXJ3aXNlIGluIG9yZGVyIHRvIGRpc3BsYXkgbmV3IHRpbGVzIF9kdXJpbmdfIHBhbm5pbmcsIHNpbmNlIGl0IGlzIGVhc3kgdG8gcGFuIG91dHNpZGUgdGhlXG4gIFx0XHQvLyBbYGtlZXBCdWZmZXJgXSgjZ3JpZGxheWVyLWtlZXBidWZmZXIpIG9wdGlvbiBpbiBkZXNrdG9wIGJyb3dzZXJzLlxuICBcdFx0dXBkYXRlV2hlbklkbGU6IEJyb3dzZXIubW9iaWxlLFxuXG4gIFx0XHQvLyBAb3B0aW9uIHVwZGF0ZVdoZW5ab29taW5nOiBCb29sZWFuID0gdHJ1ZVxuICBcdFx0Ly8gQnkgZGVmYXVsdCwgYSBzbW9vdGggem9vbSBhbmltYXRpb24gKGR1cmluZyBhIFt0b3VjaCB6b29tXSgjbWFwLXRvdWNoem9vbSkgb3IgYSBbYGZseVRvKClgXSgjbWFwLWZseXRvKSkgd2lsbCB1cGRhdGUgZ3JpZCBsYXllcnMgZXZlcnkgaW50ZWdlciB6b29tIGxldmVsLiBTZXR0aW5nIHRoaXMgb3B0aW9uIHRvIGBmYWxzZWAgd2lsbCB1cGRhdGUgdGhlIGdyaWQgbGF5ZXIgb25seSB3aGVuIHRoZSBzbW9vdGggYW5pbWF0aW9uIGVuZHMuXG4gIFx0XHR1cGRhdGVXaGVuWm9vbWluZzogdHJ1ZSxcblxuICBcdFx0Ly8gQG9wdGlvbiB1cGRhdGVJbnRlcnZhbDogTnVtYmVyID0gMjAwXG4gIFx0XHQvLyBUaWxlcyB3aWxsIG5vdCB1cGRhdGUgbW9yZSB0aGFuIG9uY2UgZXZlcnkgYHVwZGF0ZUludGVydmFsYCBtaWxsaXNlY29uZHMgd2hlbiBwYW5uaW5nLlxuICBcdFx0dXBkYXRlSW50ZXJ2YWw6IDIwMCxcblxuICBcdFx0Ly8gQG9wdGlvbiB6SW5kZXg6IE51bWJlciA9IDFcbiAgXHRcdC8vIFRoZSBleHBsaWNpdCB6SW5kZXggb2YgdGhlIHRpbGUgbGF5ZXIuXG4gIFx0XHR6SW5kZXg6IDEsXG5cbiAgXHRcdC8vIEBvcHRpb24gYm91bmRzOiBMYXRMbmdCb3VuZHMgPSB1bmRlZmluZWRcbiAgXHRcdC8vIElmIHNldCwgdGlsZXMgd2lsbCBvbmx5IGJlIGxvYWRlZCBpbnNpZGUgdGhlIHNldCBgTGF0TG5nQm91bmRzYC5cbiAgXHRcdGJvdW5kczogbnVsbCxcblxuICBcdFx0Ly8gQG9wdGlvbiBtaW5ab29tOiBOdW1iZXIgPSAwXG4gIFx0XHQvLyBUaGUgbWluaW11bSB6b29tIGxldmVsIGRvd24gdG8gd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlIGRpc3BsYXllZCAoaW5jbHVzaXZlKS5cbiAgXHRcdG1pblpvb206IDAsXG5cbiAgXHRcdC8vIEBvcHRpb24gbWF4Wm9vbTogTnVtYmVyID0gdW5kZWZpbmVkXG4gIFx0XHQvLyBUaGUgbWF4aW11bSB6b29tIGxldmVsIHVwIHRvIHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZSBkaXNwbGF5ZWQgKGluY2x1c2l2ZSkuXG4gIFx0XHRtYXhab29tOiB1bmRlZmluZWQsXG5cbiAgXHRcdC8vIEBvcHRpb24gbWF4TmF0aXZlWm9vbTogTnVtYmVyID0gdW5kZWZpbmVkXG4gIFx0XHQvLyBNYXhpbXVtIHpvb20gbnVtYmVyIHRoZSB0aWxlIHNvdXJjZSBoYXMgYXZhaWxhYmxlLiBJZiBpdCBpcyBzcGVjaWZpZWQsXG4gIFx0XHQvLyB0aGUgdGlsZXMgb24gYWxsIHpvb20gbGV2ZWxzIGhpZ2hlciB0aGFuIGBtYXhOYXRpdmVab29tYCB3aWxsIGJlIGxvYWRlZFxuICBcdFx0Ly8gZnJvbSBgbWF4TmF0aXZlWm9vbWAgbGV2ZWwgYW5kIGF1dG8tc2NhbGVkLlxuICBcdFx0bWF4TmF0aXZlWm9vbTogdW5kZWZpbmVkLFxuXG4gIFx0XHQvLyBAb3B0aW9uIG1pbk5hdGl2ZVpvb206IE51bWJlciA9IHVuZGVmaW5lZFxuICBcdFx0Ly8gTWluaW11bSB6b29tIG51bWJlciB0aGUgdGlsZSBzb3VyY2UgaGFzIGF2YWlsYWJsZS4gSWYgaXQgaXMgc3BlY2lmaWVkLFxuICBcdFx0Ly8gdGhlIHRpbGVzIG9uIGFsbCB6b29tIGxldmVscyBsb3dlciB0aGFuIGBtaW5OYXRpdmVab29tYCB3aWxsIGJlIGxvYWRlZFxuICBcdFx0Ly8gZnJvbSBgbWluTmF0aXZlWm9vbWAgbGV2ZWwgYW5kIGF1dG8tc2NhbGVkLlxuICBcdFx0bWluTmF0aXZlWm9vbTogdW5kZWZpbmVkLFxuXG4gIFx0XHQvLyBAb3B0aW9uIG5vV3JhcDogQm9vbGVhbiA9IGZhbHNlXG4gIFx0XHQvLyBXaGV0aGVyIHRoZSBsYXllciBpcyB3cmFwcGVkIGFyb3VuZCB0aGUgYW50aW1lcmlkaWFuLiBJZiBgdHJ1ZWAsIHRoZVxuICBcdFx0Ly8gR3JpZExheWVyIHdpbGwgb25seSBiZSBkaXNwbGF5ZWQgb25jZSBhdCBsb3cgem9vbSBsZXZlbHMuIEhhcyBub1xuICBcdFx0Ly8gZWZmZWN0IHdoZW4gdGhlIFttYXAgQ1JTXSgjbWFwLWNycykgZG9lc24ndCB3cmFwIGFyb3VuZC4gQ2FuIGJlIHVzZWRcbiAgXHRcdC8vIGluIGNvbWJpbmF0aW9uIHdpdGggW2Bib3VuZHNgXSgjZ3JpZGxheWVyLWJvdW5kcykgdG8gcHJldmVudCByZXF1ZXN0aW5nXG4gIFx0XHQvLyB0aWxlcyBvdXRzaWRlIHRoZSBDUlMgbGltaXRzLlxuICBcdFx0bm9XcmFwOiBmYWxzZSxcblxuICBcdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAndGlsZVBhbmUnXG4gIFx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSBncmlkIGxheWVyIHdpbGwgYmUgYWRkZWQuXG4gIFx0XHRwYW5lOiAndGlsZVBhbmUnLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcbiAgXHRcdC8vIEEgY3VzdG9tIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSB0aWxlIGxheWVyLiBFbXB0eSBieSBkZWZhdWx0LlxuICBcdFx0Y2xhc3NOYW1lOiAnJyxcblxuICBcdFx0Ly8gQG9wdGlvbiBrZWVwQnVmZmVyOiBOdW1iZXIgPSAyXG4gIFx0XHQvLyBXaGVuIHBhbm5pbmcgdGhlIG1hcCwga2VlcCB0aGlzIG1hbnkgcm93cyBhbmQgY29sdW1ucyBvZiB0aWxlcyBiZWZvcmUgdW5sb2FkaW5nIHRoZW0uXG4gIFx0XHRrZWVwQnVmZmVyOiAyXG4gIFx0fSxcblxuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICBcdH0sXG5cbiAgXHRvbkFkZDogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5faW5pdENvbnRhaW5lcigpO1xuXG4gIFx0XHR0aGlzLl9sZXZlbHMgPSB7fTtcbiAgXHRcdHRoaXMuX3RpbGVzID0ge307XG5cbiAgXHRcdHRoaXMuX3Jlc2V0VmlldygpOyAvLyBpbXBsaWNpdCBfdXBkYXRlKCkgY2FsbFxuICBcdH0sXG5cbiAgXHRiZWZvcmVBZGQ6IGZ1bmN0aW9uIChtYXApIHtcbiAgXHRcdG1hcC5fYWRkWm9vbUxpbWl0KHRoaXMpO1xuICBcdH0sXG5cbiAgXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xuICBcdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcbiAgXHRcdHJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xuICBcdFx0bWFwLl9yZW1vdmVab29tTGltaXQodGhpcyk7XG4gIFx0XHR0aGlzLl9jb250YWluZXIgPSBudWxsO1xuICBcdFx0dGhpcy5fdGlsZVpvb20gPSB1bmRlZmluZWQ7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250OiB0aGlzXG4gIFx0Ly8gQnJpbmdzIHRoZSB0aWxlIGxheWVyIHRvIHRoZSB0b3Agb2YgYWxsIHRpbGUgbGF5ZXJzLlxuICBcdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX21hcCkge1xuICBcdFx0XHR0b0Zyb250KHRoaXMuX2NvbnRhaW5lcik7XG4gIFx0XHRcdHRoaXMuX3NldEF1dG9aSW5kZXgoTWF0aC5tYXgpO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgYnJpbmdUb0JhY2s6IHRoaXNcbiAgXHQvLyBCcmluZ3MgdGhlIHRpbGUgbGF5ZXIgdG8gdGhlIGJvdHRvbSBvZiBhbGwgdGlsZSBsYXllcnMuXG4gIFx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcbiAgXHRcdFx0dG9CYWNrKHRoaXMuX2NvbnRhaW5lcik7XG4gIFx0XHRcdHRoaXMuX3NldEF1dG9aSW5kZXgoTWF0aC5taW4pO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgZ2V0Q29udGFpbmVyOiBIVE1MRWxlbWVudFxuICBcdC8vIFJldHVybnMgdGhlIEhUTUwgZWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSB0aWxlcyBmb3IgdGhpcyBsYXllci5cbiAgXHRnZXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2Qgc2V0T3BhY2l0eShvcGFjaXR5OiBOdW1iZXIpOiB0aGlzXG4gIFx0Ly8gQ2hhbmdlcyB0aGUgW29wYWNpdHldKCNncmlkbGF5ZXItb3BhY2l0eSkgb2YgdGhlIGdyaWQgbGF5ZXIuXG4gIFx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcbiAgXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcbiAgXHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHNldFpJbmRleCh6SW5kZXg6IE51bWJlcik6IHRoaXNcbiAgXHQvLyBDaGFuZ2VzIHRoZSBbekluZGV4XSgjZ3JpZGxheWVyLXppbmRleCkgb2YgdGhlIGdyaWQgbGF5ZXIuXG4gIFx0c2V0WkluZGV4OiBmdW5jdGlvbiAoekluZGV4KSB7XG4gIFx0XHR0aGlzLm9wdGlvbnMuekluZGV4ID0gekluZGV4O1xuICBcdFx0dGhpcy5fdXBkYXRlWkluZGV4KCk7XG5cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGlzTG9hZGluZzogQm9vbGVhblxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIGFueSB0aWxlIGluIHRoZSBncmlkIGxheWVyIGhhcyBub3QgZmluaXNoZWQgbG9hZGluZy5cbiAgXHRpc0xvYWRpbmc6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLl9sb2FkaW5nO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHJlZHJhdzogdGhpc1xuICBcdC8vIENhdXNlcyB0aGUgbGF5ZXIgdG8gY2xlYXIgYWxsIHRoZSB0aWxlcyBhbmQgcmVxdWVzdCB0aGVtIGFnYWluLlxuICBcdHJlZHJhdzogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX21hcCkge1xuICBcdFx0XHR0aGlzLl9yZW1vdmVBbGxUaWxlcygpO1xuICBcdFx0XHR2YXIgdGlsZVpvb20gPSB0aGlzLl9jbGFtcFpvb20odGhpcy5fbWFwLmdldFpvb20oKSk7XG4gIFx0XHRcdGlmICh0aWxlWm9vbSAhPT0gdGhpcy5fdGlsZVpvb20pIHtcbiAgXHRcdFx0XHR0aGlzLl90aWxlWm9vbSA9IHRpbGVab29tO1xuICBcdFx0XHRcdHRoaXMuX3VwZGF0ZUxldmVscygpO1xuICBcdFx0XHR9XG4gIFx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGV2ZW50cyA9IHtcbiAgXHRcdFx0dmlld3ByZXJlc2V0OiB0aGlzLl9pbnZhbGlkYXRlQWxsLFxuICBcdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0VmlldyxcbiAgXHRcdFx0em9vbTogdGhpcy5fcmVzZXRWaWV3LFxuICBcdFx0XHRtb3ZlZW5kOiB0aGlzLl9vbk1vdmVFbmRcbiAgXHRcdH07XG5cbiAgXHRcdGlmICghdGhpcy5vcHRpb25zLnVwZGF0ZVdoZW5JZGxlKSB7XG4gIFx0XHRcdC8vIHVwZGF0ZSB0aWxlcyBvbiBtb3ZlLCBidXQgbm90IG1vcmUgb2Z0ZW4gdGhhbiBvbmNlIHBlciBnaXZlbiBpbnRlcnZhbFxuICBcdFx0XHRpZiAoIXRoaXMuX29uTW92ZSkge1xuICBcdFx0XHRcdHRoaXMuX29uTW92ZSA9IHRocm90dGxlKHRoaXMuX29uTW92ZUVuZCwgdGhpcy5vcHRpb25zLnVwZGF0ZUludGVydmFsLCB0aGlzKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGV2ZW50cy5tb3ZlID0gdGhpcy5fb25Nb3ZlO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XG4gIFx0XHRcdGV2ZW50cy56b29tYW5pbSA9IHRoaXMuX2FuaW1hdGVab29tO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gZXZlbnRzO1xuICBcdH0sXG5cbiAgXHQvLyBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xuICBcdC8vIExheWVycyBleHRlbmRpbmcgYEdyaWRMYXllcmAgc2hhbGwgcmVpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBtZXRob2QuXG4gIFx0Ly8gQG1ldGhvZCBjcmVhdGVUaWxlKGNvb3JkczogT2JqZWN0LCBkb25lPzogRnVuY3Rpb24pOiBIVE1MRWxlbWVudFxuICBcdC8vIENhbGxlZCBvbmx5IGludGVybmFsbHksIG11c3QgYmUgb3ZlcnJpZGRlbiBieSBjbGFzc2VzIGV4dGVuZGluZyBgR3JpZExheWVyYC5cbiAgXHQvLyBSZXR1cm5zIHRoZSBgSFRNTEVsZW1lbnRgIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGBjb29yZHNgLiBJZiB0aGUgYGRvbmVgIGNhbGxiYWNrXG4gIFx0Ly8gaXMgc3BlY2lmaWVkLCBpdCBtdXN0IGJlIGNhbGxlZCB3aGVuIHRoZSB0aWxlIGhhcyBmaW5pc2hlZCBsb2FkaW5nIGFuZCBkcmF3aW5nLlxuICBcdGNyZWF0ZVRpbGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgXHR9LFxuXG4gIFx0Ly8gQHNlY3Rpb25cbiAgXHQvLyBAbWV0aG9kIGdldFRpbGVTaXplOiBQb2ludFxuICBcdC8vIE5vcm1hbGl6ZXMgdGhlIFt0aWxlU2l6ZSBvcHRpb25dKCNncmlkbGF5ZXItdGlsZXNpemUpIGludG8gYSBwb2ludC4gVXNlZCBieSB0aGUgYGNyZWF0ZVRpbGUoKWAgbWV0aG9kLlxuICBcdGdldFRpbGVTaXplOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgcyA9IHRoaXMub3B0aW9ucy50aWxlU2l6ZTtcbiAgXHRcdHJldHVybiBzIGluc3RhbmNlb2YgUG9pbnQgPyBzIDogbmV3IFBvaW50KHMsIHMpO1xuICBcdH0sXG5cbiAgXHRfdXBkYXRlWkluZGV4OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fY29udGFpbmVyICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IHVuZGVmaW5lZCAmJiB0aGlzLm9wdGlvbnMuekluZGV4ICE9PSBudWxsKSB7XG4gIFx0XHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS56SW5kZXggPSB0aGlzLm9wdGlvbnMuekluZGV4O1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfc2V0QXV0b1pJbmRleDogZnVuY3Rpb24gKGNvbXBhcmUpIHtcbiAgXHRcdC8vIGdvIHRocm91Z2ggYWxsIG90aGVyIGxheWVycyBvZiB0aGUgc2FtZSBwYW5lLCBzZXQgekluZGV4IHRvIG1heCArIDEgKGZyb250KSBvciBtaW4gLSAxIChiYWNrKVxuXG4gIFx0XHR2YXIgbGF5ZXJzID0gdGhpcy5nZXRQYW5lKCkuY2hpbGRyZW4sXG4gIFx0XHQgICAgZWRnZVpJbmRleCA9IC1jb21wYXJlKC1JbmZpbml0eSwgSW5maW5pdHkpOyAvLyAtSW5maW5pdHkgZm9yIG1heCwgSW5maW5pdHkgZm9yIG1pblxuXG4gIFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF5ZXJzLmxlbmd0aCwgekluZGV4OyBpIDwgbGVuOyBpKyspIHtcblxuICBcdFx0XHR6SW5kZXggPSBsYXllcnNbaV0uc3R5bGUuekluZGV4O1xuXG4gIFx0XHRcdGlmIChsYXllcnNbaV0gIT09IHRoaXMuX2NvbnRhaW5lciAmJiB6SW5kZXgpIHtcbiAgXHRcdFx0XHRlZGdlWkluZGV4ID0gY29tcGFyZShlZGdlWkluZGV4LCArekluZGV4KTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRpZiAoaXNGaW5pdGUoZWRnZVpJbmRleCkpIHtcbiAgXHRcdFx0dGhpcy5vcHRpb25zLnpJbmRleCA9IGVkZ2VaSW5kZXggKyBjb21wYXJlKC0xLCAxKTtcbiAgXHRcdFx0dGhpcy5fdXBkYXRlWkluZGV4KCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF91cGRhdGVPcGFjaXR5OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cblxuICBcdFx0Ly8gSUUgZG9lc24ndCBpbmhlcml0IGZpbHRlciBvcGFjaXR5IHByb3Blcmx5LCBzbyB3ZSdyZSBmb3JjZWQgdG8gc2V0IGl0IG9uIHRpbGVzXG4gIFx0XHRpZiAoQnJvd3Nlci5pZWx0OSkgeyByZXR1cm47IH1cblxuICBcdFx0c2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcblxuICBcdFx0dmFyIG5vdyA9ICtuZXcgRGF0ZSgpLFxuICBcdFx0ICAgIG5leHRGcmFtZSA9IGZhbHNlLFxuICBcdFx0ICAgIHdpbGxQcnVuZSA9IGZhbHNlO1xuXG4gIFx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcbiAgXHRcdFx0dmFyIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuICBcdFx0XHRpZiAoIXRpbGUuY3VycmVudCB8fCAhdGlsZS5sb2FkZWQpIHsgY29udGludWU7IH1cblxuICBcdFx0XHR2YXIgZmFkZSA9IE1hdGgubWluKDEsIChub3cgLSB0aWxlLmxvYWRlZCkgLyAyMDApO1xuXG4gIFx0XHRcdHNldE9wYWNpdHkodGlsZS5lbCwgZmFkZSk7XG4gIFx0XHRcdGlmIChmYWRlIDwgMSkge1xuICBcdFx0XHRcdG5leHRGcmFtZSA9IHRydWU7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0aWYgKHRpbGUuYWN0aXZlKSB7XG4gIFx0XHRcdFx0XHR3aWxsUHJ1bmUgPSB0cnVlO1xuICBcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHR0aGlzLl9vbk9wYXF1ZVRpbGUodGlsZSk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHRcdHRpbGUuYWN0aXZlID0gdHJ1ZTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRpZiAod2lsbFBydW5lICYmICF0aGlzLl9ub1BydW5lKSB7IHRoaXMuX3BydW5lVGlsZXMoKTsgfVxuXG4gIFx0XHRpZiAobmV4dEZyYW1lKSB7XG4gIFx0XHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9mYWRlRnJhbWUpO1xuICBcdFx0XHR0aGlzLl9mYWRlRnJhbWUgPSByZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3VwZGF0ZU9wYWNpdHksIHRoaXMpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfb25PcGFxdWVUaWxlOiBmYWxzZUZuLFxuXG4gIFx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9jb250YWluZXIpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHRoaXMuX2NvbnRhaW5lciA9IGNyZWF0ZSQxKCdkaXYnLCAnbGVhZmxldC1sYXllciAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpKTtcbiAgXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xuXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLm9wYWNpdHkgPCAxKSB7XG4gIFx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZUxldmVsczogZnVuY3Rpb24gKCkge1xuXG4gIFx0XHR2YXIgem9vbSA9IHRoaXMuX3RpbGVab29tLFxuICBcdFx0ICAgIG1heFpvb20gPSB0aGlzLm9wdGlvbnMubWF4Wm9vbTtcblxuICBcdFx0aWYgKHpvb20gPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG5cbiAgXHRcdGZvciAodmFyIHogaW4gdGhpcy5fbGV2ZWxzKSB7XG4gIFx0XHRcdHogPSBOdW1iZXIoeik7XG4gIFx0XHRcdGlmICh0aGlzLl9sZXZlbHNbel0uZWwuY2hpbGRyZW4ubGVuZ3RoIHx8IHogPT09IHpvb20pIHtcbiAgXHRcdFx0XHR0aGlzLl9sZXZlbHNbel0uZWwuc3R5bGUuekluZGV4ID0gbWF4Wm9vbSAtIE1hdGguYWJzKHpvb20gLSB6KTtcbiAgXHRcdFx0XHR0aGlzLl9vblVwZGF0ZUxldmVsKHopO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdHJlbW92ZSh0aGlzLl9sZXZlbHNbel0uZWwpO1xuICBcdFx0XHRcdHRoaXMuX3JlbW92ZVRpbGVzQXRab29tKHopO1xuICBcdFx0XHRcdHRoaXMuX29uUmVtb3ZlTGV2ZWwoeik7XG4gIFx0XHRcdFx0ZGVsZXRlIHRoaXMuX2xldmVsc1t6XTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHR2YXIgbGV2ZWwgPSB0aGlzLl9sZXZlbHNbem9vbV0sXG4gIFx0XHQgICAgbWFwID0gdGhpcy5fbWFwO1xuXG4gIFx0XHRpZiAoIWxldmVsKSB7XG4gIFx0XHRcdGxldmVsID0gdGhpcy5fbGV2ZWxzW3pvb21dID0ge307XG5cbiAgXHRcdFx0bGV2ZWwuZWwgPSBjcmVhdGUkMSgnZGl2JywgJ2xlYWZsZXQtdGlsZS1jb250YWluZXIgbGVhZmxldC16b29tLWFuaW1hdGVkJywgdGhpcy5fY29udGFpbmVyKTtcbiAgXHRcdFx0bGV2ZWwuZWwuc3R5bGUuekluZGV4ID0gbWF4Wm9vbTtcblxuICBcdFx0XHRsZXZlbC5vcmlnaW4gPSBtYXAucHJvamVjdChtYXAudW5wcm9qZWN0KG1hcC5nZXRQaXhlbE9yaWdpbigpKSwgem9vbSkucm91bmQoKTtcbiAgXHRcdFx0bGV2ZWwuem9vbSA9IHpvb207XG5cbiAgXHRcdFx0dGhpcy5fc2V0Wm9vbVRyYW5zZm9ybShsZXZlbCwgbWFwLmdldENlbnRlcigpLCBtYXAuZ2V0Wm9vbSgpKTtcblxuICBcdFx0XHQvLyBmb3JjZSB0aGUgYnJvd3NlciB0byBjb25zaWRlciB0aGUgbmV3bHkgYWRkZWQgZWxlbWVudCBmb3IgdHJhbnNpdGlvblxuICBcdFx0XHRmYWxzZUZuKGxldmVsLmVsLm9mZnNldFdpZHRoKTtcblxuICBcdFx0XHR0aGlzLl9vbkNyZWF0ZUxldmVsKGxldmVsKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fbGV2ZWwgPSBsZXZlbDtcblxuICBcdFx0cmV0dXJuIGxldmVsO1xuICBcdH0sXG5cbiAgXHRfb25VcGRhdGVMZXZlbDogZmFsc2VGbixcblxuICBcdF9vblJlbW92ZUxldmVsOiBmYWxzZUZuLFxuXG4gIFx0X29uQ3JlYXRlTGV2ZWw6IGZhbHNlRm4sXG5cbiAgXHRfcHJ1bmVUaWxlczogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLl9tYXApIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHR2YXIga2V5LCB0aWxlO1xuXG4gIFx0XHR2YXIgem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XG4gIFx0XHRpZiAoem9vbSA+IHRoaXMub3B0aW9ucy5tYXhab29tIHx8XG4gIFx0XHRcdHpvb20gPCB0aGlzLm9wdGlvbnMubWluWm9vbSkge1xuICBcdFx0XHR0aGlzLl9yZW1vdmVBbGxUaWxlcygpO1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdGZvciAoa2V5IGluIHRoaXMuX3RpbGVzKSB7XG4gIFx0XHRcdHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuICBcdFx0XHR0aWxlLnJldGFpbiA9IHRpbGUuY3VycmVudDtcbiAgXHRcdH1cblxuICBcdFx0Zm9yIChrZXkgaW4gdGhpcy5fdGlsZXMpIHtcbiAgXHRcdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG4gIFx0XHRcdGlmICh0aWxlLmN1cnJlbnQgJiYgIXRpbGUuYWN0aXZlKSB7XG4gIFx0XHRcdFx0dmFyIGNvb3JkcyA9IHRpbGUuY29vcmRzO1xuICBcdFx0XHRcdGlmICghdGhpcy5fcmV0YWluUGFyZW50KGNvb3Jkcy54LCBjb29yZHMueSwgY29vcmRzLnosIGNvb3Jkcy56IC0gNSkpIHtcbiAgXHRcdFx0XHRcdHRoaXMuX3JldGFpbkNoaWxkcmVuKGNvb3Jkcy54LCBjb29yZHMueSwgY29vcmRzLnosIGNvb3Jkcy56ICsgMik7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdGZvciAoa2V5IGluIHRoaXMuX3RpbGVzKSB7XG4gIFx0XHRcdGlmICghdGhpcy5fdGlsZXNba2V5XS5yZXRhaW4pIHtcbiAgXHRcdFx0XHR0aGlzLl9yZW1vdmVUaWxlKGtleSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3JlbW92ZVRpbGVzQXRab29tOiBmdW5jdGlvbiAoem9vbSkge1xuICBcdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG4gIFx0XHRcdGlmICh0aGlzLl90aWxlc1trZXldLmNvb3Jkcy56ICE9PSB6b29tKSB7XG4gIFx0XHRcdFx0Y29udGludWU7XG4gIFx0XHRcdH1cbiAgXHRcdFx0dGhpcy5fcmVtb3ZlVGlsZShrZXkpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfcmVtb3ZlQWxsVGlsZXM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuICBcdFx0XHR0aGlzLl9yZW1vdmVUaWxlKGtleSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9pbnZhbGlkYXRlQWxsOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRmb3IgKHZhciB6IGluIHRoaXMuX2xldmVscykge1xuICBcdFx0XHRyZW1vdmUodGhpcy5fbGV2ZWxzW3pdLmVsKTtcbiAgXHRcdFx0dGhpcy5fb25SZW1vdmVMZXZlbChOdW1iZXIoeikpO1xuICBcdFx0XHRkZWxldGUgdGhpcy5fbGV2ZWxzW3pdO1xuICBcdFx0fVxuICBcdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblxuICBcdFx0dGhpcy5fdGlsZVpvb20gPSB1bmRlZmluZWQ7XG4gIFx0fSxcblxuICBcdF9yZXRhaW5QYXJlbnQ6IGZ1bmN0aW9uICh4LCB5LCB6LCBtaW5ab29tKSB7XG4gIFx0XHR2YXIgeDIgPSBNYXRoLmZsb29yKHggLyAyKSxcbiAgXHRcdCAgICB5MiA9IE1hdGguZmxvb3IoeSAvIDIpLFxuICBcdFx0ICAgIHoyID0geiAtIDEsXG4gIFx0XHQgICAgY29vcmRzMiA9IG5ldyBQb2ludCgreDIsICt5Mik7XG4gIFx0XHRjb29yZHMyLnogPSArejI7XG5cbiAgXHRcdHZhciBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzMiksXG4gIFx0XHQgICAgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cbiAgXHRcdGlmICh0aWxlICYmIHRpbGUuYWN0aXZlKSB7XG4gIFx0XHRcdHRpbGUucmV0YWluID0gdHJ1ZTtcbiAgXHRcdFx0cmV0dXJuIHRydWU7XG5cbiAgXHRcdH0gZWxzZSBpZiAodGlsZSAmJiB0aWxlLmxvYWRlZCkge1xuICBcdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh6MiA+IG1pblpvb20pIHtcbiAgXHRcdFx0cmV0dXJuIHRoaXMuX3JldGFpblBhcmVudCh4MiwgeTIsIHoyLCBtaW5ab29tKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIGZhbHNlO1xuICBcdH0sXG5cbiAgXHRfcmV0YWluQ2hpbGRyZW46IGZ1bmN0aW9uICh4LCB5LCB6LCBtYXhab29tKSB7XG5cbiAgXHRcdGZvciAodmFyIGkgPSAyICogeDsgaSA8IDIgKiB4ICsgMjsgaSsrKSB7XG4gIFx0XHRcdGZvciAodmFyIGogPSAyICogeTsgaiA8IDIgKiB5ICsgMjsgaisrKSB7XG5cbiAgXHRcdFx0XHR2YXIgY29vcmRzID0gbmV3IFBvaW50KGksIGopO1xuICBcdFx0XHRcdGNvb3Jkcy56ID0geiArIDE7XG5cbiAgXHRcdFx0XHR2YXIga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3JkcyksXG4gIFx0XHRcdFx0ICAgIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXG4gIFx0XHRcdFx0aWYgKHRpbGUgJiYgdGlsZS5hY3RpdmUpIHtcbiAgXHRcdFx0XHRcdHRpbGUucmV0YWluID0gdHJ1ZTtcbiAgXHRcdFx0XHRcdGNvbnRpbnVlO1xuXG4gIFx0XHRcdFx0fSBlbHNlIGlmICh0aWxlICYmIHRpbGUubG9hZGVkKSB7XG4gIFx0XHRcdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0aWYgKHogKyAxIDwgbWF4Wm9vbSkge1xuICBcdFx0XHRcdFx0dGhpcy5fcmV0YWluQ2hpbGRyZW4oaSwgaiwgeiArIDEsIG1heFpvb20pO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfcmVzZXRWaWV3OiBmdW5jdGlvbiAoZSkge1xuICBcdFx0dmFyIGFuaW1hdGluZyA9IGUgJiYgKGUucGluY2ggfHwgZS5mbHlUbyk7XG4gIFx0XHR0aGlzLl9zZXRWaWV3KHRoaXMuX21hcC5nZXRDZW50ZXIoKSwgdGhpcy5fbWFwLmdldFpvb20oKSwgYW5pbWF0aW5nLCBhbmltYXRpbmcpO1xuICBcdH0sXG5cbiAgXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHR0aGlzLl9zZXRWaWV3KGUuY2VudGVyLCBlLnpvb20sIHRydWUsIGUubm9VcGRhdGUpO1xuICBcdH0sXG5cbiAgXHRfY2xhbXBab29tOiBmdW5jdGlvbiAoem9vbSkge1xuICBcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgXHRcdGlmICh1bmRlZmluZWQgIT09IG9wdGlvbnMubWluTmF0aXZlWm9vbSAmJiB6b29tIDwgb3B0aW9ucy5taW5OYXRpdmVab29tKSB7XG4gIFx0XHRcdHJldHVybiBvcHRpb25zLm1pbk5hdGl2ZVpvb207XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh1bmRlZmluZWQgIT09IG9wdGlvbnMubWF4TmF0aXZlWm9vbSAmJiBvcHRpb25zLm1heE5hdGl2ZVpvb20gPCB6b29tKSB7XG4gIFx0XHRcdHJldHVybiBvcHRpb25zLm1heE5hdGl2ZVpvb207XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB6b29tO1xuICBcdH0sXG5cbiAgXHRfc2V0VmlldzogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgbm9QcnVuZSwgbm9VcGRhdGUpIHtcbiAgXHRcdHZhciB0aWxlWm9vbSA9IE1hdGgucm91bmQoem9vbSk7XG4gIFx0XHRpZiAoKHRoaXMub3B0aW9ucy5tYXhab29tICE9PSB1bmRlZmluZWQgJiYgdGlsZVpvb20gPiB0aGlzLm9wdGlvbnMubWF4Wm9vbSkgfHxcbiAgXHRcdCAgICAodGhpcy5vcHRpb25zLm1pblpvb20gIT09IHVuZGVmaW5lZCAmJiB0aWxlWm9vbSA8IHRoaXMub3B0aW9ucy5taW5ab29tKSkge1xuICBcdFx0XHR0aWxlWm9vbSA9IHVuZGVmaW5lZDtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRpbGVab29tID0gdGhpcy5fY2xhbXBab29tKHRpbGVab29tKTtcbiAgXHRcdH1cblxuICBcdFx0dmFyIHRpbGVab29tQ2hhbmdlZCA9IHRoaXMub3B0aW9ucy51cGRhdGVXaGVuWm9vbWluZyAmJiAodGlsZVpvb20gIT09IHRoaXMuX3RpbGVab29tKTtcblxuICBcdFx0aWYgKCFub1VwZGF0ZSB8fCB0aWxlWm9vbUNoYW5nZWQpIHtcblxuICBcdFx0XHR0aGlzLl90aWxlWm9vbSA9IHRpbGVab29tO1xuXG4gIFx0XHRcdGlmICh0aGlzLl9hYm9ydExvYWRpbmcpIHtcbiAgXHRcdFx0XHR0aGlzLl9hYm9ydExvYWRpbmcoKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHRoaXMuX3VwZGF0ZUxldmVscygpO1xuICBcdFx0XHR0aGlzLl9yZXNldEdyaWQoKTtcblxuICBcdFx0XHRpZiAodGlsZVpvb20gIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRcdHRoaXMuX3VwZGF0ZShjZW50ZXIpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKCFub1BydW5lKSB7XG4gIFx0XHRcdFx0dGhpcy5fcHJ1bmVUaWxlcygpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gRmxhZyB0byBwcmV2ZW50IF91cGRhdGVPcGFjaXR5IGZyb20gcHJ1bmluZyB0aWxlcyBkdXJpbmdcbiAgXHRcdFx0Ly8gYSB6b29tIGFuaW0gb3IgYSBwaW5jaCBnZXN0dXJlXG4gIFx0XHRcdHRoaXMuX25vUHJ1bmUgPSAhIW5vUHJ1bmU7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX3NldFpvb21UcmFuc2Zvcm1zKGNlbnRlciwgem9vbSk7XG4gIFx0fSxcblxuICBcdF9zZXRab29tVHJhbnNmb3JtczogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xuICBcdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sZXZlbHMpIHtcbiAgXHRcdFx0dGhpcy5fc2V0Wm9vbVRyYW5zZm9ybSh0aGlzLl9sZXZlbHNbaV0sIGNlbnRlciwgem9vbSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9zZXRab29tVHJhbnNmb3JtOiBmdW5jdGlvbiAobGV2ZWwsIGNlbnRlciwgem9vbSkge1xuICBcdFx0dmFyIHNjYWxlID0gdGhpcy5fbWFwLmdldFpvb21TY2FsZSh6b29tLCBsZXZlbC56b29tKSxcbiAgXHRcdCAgICB0cmFuc2xhdGUgPSBsZXZlbC5vcmlnaW4ubXVsdGlwbHlCeShzY2FsZSlcbiAgXHRcdCAgICAgICAgLnN1YnRyYWN0KHRoaXMuX21hcC5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKSkucm91bmQoKTtcblxuICBcdFx0aWYgKEJyb3dzZXIuYW55M2QpIHtcbiAgXHRcdFx0c2V0VHJhbnNmb3JtKGxldmVsLmVsLCB0cmFuc2xhdGUsIHNjYWxlKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHNldFBvc2l0aW9uKGxldmVsLmVsLCB0cmFuc2xhdGUpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfcmVzZXRHcmlkOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuICBcdFx0ICAgIGNycyA9IG1hcC5vcHRpb25zLmNycyxcbiAgXHRcdCAgICB0aWxlU2l6ZSA9IHRoaXMuX3RpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpLFxuICBcdFx0ICAgIHRpbGVab29tID0gdGhpcy5fdGlsZVpvb207XG5cbiAgXHRcdHZhciBib3VuZHMgPSB0aGlzLl9tYXAuZ2V0UGl4ZWxXb3JsZEJvdW5kcyh0aGlzLl90aWxlWm9vbSk7XG4gIFx0XHRpZiAoYm91bmRzKSB7XG4gIFx0XHRcdHRoaXMuX2dsb2JhbFRpbGVSYW5nZSA9IHRoaXMuX3B4Qm91bmRzVG9UaWxlUmFuZ2UoYm91bmRzKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fd3JhcFggPSBjcnMud3JhcExuZyAmJiAhdGhpcy5vcHRpb25zLm5vV3JhcCAmJiBbXG4gIFx0XHRcdE1hdGguZmxvb3IobWFwLnByb2plY3QoWzAsIGNycy53cmFwTG5nWzBdXSwgdGlsZVpvb20pLnggLyB0aWxlU2l6ZS54KSxcbiAgXHRcdFx0TWF0aC5jZWlsKG1hcC5wcm9qZWN0KFswLCBjcnMud3JhcExuZ1sxXV0sIHRpbGVab29tKS54IC8gdGlsZVNpemUueSlcbiAgXHRcdF07XG4gIFx0XHR0aGlzLl93cmFwWSA9IGNycy53cmFwTGF0ICYmICF0aGlzLm9wdGlvbnMubm9XcmFwICYmIFtcbiAgXHRcdFx0TWF0aC5mbG9vcihtYXAucHJvamVjdChbY3JzLndyYXBMYXRbMF0sIDBdLCB0aWxlWm9vbSkueSAvIHRpbGVTaXplLngpLFxuICBcdFx0XHRNYXRoLmNlaWwobWFwLnByb2plY3QoW2Nycy53cmFwTGF0WzFdLCAwXSwgdGlsZVpvb20pLnkgLyB0aWxlU2l6ZS55KVxuICBcdFx0XTtcbiAgXHR9LFxuXG4gIFx0X29uTW92ZUVuZDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLl9tYXAgfHwgdGhpcy5fbWFwLl9hbmltYXRpbmdab29tKSB7IHJldHVybjsgfVxuXG4gIFx0XHR0aGlzLl91cGRhdGUoKTtcbiAgXHR9LFxuXG4gIFx0X2dldFRpbGVkUGl4ZWxCb3VuZHM6IGZ1bmN0aW9uIChjZW50ZXIpIHtcbiAgXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG4gIFx0XHQgICAgbWFwWm9vbSA9IG1hcC5fYW5pbWF0aW5nWm9vbSA/IE1hdGgubWF4KG1hcC5fYW5pbWF0ZVRvWm9vbSwgbWFwLmdldFpvb20oKSkgOiBtYXAuZ2V0Wm9vbSgpLFxuICBcdFx0ICAgIHNjYWxlID0gbWFwLmdldFpvb21TY2FsZShtYXBab29tLCB0aGlzLl90aWxlWm9vbSksXG4gIFx0XHQgICAgcGl4ZWxDZW50ZXIgPSBtYXAucHJvamVjdChjZW50ZXIsIHRoaXMuX3RpbGVab29tKS5mbG9vcigpLFxuICBcdFx0ICAgIGhhbGZTaXplID0gbWFwLmdldFNpemUoKS5kaXZpZGVCeShzY2FsZSAqIDIpO1xuXG4gIFx0XHRyZXR1cm4gbmV3IEJvdW5kcyhwaXhlbENlbnRlci5zdWJ0cmFjdChoYWxmU2l6ZSksIHBpeGVsQ2VudGVyLmFkZChoYWxmU2l6ZSkpO1xuICBcdH0sXG5cbiAgXHQvLyBQcml2YXRlIG1ldGhvZCB0byBsb2FkIHRpbGVzIGluIHRoZSBncmlkJ3MgYWN0aXZlIHpvb20gbGV2ZWwgYWNjb3JkaW5nIHRvIG1hcCBib3VuZHNcbiAgXHRfdXBkYXRlOiBmdW5jdGlvbiAoY2VudGVyKSB7XG4gIFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuICBcdFx0aWYgKCFtYXApIHsgcmV0dXJuOyB9XG4gIFx0XHR2YXIgem9vbSA9IHRoaXMuX2NsYW1wWm9vbShtYXAuZ2V0Wm9vbSgpKTtcblxuICBcdFx0aWYgKGNlbnRlciA9PT0gdW5kZWZpbmVkKSB7IGNlbnRlciA9IG1hcC5nZXRDZW50ZXIoKTsgfVxuICBcdFx0aWYgKHRoaXMuX3RpbGVab29tID09PSB1bmRlZmluZWQpIHsgcmV0dXJuOyB9XHQvLyBpZiBvdXQgb2YgbWluem9vbS9tYXh6b29tXG5cbiAgXHRcdHZhciBwaXhlbEJvdW5kcyA9IHRoaXMuX2dldFRpbGVkUGl4ZWxCb3VuZHMoY2VudGVyKSxcbiAgXHRcdCAgICB0aWxlUmFuZ2UgPSB0aGlzLl9weEJvdW5kc1RvVGlsZVJhbmdlKHBpeGVsQm91bmRzKSxcbiAgXHRcdCAgICB0aWxlQ2VudGVyID0gdGlsZVJhbmdlLmdldENlbnRlcigpLFxuICBcdFx0ICAgIHF1ZXVlID0gW10sXG4gIFx0XHQgICAgbWFyZ2luID0gdGhpcy5vcHRpb25zLmtlZXBCdWZmZXIsXG4gIFx0XHQgICAgbm9QcnVuZVJhbmdlID0gbmV3IEJvdW5kcyh0aWxlUmFuZ2UuZ2V0Qm90dG9tTGVmdCgpLnN1YnRyYWN0KFttYXJnaW4sIC1tYXJnaW5dKSxcbiAgXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbGVSYW5nZS5nZXRUb3BSaWdodCgpLmFkZChbbWFyZ2luLCAtbWFyZ2luXSkpO1xuXG4gIFx0XHQvLyBTYW5pdHkgY2hlY2s6IHBhbmljIGlmIHRoZSB0aWxlIHJhbmdlIGNvbnRhaW5zIEluZmluaXR5IHNvbWV3aGVyZS5cbiAgXHRcdGlmICghKGlzRmluaXRlKHRpbGVSYW5nZS5taW4ueCkgJiZcbiAgXHRcdCAgICAgIGlzRmluaXRlKHRpbGVSYW5nZS5taW4ueSkgJiZcbiAgXHRcdCAgICAgIGlzRmluaXRlKHRpbGVSYW5nZS5tYXgueCkgJiZcbiAgXHRcdCAgICAgIGlzRmluaXRlKHRpbGVSYW5nZS5tYXgueSkpKSB7IHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHRvIGxvYWQgYW4gaW5maW5pdGUgbnVtYmVyIG9mIHRpbGVzJyk7IH1cblxuICBcdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG4gIFx0XHRcdHZhciBjID0gdGhpcy5fdGlsZXNba2V5XS5jb29yZHM7XG4gIFx0XHRcdGlmIChjLnogIT09IHRoaXMuX3RpbGVab29tIHx8ICFub1BydW5lUmFuZ2UuY29udGFpbnMobmV3IFBvaW50KGMueCwgYy55KSkpIHtcbiAgXHRcdFx0XHR0aGlzLl90aWxlc1trZXldLmN1cnJlbnQgPSBmYWxzZTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHQvLyBfdXBkYXRlIGp1c3QgbG9hZHMgbW9yZSB0aWxlcy4gSWYgdGhlIHRpbGUgem9vbSBsZXZlbCBkaWZmZXJzIHRvbyBtdWNoXG4gIFx0XHQvLyBmcm9tIHRoZSBtYXAncywgbGV0IF9zZXRWaWV3IHJlc2V0IGxldmVscyBhbmQgcHJ1bmUgb2xkIHRpbGVzLlxuICBcdFx0aWYgKE1hdGguYWJzKHpvb20gLSB0aGlzLl90aWxlWm9vbSkgPiAxKSB7IHRoaXMuX3NldFZpZXcoY2VudGVyLCB6b29tKTsgcmV0dXJuOyB9XG5cbiAgXHRcdC8vIGNyZWF0ZSBhIHF1ZXVlIG9mIGNvb3JkaW5hdGVzIHRvIGxvYWQgdGlsZXMgZnJvbVxuICBcdFx0Zm9yICh2YXIgaiA9IHRpbGVSYW5nZS5taW4ueTsgaiA8PSB0aWxlUmFuZ2UubWF4Lnk7IGorKykge1xuICBcdFx0XHRmb3IgKHZhciBpID0gdGlsZVJhbmdlLm1pbi54OyBpIDw9IHRpbGVSYW5nZS5tYXgueDsgaSsrKSB7XG4gIFx0XHRcdFx0dmFyIGNvb3JkcyA9IG5ldyBQb2ludChpLCBqKTtcbiAgXHRcdFx0XHRjb29yZHMueiA9IHRoaXMuX3RpbGVab29tO1xuXG4gIFx0XHRcdFx0aWYgKCF0aGlzLl9pc1ZhbGlkVGlsZShjb29yZHMpKSB7IGNvbnRpbnVlOyB9XG5cbiAgXHRcdFx0XHR2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW3RoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpXTtcbiAgXHRcdFx0XHRpZiAodGlsZSkge1xuICBcdFx0XHRcdFx0dGlsZS5jdXJyZW50ID0gdHJ1ZTtcbiAgXHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0cXVldWUucHVzaChjb29yZHMpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHQvLyBzb3J0IHRpbGUgcXVldWUgdG8gbG9hZCB0aWxlcyBpbiBvcmRlciBvZiB0aGVpciBkaXN0YW5jZSB0byBjZW50ZXJcbiAgXHRcdHF1ZXVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgXHRcdFx0cmV0dXJuIGEuZGlzdGFuY2VUbyh0aWxlQ2VudGVyKSAtIGIuZGlzdGFuY2VUbyh0aWxlQ2VudGVyKTtcbiAgXHRcdH0pO1xuXG4gIFx0XHRpZiAocXVldWUubGVuZ3RoICE9PSAwKSB7XG4gIFx0XHRcdC8vIGlmIGl0J3MgdGhlIGZpcnN0IGJhdGNoIG9mIHRpbGVzIHRvIGxvYWRcbiAgXHRcdFx0aWYgKCF0aGlzLl9sb2FkaW5nKSB7XG4gIFx0XHRcdFx0dGhpcy5fbG9hZGluZyA9IHRydWU7XG4gIFx0XHRcdFx0Ly8gQGV2ZW50IGxvYWRpbmc6IEV2ZW50XG4gIFx0XHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgZ3JpZCBsYXllciBzdGFydHMgbG9hZGluZyB0aWxlcy5cbiAgXHRcdFx0XHR0aGlzLmZpcmUoJ2xvYWRpbmcnKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIGNyZWF0ZSBET00gZnJhZ21lbnQgdG8gYXBwZW5kIHRpbGVzIGluIG9uZSBiYXRjaFxuICBcdFx0XHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgXHRcdFx0Zm9yIChpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gIFx0XHRcdFx0dGhpcy5fYWRkVGlsZShxdWV1ZVtpXSwgZnJhZ21lbnQpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0dGhpcy5fbGV2ZWwuZWwuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfaXNWYWxpZFRpbGU6IGZ1bmN0aW9uIChjb29yZHMpIHtcbiAgXHRcdHZhciBjcnMgPSB0aGlzLl9tYXAub3B0aW9ucy5jcnM7XG5cbiAgXHRcdGlmICghY3JzLmluZmluaXRlKSB7XG4gIFx0XHRcdC8vIGRvbid0IGxvYWQgdGlsZSBpZiBpdCdzIG91dCBvZiBib3VuZHMgYW5kIG5vdCB3cmFwcGVkXG4gIFx0XHRcdHZhciBib3VuZHMgPSB0aGlzLl9nbG9iYWxUaWxlUmFuZ2U7XG4gIFx0XHRcdGlmICgoIWNycy53cmFwTG5nICYmIChjb29yZHMueCA8IGJvdW5kcy5taW4ueCB8fCBjb29yZHMueCA+IGJvdW5kcy5tYXgueCkpIHx8XG4gIFx0XHRcdCAgICAoIWNycy53cmFwTGF0ICYmIChjb29yZHMueSA8IGJvdW5kcy5taW4ueSB8fCBjb29yZHMueSA+IGJvdW5kcy5tYXgueSkpKSB7IHJldHVybiBmYWxzZTsgfVxuICBcdFx0fVxuXG4gIFx0XHRpZiAoIXRoaXMub3B0aW9ucy5ib3VuZHMpIHsgcmV0dXJuIHRydWU7IH1cblxuICBcdFx0Ly8gZG9uJ3QgbG9hZCB0aWxlIGlmIGl0IGRvZXNuJ3QgaW50ZXJzZWN0IHRoZSBib3VuZHMgaW4gb3B0aW9uc1xuICBcdFx0dmFyIHRpbGVCb3VuZHMgPSB0aGlzLl90aWxlQ29vcmRzVG9Cb3VuZHMoY29vcmRzKTtcbiAgXHRcdHJldHVybiB0b0xhdExuZ0JvdW5kcyh0aGlzLm9wdGlvbnMuYm91bmRzKS5vdmVybGFwcyh0aWxlQm91bmRzKTtcbiAgXHR9LFxuXG4gIFx0X2tleVRvQm91bmRzOiBmdW5jdGlvbiAoa2V5KSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fdGlsZUNvb3Jkc1RvQm91bmRzKHRoaXMuX2tleVRvVGlsZUNvb3JkcyhrZXkpKTtcbiAgXHR9LFxuXG4gIFx0X3RpbGVDb29yZHNUb053U2U6IGZ1bmN0aW9uIChjb29yZHMpIHtcbiAgXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG4gIFx0XHQgICAgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCksXG4gIFx0XHQgICAgbndQb2ludCA9IGNvb3Jkcy5zY2FsZUJ5KHRpbGVTaXplKSxcbiAgXHRcdCAgICBzZVBvaW50ID0gbndQb2ludC5hZGQodGlsZVNpemUpLFxuICBcdFx0ICAgIG53ID0gbWFwLnVucHJvamVjdChud1BvaW50LCBjb29yZHMueiksXG4gIFx0XHQgICAgc2UgPSBtYXAudW5wcm9qZWN0KHNlUG9pbnQsIGNvb3Jkcy56KTtcbiAgXHRcdHJldHVybiBbbncsIHNlXTtcbiAgXHR9LFxuXG4gIFx0Ly8gY29udmVydHMgdGlsZSBjb29yZGluYXRlcyB0byBpdHMgZ2VvZ3JhcGhpY2FsIGJvdW5kc1xuICBcdF90aWxlQ29vcmRzVG9Cb3VuZHM6IGZ1bmN0aW9uIChjb29yZHMpIHtcbiAgXHRcdHZhciBicCA9IHRoaXMuX3RpbGVDb29yZHNUb053U2UoY29vcmRzKSxcbiAgXHRcdCAgICBib3VuZHMgPSBuZXcgTGF0TG5nQm91bmRzKGJwWzBdLCBicFsxXSk7XG5cbiAgXHRcdGlmICghdGhpcy5vcHRpb25zLm5vV3JhcCkge1xuICBcdFx0XHRib3VuZHMgPSB0aGlzLl9tYXAud3JhcExhdExuZ0JvdW5kcyhib3VuZHMpO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIGJvdW5kcztcbiAgXHR9LFxuICBcdC8vIGNvbnZlcnRzIHRpbGUgY29vcmRpbmF0ZXMgdG8ga2V5IGZvciB0aGUgdGlsZSBjYWNoZVxuICBcdF90aWxlQ29vcmRzVG9LZXk6IGZ1bmN0aW9uIChjb29yZHMpIHtcbiAgXHRcdHJldHVybiBjb29yZHMueCArICc6JyArIGNvb3Jkcy55ICsgJzonICsgY29vcmRzLno7XG4gIFx0fSxcblxuICBcdC8vIGNvbnZlcnRzIHRpbGUgY2FjaGUga2V5IHRvIGNvb3JkaW5hdGVzXG4gIFx0X2tleVRvVGlsZUNvb3JkczogZnVuY3Rpb24gKGtleSkge1xuICBcdFx0dmFyIGsgPSBrZXkuc3BsaXQoJzonKSxcbiAgXHRcdCAgICBjb29yZHMgPSBuZXcgUG9pbnQoK2tbMF0sICtrWzFdKTtcbiAgXHRcdGNvb3Jkcy56ID0gK2tbMl07XG4gIFx0XHRyZXR1cm4gY29vcmRzO1xuICBcdH0sXG5cbiAgXHRfcmVtb3ZlVGlsZTogZnVuY3Rpb24gKGtleSkge1xuICBcdFx0dmFyIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuICBcdFx0aWYgKCF0aWxlKSB7IHJldHVybjsgfVxuXG4gIFx0XHRyZW1vdmUodGlsZS5lbCk7XG5cbiAgXHRcdGRlbGV0ZSB0aGlzLl90aWxlc1trZXldO1xuXG4gIFx0XHQvLyBAZXZlbnQgdGlsZXVubG9hZDogVGlsZUV2ZW50XG4gIFx0XHQvLyBGaXJlZCB3aGVuIGEgdGlsZSBpcyByZW1vdmVkIChlLmcuIHdoZW4gYSB0aWxlIGdvZXMgb2ZmIHRoZSBzY3JlZW4pLlxuICBcdFx0dGhpcy5maXJlKCd0aWxldW5sb2FkJywge1xuICBcdFx0XHR0aWxlOiB0aWxlLmVsLFxuICBcdFx0XHRjb29yZHM6IHRoaXMuX2tleVRvVGlsZUNvb3JkcyhrZXkpXG4gIFx0XHR9KTtcbiAgXHR9LFxuXG4gIFx0X2luaXRUaWxlOiBmdW5jdGlvbiAodGlsZSkge1xuICBcdFx0YWRkQ2xhc3ModGlsZSwgJ2xlYWZsZXQtdGlsZScpO1xuXG4gIFx0XHR2YXIgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XG4gIFx0XHR0aWxlLnN0eWxlLndpZHRoID0gdGlsZVNpemUueCArICdweCc7XG4gIFx0XHR0aWxlLnN0eWxlLmhlaWdodCA9IHRpbGVTaXplLnkgKyAncHgnO1xuXG4gIFx0XHR0aWxlLm9uc2VsZWN0c3RhcnQgPSBmYWxzZUZuO1xuICBcdFx0dGlsZS5vbm1vdXNlbW92ZSA9IGZhbHNlRm47XG5cbiAgXHRcdC8vIHVwZGF0ZSBvcGFjaXR5IG9uIHRpbGVzIGluIElFNy04IGJlY2F1c2Ugb2YgZmlsdGVyIGluaGVyaXRhbmNlIHByb2JsZW1zXG4gIFx0XHRpZiAoQnJvd3Nlci5pZWx0OSAmJiB0aGlzLm9wdGlvbnMub3BhY2l0eSA8IDEpIHtcbiAgXHRcdFx0c2V0T3BhY2l0eSh0aWxlLCB0aGlzLm9wdGlvbnMub3BhY2l0eSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9hZGRUaWxlOiBmdW5jdGlvbiAoY29vcmRzLCBjb250YWluZXIpIHtcbiAgXHRcdHZhciB0aWxlUG9zID0gdGhpcy5fZ2V0VGlsZVBvcyhjb29yZHMpLFxuICBcdFx0ICAgIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpO1xuXG4gIFx0XHR2YXIgdGlsZSA9IHRoaXMuY3JlYXRlVGlsZSh0aGlzLl93cmFwQ29vcmRzKGNvb3JkcyksIGJpbmQodGhpcy5fdGlsZVJlYWR5LCB0aGlzLCBjb29yZHMpKTtcblxuICBcdFx0dGhpcy5faW5pdFRpbGUodGlsZSk7XG5cbiAgXHRcdC8vIGlmIGNyZWF0ZVRpbGUgaXMgZGVmaW5lZCB3aXRoIGEgc2Vjb25kIGFyZ3VtZW50IChcImRvbmVcIiBjYWxsYmFjayksXG4gIFx0XHQvLyB3ZSBrbm93IHRoYXQgdGlsZSBpcyBhc3luYyBhbmQgd2lsbCBiZSByZWFkeSBsYXRlcjsgb3RoZXJ3aXNlXG4gIFx0XHRpZiAodGhpcy5jcmVhdGVUaWxlLmxlbmd0aCA8IDIpIHtcbiAgXHRcdFx0Ly8gbWFyayB0aWxlIGFzIHJlYWR5LCBidXQgZGVsYXkgb25lIGZyYW1lIGZvciBvcGFjaXR5IGFuaW1hdGlvbiB0byBoYXBwZW5cbiAgXHRcdFx0cmVxdWVzdEFuaW1GcmFtZShiaW5kKHRoaXMuX3RpbGVSZWFkeSwgdGhpcywgY29vcmRzLCBudWxsLCB0aWxlKSk7XG4gIFx0XHR9XG5cbiAgXHRcdHNldFBvc2l0aW9uKHRpbGUsIHRpbGVQb3MpO1xuXG4gIFx0XHQvLyBzYXZlIHRpbGUgaW4gY2FjaGVcbiAgXHRcdHRoaXMuX3RpbGVzW2tleV0gPSB7XG4gIFx0XHRcdGVsOiB0aWxlLFxuICBcdFx0XHRjb29yZHM6IGNvb3JkcyxcbiAgXHRcdFx0Y3VycmVudDogdHJ1ZVxuICBcdFx0fTtcblxuICBcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKHRpbGUpO1xuICBcdFx0Ly8gQGV2ZW50IHRpbGVsb2Fkc3RhcnQ6IFRpbGVFdmVudFxuICBcdFx0Ly8gRmlyZWQgd2hlbiBhIHRpbGUgaXMgcmVxdWVzdGVkIGFuZCBzdGFydHMgbG9hZGluZy5cbiAgXHRcdHRoaXMuZmlyZSgndGlsZWxvYWRzdGFydCcsIHtcbiAgXHRcdFx0dGlsZTogdGlsZSxcbiAgXHRcdFx0Y29vcmRzOiBjb29yZHNcbiAgXHRcdH0pO1xuICBcdH0sXG5cbiAgXHRfdGlsZVJlYWR5OiBmdW5jdGlvbiAoY29vcmRzLCBlcnIsIHRpbGUpIHtcbiAgXHRcdGlmIChlcnIpIHtcbiAgXHRcdFx0Ly8gQGV2ZW50IHRpbGVlcnJvcjogVGlsZUVycm9yRXZlbnRcbiAgXHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGVyZSBpcyBhbiBlcnJvciBsb2FkaW5nIGEgdGlsZS5cbiAgXHRcdFx0dGhpcy5maXJlKCd0aWxlZXJyb3InLCB7XG4gIFx0XHRcdFx0ZXJyb3I6IGVycixcbiAgXHRcdFx0XHR0aWxlOiB0aWxlLFxuICBcdFx0XHRcdGNvb3JkczogY29vcmRzXG4gIFx0XHRcdH0pO1xuICBcdFx0fVxuXG4gIFx0XHR2YXIga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3Jkcyk7XG5cbiAgXHRcdHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuICBcdFx0aWYgKCF0aWxlKSB7IHJldHVybjsgfVxuXG4gIFx0XHR0aWxlLmxvYWRlZCA9ICtuZXcgRGF0ZSgpO1xuICBcdFx0aWYgKHRoaXMuX21hcC5fZmFkZUFuaW1hdGVkKSB7XG4gIFx0XHRcdHNldE9wYWNpdHkodGlsZS5lbCwgMCk7XG4gIFx0XHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9mYWRlRnJhbWUpO1xuICBcdFx0XHR0aGlzLl9mYWRlRnJhbWUgPSByZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3VwZGF0ZU9wYWNpdHksIHRoaXMpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGlsZS5hY3RpdmUgPSB0cnVlO1xuICBcdFx0XHR0aGlzLl9wcnVuZVRpbGVzKCk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghZXJyKSB7XG4gIFx0XHRcdGFkZENsYXNzKHRpbGUuZWwsICdsZWFmbGV0LXRpbGUtbG9hZGVkJyk7XG5cbiAgXHRcdFx0Ly8gQGV2ZW50IHRpbGVsb2FkOiBUaWxlRXZlbnRcbiAgXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHRpbGUgbG9hZHMuXG4gIFx0XHRcdHRoaXMuZmlyZSgndGlsZWxvYWQnLCB7XG4gIFx0XHRcdFx0dGlsZTogdGlsZS5lbCxcbiAgXHRcdFx0XHRjb29yZHM6IGNvb3Jkc1xuICBcdFx0XHR9KTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHRoaXMuX25vVGlsZXNUb0xvYWQoKSkge1xuICBcdFx0XHR0aGlzLl9sb2FkaW5nID0gZmFsc2U7XG4gIFx0XHRcdC8vIEBldmVudCBsb2FkOiBFdmVudFxuICBcdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBncmlkIGxheWVyIGxvYWRlZCBhbGwgdmlzaWJsZSB0aWxlcy5cbiAgXHRcdFx0dGhpcy5maXJlKCdsb2FkJyk7XG5cbiAgXHRcdFx0aWYgKEJyb3dzZXIuaWVsdDkgfHwgIXRoaXMuX21hcC5fZmFkZUFuaW1hdGVkKSB7XG4gIFx0XHRcdFx0cmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9wcnVuZVRpbGVzLCB0aGlzKTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHQvLyBXYWl0IGEgYml0IG1vcmUgdGhhbiAwLjIgc2VjcyAodGhlIGR1cmF0aW9uIG9mIHRoZSB0aWxlIGZhZGUtaW4pXG4gIFx0XHRcdFx0Ly8gdG8gdHJpZ2dlciBhIHBydW5pbmcuXG4gIFx0XHRcdFx0c2V0VGltZW91dChiaW5kKHRoaXMuX3BydW5lVGlsZXMsIHRoaXMpLCAyNTApO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9nZXRUaWxlUG9zOiBmdW5jdGlvbiAoY29vcmRzKSB7XG4gIFx0XHRyZXR1cm4gY29vcmRzLnNjYWxlQnkodGhpcy5nZXRUaWxlU2l6ZSgpKS5zdWJ0cmFjdCh0aGlzLl9sZXZlbC5vcmlnaW4pO1xuICBcdH0sXG5cbiAgXHRfd3JhcENvb3JkczogZnVuY3Rpb24gKGNvb3Jkcykge1xuICBcdFx0dmFyIG5ld0Nvb3JkcyA9IG5ldyBQb2ludChcbiAgXHRcdFx0dGhpcy5fd3JhcFggPyB3cmFwTnVtKGNvb3Jkcy54LCB0aGlzLl93cmFwWCkgOiBjb29yZHMueCxcbiAgXHRcdFx0dGhpcy5fd3JhcFkgPyB3cmFwTnVtKGNvb3Jkcy55LCB0aGlzLl93cmFwWSkgOiBjb29yZHMueSk7XG4gIFx0XHRuZXdDb29yZHMueiA9IGNvb3Jkcy56O1xuICBcdFx0cmV0dXJuIG5ld0Nvb3JkcztcbiAgXHR9LFxuXG4gIFx0X3B4Qm91bmRzVG9UaWxlUmFuZ2U6IGZ1bmN0aW9uIChib3VuZHMpIHtcbiAgXHRcdHZhciB0aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcbiAgXHRcdHJldHVybiBuZXcgQm91bmRzKFxuICBcdFx0XHRib3VuZHMubWluLnVuc2NhbGVCeSh0aWxlU2l6ZSkuZmxvb3IoKSxcbiAgXHRcdFx0Ym91bmRzLm1heC51bnNjYWxlQnkodGlsZVNpemUpLmNlaWwoKS5zdWJ0cmFjdChbMSwgMV0pKTtcbiAgXHR9LFxuXG4gIFx0X25vVGlsZXNUb0xvYWQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuICBcdFx0XHRpZiAoIXRoaXMuX3RpbGVzW2tleV0ubG9hZGVkKSB7IHJldHVybiBmYWxzZTsgfVxuICBcdFx0fVxuICBcdFx0cmV0dXJuIHRydWU7XG4gIFx0fVxuICB9KTtcblxuICAvLyBAZmFjdG9yeSBMLmdyaWRMYXllcihvcHRpb25zPzogR3JpZExheWVyIG9wdGlvbnMpXG4gIC8vIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgR3JpZExheWVyIHdpdGggdGhlIHN1cHBsaWVkIG9wdGlvbnMuXG4gIGZ1bmN0aW9uIGdyaWRMYXllcihvcHRpb25zKSB7XG4gIFx0cmV0dXJuIG5ldyBHcmlkTGF5ZXIob3B0aW9ucyk7XG4gIH1cblxuICAvKlxyXG4gICAqIEBjbGFzcyBUaWxlTGF5ZXJcclxuICAgKiBAaW5oZXJpdHMgR3JpZExheWVyXHJcbiAgICogQGFrYSBMLlRpbGVMYXllclxyXG4gICAqIFVzZWQgdG8gbG9hZCBhbmQgZGlzcGxheSB0aWxlIGxheWVycyBvbiB0aGUgbWFwLiBOb3RlIHRoYXQgbW9zdCB0aWxlIHNlcnZlcnMgcmVxdWlyZSBhdHRyaWJ1dGlvbiwgd2hpY2ggeW91IGNhbiBzZXQgdW5kZXIgYExheWVyYC4gRXh0ZW5kcyBgR3JpZExheWVyYC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIEwudGlsZUxheWVyKCdodHRwczovL3RpbGUub3BlbnN0cmVldG1hcC5vcmcve3p9L3t4fS97eX0ucG5nP3tmb299Jywge2ZvbzogJ2JhcicsIGF0dHJpYnV0aW9uOiAnJmNvcHk7IDxhIGhyZWY9XCJodHRwczovL3d3dy5vcGVuc3RyZWV0bWFwLm9yZy9jb3B5cmlnaHRcIj5PcGVuU3RyZWV0TWFwPC9hPiBjb250cmlidXRvcnMnfSkuYWRkVG8obWFwKTtcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAc2VjdGlvbiBVUkwgdGVtcGxhdGVcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogQSBzdHJpbmcgb2YgdGhlIGZvbGxvd2luZyBmb3JtOlxyXG4gICAqXHJcbiAgICogYGBgXHJcbiAgICogJ2h0dHBzOi8ve3N9LnNvbWVkb21haW4uY29tL2JsYWJsYS97en0ve3h9L3t5fXtyfS5wbmcnXHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBge3N9YCBtZWFucyBvbmUgb2YgdGhlIGF2YWlsYWJsZSBzdWJkb21haW5zICh1c2VkIHNlcXVlbnRpYWxseSB0byBoZWxwIHdpdGggYnJvd3NlciBwYXJhbGxlbCByZXF1ZXN0cyBwZXIgZG9tYWluIGxpbWl0YXRpb247IHN1YmRvbWFpbiB2YWx1ZXMgYXJlIHNwZWNpZmllZCBpbiBvcHRpb25zOyBgYWAsIGBiYCBvciBgY2AgYnkgZGVmYXVsdCwgY2FuIGJlIG9taXR0ZWQpLCBge3p9YCDigJQgem9vbSBsZXZlbCwgYHt4fWAgYW5kIGB7eX1gIOKAlCB0aWxlIGNvb3JkaW5hdGVzLiBge3J9YCBjYW4gYmUgdXNlZCB0byBhZGQgXCImY29tbWF0OzJ4XCIgdG8gdGhlIFVSTCB0byBsb2FkIHJldGluYSB0aWxlcy5cclxuICAgKlxyXG4gICAqIFlvdSBjYW4gdXNlIGN1c3RvbSBrZXlzIGluIHRoZSB0ZW1wbGF0ZSwgd2hpY2ggd2lsbCBiZSBbZXZhbHVhdGVkXSgjdXRpbC10ZW1wbGF0ZSkgZnJvbSBUaWxlTGF5ZXIgb3B0aW9ucywgbGlrZSB0aGlzOlxyXG4gICAqXHJcbiAgICogYGBgXHJcbiAgICogTC50aWxlTGF5ZXIoJ2h0dHBzOi8ve3N9LnNvbWVkb21haW4uY29tL3tmb299L3t6fS97eH0ve3l9LnBuZycsIHtmb286ICdiYXInfSk7XHJcbiAgICogYGBgXHJcbiAgICovXHJcblxyXG5cclxuICB2YXIgVGlsZUxheWVyID0gR3JpZExheWVyLmV4dGVuZCh7XHJcblxyXG4gIFx0Ly8gQHNlY3Rpb25cclxuICBcdC8vIEBha2EgVGlsZUxheWVyIG9wdGlvbnNcclxuICBcdG9wdGlvbnM6IHtcclxuICBcdFx0Ly8gQG9wdGlvbiBtaW5ab29tOiBOdW1iZXIgPSAwXHJcbiAgXHRcdC8vIFRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgZG93biB0byB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmUgZGlzcGxheWVkIChpbmNsdXNpdmUpLlxyXG4gIFx0XHRtaW5ab29tOiAwLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBtYXhab29tOiBOdW1iZXIgPSAxOFxyXG4gIFx0XHQvLyBUaGUgbWF4aW11bSB6b29tIGxldmVsIHVwIHRvIHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZSBkaXNwbGF5ZWQgKGluY2x1c2l2ZSkuXHJcbiAgXHRcdG1heFpvb206IDE4LFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBzdWJkb21haW5zOiBTdHJpbmd8U3RyaW5nW10gPSAnYWJjJ1xyXG4gIFx0XHQvLyBTdWJkb21haW5zIG9mIHRoZSB0aWxlIHNlcnZpY2UuIENhbiBiZSBwYXNzZWQgaW4gdGhlIGZvcm0gb2Ygb25lIHN0cmluZyAod2hlcmUgZWFjaCBsZXR0ZXIgaXMgYSBzdWJkb21haW4gbmFtZSkgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cclxuICBcdFx0c3ViZG9tYWluczogJ2FiYycsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGVycm9yVGlsZVVybDogU3RyaW5nID0gJydcclxuICBcdFx0Ly8gVVJMIHRvIHRoZSB0aWxlIGltYWdlIHRvIHNob3cgaW4gcGxhY2Ugb2YgdGhlIHRpbGUgdGhhdCBmYWlsZWQgdG8gbG9hZC5cclxuICBcdFx0ZXJyb3JUaWxlVXJsOiAnJyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gem9vbU9mZnNldDogTnVtYmVyID0gMFxyXG4gIFx0XHQvLyBUaGUgem9vbSBudW1iZXIgdXNlZCBpbiB0aWxlIFVSTHMgd2lsbCBiZSBvZmZzZXQgd2l0aCB0aGlzIHZhbHVlLlxyXG4gIFx0XHR6b29tT2Zmc2V0OiAwLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiB0bXM6IEJvb2xlYW4gPSBmYWxzZVxyXG4gIFx0XHQvLyBJZiBgdHJ1ZWAsIGludmVyc2VzIFkgYXhpcyBudW1iZXJpbmcgZm9yIHRpbGVzICh0dXJuIHRoaXMgb24gZm9yIFtUTVNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RpbGVfTWFwX1NlcnZpY2UpIHNlcnZpY2VzKS5cclxuICBcdFx0dG1zOiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gem9vbVJldmVyc2U6IEJvb2xlYW4gPSBmYWxzZVxyXG4gIFx0XHQvLyBJZiBzZXQgdG8gdHJ1ZSwgdGhlIHpvb20gbnVtYmVyIHVzZWQgaW4gdGlsZSBVUkxzIHdpbGwgYmUgcmV2ZXJzZWQgKGBtYXhab29tIC0gem9vbWAgaW5zdGVhZCBvZiBgem9vbWApXHJcbiAgXHRcdHpvb21SZXZlcnNlOiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gZGV0ZWN0UmV0aW5hOiBCb29sZWFuID0gZmFsc2VcclxuICBcdFx0Ly8gSWYgYHRydWVgIGFuZCB1c2VyIGlzIG9uIGEgcmV0aW5hIGRpc3BsYXksIGl0IHdpbGwgcmVxdWVzdCBmb3VyIHRpbGVzIG9mIGhhbGYgdGhlIHNwZWNpZmllZCBzaXplIGFuZCBhIGJpZ2dlciB6b29tIGxldmVsIGluIHBsYWNlIG9mIG9uZSB0byB1dGlsaXplIHRoZSBoaWdoIHJlc29sdXRpb24uXHJcbiAgXHRcdGRldGVjdFJldGluYTogZmFsc2UsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGNyb3NzT3JpZ2luOiBCb29sZWFufFN0cmluZyA9IGZhbHNlXHJcbiAgXHRcdC8vIFdoZXRoZXIgdGhlIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSB0aWxlcy5cclxuICBcdFx0Ly8gSWYgYSBTdHJpbmcgaXMgcHJvdmlkZWQsIGFsbCB0aWxlcyB3aWxsIGhhdmUgdGhlaXIgY3Jvc3NPcmlnaW4gYXR0cmlidXRlIHNldCB0byB0aGUgU3RyaW5nIHByb3ZpZGVkLiBUaGlzIGlzIG5lZWRlZCBpZiB5b3Ugd2FudCB0byBhY2Nlc3MgdGlsZSBwaXhlbCBkYXRhLlxyXG4gIFx0XHQvLyBSZWZlciB0byBbQ09SUyBTZXR0aW5nc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9DT1JTX3NldHRpbmdzX2F0dHJpYnV0ZXMpIGZvciB2YWxpZCBTdHJpbmcgdmFsdWVzLlxyXG4gIFx0XHRjcm9zc09yaWdpbjogZmFsc2UsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHJlZmVycmVyUG9saWN5OiBCb29sZWFufFN0cmluZyA9IGZhbHNlXHJcbiAgXHRcdC8vIFdoZXRoZXIgdGhlIHJlZmVycmVyUG9saWN5IGF0dHJpYnV0ZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSB0aWxlcy5cclxuICBcdFx0Ly8gSWYgYSBTdHJpbmcgaXMgcHJvdmlkZWQsIGFsbCB0aWxlcyB3aWxsIGhhdmUgdGhlaXIgcmVmZXJyZXJQb2xpY3kgYXR0cmlidXRlIHNldCB0byB0aGUgU3RyaW5nIHByb3ZpZGVkLlxyXG4gIFx0XHQvLyBUaGlzIG1heSBiZSBuZWVkZWQgaWYgeW91ciBtYXAncyByZW5kZXJpbmcgY29udGV4dCBoYXMgYSBzdHJpY3QgZGVmYXVsdCBidXQgeW91ciB0aWxlIHByb3ZpZGVyIGV4cGVjdHMgYSB2YWxpZCByZWZlcnJlclxyXG4gIFx0XHQvLyAoZS5nLiB0byB2YWxpZGF0ZSBhbiBBUEkgdG9rZW4pLlxyXG4gIFx0XHQvLyBSZWZlciB0byBbSFRNTEltYWdlRWxlbWVudC5yZWZlcnJlclBvbGljeV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxJbWFnZUVsZW1lbnQvcmVmZXJyZXJQb2xpY3kpIGZvciB2YWxpZCBTdHJpbmcgdmFsdWVzLlxyXG4gIFx0XHRyZWZlcnJlclBvbGljeTogZmFsc2VcclxuICBcdH0sXHJcblxyXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xyXG5cclxuICBcdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuICBcdFx0b3B0aW9ucyA9IHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG4gIFx0XHQvLyBkZXRlY3RpbmcgcmV0aW5hIGRpc3BsYXlzLCBhZGp1c3RpbmcgdGlsZVNpemUgYW5kIHpvb20gbGV2ZWxzXHJcbiAgXHRcdGlmIChvcHRpb25zLmRldGVjdFJldGluYSAmJiBCcm93c2VyLnJldGluYSAmJiBvcHRpb25zLm1heFpvb20gPiAwKSB7XHJcblxyXG4gIFx0XHRcdG9wdGlvbnMudGlsZVNpemUgPSBNYXRoLmZsb29yKG9wdGlvbnMudGlsZVNpemUgLyAyKTtcclxuXHJcbiAgXHRcdFx0aWYgKCFvcHRpb25zLnpvb21SZXZlcnNlKSB7XHJcbiAgXHRcdFx0XHRvcHRpb25zLnpvb21PZmZzZXQrKztcclxuICBcdFx0XHRcdG9wdGlvbnMubWF4Wm9vbSA9IE1hdGgubWF4KG9wdGlvbnMubWluWm9vbSwgb3B0aW9ucy5tYXhab29tIC0gMSk7XHJcbiAgXHRcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRcdG9wdGlvbnMuem9vbU9mZnNldC0tO1xyXG4gIFx0XHRcdFx0b3B0aW9ucy5taW5ab29tID0gTWF0aC5taW4ob3B0aW9ucy5tYXhab29tLCBvcHRpb25zLm1pblpvb20gKyAxKTtcclxuICBcdFx0XHR9XHJcblxyXG4gIFx0XHRcdG9wdGlvbnMubWluWm9vbSA9IE1hdGgubWF4KDAsIG9wdGlvbnMubWluWm9vbSk7XHJcbiAgXHRcdH0gZWxzZSBpZiAoIW9wdGlvbnMuem9vbVJldmVyc2UpIHtcclxuICBcdFx0XHQvLyBtYWtlIHN1cmUgbWF4Wm9vbSBpcyBndGUgbWluWm9vbVxyXG4gIFx0XHRcdG9wdGlvbnMubWF4Wm9vbSA9IE1hdGgubWF4KG9wdGlvbnMubWluWm9vbSwgb3B0aW9ucy5tYXhab29tKTtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHQvLyBtYWtlIHN1cmUgbWluWm9vbSBpcyBsdGUgbWF4Wm9vbVxyXG4gIFx0XHRcdG9wdGlvbnMubWluWm9vbSA9IE1hdGgubWluKG9wdGlvbnMubWF4Wm9vbSwgb3B0aW9ucy5taW5ab29tKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKHR5cGVvZiBvcHRpb25zLnN1YmRvbWFpbnMgPT09ICdzdHJpbmcnKSB7XHJcbiAgXHRcdFx0b3B0aW9ucy5zdWJkb21haW5zID0gb3B0aW9ucy5zdWJkb21haW5zLnNwbGl0KCcnKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5vbigndGlsZXVubG9hZCcsIHRoaXMuX29uVGlsZVJlbW92ZSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0VXJsKHVybDogU3RyaW5nLCBub1JlZHJhdz86IEJvb2xlYW4pOiB0aGlzXHJcbiAgXHQvLyBVcGRhdGVzIHRoZSBsYXllcidzIFVSTCB0ZW1wbGF0ZSBhbmQgcmVkcmF3cyBpdCAodW5sZXNzIGBub1JlZHJhd2AgaXMgc2V0IHRvIGB0cnVlYCkuXHJcbiAgXHQvLyBJZiB0aGUgVVJMIGRvZXMgbm90IGNoYW5nZSwgdGhlIGxheWVyIHdpbGwgbm90IGJlIHJlZHJhd24gdW5sZXNzXHJcbiAgXHQvLyB0aGUgbm9SZWRyYXcgcGFyYW1ldGVyIGlzIHNldCB0byBmYWxzZS5cclxuICBcdHNldFVybDogZnVuY3Rpb24gKHVybCwgbm9SZWRyYXcpIHtcclxuICBcdFx0aWYgKHRoaXMuX3VybCA9PT0gdXJsICYmIG5vUmVkcmF3ID09PSB1bmRlZmluZWQpIHtcclxuICBcdFx0XHRub1JlZHJhdyA9IHRydWU7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHJcbiAgXHRcdGlmICghbm9SZWRyYXcpIHtcclxuICBcdFx0XHR0aGlzLnJlZHJhdygpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGNyZWF0ZVRpbGUoY29vcmRzOiBPYmplY3QsIGRvbmU/OiBGdW5jdGlvbik6IEhUTUxFbGVtZW50XHJcbiAgXHQvLyBDYWxsZWQgb25seSBpbnRlcm5hbGx5LCBvdmVycmlkZXMgR3JpZExheWVyJ3MgW2BjcmVhdGVUaWxlKClgXSgjZ3JpZGxheWVyLWNyZWF0ZXRpbGUpXHJcbiAgXHQvLyB0byByZXR1cm4gYW4gYDxpbWc+YCBIVE1MIGVsZW1lbnQgd2l0aCB0aGUgYXBwcm9wcmlhdGUgaW1hZ2UgVVJMIGdpdmVuIGBjb29yZHNgLiBUaGUgYGRvbmVgXHJcbiAgXHQvLyBjYWxsYmFjayBpcyBjYWxsZWQgd2hlbiB0aGUgdGlsZSBoYXMgYmVlbiBsb2FkZWQuXHJcbiAgXHRjcmVhdGVUaWxlOiBmdW5jdGlvbiAoY29vcmRzLCBkb25lKSB7XHJcbiAgXHRcdHZhciB0aWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XHJcblxyXG4gIFx0XHRvbih0aWxlLCAnbG9hZCcsIGJpbmQodGhpcy5fdGlsZU9uTG9hZCwgdGhpcywgZG9uZSwgdGlsZSkpO1xyXG4gIFx0XHRvbih0aWxlLCAnZXJyb3InLCBiaW5kKHRoaXMuX3RpbGVPbkVycm9yLCB0aGlzLCBkb25lLCB0aWxlKSk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luIHx8IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gJycpIHtcclxuICBcdFx0XHR0aWxlLmNyb3NzT3JpZ2luID0gdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luID09PSB0cnVlID8gJycgOiB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIGZvciB0aGlzIG5ldyBvcHRpb24gd2UgZm9sbG93IHRoZSBkb2N1bWVudGVkIGJlaGF2aW9yXHJcbiAgXHRcdC8vIG1vcmUgY2xvc2VseSBieSBvbmx5IHNldHRpbmcgdGhlIHByb3BlcnR5IHdoZW4gc3RyaW5nXHJcbiAgXHRcdGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnJlZmVycmVyUG9saWN5ID09PSAnc3RyaW5nJykge1xyXG4gIFx0XHRcdHRpbGUucmVmZXJyZXJQb2xpY3kgPSB0aGlzLm9wdGlvbnMucmVmZXJyZXJQb2xpY3k7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIFRoZSBhbHQgYXR0cmlidXRlIGlzIHNldCB0byB0aGUgZW1wdHkgc3RyaW5nLFxyXG4gIFx0XHQvLyBhbGxvd2luZyBzY3JlZW4gcmVhZGVycyB0byBpZ25vcmUgdGhlIGRlY29yYXRpdmUgaW1hZ2UgdGlsZXMuXHJcbiAgXHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9XQUkvdHV0b3JpYWxzL2ltYWdlcy9kZWNvcmF0aXZlL1xyXG4gIFx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbC1hcmlhLyNlbC1pbWctZW1wdHktYWx0XHJcbiAgXHRcdHRpbGUuYWx0ID0gJyc7XHJcblxyXG4gIFx0XHR0aWxlLnNyYyA9IHRoaXMuZ2V0VGlsZVVybChjb29yZHMpO1xyXG5cclxuICBcdFx0cmV0dXJuIHRpbGU7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXHJcbiAgXHQvLyBAdW5pbmhlcml0YWJsZVxyXG4gIFx0Ly8gTGF5ZXJzIGV4dGVuZGluZyBgVGlsZUxheWVyYCBtaWdodCByZWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZC5cclxuICBcdC8vIEBtZXRob2QgZ2V0VGlsZVVybChjb29yZHM6IE9iamVjdCk6IFN0cmluZ1xyXG4gIFx0Ly8gQ2FsbGVkIG9ubHkgaW50ZXJuYWxseSwgcmV0dXJucyB0aGUgVVJMIGZvciBhIHRpbGUgZ2l2ZW4gaXRzIGNvb3JkaW5hdGVzLlxyXG4gIFx0Ly8gQ2xhc3NlcyBleHRlbmRpbmcgYFRpbGVMYXllcmAgY2FuIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gdG8gcHJvdmlkZSBjdXN0b20gdGlsZSBVUkwgbmFtaW5nIHNjaGVtZXMuXHJcbiAgXHRnZXRUaWxlVXJsOiBmdW5jdGlvbiAoY29vcmRzKSB7XHJcbiAgXHRcdHZhciBkYXRhID0ge1xyXG4gIFx0XHRcdHI6IEJyb3dzZXIucmV0aW5hID8gJ0AyeCcgOiAnJyxcclxuICBcdFx0XHRzOiB0aGlzLl9nZXRTdWJkb21haW4oY29vcmRzKSxcclxuICBcdFx0XHR4OiBjb29yZHMueCxcclxuICBcdFx0XHR5OiBjb29yZHMueSxcclxuICBcdFx0XHR6OiB0aGlzLl9nZXRab29tRm9yVXJsKClcclxuICBcdFx0fTtcclxuICBcdFx0aWYgKHRoaXMuX21hcCAmJiAhdGhpcy5fbWFwLm9wdGlvbnMuY3JzLmluZmluaXRlKSB7XHJcbiAgXHRcdFx0dmFyIGludmVydGVkWSA9IHRoaXMuX2dsb2JhbFRpbGVSYW5nZS5tYXgueSAtIGNvb3Jkcy55O1xyXG4gIFx0XHRcdGlmICh0aGlzLm9wdGlvbnMudG1zKSB7XHJcbiAgXHRcdFx0XHRkYXRhWyd5J10gPSBpbnZlcnRlZFk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHRcdGRhdGFbJy15J10gPSBpbnZlcnRlZFk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0ZW1wbGF0ZSh0aGlzLl91cmwsIGV4dGVuZChkYXRhLCB0aGlzLm9wdGlvbnMpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3RpbGVPbkxvYWQ6IGZ1bmN0aW9uIChkb25lLCB0aWxlKSB7XHJcbiAgXHRcdC8vIEZvciBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8zMzMyXHJcbiAgXHRcdGlmIChCcm93c2VyLmllbHQ5KSB7XHJcbiAgXHRcdFx0c2V0VGltZW91dChiaW5kKGRvbmUsIHRoaXMsIG51bGwsIHRpbGUpLCAwKTtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRkb25lKG51bGwsIHRpbGUpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF90aWxlT25FcnJvcjogZnVuY3Rpb24gKGRvbmUsIHRpbGUsIGUpIHtcclxuICBcdFx0dmFyIGVycm9yVXJsID0gdGhpcy5vcHRpb25zLmVycm9yVGlsZVVybDtcclxuICBcdFx0aWYgKGVycm9yVXJsICYmIHRpbGUuZ2V0QXR0cmlidXRlKCdzcmMnKSAhPT0gZXJyb3JVcmwpIHtcclxuICBcdFx0XHR0aWxlLnNyYyA9IGVycm9yVXJsO1xyXG4gIFx0XHR9XHJcbiAgXHRcdGRvbmUoZSwgdGlsZSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9vblRpbGVSZW1vdmU6IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdGUudGlsZS5vbmxvYWQgPSBudWxsO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfZ2V0Wm9vbUZvclVybDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgem9vbSA9IHRoaXMuX3RpbGVab29tLFxyXG4gIFx0XHRtYXhab29tID0gdGhpcy5vcHRpb25zLm1heFpvb20sXHJcbiAgXHRcdHpvb21SZXZlcnNlID0gdGhpcy5vcHRpb25zLnpvb21SZXZlcnNlLFxyXG4gIFx0XHR6b29tT2Zmc2V0ID0gdGhpcy5vcHRpb25zLnpvb21PZmZzZXQ7XHJcblxyXG4gIFx0XHRpZiAoem9vbVJldmVyc2UpIHtcclxuICBcdFx0XHR6b29tID0gbWF4Wm9vbSAtIHpvb207XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB6b29tICsgem9vbU9mZnNldDtcclxuICBcdH0sXHJcblxyXG4gIFx0X2dldFN1YmRvbWFpbjogZnVuY3Rpb24gKHRpbGVQb2ludCkge1xyXG4gIFx0XHR2YXIgaW5kZXggPSBNYXRoLmFicyh0aWxlUG9pbnQueCArIHRpbGVQb2ludC55KSAlIHRoaXMub3B0aW9ucy5zdWJkb21haW5zLmxlbmd0aDtcclxuICBcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5zdWJkb21haW5zW2luZGV4XTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gc3RvcHMgbG9hZGluZyBhbGwgdGlsZXMgaW4gdGhlIGJhY2tncm91bmQgbGF5ZXJcclxuICBcdF9hYm9ydExvYWRpbmc6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIGksIHRpbGU7XHJcbiAgXHRcdGZvciAoaSBpbiB0aGlzLl90aWxlcykge1xyXG4gIFx0XHRcdGlmICh0aGlzLl90aWxlc1tpXS5jb29yZHMueiAhPT0gdGhpcy5fdGlsZVpvb20pIHtcclxuICBcdFx0XHRcdHRpbGUgPSB0aGlzLl90aWxlc1tpXS5lbDtcclxuXHJcbiAgXHRcdFx0XHR0aWxlLm9ubG9hZCA9IGZhbHNlRm47XHJcbiAgXHRcdFx0XHR0aWxlLm9uZXJyb3IgPSBmYWxzZUZuO1xyXG5cclxuICBcdFx0XHRcdGlmICghdGlsZS5jb21wbGV0ZSkge1xyXG4gIFx0XHRcdFx0XHR0aWxlLnNyYyA9IGVtcHR5SW1hZ2VVcmw7XHJcbiAgXHRcdFx0XHRcdHZhciBjb29yZHMgPSB0aGlzLl90aWxlc1tpXS5jb29yZHM7XHJcbiAgXHRcdFx0XHRcdHJlbW92ZSh0aWxlKTtcclxuICBcdFx0XHRcdFx0ZGVsZXRlIHRoaXMuX3RpbGVzW2ldO1xyXG4gIFx0XHRcdFx0XHQvLyBAZXZlbnQgdGlsZWFib3J0OiBUaWxlRXZlbnRcclxuICBcdFx0XHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHRpbGUgd2FzIGxvYWRpbmcgYnV0IGlzIG5vdyBub3Qgd2FudGVkLlxyXG4gIFx0XHRcdFx0XHR0aGlzLmZpcmUoJ3RpbGVhYm9ydCcsIHtcclxuICBcdFx0XHRcdFx0XHR0aWxlOiB0aWxlLFxyXG4gIFx0XHRcdFx0XHRcdGNvb3JkczogY29vcmRzXHJcbiAgXHRcdFx0XHRcdH0pO1xyXG4gIFx0XHRcdFx0fVxyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfcmVtb3ZlVGlsZTogZnVuY3Rpb24gKGtleSkge1xyXG4gIFx0XHR2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XHJcbiAgXHRcdGlmICghdGlsZSkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdC8vIENhbmNlbHMgYW55IHBlbmRpbmcgaHR0cCByZXF1ZXN0cyBhc3NvY2lhdGVkIHdpdGggdGhlIHRpbGVcclxuICBcdFx0dGlsZS5lbC5zZXRBdHRyaWJ1dGUoJ3NyYycsIGVtcHR5SW1hZ2VVcmwpO1xyXG5cclxuICBcdFx0cmV0dXJuIEdyaWRMYXllci5wcm90b3R5cGUuX3JlbW92ZVRpbGUuY2FsbCh0aGlzLCBrZXkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfdGlsZVJlYWR5OiBmdW5jdGlvbiAoY29vcmRzLCBlcnIsIHRpbGUpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9tYXAgfHwgKHRpbGUgJiYgdGlsZS5nZXRBdHRyaWJ1dGUoJ3NyYycpID09PSBlbXB0eUltYWdlVXJsKSkge1xyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIEdyaWRMYXllci5wcm90b3R5cGUuX3RpbGVSZWFkeS5jYWxsKHRoaXMsIGNvb3JkcywgZXJyLCB0aWxlKTtcclxuICBcdH1cclxuICB9KTtcclxuXHJcblxyXG4gIC8vIEBmYWN0b3J5IEwudGlsZWxheWVyKHVybFRlbXBsYXRlOiBTdHJpbmcsIG9wdGlvbnM/OiBUaWxlTGF5ZXIgb3B0aW9ucylcclxuICAvLyBJbnN0YW50aWF0ZXMgYSB0aWxlIGxheWVyIG9iamVjdCBnaXZlbiBhIGBVUkwgdGVtcGxhdGVgIGFuZCBvcHRpb25hbGx5IGFuIG9wdGlvbnMgb2JqZWN0LlxyXG5cclxuICBmdW5jdGlvbiB0aWxlTGF5ZXIodXJsLCBvcHRpb25zKSB7XHJcbiAgXHRyZXR1cm4gbmV3IFRpbGVMYXllcih1cmwsIG9wdGlvbnMpO1xyXG4gIH1cblxuICAvKlxyXG4gICAqIEBjbGFzcyBUaWxlTGF5ZXIuV01TXHJcbiAgICogQGluaGVyaXRzIFRpbGVMYXllclxyXG4gICAqIEBha2EgTC5UaWxlTGF5ZXIuV01TXHJcbiAgICogVXNlZCB0byBkaXNwbGF5IFtXTVNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1dlYl9NYXBfU2VydmljZSkgc2VydmljZXMgYXMgdGlsZSBsYXllcnMgb24gdGhlIG1hcC4gRXh0ZW5kcyBgVGlsZUxheWVyYC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIHZhciBuZXhyYWQgPSBMLnRpbGVMYXllci53bXMoXCJodHRwOi8vbWVzb25ldC5hZ3Jvbi5pYXN0YXRlLmVkdS9jZ2ktYmluL3dtcy9uZXhyYWQvbjByLmNnaVwiLCB7XHJcbiAgICogXHRsYXllcnM6ICduZXhyYWQtbjByLTkwMDkxMycsXHJcbiAgICogXHRmb3JtYXQ6ICdpbWFnZS9wbmcnLFxyXG4gICAqIFx0dHJhbnNwYXJlbnQ6IHRydWUsXHJcbiAgICogXHRhdHRyaWJ1dGlvbjogXCJXZWF0aGVyIGRhdGEgwqkgMjAxMiBJRU0gTmV4cmFkXCJcclxuICAgKiB9KTtcclxuICAgKiBgYGBcclxuICAgKi9cclxuXHJcbiAgdmFyIFRpbGVMYXllcldNUyA9IFRpbGVMYXllci5leHRlbmQoe1xyXG5cclxuICBcdC8vIEBzZWN0aW9uXHJcbiAgXHQvLyBAYWthIFRpbGVMYXllci5XTVMgb3B0aW9uc1xyXG4gIFx0Ly8gSWYgYW55IGN1c3RvbSBvcHRpb25zIG5vdCBkb2N1bWVudGVkIGhlcmUgYXJlIHVzZWQsIHRoZXkgd2lsbCBiZSBzZW50IHRvIHRoZVxyXG4gIFx0Ly8gV01TIHNlcnZlciBhcyBleHRyYSBwYXJhbWV0ZXJzIGluIGVhY2ggcmVxdWVzdCBVUkwuIFRoaXMgY2FuIGJlIHVzZWZ1bCBmb3JcclxuICBcdC8vIFtub24tc3RhbmRhcmQgdmVuZG9yIFdNUyBwYXJhbWV0ZXJzXShodHRwczovL2RvY3MuZ2Vvc2VydmVyLm9yZy9zdGFibGUvZW4vdXNlci9zZXJ2aWNlcy93bXMvdmVuZG9yLmh0bWwpLlxyXG4gIFx0ZGVmYXVsdFdtc1BhcmFtczoge1xyXG4gIFx0XHRzZXJ2aWNlOiAnV01TJyxcclxuICBcdFx0cmVxdWVzdDogJ0dldE1hcCcsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGxheWVyczogU3RyaW5nID0gJydcclxuICBcdFx0Ly8gKioocmVxdWlyZWQpKiogQ29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgV01TIGxheWVycyB0byBzaG93LlxyXG4gIFx0XHRsYXllcnM6ICcnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBzdHlsZXM6IFN0cmluZyA9ICcnXHJcbiAgXHRcdC8vIENvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIFdNUyBzdHlsZXMuXHJcbiAgXHRcdHN0eWxlczogJycsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGZvcm1hdDogU3RyaW5nID0gJ2ltYWdlL2pwZWcnXHJcbiAgXHRcdC8vIFdNUyBpbWFnZSBmb3JtYXQgKHVzZSBgJ2ltYWdlL3BuZydgIGZvciBsYXllcnMgd2l0aCB0cmFuc3BhcmVuY3kpLlxyXG4gIFx0XHRmb3JtYXQ6ICdpbWFnZS9qcGVnJyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gdHJhbnNwYXJlbnQ6IEJvb2xlYW4gPSBmYWxzZVxyXG4gIFx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBXTVMgc2VydmljZSB3aWxsIHJldHVybiBpbWFnZXMgd2l0aCB0cmFuc3BhcmVuY3kuXHJcbiAgXHRcdHRyYW5zcGFyZW50OiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gdmVyc2lvbjogU3RyaW5nID0gJzEuMS4xJ1xyXG4gIFx0XHQvLyBWZXJzaW9uIG9mIHRoZSBXTVMgc2VydmljZSB0byB1c2VcclxuICBcdFx0dmVyc2lvbjogJzEuMS4xJ1xyXG4gIFx0fSxcclxuXHJcbiAgXHRvcHRpb25zOiB7XHJcbiAgXHRcdC8vIEBvcHRpb24gY3JzOiBDUlMgPSBudWxsXHJcbiAgXHRcdC8vIENvb3JkaW5hdGUgUmVmZXJlbmNlIFN5c3RlbSB0byB1c2UgZm9yIHRoZSBXTVMgcmVxdWVzdHMsIGRlZmF1bHRzIHRvXHJcbiAgXHRcdC8vIG1hcCBDUlMuIERvbid0IGNoYW5nZSB0aGlzIGlmIHlvdSdyZSBub3Qgc3VyZSB3aGF0IGl0IG1lYW5zLlxyXG4gIFx0XHRjcnM6IG51bGwsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHVwcGVyY2FzZTogQm9vbGVhbiA9IGZhbHNlXHJcbiAgXHRcdC8vIElmIGB0cnVlYCwgV01TIHJlcXVlc3QgcGFyYW1ldGVyIGtleXMgd2lsbCBiZSB1cHBlcmNhc2UuXHJcbiAgXHRcdHVwcGVyY2FzZTogZmFsc2VcclxuICBcdH0sXHJcblxyXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xyXG5cclxuICBcdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuICBcdFx0dmFyIHdtc1BhcmFtcyA9IGV4dGVuZCh7fSwgdGhpcy5kZWZhdWx0V21zUGFyYW1zKTtcclxuXHJcbiAgXHRcdC8vIGFsbCBrZXlzIHRoYXQgYXJlIG5vdCBUaWxlTGF5ZXIgb3B0aW9ucyBnbyB0byBXTVMgcGFyYW1zXHJcbiAgXHRcdGZvciAodmFyIGkgaW4gb3B0aW9ucykge1xyXG4gIFx0XHRcdGlmICghKGkgaW4gdGhpcy5vcHRpb25zKSkge1xyXG4gIFx0XHRcdFx0d21zUGFyYW1zW2ldID0gb3B0aW9uc1tpXTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdG9wdGlvbnMgPSBzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuICBcdFx0dmFyIHJlYWxSZXRpbmEgPSBvcHRpb25zLmRldGVjdFJldGluYSAmJiBCcm93c2VyLnJldGluYSA/IDIgOiAxO1xyXG4gIFx0XHR2YXIgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XHJcbiAgXHRcdHdtc1BhcmFtcy53aWR0aCA9IHRpbGVTaXplLnggKiByZWFsUmV0aW5hO1xyXG4gIFx0XHR3bXNQYXJhbXMuaGVpZ2h0ID0gdGlsZVNpemUueSAqIHJlYWxSZXRpbmE7XHJcblxyXG4gIFx0XHR0aGlzLndtc1BhcmFtcyA9IHdtc1BhcmFtcztcclxuICBcdH0sXHJcblxyXG4gIFx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHJcbiAgXHRcdHRoaXMuX2NycyA9IHRoaXMub3B0aW9ucy5jcnMgfHwgbWFwLm9wdGlvbnMuY3JzO1xyXG4gIFx0XHR0aGlzLl93bXNWZXJzaW9uID0gcGFyc2VGbG9hdCh0aGlzLndtc1BhcmFtcy52ZXJzaW9uKTtcclxuXHJcbiAgXHRcdHZhciBwcm9qZWN0aW9uS2V5ID0gdGhpcy5fd21zVmVyc2lvbiA+PSAxLjMgPyAnY3JzJyA6ICdzcnMnO1xyXG4gIFx0XHR0aGlzLndtc1BhcmFtc1twcm9qZWN0aW9uS2V5XSA9IHRoaXMuX2Nycy5jb2RlO1xyXG5cclxuICBcdFx0VGlsZUxheWVyLnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdGdldFRpbGVVcmw6IGZ1bmN0aW9uIChjb29yZHMpIHtcclxuXHJcbiAgXHRcdHZhciB0aWxlQm91bmRzID0gdGhpcy5fdGlsZUNvb3Jkc1RvTndTZShjb29yZHMpLFxyXG4gIFx0XHQgICAgY3JzID0gdGhpcy5fY3JzLFxyXG4gIFx0XHQgICAgYm91bmRzID0gdG9Cb3VuZHMoY3JzLnByb2plY3QodGlsZUJvdW5kc1swXSksIGNycy5wcm9qZWN0KHRpbGVCb3VuZHNbMV0pKSxcclxuICBcdFx0ICAgIG1pbiA9IGJvdW5kcy5taW4sXHJcbiAgXHRcdCAgICBtYXggPSBib3VuZHMubWF4LFxyXG4gIFx0XHQgICAgYmJveCA9ICh0aGlzLl93bXNWZXJzaW9uID49IDEuMyAmJiB0aGlzLl9jcnMgPT09IEVQU0c0MzI2ID9cclxuICBcdFx0ICAgIFttaW4ueSwgbWluLngsIG1heC55LCBtYXgueF0gOlxyXG4gIFx0XHQgICAgW21pbi54LCBtaW4ueSwgbWF4LngsIG1heC55XSkuam9pbignLCcpLFxyXG4gIFx0XHQgICAgdXJsID0gVGlsZUxheWVyLnByb3RvdHlwZS5nZXRUaWxlVXJsLmNhbGwodGhpcywgY29vcmRzKTtcclxuICBcdFx0cmV0dXJuIHVybCArXHJcbiAgXHRcdFx0Z2V0UGFyYW1TdHJpbmcodGhpcy53bXNQYXJhbXMsIHVybCwgdGhpcy5vcHRpb25zLnVwcGVyY2FzZSkgK1xyXG4gIFx0XHRcdCh0aGlzLm9wdGlvbnMudXBwZXJjYXNlID8gJyZCQk9YPScgOiAnJmJib3g9JykgKyBiYm94O1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldFBhcmFtcyhwYXJhbXM6IE9iamVjdCwgbm9SZWRyYXc/OiBCb29sZWFuKTogdGhpc1xyXG4gIFx0Ly8gTWVyZ2VzIGFuIG9iamVjdCB3aXRoIHRoZSBuZXcgcGFyYW1ldGVycyBhbmQgcmUtcmVxdWVzdHMgdGlsZXMgb24gdGhlIGN1cnJlbnQgc2NyZWVuICh1bmxlc3MgYG5vUmVkcmF3YCB3YXMgc2V0IHRvIHRydWUpLlxyXG4gIFx0c2V0UGFyYW1zOiBmdW5jdGlvbiAocGFyYW1zLCBub1JlZHJhdykge1xyXG5cclxuICBcdFx0ZXh0ZW5kKHRoaXMud21zUGFyYW1zLCBwYXJhbXMpO1xyXG5cclxuICBcdFx0aWYgKCFub1JlZHJhdykge1xyXG4gIFx0XHRcdHRoaXMucmVkcmF3KCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuXHJcbiAgLy8gQGZhY3RvcnkgTC50aWxlTGF5ZXIud21zKGJhc2VVcmw6IFN0cmluZywgb3B0aW9uczogVGlsZUxheWVyLldNUyBvcHRpb25zKVxyXG4gIC8vIEluc3RhbnRpYXRlcyBhIFdNUyB0aWxlIGxheWVyIG9iamVjdCBnaXZlbiBhIGJhc2UgVVJMIG9mIHRoZSBXTVMgc2VydmljZSBhbmQgYSBXTVMgcGFyYW1ldGVycy9vcHRpb25zIG9iamVjdC5cclxuICBmdW5jdGlvbiB0aWxlTGF5ZXJXTVModXJsLCBvcHRpb25zKSB7XHJcbiAgXHRyZXR1cm4gbmV3IFRpbGVMYXllcldNUyh1cmwsIG9wdGlvbnMpO1xyXG4gIH1cblxuICBUaWxlTGF5ZXIuV01TID0gVGlsZUxheWVyV01TO1xuICB0aWxlTGF5ZXIud21zID0gdGlsZUxheWVyV01TO1xuXG4gIC8qXG4gICAqIEBjbGFzcyBSZW5kZXJlclxuICAgKiBAaW5oZXJpdHMgTGF5ZXJcbiAgICogQGFrYSBMLlJlbmRlcmVyXG4gICAqXG4gICAqIEJhc2UgY2xhc3MgZm9yIHZlY3RvciByZW5kZXJlciBpbXBsZW1lbnRhdGlvbnMgKGBTVkdgLCBgQ2FudmFzYCkuIEhhbmRsZXMgdGhlXG4gICAqIERPTSBjb250YWluZXIgb2YgdGhlIHJlbmRlcmVyLCBpdHMgYm91bmRzLCBhbmQgaXRzIHpvb20gYW5pbWF0aW9uLlxuICAgKlxuICAgKiBBIGBSZW5kZXJlcmAgd29ya3MgYXMgYW4gaW1wbGljaXQgbGF5ZXIgZ3JvdXAgZm9yIGFsbCBgUGF0aGBzIC0gdGhlIHJlbmRlcmVyXG4gICAqIGl0c2VsZiBjYW4gYmUgYWRkZWQgb3IgcmVtb3ZlZCB0byB0aGUgbWFwLiBBbGwgcGF0aHMgdXNlIGEgcmVuZGVyZXIsIHdoaWNoIGNhblxuICAgKiBiZSBpbXBsaWNpdCAodGhlIG1hcCB3aWxsIGRlY2lkZSB0aGUgdHlwZSBvZiByZW5kZXJlciBhbmQgdXNlIGl0IGF1dG9tYXRpY2FsbHkpXG4gICAqIG9yIGV4cGxpY2l0ICh1c2luZyB0aGUgW2ByZW5kZXJlcmBdKCNwYXRoLXJlbmRlcmVyKSBvcHRpb24gb2YgdGhlIHBhdGgpLlxuICAgKlxuICAgKiBEbyBub3QgdXNlIHRoaXMgY2xhc3MgZGlyZWN0bHksIHVzZSBgU1ZHYCBhbmQgYENhbnZhc2AgaW5zdGVhZC5cbiAgICpcbiAgICogQGV2ZW50IHVwZGF0ZTogRXZlbnRcbiAgICogRmlyZWQgd2hlbiB0aGUgcmVuZGVyZXIgdXBkYXRlcyBpdHMgYm91bmRzLCBjZW50ZXIgYW5kIHpvb20sIGZvciBleGFtcGxlIHdoZW5cbiAgICogaXRzIG1hcCBoYXMgbW92ZWRcbiAgICovXG5cbiAgdmFyIFJlbmRlcmVyID0gTGF5ZXIuZXh0ZW5kKHtcblxuICBcdC8vIEBzZWN0aW9uXG4gIFx0Ly8gQGFrYSBSZW5kZXJlciBvcHRpb25zXG4gIFx0b3B0aW9uczoge1xuICBcdFx0Ly8gQG9wdGlvbiBwYWRkaW5nOiBOdW1iZXIgPSAwLjFcbiAgXHRcdC8vIEhvdyBtdWNoIHRvIGV4dGVuZCB0aGUgY2xpcCBhcmVhIGFyb3VuZCB0aGUgbWFwIHZpZXcgKHJlbGF0aXZlIHRvIGl0cyBzaXplKVxuICBcdFx0Ly8gZS5nLiAwLjEgd291bGQgYmUgMTAlIG9mIG1hcCB2aWV3IGluIGVhY2ggZGlyZWN0aW9uXG4gIFx0XHRwYWRkaW5nOiAwLjFcbiAgXHR9LFxuXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gIFx0XHRzdGFtcCh0aGlzKTtcbiAgXHRcdHRoaXMuX2xheWVycyA9IHRoaXMuX2xheWVycyB8fCB7fTtcbiAgXHR9LFxuXG4gIFx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5fY29udGFpbmVyKSB7XG4gIFx0XHRcdHRoaXMuX2luaXRDb250YWluZXIoKTsgLy8gZGVmaW5lZCBieSByZW5kZXJlciBpbXBsZW1lbnRhdGlvbnNcblxuICBcdFx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XG4gIFx0XHRcdFx0YWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcbiAgXHRcdHRoaXMuX3VwZGF0ZSgpO1xuICBcdFx0dGhpcy5vbigndXBkYXRlJywgdGhpcy5fdXBkYXRlUGF0aHMsIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5vZmYoJ3VwZGF0ZScsIHRoaXMuX3VwZGF0ZVBhdGhzLCB0aGlzKTtcbiAgXHRcdHRoaXMuX2Rlc3Ryb3lDb250YWluZXIoKTtcbiAgXHR9LFxuXG4gIFx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgZXZlbnRzID0ge1xuICBcdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0LFxuICBcdFx0XHR6b29tOiB0aGlzLl9vblpvb20sXG4gIFx0XHRcdG1vdmVlbmQ6IHRoaXMuX3VwZGF0ZSxcbiAgXHRcdFx0em9vbWVuZDogdGhpcy5fb25ab29tRW5kXG4gIFx0XHR9O1xuICBcdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuICBcdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9vbkFuaW1ab29tO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIGV2ZW50cztcbiAgXHR9LFxuXG4gIFx0X29uQW5pbVpvb206IGZ1bmN0aW9uIChldikge1xuICBcdFx0dGhpcy5fdXBkYXRlVHJhbnNmb3JtKGV2LmNlbnRlciwgZXYuem9vbSk7XG4gIFx0fSxcblxuICBcdF9vblpvb206IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX3VwZGF0ZVRyYW5zZm9ybSh0aGlzLl9tYXAuZ2V0Q2VudGVyKCksIHRoaXMuX21hcC5nZXRab29tKCkpO1xuICBcdH0sXG5cbiAgXHRfdXBkYXRlVHJhbnNmb3JtOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XG4gIFx0XHR2YXIgc2NhbGUgPSB0aGlzLl9tYXAuZ2V0Wm9vbVNjYWxlKHpvb20sIHRoaXMuX3pvb20pLFxuICBcdFx0ICAgIHZpZXdIYWxmID0gdGhpcy5fbWFwLmdldFNpemUoKS5tdWx0aXBseUJ5KDAuNSArIHRoaXMub3B0aW9ucy5wYWRkaW5nKSxcbiAgXHRcdCAgICBjdXJyZW50Q2VudGVyUG9pbnQgPSB0aGlzLl9tYXAucHJvamVjdCh0aGlzLl9jZW50ZXIsIHpvb20pLFxuXG4gIFx0XHQgICAgdG9wTGVmdE9mZnNldCA9IHZpZXdIYWxmLm11bHRpcGx5QnkoLXNjYWxlKS5hZGQoY3VycmVudENlbnRlclBvaW50KVxuICBcdFx0XHRcdCAgLnN1YnRyYWN0KHRoaXMuX21hcC5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKSk7XG5cbiAgXHRcdGlmIChCcm93c2VyLmFueTNkKSB7XG4gIFx0XHRcdHNldFRyYW5zZm9ybSh0aGlzLl9jb250YWluZXIsIHRvcExlZnRPZmZzZXQsIHNjYWxlKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHNldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lciwgdG9wTGVmdE9mZnNldCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9yZXNldDogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5fdXBkYXRlKCk7XG4gIFx0XHR0aGlzLl91cGRhdGVUcmFuc2Zvcm0odGhpcy5fY2VudGVyLCB0aGlzLl96b29tKTtcblxuICBcdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG4gIFx0XHRcdHRoaXMuX2xheWVyc1tpZF0uX3Jlc2V0KCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9vblpvb21FbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuICBcdFx0XHR0aGlzLl9sYXllcnNbaWRdLl9wcm9qZWN0KCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF91cGRhdGVQYXRoczogZnVuY3Rpb24gKCkge1xuICBcdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG4gIFx0XHRcdHRoaXMuX2xheWVyc1tpZF0uX3VwZGF0ZSgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHQvLyBVcGRhdGUgcGl4ZWwgYm91bmRzIG9mIHJlbmRlcmVyIGNvbnRhaW5lciAoZm9yIHBvc2l0aW9uaW5nL3NpemluZy9jbGlwcGluZyBsYXRlcilcbiAgXHRcdC8vIFN1YmNsYXNzZXMgYXJlIHJlc3BvbnNpYmxlIG9mIGZpcmluZyB0aGUgJ3VwZGF0ZScgZXZlbnQuXG4gIFx0XHR2YXIgcCA9IHRoaXMub3B0aW9ucy5wYWRkaW5nLFxuICBcdFx0ICAgIHNpemUgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLFxuICBcdFx0ICAgIG1pbiA9IHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChzaXplLm11bHRpcGx5QnkoLXApKS5yb3VuZCgpO1xuXG4gIFx0XHR0aGlzLl9ib3VuZHMgPSBuZXcgQm91bmRzKG1pbiwgbWluLmFkZChzaXplLm11bHRpcGx5QnkoMSArIHAgKiAyKSkucm91bmQoKSk7XG5cbiAgXHRcdHRoaXMuX2NlbnRlciA9IHRoaXMuX21hcC5nZXRDZW50ZXIoKTtcbiAgXHRcdHRoaXMuX3pvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xuICBcdH1cbiAgfSk7XG5cbiAgLypcbiAgICogQGNsYXNzIENhbnZhc1xuICAgKiBAaW5oZXJpdHMgUmVuZGVyZXJcbiAgICogQGFrYSBMLkNhbnZhc1xuICAgKlxuICAgKiBBbGxvd3MgdmVjdG9yIGxheWVycyB0byBiZSBkaXNwbGF5ZWQgd2l0aCBbYDxjYW52YXM+YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0NhbnZhc19BUEkpLlxuICAgKiBJbmhlcml0cyBgUmVuZGVyZXJgLlxuICAgKlxuICAgKiBEdWUgdG8gW3RlY2huaWNhbCBsaW1pdGF0aW9uc10oaHR0cHM6Ly9jYW5pdXNlLmNvbS9jYW52YXMpLCBDYW52YXMgaXMgbm90XG4gICAqIGF2YWlsYWJsZSBpbiBhbGwgd2ViIGJyb3dzZXJzLCBub3RhYmx5IElFOCwgYW5kIG92ZXJsYXBwaW5nIGdlb21ldHJpZXMgbWlnaHRcbiAgICogbm90IGRpc3BsYXkgcHJvcGVybHkgaW4gc29tZSBlZGdlIGNhc2VzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBVc2UgQ2FudmFzIGJ5IGRlZmF1bHQgZm9yIGFsbCBwYXRocyBpbiB0aGUgbWFwOlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcsIHtcbiAgICogXHRyZW5kZXJlcjogTC5jYW52YXMoKVxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIFVzZSBhIENhbnZhcyByZW5kZXJlciB3aXRoIGV4dHJhIHBhZGRpbmcgZm9yIHNwZWNpZmljIHZlY3RvciBnZW9tZXRyaWVzOlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcpO1xuICAgKiB2YXIgbXlSZW5kZXJlciA9IEwuY2FudmFzKHsgcGFkZGluZzogMC41IH0pO1xuICAgKiB2YXIgbGluZSA9IEwucG9seWxpbmUoIGNvb3JkaW5hdGVzLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAgICogdmFyIGNpcmNsZSA9IEwuY2lyY2xlKCBjZW50ZXIsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICAgKiBgYGBcbiAgICovXG5cbiAgdmFyIENhbnZhcyA9IFJlbmRlcmVyLmV4dGVuZCh7XG5cbiAgXHQvLyBAc2VjdGlvblxuICBcdC8vIEBha2EgQ2FudmFzIG9wdGlvbnNcbiAgXHRvcHRpb25zOiB7XG4gIFx0XHQvLyBAb3B0aW9uIHRvbGVyYW5jZTogTnVtYmVyID0gMFxuICBcdFx0Ly8gSG93IG11Y2ggdG8gZXh0ZW5kIHRoZSBjbGljayB0b2xlcmFuY2UgYXJvdW5kIGEgcGF0aC9vYmplY3Qgb24gdGhlIG1hcC5cbiAgXHRcdHRvbGVyYW5jZTogMFxuICBcdH0sXG5cbiAgXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBldmVudHMgPSBSZW5kZXJlci5wcm90b3R5cGUuZ2V0RXZlbnRzLmNhbGwodGhpcyk7XG4gIFx0XHRldmVudHMudmlld3ByZXJlc2V0ID0gdGhpcy5fb25WaWV3UHJlUmVzZXQ7XG4gIFx0XHRyZXR1cm4gZXZlbnRzO1xuICBcdH0sXG5cbiAgXHRfb25WaWV3UHJlUmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdC8vIFNldCBhIGZsYWcgc28gdGhhdCBhIHZpZXdwcmVyZXNldCttb3ZlZW5kK3ZpZXdyZXNldCBvbmx5IHVwZGF0ZXMmcmVkcmF3cyBvbmNlXG4gIFx0XHR0aGlzLl9wb3N0cG9uZVVwZGF0ZVBhdGhzID0gdHJ1ZTtcbiAgXHR9LFxuXG4gIFx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFJlbmRlcmVyLnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMpO1xuXG4gIFx0XHQvLyBSZWRyYXcgdmVjdG9ycyBzaW5jZSBjYW52YXMgaXMgY2xlYXJlZCB1cG9uIHJlbW92YWwsXG4gIFx0XHQvLyBpbiBjYXNlIG9mIHJlbW92aW5nIHRoZSByZW5kZXJlciBpdHNlbGYgZnJvbSB0aGUgbWFwLlxuICBcdFx0dGhpcy5fZHJhdygpO1xuICBcdH0sXG5cbiAgXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXG4gIFx0XHRvbihjb250YWluZXIsICdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgdGhpcyk7XG4gIFx0XHRvbihjb250YWluZXIsICdjbGljayBkYmxjbGljayBtb3VzZWRvd24gbW91c2V1cCBjb250ZXh0bWVudScsIHRoaXMuX29uQ2xpY2ssIHRoaXMpO1xuICBcdFx0b24oY29udGFpbmVyLCAnbW91c2VvdXQnLCB0aGlzLl9oYW5kbGVNb3VzZU91dCwgdGhpcyk7XG4gIFx0XHRjb250YWluZXJbJ19sZWFmbGV0X2Rpc2FibGVfZXZlbnRzJ10gPSB0cnVlO1xuXG4gIFx0XHR0aGlzLl9jdHggPSBjb250YWluZXIuZ2V0Q29udGV4dCgnMmQnKTtcbiAgXHR9LFxuXG4gIFx0X2Rlc3Ryb3lDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9yZWRyYXdSZXF1ZXN0KTtcbiAgXHRcdGRlbGV0ZSB0aGlzLl9jdHg7XG4gIFx0XHRyZW1vdmUodGhpcy5fY29udGFpbmVyKTtcbiAgXHRcdG9mZih0aGlzLl9jb250YWluZXIpO1xuICBcdFx0ZGVsZXRlIHRoaXMuX2NvbnRhaW5lcjtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVBhdGhzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fcG9zdHBvbmVVcGRhdGVQYXRocykgeyByZXR1cm47IH1cblxuICBcdFx0dmFyIGxheWVyO1xuICBcdFx0dGhpcy5fcmVkcmF3Qm91bmRzID0gbnVsbDtcbiAgXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuICBcdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tpZF07XG4gIFx0XHRcdGxheWVyLl91cGRhdGUoKTtcbiAgXHRcdH1cbiAgXHRcdHRoaXMuX3JlZHJhdygpO1xuICBcdH0sXG5cbiAgXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fbWFwLl9hbmltYXRpbmdab29tICYmIHRoaXMuX2JvdW5kcykgeyByZXR1cm47IH1cblxuICBcdFx0UmVuZGVyZXIucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcblxuICBcdFx0dmFyIGIgPSB0aGlzLl9ib3VuZHMsXG4gIFx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyLFxuICBcdFx0ICAgIHNpemUgPSBiLmdldFNpemUoKSxcbiAgXHRcdCAgICBtID0gQnJvd3Nlci5yZXRpbmEgPyAyIDogMTtcblxuICBcdFx0c2V0UG9zaXRpb24oY29udGFpbmVyLCBiLm1pbik7XG5cbiAgXHRcdC8vIHNldCBjYW52YXMgc2l6ZSAoYWxzbyBjbGVhcmluZyBpdCk7IHVzZSBkb3VibGUgc2l6ZSBvbiByZXRpbmFcbiAgXHRcdGNvbnRhaW5lci53aWR0aCA9IG0gKiBzaXplLng7XG4gIFx0XHRjb250YWluZXIuaGVpZ2h0ID0gbSAqIHNpemUueTtcbiAgXHRcdGNvbnRhaW5lci5zdHlsZS53aWR0aCA9IHNpemUueCArICdweCc7XG4gIFx0XHRjb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4JztcblxuICBcdFx0aWYgKEJyb3dzZXIucmV0aW5hKSB7XG4gIFx0XHRcdHRoaXMuX2N0eC5zY2FsZSgyLCAyKTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gdHJhbnNsYXRlIHNvIHdlIHVzZSB0aGUgc2FtZSBwYXRoIGNvb3JkaW5hdGVzIGFmdGVyIGNhbnZhcyBlbGVtZW50IG1vdmVzXG4gIFx0XHR0aGlzLl9jdHgudHJhbnNsYXRlKC1iLm1pbi54LCAtYi5taW4ueSk7XG5cbiAgXHRcdC8vIFRlbGwgcGF0aHMgdG8gcmVkcmF3IHRoZW1zZWx2ZXNcbiAgXHRcdHRoaXMuZmlyZSgndXBkYXRlJyk7XG4gIFx0fSxcblxuICBcdF9yZXNldDogZnVuY3Rpb24gKCkge1xuICBcdFx0UmVuZGVyZXIucHJvdG90eXBlLl9yZXNldC5jYWxsKHRoaXMpO1xuXG4gIFx0XHRpZiAodGhpcy5fcG9zdHBvbmVVcGRhdGVQYXRocykge1xuICBcdFx0XHR0aGlzLl9wb3N0cG9uZVVwZGF0ZVBhdGhzID0gZmFsc2U7XG4gIFx0XHRcdHRoaXMuX3VwZGF0ZVBhdGhzKCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9pbml0UGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR0aGlzLl91cGRhdGVEYXNoQXJyYXkobGF5ZXIpO1xuICBcdFx0dGhpcy5fbGF5ZXJzW3N0YW1wKGxheWVyKV0gPSBsYXllcjtcblxuICBcdFx0dmFyIG9yZGVyID0gbGF5ZXIuX29yZGVyID0ge1xuICBcdFx0XHRsYXllcjogbGF5ZXIsXG4gIFx0XHRcdHByZXY6IHRoaXMuX2RyYXdMYXN0LFxuICBcdFx0XHRuZXh0OiBudWxsXG4gIFx0XHR9O1xuICBcdFx0aWYgKHRoaXMuX2RyYXdMYXN0KSB7IHRoaXMuX2RyYXdMYXN0Lm5leHQgPSBvcmRlcjsgfVxuICBcdFx0dGhpcy5fZHJhd0xhc3QgPSBvcmRlcjtcbiAgXHRcdHRoaXMuX2RyYXdGaXJzdCA9IHRoaXMuX2RyYXdGaXJzdCB8fCB0aGlzLl9kcmF3TGFzdDtcbiAgXHR9LFxuXG4gIFx0X2FkZFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG4gIFx0fSxcblxuICBcdF9yZW1vdmVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHZhciBvcmRlciA9IGxheWVyLl9vcmRlcjtcbiAgXHRcdHZhciBuZXh0ID0gb3JkZXIubmV4dDtcbiAgXHRcdHZhciBwcmV2ID0gb3JkZXIucHJldjtcblxuICBcdFx0aWYgKG5leHQpIHtcbiAgXHRcdFx0bmV4dC5wcmV2ID0gcHJldjtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRoaXMuX2RyYXdMYXN0ID0gcHJldjtcbiAgXHRcdH1cbiAgXHRcdGlmIChwcmV2KSB7XG4gIFx0XHRcdHByZXYubmV4dCA9IG5leHQ7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aGlzLl9kcmF3Rmlyc3QgPSBuZXh0O1xuICBcdFx0fVxuXG4gIFx0XHRkZWxldGUgbGF5ZXIuX29yZGVyO1xuXG4gIFx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW3N0YW1wKGxheWVyKV07XG5cbiAgXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuICBcdH0sXG5cbiAgXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHQvLyBSZWRyYXcgdGhlIHVuaW9uIG9mIHRoZSBsYXllcidzIG9sZCBwaXhlbFxuICBcdFx0Ly8gYm91bmRzIGFuZCB0aGUgbmV3IHBpeGVsIGJvdW5kcy5cbiAgXHRcdHRoaXMuX2V4dGVuZFJlZHJhd0JvdW5kcyhsYXllcik7XG4gIFx0XHRsYXllci5fcHJvamVjdCgpO1xuICBcdFx0bGF5ZXIuX3VwZGF0ZSgpO1xuICBcdFx0Ly8gVGhlIHJlZHJhdyB3aWxsIGV4dGVuZCB0aGUgcmVkcmF3IGJvdW5kc1xuICBcdFx0Ly8gd2l0aCB0aGUgbmV3IHBpeGVsIGJvdW5kcy5cbiAgXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuICBcdH0sXG5cbiAgXHRfdXBkYXRlU3R5bGU6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dGhpcy5fdXBkYXRlRGFzaEFycmF5KGxheWVyKTtcbiAgXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuICBcdH0sXG5cbiAgXHRfdXBkYXRlRGFzaEFycmF5OiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdGlmICh0eXBlb2YgbGF5ZXIub3B0aW9ucy5kYXNoQXJyYXkgPT09ICdzdHJpbmcnKSB7XG4gIFx0XHRcdHZhciBwYXJ0cyA9IGxheWVyLm9wdGlvbnMuZGFzaEFycmF5LnNwbGl0KC9bLCBdKy8pLFxuICBcdFx0XHQgICAgZGFzaEFycmF5ID0gW10sXG4gIFx0XHRcdCAgICBkYXNoVmFsdWUsXG4gIFx0XHRcdCAgICBpO1xuICBcdFx0XHRmb3IgKGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgXHRcdFx0XHRkYXNoVmFsdWUgPSBOdW1iZXIocGFydHNbaV0pO1xuICBcdFx0XHRcdC8vIElnbm9yZSBkYXNoIGFycmF5IGNvbnRhaW5pbmcgaW52YWxpZCBsZW5ndGhzXG4gIFx0XHRcdFx0aWYgKGlzTmFOKGRhc2hWYWx1ZSkpIHsgcmV0dXJuOyB9XG4gIFx0XHRcdFx0ZGFzaEFycmF5LnB1c2goZGFzaFZhbHVlKTtcbiAgXHRcdFx0fVxuICBcdFx0XHRsYXllci5vcHRpb25zLl9kYXNoQXJyYXkgPSBkYXNoQXJyYXk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRsYXllci5vcHRpb25zLl9kYXNoQXJyYXkgPSBsYXllci5vcHRpb25zLmRhc2hBcnJheTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3JlcXVlc3RSZWRyYXc6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHRoaXMuX2V4dGVuZFJlZHJhd0JvdW5kcyhsYXllcik7XG4gIFx0XHR0aGlzLl9yZWRyYXdSZXF1ZXN0ID0gdGhpcy5fcmVkcmF3UmVxdWVzdCB8fCByZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3JlZHJhdywgdGhpcyk7XG4gIFx0fSxcblxuICBcdF9leHRlbmRSZWRyYXdCb3VuZHM6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0aWYgKGxheWVyLl9weEJvdW5kcykge1xuICBcdFx0XHR2YXIgcGFkZGluZyA9IChsYXllci5vcHRpb25zLndlaWdodCB8fCAwKSArIDE7XG4gIFx0XHRcdHRoaXMuX3JlZHJhd0JvdW5kcyA9IHRoaXMuX3JlZHJhd0JvdW5kcyB8fCBuZXcgQm91bmRzKCk7XG4gIFx0XHRcdHRoaXMuX3JlZHJhd0JvdW5kcy5leHRlbmQobGF5ZXIuX3B4Qm91bmRzLm1pbi5zdWJ0cmFjdChbcGFkZGluZywgcGFkZGluZ10pKTtcbiAgXHRcdFx0dGhpcy5fcmVkcmF3Qm91bmRzLmV4dGVuZChsYXllci5fcHhCb3VuZHMubWF4LmFkZChbcGFkZGluZywgcGFkZGluZ10pKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3JlZHJhdzogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5fcmVkcmF3UmVxdWVzdCA9IG51bGw7XG5cbiAgXHRcdGlmICh0aGlzLl9yZWRyYXdCb3VuZHMpIHtcbiAgXHRcdFx0dGhpcy5fcmVkcmF3Qm91bmRzLm1pbi5fZmxvb3IoKTtcbiAgXHRcdFx0dGhpcy5fcmVkcmF3Qm91bmRzLm1heC5fY2VpbCgpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl9jbGVhcigpOyAvLyBjbGVhciBsYXllcnMgaW4gcmVkcmF3IGJvdW5kc1xuICBcdFx0dGhpcy5fZHJhdygpOyAvLyBkcmF3IGxheWVyc1xuXG4gIFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMgPSBudWxsO1xuICBcdH0sXG5cbiAgXHRfY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBib3VuZHMgPSB0aGlzLl9yZWRyYXdCb3VuZHM7XG4gIFx0XHRpZiAoYm91bmRzKSB7XG4gIFx0XHRcdHZhciBzaXplID0gYm91bmRzLmdldFNpemUoKTtcbiAgXHRcdFx0dGhpcy5fY3R4LmNsZWFyUmVjdChib3VuZHMubWluLngsIGJvdW5kcy5taW4ueSwgc2l6ZS54LCBzaXplLnkpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGhpcy5fY3R4LnNhdmUoKTtcbiAgXHRcdFx0dGhpcy5fY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgXHRcdFx0dGhpcy5fY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLl9jb250YWluZXIud2lkdGgsIHRoaXMuX2NvbnRhaW5lci5oZWlnaHQpO1xuICBcdFx0XHR0aGlzLl9jdHgucmVzdG9yZSgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfZHJhdzogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGxheWVyLCBib3VuZHMgPSB0aGlzLl9yZWRyYXdCb3VuZHM7XG4gIFx0XHR0aGlzLl9jdHguc2F2ZSgpO1xuICBcdFx0aWYgKGJvdW5kcykge1xuICBcdFx0XHR2YXIgc2l6ZSA9IGJvdW5kcy5nZXRTaXplKCk7XG4gIFx0XHRcdHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcbiAgXHRcdFx0dGhpcy5fY3R4LnJlY3QoYm91bmRzLm1pbi54LCBib3VuZHMubWluLnksIHNpemUueCwgc2l6ZS55KTtcbiAgXHRcdFx0dGhpcy5fY3R4LmNsaXAoKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fZHJhd2luZyA9IHRydWU7XG5cbiAgXHRcdGZvciAodmFyIG9yZGVyID0gdGhpcy5fZHJhd0ZpcnN0OyBvcmRlcjsgb3JkZXIgPSBvcmRlci5uZXh0KSB7XG4gIFx0XHRcdGxheWVyID0gb3JkZXIubGF5ZXI7XG4gIFx0XHRcdGlmICghYm91bmRzIHx8IChsYXllci5fcHhCb3VuZHMgJiYgbGF5ZXIuX3B4Qm91bmRzLmludGVyc2VjdHMoYm91bmRzKSkpIHtcbiAgXHRcdFx0XHRsYXllci5fdXBkYXRlUGF0aCgpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX2RyYXdpbmcgPSBmYWxzZTtcblxuICBcdFx0dGhpcy5fY3R4LnJlc3RvcmUoKTsgIC8vIFJlc3RvcmUgc3RhdGUgYmVmb3JlIGNsaXBwaW5nLlxuICBcdH0sXG5cbiAgXHRfdXBkYXRlUG9seTogZnVuY3Rpb24gKGxheWVyLCBjbG9zZWQpIHtcbiAgXHRcdGlmICghdGhpcy5fZHJhd2luZykgeyByZXR1cm47IH1cblxuICBcdFx0dmFyIGksIGosIGxlbjIsIHAsXG4gIFx0XHQgICAgcGFydHMgPSBsYXllci5fcGFydHMsXG4gIFx0XHQgICAgbGVuID0gcGFydHMubGVuZ3RoLFxuICBcdFx0ICAgIGN0eCA9IHRoaXMuX2N0eDtcblxuICBcdFx0aWYgKCFsZW4pIHsgcmV0dXJuOyB9XG5cbiAgXHRcdGN0eC5iZWdpblBhdGgoKTtcblxuICBcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gIFx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwYXJ0c1tpXS5sZW5ndGg7IGogPCBsZW4yOyBqKyspIHtcbiAgXHRcdFx0XHRwID0gcGFydHNbaV1bal07XG4gIFx0XHRcdFx0Y3R4W2ogPyAnbGluZVRvJyA6ICdtb3ZlVG8nXShwLngsIHAueSk7XG4gIFx0XHRcdH1cbiAgXHRcdFx0aWYgKGNsb3NlZCkge1xuICBcdFx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl9maWxsU3Ryb2tlKGN0eCwgbGF5ZXIpO1xuXG4gIFx0XHQvLyBUT0RPIG9wdGltaXphdGlvbjogMSBmaWxsL3N0cm9rZSBmb3IgYWxsIGZlYXR1cmVzIHdpdGggZXF1YWwgc3R5bGUgaW5zdGVhZCBvZiAxIGZvciBlYWNoIGZlYXR1cmVcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZUNpcmNsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cbiAgXHRcdGlmICghdGhpcy5fZHJhd2luZyB8fCBsYXllci5fZW1wdHkoKSkgeyByZXR1cm47IH1cblxuICBcdFx0dmFyIHAgPSBsYXllci5fcG9pbnQsXG4gIFx0XHQgICAgY3R4ID0gdGhpcy5fY3R4LFxuICBcdFx0ICAgIHIgPSBNYXRoLm1heChNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXMpLCAxKSxcbiAgXHRcdCAgICBzID0gKE1hdGgubWF4KE1hdGgucm91bmQobGF5ZXIuX3JhZGl1c1kpLCAxKSB8fCByKSAvIHI7XG5cbiAgXHRcdGlmIChzICE9PSAxKSB7XG4gIFx0XHRcdGN0eC5zYXZlKCk7XG4gIFx0XHRcdGN0eC5zY2FsZSgxLCBzKTtcbiAgXHRcdH1cblxuICBcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuICBcdFx0Y3R4LmFyYyhwLngsIHAueSAvIHMsIHIsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG5cbiAgXHRcdGlmIChzICE9PSAxKSB7XG4gIFx0XHRcdGN0eC5yZXN0b3JlKCk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX2ZpbGxTdHJva2UoY3R4LCBsYXllcik7XG4gIFx0fSxcblxuICBcdF9maWxsU3Ryb2tlOiBmdW5jdGlvbiAoY3R4LCBsYXllcikge1xuICBcdFx0dmFyIG9wdGlvbnMgPSBsYXllci5vcHRpb25zO1xuXG4gIFx0XHRpZiAob3B0aW9ucy5maWxsKSB7XG4gIFx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IG9wdGlvbnMuZmlsbE9wYWNpdHk7XG4gIFx0XHRcdGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmZpbGxDb2xvciB8fCBvcHRpb25zLmNvbG9yO1xuICBcdFx0XHRjdHguZmlsbChvcHRpb25zLmZpbGxSdWxlIHx8ICdldmVub2RkJyk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChvcHRpb25zLnN0cm9rZSAmJiBvcHRpb25zLndlaWdodCAhPT0gMCkge1xuICBcdFx0XHRpZiAoY3R4LnNldExpbmVEYXNoKSB7XG4gIFx0XHRcdFx0Y3R4LnNldExpbmVEYXNoKGxheWVyLm9wdGlvbnMgJiYgbGF5ZXIub3B0aW9ucy5fZGFzaEFycmF5IHx8IFtdKTtcbiAgXHRcdFx0fVxuICBcdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSBvcHRpb25zLm9wYWNpdHk7XG4gIFx0XHRcdGN0eC5saW5lV2lkdGggPSBvcHRpb25zLndlaWdodDtcbiAgXHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5jb2xvcjtcbiAgXHRcdFx0Y3R4LmxpbmVDYXAgPSBvcHRpb25zLmxpbmVDYXA7XG4gIFx0XHRcdGN0eC5saW5lSm9pbiA9IG9wdGlvbnMubGluZUpvaW47XG4gIFx0XHRcdGN0eC5zdHJva2UoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0Ly8gQ2FudmFzIG9idmlvdXNseSBkb2Vzbid0IGhhdmUgbW91c2UgZXZlbnRzIGZvciBpbmRpdmlkdWFsIGRyYXduIG9iamVjdHMsXG4gIFx0Ly8gc28gd2UgZW11bGF0ZSB0aGF0IGJ5IGNhbGN1bGF0aW5nIHdoYXQncyB1bmRlciB0aGUgbW91c2Ugb24gbW91c2Vtb3ZlL2NsaWNrIG1hbnVhbGx5XG5cbiAgXHRfb25DbGljazogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdHZhciBwb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUpLCBsYXllciwgY2xpY2tlZExheWVyO1xuXG4gIFx0XHRmb3IgKHZhciBvcmRlciA9IHRoaXMuX2RyYXdGaXJzdDsgb3JkZXI7IG9yZGVyID0gb3JkZXIubmV4dCkge1xuICBcdFx0XHRsYXllciA9IG9yZGVyLmxheWVyO1xuICBcdFx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSAmJiBsYXllci5fY29udGFpbnNQb2ludChwb2ludCkpIHtcbiAgXHRcdFx0XHRpZiAoIShlLnR5cGUgPT09ICdjbGljaycgfHwgZS50eXBlID09PSAncHJlY2xpY2snKSB8fCAhdGhpcy5fbWFwLl9kcmFnZ2FibGVNb3ZlZChsYXllcikpIHtcbiAgXHRcdFx0XHRcdGNsaWNrZWRMYXllciA9IGxheWVyO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdFx0dGhpcy5fZmlyZUV2ZW50KGNsaWNrZWRMYXllciA/IFtjbGlja2VkTGF5ZXJdIDogZmFsc2UsIGUpO1xuICBcdH0sXG5cbiAgXHRfb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHRpZiAoIXRoaXMuX21hcCB8fCB0aGlzLl9tYXAuZHJhZ2dpbmcubW92aW5nKCkgfHwgdGhpcy5fbWFwLl9hbmltYXRpbmdab29tKSB7IHJldHVybjsgfVxuXG4gIFx0XHR2YXIgcG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvTGF5ZXJQb2ludChlKTtcbiAgXHRcdHRoaXMuX2hhbmRsZU1vdXNlSG92ZXIoZSwgcG9pbnQpO1xuICBcdH0sXG5cblxuICBcdF9oYW5kbGVNb3VzZU91dDogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdHZhciBsYXllciA9IHRoaXMuX2hvdmVyZWRMYXllcjtcbiAgXHRcdGlmIChsYXllcikge1xuICBcdFx0XHQvLyBpZiB3ZSdyZSBsZWF2aW5nIHRoZSBsYXllciwgZmlyZSBtb3VzZW91dFxuICBcdFx0XHRyZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XG4gIFx0XHRcdHRoaXMuX2ZpcmVFdmVudChbbGF5ZXJdLCBlLCAnbW91c2VvdXQnKTtcbiAgXHRcdFx0dGhpcy5faG92ZXJlZExheWVyID0gbnVsbDtcbiAgXHRcdFx0dGhpcy5fbW91c2VIb3ZlclRocm90dGxlZCA9IGZhbHNlO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfaGFuZGxlTW91c2VIb3ZlcjogZnVuY3Rpb24gKGUsIHBvaW50KSB7XG4gIFx0XHRpZiAodGhpcy5fbW91c2VIb3ZlclRocm90dGxlZCkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHZhciBsYXllciwgY2FuZGlkYXRlSG92ZXJlZExheWVyO1xuXG4gIFx0XHRmb3IgKHZhciBvcmRlciA9IHRoaXMuX2RyYXdGaXJzdDsgb3JkZXI7IG9yZGVyID0gb3JkZXIubmV4dCkge1xuICBcdFx0XHRsYXllciA9IG9yZGVyLmxheWVyO1xuICBcdFx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSAmJiBsYXllci5fY29udGFpbnNQb2ludChwb2ludCkpIHtcbiAgXHRcdFx0XHRjYW5kaWRhdGVIb3ZlcmVkTGF5ZXIgPSBsYXllcjtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRpZiAoY2FuZGlkYXRlSG92ZXJlZExheWVyICE9PSB0aGlzLl9ob3ZlcmVkTGF5ZXIpIHtcbiAgXHRcdFx0dGhpcy5faGFuZGxlTW91c2VPdXQoZSk7XG5cbiAgXHRcdFx0aWYgKGNhbmRpZGF0ZUhvdmVyZWRMYXllcikge1xuICBcdFx0XHRcdGFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTsgLy8gY2hhbmdlIGN1cnNvclxuICBcdFx0XHRcdHRoaXMuX2ZpcmVFdmVudChbY2FuZGlkYXRlSG92ZXJlZExheWVyXSwgZSwgJ21vdXNlb3ZlcicpO1xuICBcdFx0XHRcdHRoaXMuX2hvdmVyZWRMYXllciA9IGNhbmRpZGF0ZUhvdmVyZWRMYXllcjtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl9maXJlRXZlbnQodGhpcy5faG92ZXJlZExheWVyID8gW3RoaXMuX2hvdmVyZWRMYXllcl0gOiBmYWxzZSwgZSk7XG5cbiAgXHRcdHRoaXMuX21vdXNlSG92ZXJUaHJvdHRsZWQgPSB0cnVlO1xuICBcdFx0c2V0VGltZW91dChiaW5kKGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0dGhpcy5fbW91c2VIb3ZlclRocm90dGxlZCA9IGZhbHNlO1xuICBcdFx0fSwgdGhpcyksIDMyKTtcbiAgXHR9LFxuXG4gIFx0X2ZpcmVFdmVudDogZnVuY3Rpb24gKGxheWVycywgZSwgdHlwZSkge1xuICBcdFx0dGhpcy5fbWFwLl9maXJlRE9NRXZlbnQoZSwgdHlwZSB8fCBlLnR5cGUsIGxheWVycyk7XG4gIFx0fSxcblxuICBcdF9icmluZ1RvRnJvbnQ6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dmFyIG9yZGVyID0gbGF5ZXIuX29yZGVyO1xuXG4gIFx0XHRpZiAoIW9yZGVyKSB7IHJldHVybjsgfVxuXG4gIFx0XHR2YXIgbmV4dCA9IG9yZGVyLm5leHQ7XG4gIFx0XHR2YXIgcHJldiA9IG9yZGVyLnByZXY7XG5cbiAgXHRcdGlmIChuZXh0KSB7XG4gIFx0XHRcdG5leHQucHJldiA9IHByZXY7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHQvLyBBbHJlYWR5IGxhc3RcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuICBcdFx0aWYgKHByZXYpIHtcbiAgXHRcdFx0cHJldi5uZXh0ID0gbmV4dDtcbiAgXHRcdH0gZWxzZSBpZiAobmV4dCkge1xuICBcdFx0XHQvLyBVcGRhdGUgZmlyc3QgZW50cnkgdW5sZXNzIHRoaXMgaXMgdGhlXG4gIFx0XHRcdC8vIHNpbmdsZSBlbnRyeVxuICBcdFx0XHR0aGlzLl9kcmF3Rmlyc3QgPSBuZXh0O1xuICBcdFx0fVxuXG4gIFx0XHRvcmRlci5wcmV2ID0gdGhpcy5fZHJhd0xhc3Q7XG4gIFx0XHR0aGlzLl9kcmF3TGFzdC5uZXh0ID0gb3JkZXI7XG5cbiAgXHRcdG9yZGVyLm5leHQgPSBudWxsO1xuICBcdFx0dGhpcy5fZHJhd0xhc3QgPSBvcmRlcjtcblxuICBcdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG4gIFx0fSxcblxuICBcdF9icmluZ1RvQmFjazogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR2YXIgb3JkZXIgPSBsYXllci5fb3JkZXI7XG5cbiAgXHRcdGlmICghb3JkZXIpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHZhciBuZXh0ID0gb3JkZXIubmV4dDtcbiAgXHRcdHZhciBwcmV2ID0gb3JkZXIucHJldjtcblxuICBcdFx0aWYgKHByZXYpIHtcbiAgXHRcdFx0cHJldi5uZXh0ID0gbmV4dDtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdC8vIEFscmVhZHkgZmlyc3RcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuICBcdFx0aWYgKG5leHQpIHtcbiAgXHRcdFx0bmV4dC5wcmV2ID0gcHJldjtcbiAgXHRcdH0gZWxzZSBpZiAocHJldikge1xuICBcdFx0XHQvLyBVcGRhdGUgbGFzdCBlbnRyeSB1bmxlc3MgdGhpcyBpcyB0aGVcbiAgXHRcdFx0Ly8gc2luZ2xlIGVudHJ5XG4gIFx0XHRcdHRoaXMuX2RyYXdMYXN0ID0gcHJldjtcbiAgXHRcdH1cblxuICBcdFx0b3JkZXIucHJldiA9IG51bGw7XG5cbiAgXHRcdG9yZGVyLm5leHQgPSB0aGlzLl9kcmF3Rmlyc3Q7XG4gIFx0XHR0aGlzLl9kcmF3Rmlyc3QucHJldiA9IG9yZGVyO1xuICBcdFx0dGhpcy5fZHJhd0ZpcnN0ID0gb3JkZXI7XG5cbiAgXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuICBcdH1cbiAgfSk7XG5cbiAgLy8gQGZhY3RvcnkgTC5jYW52YXMob3B0aW9ucz86IFJlbmRlcmVyIG9wdGlvbnMpXG4gIC8vIENyZWF0ZXMgYSBDYW52YXMgcmVuZGVyZXIgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbiAgZnVuY3Rpb24gY2FudmFzKG9wdGlvbnMpIHtcbiAgXHRyZXR1cm4gQnJvd3Nlci5jYW52YXMgPyBuZXcgQ2FudmFzKG9wdGlvbnMpIDogbnVsbDtcbiAgfVxuXG4gIC8qXG4gICAqIFRoYW5rcyB0byBEbWl0cnkgQmFyYW5vdnNreSBhbmQgaGlzIFJhcGhhZWwgbGlicmFyeSBmb3IgaW5zcGlyYXRpb24hXG4gICAqL1xuXG5cbiAgdmFyIHZtbENyZWF0ZSA9IChmdW5jdGlvbiAoKSB7XG4gIFx0dHJ5IHtcbiAgXHRcdGRvY3VtZW50Lm5hbWVzcGFjZXMuYWRkKCdsdm1sJywgJ3VybjpzY2hlbWFzLW1pY3Jvc29mdC1jb206dm1sJyk7XG4gIFx0XHRyZXR1cm4gZnVuY3Rpb24gKG5hbWUpIHtcbiAgXHRcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJzxsdm1sOicgKyBuYW1lICsgJyBjbGFzcz1cImx2bWxcIj4nKTtcbiAgXHRcdH07XG4gIFx0fSBjYXRjaCAoZSkge1xuICBcdFx0Ly8gRG8gbm90IHJldHVybiBmbiBmcm9tIGNhdGNoIGJsb2NrIHNvIGBlYCBjYW4gYmUgZ2FyYmFnZSBjb2xsZWN0ZWRcbiAgXHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L3B1bGwvNzI3OVxuICBcdH1cbiAgXHRyZXR1cm4gZnVuY3Rpb24gKG5hbWUpIHtcbiAgXHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCc8JyArIG5hbWUgKyAnIHhtbG5zPVwidXJuOnNjaGVtYXMtbWljcm9zb2Z0LmNvbTp2bWxcIiBjbGFzcz1cImx2bWxcIj4nKTtcbiAgXHR9O1xuICB9KSgpO1xuXG5cbiAgLypcbiAgICogQGNsYXNzIFNWR1xuICAgKlxuICAgKlxuICAgKiBWTUwgd2FzIGRlcHJlY2F0ZWQgaW4gMjAxMiwgd2hpY2ggbWVhbnMgVk1MIGZ1bmN0aW9uYWxpdHkgZXhpc3RzIG9ubHkgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAqIHdpdGggb2xkIHZlcnNpb25zIG9mIEludGVybmV0IEV4cGxvcmVyLlxuICAgKi9cblxuICAvLyBtaXhpbiB0byByZWRlZmluZSBzb21lIFNWRyBtZXRob2RzIHRvIGhhbmRsZSBWTUwgc3ludGF4IHdoaWNoIGlzIHNpbWlsYXIgYnV0IHdpdGggc29tZSBkaWZmZXJlbmNlc1xuICB2YXIgdm1sTWl4aW4gPSB7XG5cbiAgXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5fY29udGFpbmVyID0gY3JlYXRlJDEoJ2RpdicsICdsZWFmbGV0LXZtbC1jb250YWluZXInKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cbiAgXHRcdFJlbmRlcmVyLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyk7XG4gIFx0XHR0aGlzLmZpcmUoJ3VwZGF0ZScpO1xuICBcdH0sXG5cbiAgXHRfaW5pdFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dmFyIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXIgPSB2bWxDcmVhdGUoJ3NoYXBlJyk7XG5cbiAgXHRcdGFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdm1sLXNoYXBlICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykpO1xuXG4gIFx0XHRjb250YWluZXIuY29vcmRzaXplID0gJzEgMSc7XG5cbiAgXHRcdGxheWVyLl9wYXRoID0gdm1sQ3JlYXRlKCdwYXRoJyk7XG4gIFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQobGF5ZXIuX3BhdGgpO1xuXG4gIFx0XHR0aGlzLl91cGRhdGVTdHlsZShsYXllcik7XG4gIFx0XHR0aGlzLl9sYXllcnNbc3RhbXAobGF5ZXIpXSA9IGxheWVyO1xuICBcdH0sXG5cbiAgXHRfYWRkUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR2YXIgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lcjtcbiAgXHRcdHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuXG4gIFx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xuICBcdFx0XHRsYXllci5hZGRJbnRlcmFjdGl2ZVRhcmdldChjb250YWluZXIpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfcmVtb3ZlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR2YXIgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lcjtcbiAgXHRcdHJlbW92ZShjb250YWluZXIpO1xuICBcdFx0bGF5ZXIucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQoY29udGFpbmVyKTtcbiAgXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbc3RhbXAobGF5ZXIpXTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHZhciBzdHJva2UgPSBsYXllci5fc3Ryb2tlLFxuICBcdFx0ICAgIGZpbGwgPSBsYXllci5fZmlsbCxcbiAgXHRcdCAgICBvcHRpb25zID0gbGF5ZXIub3B0aW9ucyxcbiAgXHRcdCAgICBjb250YWluZXIgPSBsYXllci5fY29udGFpbmVyO1xuXG4gIFx0XHRjb250YWluZXIuc3Ryb2tlZCA9ICEhb3B0aW9ucy5zdHJva2U7XG4gIFx0XHRjb250YWluZXIuZmlsbGVkID0gISFvcHRpb25zLmZpbGw7XG5cbiAgXHRcdGlmIChvcHRpb25zLnN0cm9rZSkge1xuICBcdFx0XHRpZiAoIXN0cm9rZSkge1xuICBcdFx0XHRcdHN0cm9rZSA9IGxheWVyLl9zdHJva2UgPSB2bWxDcmVhdGUoJ3N0cm9rZScpO1xuICBcdFx0XHR9XG4gIFx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChzdHJva2UpO1xuICBcdFx0XHRzdHJva2Uud2VpZ2h0ID0gb3B0aW9ucy53ZWlnaHQgKyAncHgnO1xuICBcdFx0XHRzdHJva2UuY29sb3IgPSBvcHRpb25zLmNvbG9yO1xuICBcdFx0XHRzdHJva2Uub3BhY2l0eSA9IG9wdGlvbnMub3BhY2l0eTtcblxuICBcdFx0XHRpZiAob3B0aW9ucy5kYXNoQXJyYXkpIHtcbiAgXHRcdFx0XHRzdHJva2UuZGFzaFN0eWxlID0gaXNBcnJheShvcHRpb25zLmRhc2hBcnJheSkgP1xuICBcdFx0XHRcdCAgICBvcHRpb25zLmRhc2hBcnJheS5qb2luKCcgJykgOlxuICBcdFx0XHRcdCAgICBvcHRpb25zLmRhc2hBcnJheS5yZXBsYWNlKC8oICosICopL2csICcgJyk7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0c3Ryb2tlLmRhc2hTdHlsZSA9ICcnO1xuICBcdFx0XHR9XG4gIFx0XHRcdHN0cm9rZS5lbmRjYXAgPSBvcHRpb25zLmxpbmVDYXAucmVwbGFjZSgnYnV0dCcsICdmbGF0Jyk7XG4gIFx0XHRcdHN0cm9rZS5qb2luc3R5bGUgPSBvcHRpb25zLmxpbmVKb2luO1xuXG4gIFx0XHR9IGVsc2UgaWYgKHN0cm9rZSkge1xuICBcdFx0XHRjb250YWluZXIucmVtb3ZlQ2hpbGQoc3Ryb2tlKTtcbiAgXHRcdFx0bGF5ZXIuX3N0cm9rZSA9IG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChvcHRpb25zLmZpbGwpIHtcbiAgXHRcdFx0aWYgKCFmaWxsKSB7XG4gIFx0XHRcdFx0ZmlsbCA9IGxheWVyLl9maWxsID0gdm1sQ3JlYXRlKCdmaWxsJyk7XG4gIFx0XHRcdH1cbiAgXHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGZpbGwpO1xuICBcdFx0XHRmaWxsLmNvbG9yID0gb3B0aW9ucy5maWxsQ29sb3IgfHwgb3B0aW9ucy5jb2xvcjtcbiAgXHRcdFx0ZmlsbC5vcGFjaXR5ID0gb3B0aW9ucy5maWxsT3BhY2l0eTtcblxuICBcdFx0fSBlbHNlIGlmIChmaWxsKSB7XG4gIFx0XHRcdGNvbnRhaW5lci5yZW1vdmVDaGlsZChmaWxsKTtcbiAgXHRcdFx0bGF5ZXIuX2ZpbGwgPSBudWxsO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfdXBkYXRlQ2lyY2xlOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHZhciBwID0gbGF5ZXIuX3BvaW50LnJvdW5kKCksXG4gIFx0XHQgICAgciA9IE1hdGgucm91bmQobGF5ZXIuX3JhZGl1cyksXG4gIFx0XHQgICAgcjIgPSBNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXNZIHx8IHIpO1xuXG4gIFx0XHR0aGlzLl9zZXRQYXRoKGxheWVyLCBsYXllci5fZW1wdHkoKSA/ICdNMCAwJyA6XG4gIFx0XHRcdCdBTCAnICsgcC54ICsgJywnICsgcC55ICsgJyAnICsgciArICcsJyArIHIyICsgJyAwLCcgKyAoNjU1MzUgKiAzNjApKTtcbiAgXHR9LFxuXG4gIFx0X3NldFBhdGg6IGZ1bmN0aW9uIChsYXllciwgcGF0aCkge1xuICBcdFx0bGF5ZXIuX3BhdGgudiA9IHBhdGg7XG4gIFx0fSxcblxuICBcdF9icmluZ1RvRnJvbnQ6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dG9Gcm9udChsYXllci5fY29udGFpbmVyKTtcbiAgXHR9LFxuXG4gIFx0X2JyaW5nVG9CYWNrOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHRvQmFjayhsYXllci5fY29udGFpbmVyKTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIGNyZWF0ZSA9IEJyb3dzZXIudm1sID8gdm1sQ3JlYXRlIDogc3ZnQ3JlYXRlO1xuXG4gIC8qXG4gICAqIEBjbGFzcyBTVkdcbiAgICogQGluaGVyaXRzIFJlbmRlcmVyXG4gICAqIEBha2EgTC5TVkdcbiAgICpcbiAgICogQWxsb3dzIHZlY3RvciBsYXllcnMgdG8gYmUgZGlzcGxheWVkIHdpdGggW1NWR10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHKS5cbiAgICogSW5oZXJpdHMgYFJlbmRlcmVyYC5cbiAgICpcbiAgICogRHVlIHRvIFt0ZWNobmljYWwgbGltaXRhdGlvbnNdKGh0dHBzOi8vY2FuaXVzZS5jb20vc3ZnKSwgU1ZHIGlzIG5vdFxuICAgKiBhdmFpbGFibGUgaW4gYWxsIHdlYiBicm93c2Vycywgbm90YWJseSBBbmRyb2lkIDIueCBhbmQgMy54LlxuICAgKlxuICAgKiBBbHRob3VnaCBTVkcgaXMgbm90IGF2YWlsYWJsZSBvbiBJRTcgYW5kIElFOCwgdGhlc2UgYnJvd3NlcnMgc3VwcG9ydFxuICAgKiBbVk1MXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WZWN0b3JfTWFya3VwX0xhbmd1YWdlKVxuICAgKiAoYSBub3cgZGVwcmVjYXRlZCB0ZWNobm9sb2d5KSwgYW5kIHRoZSBTVkcgcmVuZGVyZXIgd2lsbCBmYWxsIGJhY2sgdG8gVk1MIGluXG4gICAqIHRoaXMgY2FzZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogVXNlIFNWRyBieSBkZWZhdWx0IGZvciBhbGwgcGF0aHMgaW4gdGhlIG1hcDpcbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIG1hcCA9IEwubWFwKCdtYXAnLCB7XG4gICAqIFx0cmVuZGVyZXI6IEwuc3ZnKClcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBVc2UgYSBTVkcgcmVuZGVyZXIgd2l0aCBleHRyYSBwYWRkaW5nIGZvciBzcGVjaWZpYyB2ZWN0b3IgZ2VvbWV0cmllczpcbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIG1hcCA9IEwubWFwKCdtYXAnKTtcbiAgICogdmFyIG15UmVuZGVyZXIgPSBMLnN2Zyh7IHBhZGRpbmc6IDAuNSB9KTtcbiAgICogdmFyIGxpbmUgPSBMLnBvbHlsaW5lKCBjb29yZGluYXRlcywgeyByZW5kZXJlcjogbXlSZW5kZXJlciB9ICk7XG4gICAqIHZhciBjaXJjbGUgPSBMLmNpcmNsZSggY2VudGVyLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAgICogYGBgXG4gICAqL1xuXG4gIHZhciBTVkcgPSBSZW5kZXJlci5leHRlbmQoe1xuXG4gIFx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX2NvbnRhaW5lciA9IGNyZWF0ZSgnc3ZnJyk7XG5cbiAgXHRcdC8vIG1ha2VzIGl0IHBvc3NpYmxlIHRvIGNsaWNrIHRocm91Z2ggc3ZnIHJvb3Q7IHdlJ2xsIHJlc2V0IGl0IGJhY2sgaW4gaW5kaXZpZHVhbCBwYXRoc1xuICBcdFx0dGhpcy5fY29udGFpbmVyLnNldEF0dHJpYnV0ZSgncG9pbnRlci1ldmVudHMnLCAnbm9uZScpO1xuXG4gIFx0XHR0aGlzLl9yb290R3JvdXAgPSBjcmVhdGUoJ2cnKTtcbiAgXHRcdHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9yb290R3JvdXApO1xuICBcdH0sXG5cbiAgXHRfZGVzdHJveUNvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuICBcdFx0cmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XG4gIFx0XHRvZmYodGhpcy5fY29udGFpbmVyKTtcbiAgXHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXI7XG4gIFx0XHRkZWxldGUgdGhpcy5fcm9vdEdyb3VwO1xuICBcdFx0ZGVsZXRlIHRoaXMuX3N2Z1NpemU7XG4gIFx0fSxcblxuICBcdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20gJiYgdGhpcy5fYm91bmRzKSB7IHJldHVybjsgfVxuXG4gIFx0XHRSZW5kZXJlci5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuXG4gIFx0XHR2YXIgYiA9IHRoaXMuX2JvdW5kcyxcbiAgXHRcdCAgICBzaXplID0gYi5nZXRTaXplKCksXG4gIFx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xuXG4gIFx0XHQvLyBzZXQgc2l6ZSBvZiBzdmctY29udGFpbmVyIGlmIGNoYW5nZWRcbiAgXHRcdGlmICghdGhpcy5fc3ZnU2l6ZSB8fCAhdGhpcy5fc3ZnU2l6ZS5lcXVhbHMoc2l6ZSkpIHtcbiAgXHRcdFx0dGhpcy5fc3ZnU2l6ZSA9IHNpemU7XG4gIFx0XHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgc2l6ZS54KTtcbiAgXHRcdFx0Y29udGFpbmVyLnNldEF0dHJpYnV0ZSgnaGVpZ2h0Jywgc2l6ZS55KTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gbW92ZW1lbnQ6IHVwZGF0ZSBjb250YWluZXIgdmlld0JveCBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gY2hhbmdlIGNvb3JkaW5hdGVzIG9mIGluZGl2aWR1YWwgbGF5ZXJzXG4gIFx0XHRzZXRQb3NpdGlvbihjb250YWluZXIsIGIubWluKTtcbiAgXHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCBbYi5taW4ueCwgYi5taW4ueSwgc2l6ZS54LCBzaXplLnldLmpvaW4oJyAnKSk7XG5cbiAgXHRcdHRoaXMuZmlyZSgndXBkYXRlJyk7XG4gIFx0fSxcblxuICBcdC8vIG1ldGhvZHMgYmVsb3cgYXJlIGNhbGxlZCBieSB2ZWN0b3IgbGF5ZXJzIGltcGxlbWVudGF0aW9uc1xuXG4gIFx0X2luaXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHZhciBwYXRoID0gbGF5ZXIuX3BhdGggPSBjcmVhdGUoJ3BhdGgnKTtcblxuICBcdFx0Ly8gQG5hbWVzcGFjZSBQYXRoXG4gIFx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gbnVsbFxuICBcdFx0Ly8gQ3VzdG9tIGNsYXNzIG5hbWUgc2V0IG9uIGFuIGVsZW1lbnQuIE9ubHkgZm9yIFNWRyByZW5kZXJlci5cbiAgXHRcdGlmIChsYXllci5vcHRpb25zLmNsYXNzTmFtZSkge1xuICBcdFx0XHRhZGRDbGFzcyhwYXRoLCBsYXllci5vcHRpb25zLmNsYXNzTmFtZSk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChsYXllci5vcHRpb25zLmludGVyYWN0aXZlKSB7XG4gIFx0XHRcdGFkZENsYXNzKHBhdGgsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX3VwZGF0ZVN0eWxlKGxheWVyKTtcbiAgXHRcdHRoaXMuX2xheWVyc1tzdGFtcChsYXllcildID0gbGF5ZXI7XG4gIFx0fSxcblxuICBcdF9hZGRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdGlmICghdGhpcy5fcm9vdEdyb3VwKSB7IHRoaXMuX2luaXRDb250YWluZXIoKTsgfVxuICBcdFx0dGhpcy5fcm9vdEdyb3VwLmFwcGVuZENoaWxkKGxheWVyLl9wYXRoKTtcbiAgXHRcdGxheWVyLmFkZEludGVyYWN0aXZlVGFyZ2V0KGxheWVyLl9wYXRoKTtcbiAgXHR9LFxuXG4gIFx0X3JlbW92ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0cmVtb3ZlKGxheWVyLl9wYXRoKTtcbiAgXHRcdGxheWVyLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KGxheWVyLl9wYXRoKTtcbiAgXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbc3RhbXAobGF5ZXIpXTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0bGF5ZXIuX3Byb2plY3QoKTtcbiAgXHRcdGxheWVyLl91cGRhdGUoKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHZhciBwYXRoID0gbGF5ZXIuX3BhdGgsXG4gIFx0XHQgICAgb3B0aW9ucyA9IGxheWVyLm9wdGlvbnM7XG5cbiAgXHRcdGlmICghcGF0aCkgeyByZXR1cm47IH1cblxuICBcdFx0aWYgKG9wdGlvbnMuc3Ryb2tlKSB7XG4gIFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UnLCBvcHRpb25zLmNvbG9yKTtcbiAgXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1vcGFjaXR5Jywgb3B0aW9ucy5vcGFjaXR5KTtcbiAgXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsIG9wdGlvbnMud2VpZ2h0KTtcbiAgXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lY2FwJywgb3B0aW9ucy5saW5lQ2FwKTtcbiAgXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lam9pbicsIG9wdGlvbnMubGluZUpvaW4pO1xuXG4gIFx0XHRcdGlmIChvcHRpb25zLmRhc2hBcnJheSkge1xuICBcdFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaGFycmF5Jywgb3B0aW9ucy5kYXNoQXJyYXkpO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdHBhdGgucmVtb3ZlQXR0cmlidXRlKCdzdHJva2UtZGFzaGFycmF5Jyk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAob3B0aW9ucy5kYXNoT2Zmc2V0KSB7XG4gIFx0XHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNob2Zmc2V0Jywgb3B0aW9ucy5kYXNoT2Zmc2V0KTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRwYXRoLnJlbW92ZUF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hvZmZzZXQnKTtcbiAgXHRcdFx0fVxuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsICdub25lJyk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChvcHRpb25zLmZpbGwpIHtcbiAgXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCBvcHRpb25zLmZpbGxDb2xvciB8fCBvcHRpb25zLmNvbG9yKTtcbiAgXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwtb3BhY2l0eScsIG9wdGlvbnMuZmlsbE9wYWNpdHkpO1xuICBcdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbC1ydWxlJywgb3B0aW9ucy5maWxsUnVsZSB8fCAnZXZlbm9kZCcpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCAnbm9uZScpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfdXBkYXRlUG9seTogZnVuY3Rpb24gKGxheWVyLCBjbG9zZWQpIHtcbiAgXHRcdHRoaXMuX3NldFBhdGgobGF5ZXIsIHBvaW50c1RvUGF0aChsYXllci5fcGFydHMsIGNsb3NlZCkpO1xuICBcdH0sXG5cbiAgXHRfdXBkYXRlQ2lyY2xlOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHZhciBwID0gbGF5ZXIuX3BvaW50LFxuICBcdFx0ICAgIHIgPSBNYXRoLm1heChNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXMpLCAxKSxcbiAgXHRcdCAgICByMiA9IE1hdGgubWF4KE1hdGgucm91bmQobGF5ZXIuX3JhZGl1c1kpLCAxKSB8fCByLFxuICBcdFx0ICAgIGFyYyA9ICdhJyArIHIgKyAnLCcgKyByMiArICcgMCAxLDAgJztcblxuICBcdFx0Ly8gZHJhd2luZyBhIGNpcmNsZSB3aXRoIHR3byBoYWxmLWFyY3NcbiAgXHRcdHZhciBkID0gbGF5ZXIuX2VtcHR5KCkgPyAnTTAgMCcgOlxuICBcdFx0XHQnTScgKyAocC54IC0gcikgKyAnLCcgKyBwLnkgK1xuICBcdFx0XHRhcmMgKyAociAqIDIpICsgJywwICcgK1xuICBcdFx0XHRhcmMgKyAoLXIgKiAyKSArICcsMCAnO1xuXG4gIFx0XHR0aGlzLl9zZXRQYXRoKGxheWVyLCBkKTtcbiAgXHR9LFxuXG4gIFx0X3NldFBhdGg6IGZ1bmN0aW9uIChsYXllciwgcGF0aCkge1xuICBcdFx0bGF5ZXIuX3BhdGguc2V0QXR0cmlidXRlKCdkJywgcGF0aCk7XG4gIFx0fSxcblxuICBcdC8vIFNWRyBkb2VzIG5vdCBoYXZlIHRoZSBjb25jZXB0IG9mIHpJbmRleCBzbyB3ZSByZXNvcnQgdG8gY2hhbmdpbmcgdGhlIERPTSBvcmRlciBvZiBlbGVtZW50c1xuICBcdF9icmluZ1RvRnJvbnQ6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dG9Gcm9udChsYXllci5fcGF0aCk7XG4gIFx0fSxcblxuICBcdF9icmluZ1RvQmFjazogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR0b0JhY2sobGF5ZXIuX3BhdGgpO1xuICBcdH1cbiAgfSk7XG5cbiAgaWYgKEJyb3dzZXIudm1sKSB7XG4gIFx0U1ZHLmluY2x1ZGUodm1sTWl4aW4pO1xuICB9XG5cbiAgLy8gQG5hbWVzcGFjZSBTVkdcbiAgLy8gQGZhY3RvcnkgTC5zdmcob3B0aW9ucz86IFJlbmRlcmVyIG9wdGlvbnMpXG4gIC8vIENyZWF0ZXMgYSBTVkcgcmVuZGVyZXIgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbiAgZnVuY3Rpb24gc3ZnKG9wdGlvbnMpIHtcbiAgXHRyZXR1cm4gQnJvd3Nlci5zdmcgfHwgQnJvd3Nlci52bWwgPyBuZXcgU1ZHKG9wdGlvbnMpIDogbnVsbDtcbiAgfVxuXG4gIE1hcC5pbmNsdWRlKHtcbiAgXHQvLyBAbmFtZXNwYWNlIE1hcDsgQG1ldGhvZCBnZXRSZW5kZXJlcihsYXllcjogUGF0aCk6IFJlbmRlcmVyXG4gIFx0Ly8gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgYFJlbmRlcmVyYCB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHJlbmRlciB0aGUgZ2l2ZW5cbiAgXHQvLyBgUGF0aGAuIEl0IHdpbGwgZW5zdXJlIHRoYXQgdGhlIGByZW5kZXJlcmAgb3B0aW9ucyBvZiB0aGUgbWFwIGFuZCBwYXRoc1xuICBcdC8vIGFyZSByZXNwZWN0ZWQsIGFuZCB0aGF0IHRoZSByZW5kZXJlcnMgZG8gZXhpc3Qgb24gdGhlIG1hcC5cbiAgXHRnZXRSZW5kZXJlcjogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHQvLyBAbmFtZXNwYWNlIFBhdGg7IEBvcHRpb24gcmVuZGVyZXI6IFJlbmRlcmVyXG4gIFx0XHQvLyBVc2UgdGhpcyBzcGVjaWZpYyBpbnN0YW5jZSBvZiBgUmVuZGVyZXJgIGZvciB0aGlzIHBhdGguIFRha2VzXG4gIFx0XHQvLyBwcmVjZWRlbmNlIG92ZXIgdGhlIG1hcCdzIFtkZWZhdWx0IHJlbmRlcmVyXSgjbWFwLXJlbmRlcmVyKS5cbiAgXHRcdHZhciByZW5kZXJlciA9IGxheWVyLm9wdGlvbnMucmVuZGVyZXIgfHwgdGhpcy5fZ2V0UGFuZVJlbmRlcmVyKGxheWVyLm9wdGlvbnMucGFuZSkgfHwgdGhpcy5vcHRpb25zLnJlbmRlcmVyIHx8IHRoaXMuX3JlbmRlcmVyO1xuXG4gIFx0XHRpZiAoIXJlbmRlcmVyKSB7XG4gIFx0XHRcdHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXIgPSB0aGlzLl9jcmVhdGVSZW5kZXJlcigpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIXRoaXMuaGFzTGF5ZXIocmVuZGVyZXIpKSB7XG4gIFx0XHRcdHRoaXMuYWRkTGF5ZXIocmVuZGVyZXIpO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHJlbmRlcmVyO1xuICBcdH0sXG5cbiAgXHRfZ2V0UGFuZVJlbmRlcmVyOiBmdW5jdGlvbiAobmFtZSkge1xuICBcdFx0aWYgKG5hbWUgPT09ICdvdmVybGF5UGFuZScgfHwgbmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdHJldHVybiBmYWxzZTtcbiAgXHRcdH1cblxuICBcdFx0dmFyIHJlbmRlcmVyID0gdGhpcy5fcGFuZVJlbmRlcmVyc1tuYW1lXTtcbiAgXHRcdGlmIChyZW5kZXJlciA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdHJlbmRlcmVyID0gdGhpcy5fY3JlYXRlUmVuZGVyZXIoe3BhbmU6IG5hbWV9KTtcbiAgXHRcdFx0dGhpcy5fcGFuZVJlbmRlcmVyc1tuYW1lXSA9IHJlbmRlcmVyO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHJlbmRlcmVyO1xuICBcdH0sXG5cbiAgXHRfY3JlYXRlUmVuZGVyZXI6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0XHQvLyBAbmFtZXNwYWNlIE1hcDsgQG9wdGlvbiBwcmVmZXJDYW52YXM6IEJvb2xlYW4gPSBmYWxzZVxuICBcdFx0Ly8gV2hldGhlciBgUGF0aGBzIHNob3VsZCBiZSByZW5kZXJlZCBvbiBhIGBDYW52YXNgIHJlbmRlcmVyLlxuICBcdFx0Ly8gQnkgZGVmYXVsdCwgYWxsIGBQYXRoYHMgYXJlIHJlbmRlcmVkIGluIGEgYFNWR2AgcmVuZGVyZXIuXG4gIFx0XHRyZXR1cm4gKHRoaXMub3B0aW9ucy5wcmVmZXJDYW52YXMgJiYgY2FudmFzKG9wdGlvbnMpKSB8fCBzdmcob3B0aW9ucyk7XG4gIFx0fVxuICB9KTtcblxuICAvKlxuICAgKiBMLlJlY3RhbmdsZSBleHRlbmRzIFBvbHlnb24gYW5kIGNyZWF0ZXMgYSByZWN0YW5nbGUgd2hlbiBwYXNzZWQgYSBMYXRMbmdCb3VuZHMgb2JqZWN0LlxuICAgKi9cblxuICAvKlxuICAgKiBAY2xhc3MgUmVjdGFuZ2xlXG4gICAqIEBha2EgTC5SZWN0YW5nbGVcbiAgICogQGluaGVyaXRzIFBvbHlnb25cbiAgICpcbiAgICogQSBjbGFzcyBmb3IgZHJhd2luZyByZWN0YW5nbGUgb3ZlcmxheXMgb24gYSBtYXAuIEV4dGVuZHMgYFBvbHlnb25gLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGBqc1xuICAgKiAvLyBkZWZpbmUgcmVjdGFuZ2xlIGdlb2dyYXBoaWNhbCBib3VuZHNcbiAgICogdmFyIGJvdW5kcyA9IFtbNTQuNTU5MzIyLCAtNS43Njc4MjJdLCBbNTYuMTIxMDYwNCwgLTMuMDIxMjQwXV07XG4gICAqXG4gICAqIC8vIGNyZWF0ZSBhbiBvcmFuZ2UgcmVjdGFuZ2xlXG4gICAqIEwucmVjdGFuZ2xlKGJvdW5kcywge2NvbG9yOiBcIiNmZjc4MDBcIiwgd2VpZ2h0OiAxfSkuYWRkVG8obWFwKTtcbiAgICpcbiAgICogLy8gem9vbSB0aGUgbWFwIHRvIHRoZSByZWN0YW5nbGUgYm91bmRzXG4gICAqIG1hcC5maXRCb3VuZHMoYm91bmRzKTtcbiAgICogYGBgXG4gICAqXG4gICAqL1xuXG5cbiAgdmFyIFJlY3RhbmdsZSA9IFBvbHlnb24uZXh0ZW5kKHtcbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzLCBvcHRpb25zKSB7XG4gIFx0XHRQb2x5Z29uLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgdGhpcy5fYm91bmRzVG9MYXRMbmdzKGxhdExuZ0JvdW5kcyksIG9wdGlvbnMpO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHNldEJvdW5kcyhsYXRMbmdCb3VuZHM6IExhdExuZ0JvdW5kcyk6IHRoaXNcbiAgXHQvLyBSZWRyYXdzIHRoZSByZWN0YW5nbGUgd2l0aCB0aGUgcGFzc2VkIGJvdW5kcy5cbiAgXHRzZXRCb3VuZHM6IGZ1bmN0aW9uIChsYXRMbmdCb3VuZHMpIHtcbiAgXHRcdHJldHVybiB0aGlzLnNldExhdExuZ3ModGhpcy5fYm91bmRzVG9MYXRMbmdzKGxhdExuZ0JvdW5kcykpO1xuICBcdH0sXG5cbiAgXHRfYm91bmRzVG9MYXRMbmdzOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzKSB7XG4gIFx0XHRsYXRMbmdCb3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhsYXRMbmdCb3VuZHMpO1xuICBcdFx0cmV0dXJuIFtcbiAgXHRcdFx0bGF0TG5nQm91bmRzLmdldFNvdXRoV2VzdCgpLFxuICBcdFx0XHRsYXRMbmdCb3VuZHMuZ2V0Tm9ydGhXZXN0KCksXG4gIFx0XHRcdGxhdExuZ0JvdW5kcy5nZXROb3J0aEVhc3QoKSxcbiAgXHRcdFx0bGF0TG5nQm91bmRzLmdldFNvdXRoRWFzdCgpXG4gIFx0XHRdO1xuICBcdH1cbiAgfSk7XG5cblxuICAvLyBAZmFjdG9yeSBMLnJlY3RhbmdsZShsYXRMbmdCb3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IFBvbHlsaW5lIG9wdGlvbnMpXG4gIGZ1bmN0aW9uIHJlY3RhbmdsZShsYXRMbmdCb3VuZHMsIG9wdGlvbnMpIHtcbiAgXHRyZXR1cm4gbmV3IFJlY3RhbmdsZShsYXRMbmdCb3VuZHMsIG9wdGlvbnMpO1xuICB9XG5cbiAgU1ZHLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgU1ZHLnBvaW50c1RvUGF0aCA9IHBvaW50c1RvUGF0aDtcblxuICBHZW9KU09OLmdlb21ldHJ5VG9MYXllciA9IGdlb21ldHJ5VG9MYXllcjtcbiAgR2VvSlNPTi5jb29yZHNUb0xhdExuZyA9IGNvb3Jkc1RvTGF0TG5nO1xuICBHZW9KU09OLmNvb3Jkc1RvTGF0TG5ncyA9IGNvb3Jkc1RvTGF0TG5ncztcbiAgR2VvSlNPTi5sYXRMbmdUb0Nvb3JkcyA9IGxhdExuZ1RvQ29vcmRzO1xuICBHZW9KU09OLmxhdExuZ3NUb0Nvb3JkcyA9IGxhdExuZ3NUb0Nvb3JkcztcbiAgR2VvSlNPTi5nZXRGZWF0dXJlID0gZ2V0RmVhdHVyZTtcbiAgR2VvSlNPTi5hc0ZlYXR1cmUgPSBhc0ZlYXR1cmU7XG5cbiAgLypcbiAgICogTC5IYW5kbGVyLkJveFpvb20gaXMgdXNlZCB0byBhZGQgc2hpZnQtZHJhZyB6b29tIGludGVyYWN0aW9uIHRvIHRoZSBtYXBcbiAgICogKHpvb20gdG8gYSBzZWxlY3RlZCBib3VuZGluZyBib3gpLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gICAqL1xuXG4gIC8vIEBuYW1lc3BhY2UgTWFwXG4gIC8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbiAgTWFwLm1lcmdlT3B0aW9ucyh7XG4gIFx0Ly8gQG9wdGlvbiBib3hab29tOiBCb29sZWFuID0gdHJ1ZVxuICBcdC8vIFdoZXRoZXIgdGhlIG1hcCBjYW4gYmUgem9vbWVkIHRvIGEgcmVjdGFuZ3VsYXIgYXJlYSBzcGVjaWZpZWQgYnlcbiAgXHQvLyBkcmFnZ2luZyB0aGUgbW91c2Ugd2hpbGUgcHJlc3NpbmcgdGhlIHNoaWZ0IGtleS5cbiAgXHRib3hab29tOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBCb3hab29tID0gSGFuZGxlci5leHRlbmQoe1xuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXApIHtcbiAgXHRcdHRoaXMuX21hcCA9IG1hcDtcbiAgXHRcdHRoaXMuX2NvbnRhaW5lciA9IG1hcC5fY29udGFpbmVyO1xuICBcdFx0dGhpcy5fcGFuZSA9IG1hcC5fcGFuZXMub3ZlcmxheVBhbmU7XG4gIFx0XHR0aGlzLl9yZXNldFN0YXRlVGltZW91dCA9IDA7XG4gIFx0XHRtYXAub24oJ3VubG9hZCcsIHRoaXMuX2Rlc3Ryb3ksIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0b24odGhpcy5fY29udGFpbmVyLCAnbW91c2Vkb3duJywgdGhpcy5fb25Nb3VzZURvd24sIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0b2ZmKHRoaXMuX2NvbnRhaW5lciwgJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0bW92ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLl9tb3ZlZDtcbiAgXHR9LFxuXG4gIFx0X2Rlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJlbW92ZSh0aGlzLl9wYW5lKTtcbiAgXHRcdGRlbGV0ZSB0aGlzLl9wYW5lO1xuICBcdH0sXG5cbiAgXHRfcmVzZXRTdGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQgPSAwO1xuICBcdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcbiAgXHR9LFxuXG4gIFx0X2NsZWFyRGVmZXJyZWRSZXNldFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQgIT09IDApIHtcbiAgXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0KTtcbiAgXHRcdFx0dGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQgPSAwO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfb25Nb3VzZURvd246IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHRpZiAoIWUuc2hpZnRLZXkgfHwgKChlLndoaWNoICE9PSAxKSAmJiAoZS5idXR0b24gIT09IDEpKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBcdFx0Ly8gQ2xlYXIgdGhlIGRlZmVycmVkIHJlc2V0U3RhdGUgaWYgaXQgaGFzbid0IGV4ZWN1dGVkIHlldCwgb3RoZXJ3aXNlIGl0XG4gIFx0XHQvLyB3aWxsIGludGVycnVwdCB0aGUgaW50ZXJhY3Rpb24gYW5kIG9ycGhhbiBhIGJveCBlbGVtZW50IGluIHRoZSBjb250YWluZXIuXG4gIFx0XHR0aGlzLl9jbGVhckRlZmVycmVkUmVzZXRTdGF0ZSgpO1xuICBcdFx0dGhpcy5fcmVzZXRTdGF0ZSgpO1xuXG4gIFx0XHRkaXNhYmxlVGV4dFNlbGVjdGlvbigpO1xuICBcdFx0ZGlzYWJsZUltYWdlRHJhZygpO1xuXG4gIFx0XHR0aGlzLl9zdGFydFBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xuXG4gIFx0XHRvbihkb2N1bWVudCwge1xuICBcdFx0XHRjb250ZXh0bWVudTogc3RvcCxcbiAgXHRcdFx0bW91c2Vtb3ZlOiB0aGlzLl9vbk1vdXNlTW92ZSxcbiAgXHRcdFx0bW91c2V1cDogdGhpcy5fb25Nb3VzZVVwLFxuICBcdFx0XHRrZXlkb3duOiB0aGlzLl9vbktleURvd25cbiAgXHRcdH0sIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRfb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHRpZiAoIXRoaXMuX21vdmVkKSB7XG4gIFx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcblxuICBcdFx0XHR0aGlzLl9ib3ggPSBjcmVhdGUkMSgnZGl2JywgJ2xlYWZsZXQtem9vbS1ib3gnLCB0aGlzLl9jb250YWluZXIpO1xuICBcdFx0XHRhZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNyb3NzaGFpcicpO1xuXG4gIFx0XHRcdHRoaXMuX21hcC5maXJlKCdib3h6b29tc3RhcnQnKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fcG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XG5cbiAgXHRcdHZhciBib3VuZHMgPSBuZXcgQm91bmRzKHRoaXMuX3BvaW50LCB0aGlzLl9zdGFydFBvaW50KSxcbiAgXHRcdCAgICBzaXplID0gYm91bmRzLmdldFNpemUoKTtcblxuICBcdFx0c2V0UG9zaXRpb24odGhpcy5fYm94LCBib3VuZHMubWluKTtcblxuICBcdFx0dGhpcy5fYm94LnN0eWxlLndpZHRoICA9IHNpemUueCArICdweCc7XG4gIFx0XHR0aGlzLl9ib3guc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4JztcbiAgXHR9LFxuXG4gIFx0X2ZpbmlzaDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX21vdmVkKSB7XG4gIFx0XHRcdHJlbW92ZSh0aGlzLl9ib3gpO1xuICBcdFx0XHRyZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNyb3NzaGFpcicpO1xuICBcdFx0fVxuXG4gIFx0XHRlbmFibGVUZXh0U2VsZWN0aW9uKCk7XG4gIFx0XHRlbmFibGVJbWFnZURyYWcoKTtcblxuICBcdFx0b2ZmKGRvY3VtZW50LCB7XG4gIFx0XHRcdGNvbnRleHRtZW51OiBzdG9wLFxuICBcdFx0XHRtb3VzZW1vdmU6IHRoaXMuX29uTW91c2VNb3ZlLFxuICBcdFx0XHRtb3VzZXVwOiB0aGlzLl9vbk1vdXNlVXAsXG4gIFx0XHRcdGtleWRvd246IHRoaXMuX29uS2V5RG93blxuICBcdFx0fSwgdGhpcyk7XG4gIFx0fSxcblxuICBcdF9vbk1vdXNlVXA6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHRpZiAoKGUud2hpY2ggIT09IDEpICYmIChlLmJ1dHRvbiAhPT0gMSkpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHRoaXMuX2ZpbmlzaCgpO1xuXG4gIFx0XHRpZiAoIXRoaXMuX21vdmVkKSB7IHJldHVybjsgfVxuICBcdFx0Ly8gUG9zdHBvbmUgdG8gbmV4dCBKUyB0aWNrIHNvIGludGVybmFsIGNsaWNrIGV2ZW50IGhhbmRsaW5nXG4gIFx0XHQvLyBzdGlsbCBzZWUgaXQgYXMgXCJtb3ZlZFwiLlxuICBcdFx0dGhpcy5fY2xlYXJEZWZlcnJlZFJlc2V0U3RhdGUoKTtcbiAgXHRcdHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ID0gc2V0VGltZW91dChiaW5kKHRoaXMuX3Jlc2V0U3RhdGUsIHRoaXMpLCAwKTtcblxuICBcdFx0dmFyIGJvdW5kcyA9IG5ldyBMYXRMbmdCb3VuZHMoXG4gIFx0XHQgICAgICAgIHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHRoaXMuX3N0YXJ0UG9pbnQpLFxuICBcdFx0ICAgICAgICB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyh0aGlzLl9wb2ludCkpO1xuXG4gIFx0XHR0aGlzLl9tYXBcbiAgXHRcdFx0LmZpdEJvdW5kcyhib3VuZHMpXG4gIFx0XHRcdC5maXJlKCdib3h6b29tZW5kJywge2JveFpvb21Cb3VuZHM6IGJvdW5kc30pO1xuICBcdH0sXG5cbiAgXHRfb25LZXlEb3duOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0aWYgKGUua2V5Q29kZSA9PT0gMjcpIHtcbiAgXHRcdFx0dGhpcy5fZmluaXNoKCk7XG4gIFx0XHRcdHRoaXMuX2NsZWFyRGVmZXJyZWRSZXNldFN0YXRlKCk7XG4gIFx0XHRcdHRoaXMuX3Jlc2V0U3RhdGUoKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH0pO1xuXG4gIC8vIEBzZWN0aW9uIEhhbmRsZXJzXG4gIC8vIEBwcm9wZXJ0eSBib3hab29tOiBIYW5kbGVyXG4gIC8vIEJveCAoc2hpZnQtZHJhZyB3aXRoIG1vdXNlKSB6b29tIGhhbmRsZXIuXG4gIE1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdib3hab29tJywgQm94Wm9vbSk7XG5cbiAgLypcbiAgICogTC5IYW5kbGVyLkRvdWJsZUNsaWNrWm9vbSBpcyB1c2VkIHRvIGhhbmRsZSBkb3VibGUtY2xpY2sgem9vbSBvbiB0aGUgbWFwLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gICAqL1xuXG4gIC8vIEBuYW1lc3BhY2UgTWFwXG4gIC8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcblxuICBNYXAubWVyZ2VPcHRpb25zKHtcbiAgXHQvLyBAb3B0aW9uIGRvdWJsZUNsaWNrWm9vbTogQm9vbGVhbnxTdHJpbmcgPSB0cnVlXG4gIFx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgaW4gYnkgZG91YmxlIGNsaWNraW5nIG9uIGl0IGFuZFxuICBcdC8vIHpvb21lZCBvdXQgYnkgZG91YmxlIGNsaWNraW5nIHdoaWxlIGhvbGRpbmcgc2hpZnQuIElmIHBhc3NlZFxuICBcdC8vIGAnY2VudGVyJ2AsIGRvdWJsZS1jbGljayB6b29tIHdpbGwgem9vbSB0byB0aGUgY2VudGVyIG9mIHRoZVxuICBcdC8vICB2aWV3IHJlZ2FyZGxlc3Mgb2Ygd2hlcmUgdGhlIG1vdXNlIHdhcy5cbiAgXHRkb3VibGVDbGlja1pvb206IHRydWVcbiAgfSk7XG5cbiAgdmFyIERvdWJsZUNsaWNrWm9vbSA9IEhhbmRsZXIuZXh0ZW5kKHtcbiAgXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5fbWFwLm9uKCdkYmxjbGljaycsIHRoaXMuX29uRG91YmxlQ2xpY2ssIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5fbWFwLm9mZignZGJsY2xpY2snLCB0aGlzLl9vbkRvdWJsZUNsaWNrLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0X29uRG91YmxlQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuICBcdFx0ICAgIG9sZFpvb20gPSBtYXAuZ2V0Wm9vbSgpLFxuICBcdFx0ICAgIGRlbHRhID0gbWFwLm9wdGlvbnMuem9vbURlbHRhLFxuICBcdFx0ICAgIHpvb20gPSBlLm9yaWdpbmFsRXZlbnQuc2hpZnRLZXkgPyBvbGRab29tIC0gZGVsdGEgOiBvbGRab29tICsgZGVsdGE7XG5cbiAgXHRcdGlmIChtYXAub3B0aW9ucy5kb3VibGVDbGlja1pvb20gPT09ICdjZW50ZXInKSB7XG4gIFx0XHRcdG1hcC5zZXRab29tKHpvb20pO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0bWFwLnNldFpvb21Bcm91bmQoZS5jb250YWluZXJQb2ludCwgem9vbSk7XG4gIFx0XHR9XG4gIFx0fVxuICB9KTtcblxuICAvLyBAc2VjdGlvbiBIYW5kbGVyc1xuICAvL1xuICAvLyBNYXAgcHJvcGVydGllcyBpbmNsdWRlIGludGVyYWN0aW9uIGhhbmRsZXJzIHRoYXQgYWxsb3cgeW91IHRvIGNvbnRyb2xcbiAgLy8gaW50ZXJhY3Rpb24gYmVoYXZpb3IgaW4gcnVudGltZSwgZW5hYmxpbmcgb3IgZGlzYWJsaW5nIGNlcnRhaW4gZmVhdHVyZXMgc3VjaFxuICAvLyBhcyBkcmFnZ2luZyBvciB0b3VjaCB6b29tIChzZWUgYEhhbmRsZXJgIG1ldGhvZHMpLiBGb3IgZXhhbXBsZTpcbiAgLy9cbiAgLy8gYGBganNcbiAgLy8gbWFwLmRvdWJsZUNsaWNrWm9vbS5kaXNhYmxlKCk7XG4gIC8vIGBgYFxuICAvL1xuICAvLyBAcHJvcGVydHkgZG91YmxlQ2xpY2tab29tOiBIYW5kbGVyXG4gIC8vIERvdWJsZSBjbGljayB6b29tIGhhbmRsZXIuXG4gIE1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdkb3VibGVDbGlja1pvb20nLCBEb3VibGVDbGlja1pvb20pO1xuXG4gIC8qXG4gICAqIEwuSGFuZGxlci5NYXBEcmFnIGlzIHVzZWQgdG8gbWFrZSB0aGUgbWFwIGRyYWdnYWJsZSAod2l0aCBwYW5uaW5nIGluZXJ0aWEpLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gICAqL1xuXG4gIC8vIEBuYW1lc3BhY2UgTWFwXG4gIC8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbiAgTWFwLm1lcmdlT3B0aW9ucyh7XG4gIFx0Ly8gQG9wdGlvbiBkcmFnZ2luZzogQm9vbGVhbiA9IHRydWVcbiAgXHQvLyBXaGV0aGVyIHRoZSBtYXAgaXMgZHJhZ2dhYmxlIHdpdGggbW91c2UvdG91Y2ggb3Igbm90LlxuICBcdGRyYWdnaW5nOiB0cnVlLFxuXG4gIFx0Ly8gQHNlY3Rpb24gUGFubmluZyBJbmVydGlhIE9wdGlvbnNcbiAgXHQvLyBAb3B0aW9uIGluZXJ0aWE6IEJvb2xlYW4gPSAqXG4gIFx0Ly8gSWYgZW5hYmxlZCwgcGFubmluZyBvZiB0aGUgbWFwIHdpbGwgaGF2ZSBhbiBpbmVydGlhIGVmZmVjdCB3aGVyZVxuICBcdC8vIHRoZSBtYXAgYnVpbGRzIG1vbWVudHVtIHdoaWxlIGRyYWdnaW5nIGFuZCBjb250aW51ZXMgbW92aW5nIGluXG4gIFx0Ly8gdGhlIHNhbWUgZGlyZWN0aW9uIGZvciBzb21lIHRpbWUuIEZlZWxzIGVzcGVjaWFsbHkgbmljZSBvbiB0b3VjaFxuICBcdC8vIGRldmljZXMuIEVuYWJsZWQgYnkgZGVmYXVsdC5cbiAgXHRpbmVydGlhOiB0cnVlLFxuXG4gIFx0Ly8gQG9wdGlvbiBpbmVydGlhRGVjZWxlcmF0aW9uOiBOdW1iZXIgPSAzMDAwXG4gIFx0Ly8gVGhlIHJhdGUgd2l0aCB3aGljaCB0aGUgaW5lcnRpYWwgbW92ZW1lbnQgc2xvd3MgZG93biwgaW4gcGl4ZWxzL3NlY29uZMKyLlxuICBcdGluZXJ0aWFEZWNlbGVyYXRpb246IDM0MDAsIC8vIHB4L3NeMlxuXG4gIFx0Ly8gQG9wdGlvbiBpbmVydGlhTWF4U3BlZWQ6IE51bWJlciA9IEluZmluaXR5XG4gIFx0Ly8gTWF4IHNwZWVkIG9mIHRoZSBpbmVydGlhbCBtb3ZlbWVudCwgaW4gcGl4ZWxzL3NlY29uZC5cbiAgXHRpbmVydGlhTWF4U3BlZWQ6IEluZmluaXR5LCAvLyBweC9zXG5cbiAgXHQvLyBAb3B0aW9uIGVhc2VMaW5lYXJpdHk6IE51bWJlciA9IDAuMlxuICBcdGVhc2VMaW5lYXJpdHk6IDAuMixcblxuICBcdC8vIFRPRE8gcmVmYWN0b3IsIG1vdmUgdG8gQ1JTXG4gIFx0Ly8gQG9wdGlvbiB3b3JsZENvcHlKdW1wOiBCb29sZWFuID0gZmFsc2VcbiAgXHQvLyBXaXRoIHRoaXMgb3B0aW9uIGVuYWJsZWQsIHRoZSBtYXAgdHJhY2tzIHdoZW4geW91IHBhbiB0byBhbm90aGVyIFwiY29weVwiXG4gIFx0Ly8gb2YgdGhlIHdvcmxkIGFuZCBzZWFtbGVzc2x5IGp1bXBzIHRvIHRoZSBvcmlnaW5hbCBvbmUgc28gdGhhdCBhbGwgb3ZlcmxheXNcbiAgXHQvLyBsaWtlIG1hcmtlcnMgYW5kIHZlY3RvciBsYXllcnMgYXJlIHN0aWxsIHZpc2libGUuXG4gIFx0d29ybGRDb3B5SnVtcDogZmFsc2UsXG5cbiAgXHQvLyBAb3B0aW9uIG1heEJvdW5kc1Zpc2Nvc2l0eTogTnVtYmVyID0gMC4wXG4gIFx0Ly8gSWYgYG1heEJvdW5kc2AgaXMgc2V0LCB0aGlzIG9wdGlvbiB3aWxsIGNvbnRyb2wgaG93IHNvbGlkIHRoZSBib3VuZHNcbiAgXHQvLyBhcmUgd2hlbiBkcmFnZ2luZyB0aGUgbWFwIGFyb3VuZC4gVGhlIGRlZmF1bHQgdmFsdWUgb2YgYDAuMGAgYWxsb3dzIHRoZVxuICBcdC8vIHVzZXIgdG8gZHJhZyBvdXRzaWRlIHRoZSBib3VuZHMgYXQgbm9ybWFsIHNwZWVkLCBoaWdoZXIgdmFsdWVzIHdpbGxcbiAgXHQvLyBzbG93IGRvd24gbWFwIGRyYWdnaW5nIG91dHNpZGUgYm91bmRzLCBhbmQgYDEuMGAgbWFrZXMgdGhlIGJvdW5kcyBmdWxseVxuICBcdC8vIHNvbGlkLCBwcmV2ZW50aW5nIHRoZSB1c2VyIGZyb20gZHJhZ2dpbmcgb3V0c2lkZSB0aGUgYm91bmRzLlxuICBcdG1heEJvdW5kc1Zpc2Nvc2l0eTogMC4wXG4gIH0pO1xuXG4gIHZhciBEcmFnID0gSGFuZGxlci5leHRlbmQoe1xuICBcdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMuX2RyYWdnYWJsZSkge1xuICBcdFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG4gIFx0XHRcdHRoaXMuX2RyYWdnYWJsZSA9IG5ldyBEcmFnZ2FibGUobWFwLl9tYXBQYW5lLCBtYXAuX2NvbnRhaW5lcik7XG5cbiAgXHRcdFx0dGhpcy5fZHJhZ2dhYmxlLm9uKHtcbiAgXHRcdFx0XHRkcmFnc3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuICBcdFx0XHRcdGRyYWc6IHRoaXMuX29uRHJhZyxcbiAgXHRcdFx0XHRkcmFnZW5kOiB0aGlzLl9vbkRyYWdFbmRcbiAgXHRcdFx0fSwgdGhpcyk7XG5cbiAgXHRcdFx0dGhpcy5fZHJhZ2dhYmxlLm9uKCdwcmVkcmFnJywgdGhpcy5fb25QcmVEcmFnTGltaXQsIHRoaXMpO1xuICBcdFx0XHRpZiAobWFwLm9wdGlvbnMud29ybGRDb3B5SnVtcCkge1xuICBcdFx0XHRcdHRoaXMuX2RyYWdnYWJsZS5vbigncHJlZHJhZycsIHRoaXMuX29uUHJlRHJhZ1dyYXAsIHRoaXMpO1xuICBcdFx0XHRcdG1hcC5vbignem9vbWVuZCcsIHRoaXMuX29uWm9vbUVuZCwgdGhpcyk7XG5cbiAgXHRcdFx0XHRtYXAud2hlblJlYWR5KHRoaXMuX29uWm9vbUVuZCwgdGhpcyk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHRcdGFkZENsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC1ncmFiIGxlYWZsZXQtdG91Y2gtZHJhZycpO1xuICBcdFx0dGhpcy5fZHJhZ2dhYmxlLmVuYWJsZSgpO1xuICBcdFx0dGhpcy5fcG9zaXRpb25zID0gW107XG4gIFx0XHR0aGlzLl90aW1lcyA9IFtdO1xuICBcdH0sXG5cbiAgXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LWdyYWInKTtcbiAgXHRcdHJlbW92ZUNsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC10b3VjaC1kcmFnJyk7XG4gIFx0XHR0aGlzLl9kcmFnZ2FibGUuZGlzYWJsZSgpO1xuICBcdH0sXG5cbiAgXHRtb3ZlZDogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuX2RyYWdnYWJsZSAmJiB0aGlzLl9kcmFnZ2FibGUuX21vdmVkO1xuICBcdH0sXG5cbiAgXHRtb3Zpbmc6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLl9kcmFnZ2FibGUgJiYgdGhpcy5fZHJhZ2dhYmxlLl9tb3Zpbmc7XG4gIFx0fSxcblxuICBcdF9vbkRyYWdTdGFydDogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblxuICBcdFx0bWFwLl9zdG9wKCk7XG4gIFx0XHRpZiAodGhpcy5fbWFwLm9wdGlvbnMubWF4Qm91bmRzICYmIHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kc1Zpc2Nvc2l0eSkge1xuICBcdFx0XHR2YXIgYm91bmRzID0gdG9MYXRMbmdCb3VuZHModGhpcy5fbWFwLm9wdGlvbnMubWF4Qm91bmRzKTtcblxuICBcdFx0XHR0aGlzLl9vZmZzZXRMaW1pdCA9IHRvQm91bmRzKFxuICBcdFx0XHRcdHRoaXMuX21hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KGJvdW5kcy5nZXROb3J0aFdlc3QoKSkubXVsdGlwbHlCeSgtMSksXG4gIFx0XHRcdFx0dGhpcy5fbWFwLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQoYm91bmRzLmdldFNvdXRoRWFzdCgpKS5tdWx0aXBseUJ5KC0xKVxuICBcdFx0XHRcdFx0LmFkZCh0aGlzLl9tYXAuZ2V0U2l6ZSgpKSk7XG5cbiAgXHRcdFx0dGhpcy5fdmlzY29zaXR5ID0gTWF0aC5taW4oMS4wLCBNYXRoLm1heCgwLjAsIHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kc1Zpc2Nvc2l0eSkpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGhpcy5fb2Zmc2V0TGltaXQgPSBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRtYXBcbiAgXHRcdCAgICAuZmlyZSgnbW92ZXN0YXJ0JylcbiAgXHRcdCAgICAuZmlyZSgnZHJhZ3N0YXJ0Jyk7XG5cbiAgXHRcdGlmIChtYXAub3B0aW9ucy5pbmVydGlhKSB7XG4gIFx0XHRcdHRoaXMuX3Bvc2l0aW9ucyA9IFtdO1xuICBcdFx0XHR0aGlzLl90aW1lcyA9IFtdO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfb25EcmFnOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0aWYgKHRoaXMuX21hcC5vcHRpb25zLmluZXJ0aWEpIHtcbiAgXHRcdFx0dmFyIHRpbWUgPSB0aGlzLl9sYXN0VGltZSA9ICtuZXcgRGF0ZSgpLFxuICBcdFx0XHQgICAgcG9zID0gdGhpcy5fbGFzdFBvcyA9IHRoaXMuX2RyYWdnYWJsZS5fYWJzUG9zIHx8IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zO1xuXG4gIFx0XHRcdHRoaXMuX3Bvc2l0aW9ucy5wdXNoKHBvcyk7XG4gIFx0XHRcdHRoaXMuX3RpbWVzLnB1c2godGltZSk7XG5cbiAgXHRcdFx0dGhpcy5fcHJ1bmVQb3NpdGlvbnModGltZSk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX21hcFxuICBcdFx0ICAgIC5maXJlKCdtb3ZlJywgZSlcbiAgXHRcdCAgICAuZmlyZSgnZHJhZycsIGUpO1xuICBcdH0sXG5cbiAgXHRfcHJ1bmVQb3NpdGlvbnM6IGZ1bmN0aW9uICh0aW1lKSB7XG4gIFx0XHR3aGlsZSAodGhpcy5fcG9zaXRpb25zLmxlbmd0aCA+IDEgJiYgdGltZSAtIHRoaXMuX3RpbWVzWzBdID4gNTApIHtcbiAgXHRcdFx0dGhpcy5fcG9zaXRpb25zLnNoaWZ0KCk7XG4gIFx0XHRcdHRoaXMuX3RpbWVzLnNoaWZ0KCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9vblpvb21FbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBweENlbnRlciA9IHRoaXMuX21hcC5nZXRTaXplKCkuZGl2aWRlQnkoMiksXG4gIFx0XHQgICAgcHhXb3JsZENlbnRlciA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQoWzAsIDBdKTtcblxuICBcdFx0dGhpcy5faW5pdGlhbFdvcmxkT2Zmc2V0ID0gcHhXb3JsZENlbnRlci5zdWJ0cmFjdChweENlbnRlcikueDtcbiAgXHRcdHRoaXMuX3dvcmxkV2lkdGggPSB0aGlzLl9tYXAuZ2V0UGl4ZWxXb3JsZEJvdW5kcygpLmdldFNpemUoKS54O1xuICBcdH0sXG5cbiAgXHRfdmlzY291c0xpbWl0OiBmdW5jdGlvbiAodmFsdWUsIHRocmVzaG9sZCkge1xuICBcdFx0cmV0dXJuIHZhbHVlIC0gKHZhbHVlIC0gdGhyZXNob2xkKSAqIHRoaXMuX3Zpc2Nvc2l0eTtcbiAgXHR9LFxuXG4gIFx0X29uUHJlRHJhZ0xpbWl0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMuX3Zpc2Nvc2l0eSB8fCAhdGhpcy5fb2Zmc2V0TGltaXQpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHZhciBvZmZzZXQgPSB0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy5zdWJ0cmFjdCh0aGlzLl9kcmFnZ2FibGUuX3N0YXJ0UG9zKTtcblxuICBcdFx0dmFyIGxpbWl0ID0gdGhpcy5fb2Zmc2V0TGltaXQ7XG4gIFx0XHRpZiAob2Zmc2V0LnggPCBsaW1pdC5taW4ueCkgeyBvZmZzZXQueCA9IHRoaXMuX3Zpc2NvdXNMaW1pdChvZmZzZXQueCwgbGltaXQubWluLngpOyB9XG4gIFx0XHRpZiAob2Zmc2V0LnkgPCBsaW1pdC5taW4ueSkgeyBvZmZzZXQueSA9IHRoaXMuX3Zpc2NvdXNMaW1pdChvZmZzZXQueSwgbGltaXQubWluLnkpOyB9XG4gIFx0XHRpZiAob2Zmc2V0LnggPiBsaW1pdC5tYXgueCkgeyBvZmZzZXQueCA9IHRoaXMuX3Zpc2NvdXNMaW1pdChvZmZzZXQueCwgbGltaXQubWF4LngpOyB9XG4gIFx0XHRpZiAob2Zmc2V0LnkgPiBsaW1pdC5tYXgueSkgeyBvZmZzZXQueSA9IHRoaXMuX3Zpc2NvdXNMaW1pdChvZmZzZXQueSwgbGltaXQubWF4LnkpOyB9XG5cbiAgXHRcdHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zID0gdGhpcy5fZHJhZ2dhYmxlLl9zdGFydFBvcy5hZGQob2Zmc2V0KTtcbiAgXHR9LFxuXG4gIFx0X29uUHJlRHJhZ1dyYXA6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdC8vIFRPRE8gcmVmYWN0b3IgdG8gYmUgYWJsZSB0byBhZGp1c3QgbWFwIHBhbmUgcG9zaXRpb24gYWZ0ZXIgem9vbVxuICBcdFx0dmFyIHdvcmxkV2lkdGggPSB0aGlzLl93b3JsZFdpZHRoLFxuICBcdFx0ICAgIGhhbGZXaWR0aCA9IE1hdGgucm91bmQod29ybGRXaWR0aCAvIDIpLFxuICBcdFx0ICAgIGR4ID0gdGhpcy5faW5pdGlhbFdvcmxkT2Zmc2V0LFxuICBcdFx0ICAgIHggPSB0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy54LFxuICBcdFx0ICAgIG5ld1gxID0gKHggLSBoYWxmV2lkdGggKyBkeCkgJSB3b3JsZFdpZHRoICsgaGFsZldpZHRoIC0gZHgsXG4gIFx0XHQgICAgbmV3WDIgPSAoeCArIGhhbGZXaWR0aCArIGR4KSAlIHdvcmxkV2lkdGggLSBoYWxmV2lkdGggLSBkeCxcbiAgXHRcdCAgICBuZXdYID0gTWF0aC5hYnMobmV3WDEgKyBkeCkgPCBNYXRoLmFicyhuZXdYMiArIGR4KSA/IG5ld1gxIDogbmV3WDI7XG5cbiAgXHRcdHRoaXMuX2RyYWdnYWJsZS5fYWJzUG9zID0gdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MuY2xvbmUoKTtcbiAgXHRcdHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLnggPSBuZXdYO1xuICBcdH0sXG5cbiAgXHRfb25EcmFnRW5kOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcbiAgXHRcdCAgICBvcHRpb25zID0gbWFwLm9wdGlvbnMsXG5cbiAgXHRcdCAgICBub0luZXJ0aWEgPSAhb3B0aW9ucy5pbmVydGlhIHx8IGUubm9JbmVydGlhIHx8IHRoaXMuX3RpbWVzLmxlbmd0aCA8IDI7XG5cbiAgXHRcdG1hcC5maXJlKCdkcmFnZW5kJywgZSk7XG5cbiAgXHRcdGlmIChub0luZXJ0aWEpIHtcbiAgXHRcdFx0bWFwLmZpcmUoJ21vdmVlbmQnKTtcblxuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGhpcy5fcHJ1bmVQb3NpdGlvbnMoK25ldyBEYXRlKCkpO1xuXG4gIFx0XHRcdHZhciBkaXJlY3Rpb24gPSB0aGlzLl9sYXN0UG9zLnN1YnRyYWN0KHRoaXMuX3Bvc2l0aW9uc1swXSksXG4gIFx0XHRcdCAgICBkdXJhdGlvbiA9ICh0aGlzLl9sYXN0VGltZSAtIHRoaXMuX3RpbWVzWzBdKSAvIDEwMDAsXG4gIFx0XHRcdCAgICBlYXNlID0gb3B0aW9ucy5lYXNlTGluZWFyaXR5LFxuXG4gIFx0XHRcdCAgICBzcGVlZFZlY3RvciA9IGRpcmVjdGlvbi5tdWx0aXBseUJ5KGVhc2UgLyBkdXJhdGlvbiksXG4gIFx0XHRcdCAgICBzcGVlZCA9IHNwZWVkVmVjdG9yLmRpc3RhbmNlVG8oWzAsIDBdKSxcblxuICBcdFx0XHQgICAgbGltaXRlZFNwZWVkID0gTWF0aC5taW4ob3B0aW9ucy5pbmVydGlhTWF4U3BlZWQsIHNwZWVkKSxcbiAgXHRcdFx0ICAgIGxpbWl0ZWRTcGVlZFZlY3RvciA9IHNwZWVkVmVjdG9yLm11bHRpcGx5QnkobGltaXRlZFNwZWVkIC8gc3BlZWQpLFxuXG4gIFx0XHRcdCAgICBkZWNlbGVyYXRpb25EdXJhdGlvbiA9IGxpbWl0ZWRTcGVlZCAvIChvcHRpb25zLmluZXJ0aWFEZWNlbGVyYXRpb24gKiBlYXNlKSxcbiAgXHRcdFx0ICAgIG9mZnNldCA9IGxpbWl0ZWRTcGVlZFZlY3Rvci5tdWx0aXBseUJ5KC1kZWNlbGVyYXRpb25EdXJhdGlvbiAvIDIpLnJvdW5kKCk7XG5cbiAgXHRcdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHtcbiAgXHRcdFx0XHRtYXAuZmlyZSgnbW92ZWVuZCcpO1xuXG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0b2Zmc2V0ID0gbWFwLl9saW1pdE9mZnNldChvZmZzZXQsIG1hcC5vcHRpb25zLm1heEJvdW5kcyk7XG5cbiAgXHRcdFx0XHRyZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0XHRcdG1hcC5wYW5CeShvZmZzZXQsIHtcbiAgXHRcdFx0XHRcdFx0ZHVyYXRpb246IGRlY2VsZXJhdGlvbkR1cmF0aW9uLFxuICBcdFx0XHRcdFx0XHRlYXNlTGluZWFyaXR5OiBlYXNlLFxuICBcdFx0XHRcdFx0XHRub01vdmVTdGFydDogdHJ1ZSxcbiAgXHRcdFx0XHRcdFx0YW5pbWF0ZTogdHJ1ZVxuICBcdFx0XHRcdFx0fSk7XG4gIFx0XHRcdFx0fSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG4gIH0pO1xuXG4gIC8vIEBzZWN0aW9uIEhhbmRsZXJzXG4gIC8vIEBwcm9wZXJ0eSBkcmFnZ2luZzogSGFuZGxlclxuICAvLyBNYXAgZHJhZ2dpbmcgaGFuZGxlciAoYnkgYm90aCBtb3VzZSBhbmQgdG91Y2gpLlxuICBNYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnZHJhZ2dpbmcnLCBEcmFnKTtcblxuICAvKlxuICAgKiBMLk1hcC5LZXlib2FyZCBpcyBoYW5kbGluZyBrZXlib2FyZCBpbnRlcmFjdGlvbiB3aXRoIHRoZSBtYXAsIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAgICovXG5cbiAgLy8gQG5hbWVzcGFjZSBNYXBcbiAgLy8gQHNlY3Rpb24gS2V5Ym9hcmQgTmF2aWdhdGlvbiBPcHRpb25zXG4gIE1hcC5tZXJnZU9wdGlvbnMoe1xuICBcdC8vIEBvcHRpb24ga2V5Ym9hcmQ6IEJvb2xlYW4gPSB0cnVlXG4gIFx0Ly8gTWFrZXMgdGhlIG1hcCBmb2N1c2FibGUgYW5kIGFsbG93cyB1c2VycyB0byBuYXZpZ2F0ZSB0aGUgbWFwIHdpdGgga2V5Ym9hcmRcbiAgXHQvLyBhcnJvd3MgYW5kIGArYC9gLWAga2V5cy5cbiAgXHRrZXlib2FyZDogdHJ1ZSxcblxuICBcdC8vIEBvcHRpb24ga2V5Ym9hcmRQYW5EZWx0YTogTnVtYmVyID0gODBcbiAgXHQvLyBBbW91bnQgb2YgcGl4ZWxzIHRvIHBhbiB3aGVuIHByZXNzaW5nIGFuIGFycm93IGtleS5cbiAgXHRrZXlib2FyZFBhbkRlbHRhOiA4MFxuICB9KTtcblxuICB2YXIgS2V5Ym9hcmQgPSBIYW5kbGVyLmV4dGVuZCh7XG5cbiAgXHRrZXlDb2Rlczoge1xuICBcdFx0bGVmdDogICAgWzM3XSxcbiAgXHRcdHJpZ2h0OiAgIFszOV0sXG4gIFx0XHRkb3duOiAgICBbNDBdLFxuICBcdFx0dXA6ICAgICAgWzM4XSxcbiAgXHRcdHpvb21JbjogIFsxODcsIDEwNywgNjEsIDE3MV0sXG4gIFx0XHR6b29tT3V0OiBbMTg5LCAxMDksIDU0LCAxNzNdXG4gIFx0fSxcblxuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXApIHtcbiAgXHRcdHRoaXMuX21hcCA9IG1hcDtcblxuICBcdFx0dGhpcy5fc2V0UGFuRGVsdGEobWFwLm9wdGlvbnMua2V5Ym9hcmRQYW5EZWx0YSk7XG4gIFx0XHR0aGlzLl9zZXRab29tRGVsdGEobWFwLm9wdGlvbnMuem9vbURlbHRhKTtcbiAgXHR9LFxuXG4gIFx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9tYXAuX2NvbnRhaW5lcjtcblxuICBcdFx0Ly8gbWFrZSB0aGUgY29udGFpbmVyIGZvY3VzYWJsZSBieSB0YWJiaW5nXG4gIFx0XHRpZiAoY29udGFpbmVyLnRhYkluZGV4IDw9IDApIHtcbiAgXHRcdFx0Y29udGFpbmVyLnRhYkluZGV4ID0gJzAnO1xuICBcdFx0fVxuXG4gIFx0XHRvbihjb250YWluZXIsIHtcbiAgXHRcdFx0Zm9jdXM6IHRoaXMuX29uRm9jdXMsXG4gIFx0XHRcdGJsdXI6IHRoaXMuX29uQmx1cixcbiAgXHRcdFx0bW91c2Vkb3duOiB0aGlzLl9vbk1vdXNlRG93blxuICBcdFx0fSwgdGhpcyk7XG5cbiAgXHRcdHRoaXMuX21hcC5vbih7XG4gIFx0XHRcdGZvY3VzOiB0aGlzLl9hZGRIb29rcyxcbiAgXHRcdFx0Ymx1cjogdGhpcy5fcmVtb3ZlSG9va3NcbiAgXHRcdH0sIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5fcmVtb3ZlSG9va3MoKTtcblxuICBcdFx0b2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCB7XG4gIFx0XHRcdGZvY3VzOiB0aGlzLl9vbkZvY3VzLFxuICBcdFx0XHRibHVyOiB0aGlzLl9vbkJsdXIsXG4gIFx0XHRcdG1vdXNlZG93bjogdGhpcy5fb25Nb3VzZURvd25cbiAgXHRcdH0sIHRoaXMpO1xuXG4gIFx0XHR0aGlzLl9tYXAub2ZmKHtcbiAgXHRcdFx0Zm9jdXM6IHRoaXMuX2FkZEhvb2tzLFxuICBcdFx0XHRibHVyOiB0aGlzLl9yZW1vdmVIb29rc1xuICBcdFx0fSwgdGhpcyk7XG4gIFx0fSxcblxuICBcdF9vbk1vdXNlRG93bjogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX2ZvY3VzZWQpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHZhciBib2R5ID0gZG9jdW1lbnQuYm9keSxcbiAgXHRcdCAgICBkb2NFbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgXHRcdCAgICB0b3AgPSBib2R5LnNjcm9sbFRvcCB8fCBkb2NFbC5zY3JvbGxUb3AsXG4gIFx0XHQgICAgbGVmdCA9IGJvZHkuc2Nyb2xsTGVmdCB8fCBkb2NFbC5zY3JvbGxMZWZ0O1xuXG4gIFx0XHR0aGlzLl9tYXAuX2NvbnRhaW5lci5mb2N1cygpO1xuXG4gIFx0XHR3aW5kb3cuc2Nyb2xsVG8obGVmdCwgdG9wKTtcbiAgXHR9LFxuXG4gIFx0X29uRm9jdXM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX2ZvY3VzZWQgPSB0cnVlO1xuICBcdFx0dGhpcy5fbWFwLmZpcmUoJ2ZvY3VzJyk7XG4gIFx0fSxcblxuICBcdF9vbkJsdXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX2ZvY3VzZWQgPSBmYWxzZTtcbiAgXHRcdHRoaXMuX21hcC5maXJlKCdibHVyJyk7XG4gIFx0fSxcblxuICBcdF9zZXRQYW5EZWx0YTogZnVuY3Rpb24gKHBhbkRlbHRhKSB7XG4gIFx0XHR2YXIga2V5cyA9IHRoaXMuX3BhbktleXMgPSB7fSxcbiAgXHRcdCAgICBjb2RlcyA9IHRoaXMua2V5Q29kZXMsXG4gIFx0XHQgICAgaSwgbGVuO1xuXG4gIFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy5sZWZ0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gIFx0XHRcdGtleXNbY29kZXMubGVmdFtpXV0gPSBbLTEgKiBwYW5EZWx0YSwgMF07XG4gIFx0XHR9XG4gIFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy5yaWdodC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICBcdFx0XHRrZXlzW2NvZGVzLnJpZ2h0W2ldXSA9IFtwYW5EZWx0YSwgMF07XG4gIFx0XHR9XG4gIFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy5kb3duLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gIFx0XHRcdGtleXNbY29kZXMuZG93bltpXV0gPSBbMCwgcGFuRGVsdGFdO1xuICBcdFx0fVxuICBcdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMudXAubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0a2V5c1tjb2Rlcy51cFtpXV0gPSBbMCwgLTEgKiBwYW5EZWx0YV07XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9zZXRab29tRGVsdGE6IGZ1bmN0aW9uICh6b29tRGVsdGEpIHtcbiAgXHRcdHZhciBrZXlzID0gdGhpcy5fem9vbUtleXMgPSB7fSxcbiAgXHRcdCAgICBjb2RlcyA9IHRoaXMua2V5Q29kZXMsXG4gIFx0XHQgICAgaSwgbGVuO1xuXG4gIFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy56b29tSW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0a2V5c1tjb2Rlcy56b29tSW5baV1dID0gem9vbURlbHRhO1xuICBcdFx0fVxuICBcdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMuem9vbU91dC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICBcdFx0XHRrZXlzW2NvZGVzLnpvb21PdXRbaV1dID0gLXpvb21EZWx0YTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X2FkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRvbihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24sIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRfcmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdG9mZihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24sIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRfb25LZXlEb3duOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0aWYgKGUuYWx0S2V5IHx8IGUuY3RybEtleSB8fCBlLm1ldGFLZXkpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHZhciBrZXkgPSBlLmtleUNvZGUsXG4gIFx0XHQgICAgbWFwID0gdGhpcy5fbWFwLFxuICBcdFx0ICAgIG9mZnNldDtcblxuICBcdFx0aWYgKGtleSBpbiB0aGlzLl9wYW5LZXlzKSB7XG4gIFx0XHRcdGlmICghbWFwLl9wYW5BbmltIHx8ICFtYXAuX3BhbkFuaW0uX2luUHJvZ3Jlc3MpIHtcbiAgXHRcdFx0XHRvZmZzZXQgPSB0aGlzLl9wYW5LZXlzW2tleV07XG4gIFx0XHRcdFx0aWYgKGUuc2hpZnRLZXkpIHtcbiAgXHRcdFx0XHRcdG9mZnNldCA9IHRvUG9pbnQob2Zmc2V0KS5tdWx0aXBseUJ5KDMpO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdGlmIChtYXAub3B0aW9ucy5tYXhCb3VuZHMpIHtcbiAgXHRcdFx0XHRcdG9mZnNldCA9IG1hcC5fbGltaXRPZmZzZXQodG9Qb2ludChvZmZzZXQpLCBtYXAub3B0aW9ucy5tYXhCb3VuZHMpO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdGlmIChtYXAub3B0aW9ucy53b3JsZENvcHlKdW1wKSB7XG4gIFx0XHRcdFx0XHR2YXIgbmV3TGF0TG5nID0gbWFwLndyYXBMYXRMbmcobWFwLnVucHJvamVjdChtYXAucHJvamVjdChtYXAuZ2V0Q2VudGVyKCkpLmFkZChvZmZzZXQpKSk7XG4gIFx0XHRcdFx0XHRtYXAucGFuVG8obmV3TGF0TG5nKTtcbiAgXHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0bWFwLnBhbkJ5KG9mZnNldCk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9IGVsc2UgaWYgKGtleSBpbiB0aGlzLl96b29tS2V5cykge1xuICBcdFx0XHRtYXAuc2V0Wm9vbShtYXAuZ2V0Wm9vbSgpICsgKGUuc2hpZnRLZXkgPyAzIDogMSkgKiB0aGlzLl96b29tS2V5c1trZXldKTtcblxuICBcdFx0fSBlbHNlIGlmIChrZXkgPT09IDI3ICYmIG1hcC5fcG9wdXAgJiYgbWFwLl9wb3B1cC5vcHRpb25zLmNsb3NlT25Fc2NhcGVLZXkpIHtcbiAgXHRcdFx0bWFwLmNsb3NlUG9wdXAoKTtcblxuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRzdG9wKGUpO1xuICBcdH1cbiAgfSk7XG5cbiAgLy8gQHNlY3Rpb24gSGFuZGxlcnNcbiAgLy8gQHNlY3Rpb24gSGFuZGxlcnNcbiAgLy8gQHByb3BlcnR5IGtleWJvYXJkOiBIYW5kbGVyXG4gIC8vIEtleWJvYXJkIG5hdmlnYXRpb24gaGFuZGxlci5cbiAgTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2tleWJvYXJkJywgS2V5Ym9hcmQpO1xuXG4gIC8qXG4gICAqIEwuSGFuZGxlci5TY3JvbGxXaGVlbFpvb20gaXMgdXNlZCBieSBMLk1hcCB0byBlbmFibGUgbW91c2Ugc2Nyb2xsIHdoZWVsIHpvb20gb24gdGhlIG1hcC5cbiAgICovXG5cbiAgLy8gQG5hbWVzcGFjZSBNYXBcbiAgLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuICBNYXAubWVyZ2VPcHRpb25zKHtcbiAgXHQvLyBAc2VjdGlvbiBNb3VzZSB3aGVlbCBvcHRpb25zXG4gIFx0Ly8gQG9wdGlvbiBzY3JvbGxXaGVlbFpvb206IEJvb2xlYW58U3RyaW5nID0gdHJ1ZVxuICBcdC8vIFdoZXRoZXIgdGhlIG1hcCBjYW4gYmUgem9vbWVkIGJ5IHVzaW5nIHRoZSBtb3VzZSB3aGVlbC4gSWYgcGFzc2VkIGAnY2VudGVyJ2AsXG4gIFx0Ly8gaXQgd2lsbCB6b29tIHRvIHRoZSBjZW50ZXIgb2YgdGhlIHZpZXcgcmVnYXJkbGVzcyBvZiB3aGVyZSB0aGUgbW91c2Ugd2FzLlxuICBcdHNjcm9sbFdoZWVsWm9vbTogdHJ1ZSxcblxuICBcdC8vIEBvcHRpb24gd2hlZWxEZWJvdW5jZVRpbWU6IE51bWJlciA9IDQwXG4gIFx0Ly8gTGltaXRzIHRoZSByYXRlIGF0IHdoaWNoIGEgd2hlZWwgY2FuIGZpcmUgKGluIG1pbGxpc2Vjb25kcykuIEJ5IGRlZmF1bHRcbiAgXHQvLyB1c2VyIGNhbid0IHpvb20gdmlhIHdoZWVsIG1vcmUgb2Z0ZW4gdGhhbiBvbmNlIHBlciA0MCBtcy5cbiAgXHR3aGVlbERlYm91bmNlVGltZTogNDAsXG5cbiAgXHQvLyBAb3B0aW9uIHdoZWVsUHhQZXJab29tTGV2ZWw6IE51bWJlciA9IDYwXG4gIFx0Ly8gSG93IG1hbnkgc2Nyb2xsIHBpeGVscyAoYXMgcmVwb3J0ZWQgYnkgW0wuRG9tRXZlbnQuZ2V0V2hlZWxEZWx0YV0oI2RvbWV2ZW50LWdldHdoZWVsZGVsdGEpKVxuICBcdC8vIG1lYW4gYSBjaGFuZ2Ugb2Ygb25lIGZ1bGwgem9vbSBsZXZlbC4gU21hbGxlciB2YWx1ZXMgd2lsbCBtYWtlIHdoZWVsLXpvb21pbmdcbiAgXHQvLyBmYXN0ZXIgKGFuZCB2aWNlIHZlcnNhKS5cbiAgXHR3aGVlbFB4UGVyWm9vbUxldmVsOiA2MFxuICB9KTtcblxuICB2YXIgU2Nyb2xsV2hlZWxab29tID0gSGFuZGxlci5leHRlbmQoe1xuICBcdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRvbih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3doZWVsJywgdGhpcy5fb25XaGVlbFNjcm9sbCwgdGhpcyk7XG5cbiAgXHRcdHRoaXMuX2RlbHRhID0gMDtcbiAgXHR9LFxuXG4gIFx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdG9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3doZWVsJywgdGhpcy5fb25XaGVlbFNjcm9sbCwgdGhpcyk7XG4gIFx0fSxcblxuICBcdF9vbldoZWVsU2Nyb2xsOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0dmFyIGRlbHRhID0gZ2V0V2hlZWxEZWx0YShlKTtcblxuICBcdFx0dmFyIGRlYm91bmNlID0gdGhpcy5fbWFwLm9wdGlvbnMud2hlZWxEZWJvdW5jZVRpbWU7XG5cbiAgXHRcdHRoaXMuX2RlbHRhICs9IGRlbHRhO1xuICBcdFx0dGhpcy5fbGFzdE1vdXNlUG9zID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xuXG4gIFx0XHRpZiAoIXRoaXMuX3N0YXJ0VGltZSkge1xuICBcdFx0XHR0aGlzLl9zdGFydFRpbWUgPSArbmV3IERhdGUoKTtcbiAgXHRcdH1cblxuICBcdFx0dmFyIGxlZnQgPSBNYXRoLm1heChkZWJvdW5jZSAtICgrbmV3IERhdGUoKSAtIHRoaXMuX3N0YXJ0VGltZSksIDApO1xuXG4gIFx0XHRjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICBcdFx0dGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KGJpbmQodGhpcy5fcGVyZm9ybVpvb20sIHRoaXMpLCBsZWZ0KTtcblxuICBcdFx0c3RvcChlKTtcbiAgXHR9LFxuXG4gIFx0X3BlcmZvcm1ab29tOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuICBcdFx0ICAgIHpvb20gPSBtYXAuZ2V0Wm9vbSgpLFxuICBcdFx0ICAgIHNuYXAgPSB0aGlzLl9tYXAub3B0aW9ucy56b29tU25hcCB8fCAwO1xuXG4gIFx0XHRtYXAuX3N0b3AoKTsgLy8gc3RvcCBwYW5uaW5nIGFuZCBmbHkgYW5pbWF0aW9ucyBpZiBhbnlcblxuICBcdFx0Ly8gbWFwIHRoZSBkZWx0YSB3aXRoIGEgc2lnbW9pZCBmdW5jdGlvbiB0byAtNC4uNCByYW5nZSBsZWFuaW5nIG9uIC0xLi4xXG4gIFx0XHR2YXIgZDIgPSB0aGlzLl9kZWx0YSAvICh0aGlzLl9tYXAub3B0aW9ucy53aGVlbFB4UGVyWm9vbUxldmVsICogNCksXG4gIFx0XHQgICAgZDMgPSA0ICogTWF0aC5sb2coMiAvICgxICsgTWF0aC5leHAoLU1hdGguYWJzKGQyKSkpKSAvIE1hdGguTE4yLFxuICBcdFx0ICAgIGQ0ID0gc25hcCA/IE1hdGguY2VpbChkMyAvIHNuYXApICogc25hcCA6IGQzLFxuICBcdFx0ICAgIGRlbHRhID0gbWFwLl9saW1pdFpvb20oem9vbSArICh0aGlzLl9kZWx0YSA+IDAgPyBkNCA6IC1kNCkpIC0gem9vbTtcblxuICBcdFx0dGhpcy5fZGVsdGEgPSAwO1xuICBcdFx0dGhpcy5fc3RhcnRUaW1lID0gbnVsbDtcblxuICBcdFx0aWYgKCFkZWx0YSkgeyByZXR1cm47IH1cblxuICBcdFx0aWYgKG1hcC5vcHRpb25zLnNjcm9sbFdoZWVsWm9vbSA9PT0gJ2NlbnRlcicpIHtcbiAgXHRcdFx0bWFwLnNldFpvb20oem9vbSArIGRlbHRhKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdG1hcC5zZXRab29tQXJvdW5kKHRoaXMuX2xhc3RNb3VzZVBvcywgem9vbSArIGRlbHRhKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH0pO1xuXG4gIC8vIEBzZWN0aW9uIEhhbmRsZXJzXG4gIC8vIEBwcm9wZXJ0eSBzY3JvbGxXaGVlbFpvb206IEhhbmRsZXJcbiAgLy8gU2Nyb2xsIHdoZWVsIHpvb20gaGFuZGxlci5cbiAgTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3Njcm9sbFdoZWVsWm9vbScsIFNjcm9sbFdoZWVsWm9vbSk7XG5cbiAgLypcbiAgICogTC5NYXAuVGFwSG9sZCBpcyB1c2VkIHRvIHNpbXVsYXRlIGBjb250ZXh0bWVudWAgZXZlbnQgb24gbG9uZyBob2xkLFxuICAgKiB3aGljaCBvdGhlcndpc2UgaXMgbm90IGZpcmVkIGJ5IG1vYmlsZSBTYWZhcmkuXG4gICAqL1xuXG4gIHZhciB0YXBIb2xkRGVsYXkgPSA2MDA7XG5cbiAgLy8gQG5hbWVzcGFjZSBNYXBcbiAgLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuICBNYXAubWVyZ2VPcHRpb25zKHtcbiAgXHQvLyBAc2VjdGlvbiBUb3VjaCBpbnRlcmFjdGlvbiBvcHRpb25zXG4gIFx0Ly8gQG9wdGlvbiB0YXBIb2xkOiBCb29sZWFuXG4gIFx0Ly8gRW5hYmxlcyBzaW11bGF0aW9uIG9mIGBjb250ZXh0bWVudWAgZXZlbnQsIGRlZmF1bHQgaXMgYHRydWVgIGZvciBtb2JpbGUgU2FmYXJpLlxuICBcdHRhcEhvbGQ6IEJyb3dzZXIudG91Y2hOYXRpdmUgJiYgQnJvd3Nlci5zYWZhcmkgJiYgQnJvd3Nlci5tb2JpbGUsXG5cbiAgXHQvLyBAb3B0aW9uIHRhcFRvbGVyYW5jZTogTnVtYmVyID0gMTVcbiAgXHQvLyBUaGUgbWF4IG51bWJlciBvZiBwaXhlbHMgYSB1c2VyIGNhbiBzaGlmdCBoaXMgZmluZ2VyIGR1cmluZyB0b3VjaFxuICBcdC8vIGZvciBpdCB0byBiZSBjb25zaWRlcmVkIGEgdmFsaWQgdGFwLlxuICBcdHRhcFRvbGVyYW5jZTogMTVcbiAgfSk7XG5cbiAgdmFyIFRhcEhvbGQgPSBIYW5kbGVyLmV4dGVuZCh7XG4gIFx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdG9uKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uRG93biwgdGhpcyk7XG4gIFx0fSxcblxuICBcdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRvZmYodGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Eb3duLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0X29uRG93bjogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdGNsZWFyVGltZW91dCh0aGlzLl9ob2xkVGltZW91dCk7XG4gIFx0XHRpZiAoZS50b3VjaGVzLmxlbmd0aCAhPT0gMSkgeyByZXR1cm47IH1cblxuICBcdFx0dmFyIGZpcnN0ID0gZS50b3VjaGVzWzBdO1xuICBcdFx0dGhpcy5fc3RhcnRQb3MgPSB0aGlzLl9uZXdQb3MgPSBuZXcgUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSk7XG5cbiAgXHRcdHRoaXMuX2hvbGRUaW1lb3V0ID0gc2V0VGltZW91dChiaW5kKGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0dGhpcy5fY2FuY2VsKCk7XG4gIFx0XHRcdGlmICghdGhpcy5faXNUYXBWYWxpZCgpKSB7IHJldHVybjsgfVxuXG4gIFx0XHRcdC8vIHByZXZlbnQgc2ltdWxhdGVkIG1vdXNlIGV2ZW50cyBodHRwczovL3czYy5naXRodWIuaW8vdG91Y2gtZXZlbnRzLyNtb3VzZS1ldmVudHNcbiAgXHRcdFx0b24oZG9jdW1lbnQsICd0b3VjaGVuZCcsIHByZXZlbnREZWZhdWx0KTtcbiAgXHRcdFx0b24oZG9jdW1lbnQsICd0b3VjaGVuZCB0b3VjaGNhbmNlbCcsIHRoaXMuX2NhbmNlbENsaWNrUHJldmVudCk7XG4gIFx0XHRcdHRoaXMuX3NpbXVsYXRlRXZlbnQoJ2NvbnRleHRtZW51JywgZmlyc3QpO1xuICBcdFx0fSwgdGhpcyksIHRhcEhvbGREZWxheSk7XG5cbiAgXHRcdG9uKGRvY3VtZW50LCAndG91Y2hlbmQgdG91Y2hjYW5jZWwgY29udGV4dG1lbnUnLCB0aGlzLl9jYW5jZWwsIHRoaXMpO1xuICBcdFx0b24oZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vbk1vdmUsIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRfY2FuY2VsQ2xpY2tQcmV2ZW50OiBmdW5jdGlvbiBjYW5jZWxDbGlja1ByZXZlbnQoKSB7XG4gIFx0XHRvZmYoZG9jdW1lbnQsICd0b3VjaGVuZCcsIHByZXZlbnREZWZhdWx0KTtcbiAgXHRcdG9mZihkb2N1bWVudCwgJ3RvdWNoZW5kIHRvdWNoY2FuY2VsJywgY2FuY2VsQ2xpY2tQcmV2ZW50KTtcbiAgXHR9LFxuXG4gIFx0X2NhbmNlbDogZnVuY3Rpb24gKCkge1xuICBcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2hvbGRUaW1lb3V0KTtcbiAgXHRcdG9mZihkb2N1bWVudCwgJ3RvdWNoZW5kIHRvdWNoY2FuY2VsIGNvbnRleHRtZW51JywgdGhpcy5fY2FuY2VsLCB0aGlzKTtcbiAgXHRcdG9mZihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uTW92ZSwgdGhpcyk7XG4gIFx0fSxcblxuICBcdF9vbk1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHR2YXIgZmlyc3QgPSBlLnRvdWNoZXNbMF07XG4gIFx0XHR0aGlzLl9uZXdQb3MgPSBuZXcgUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSk7XG4gIFx0fSxcblxuICBcdF9pc1RhcFZhbGlkOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fbmV3UG9zLmRpc3RhbmNlVG8odGhpcy5fc3RhcnRQb3MpIDw9IHRoaXMuX21hcC5vcHRpb25zLnRhcFRvbGVyYW5jZTtcbiAgXHR9LFxuXG4gIFx0X3NpbXVsYXRlRXZlbnQ6IGZ1bmN0aW9uICh0eXBlLCBlKSB7XG4gIFx0XHR2YXIgc2ltdWxhdGVkRXZlbnQgPSBuZXcgTW91c2VFdmVudCh0eXBlLCB7XG4gIFx0XHRcdGJ1YmJsZXM6IHRydWUsXG4gIFx0XHRcdGNhbmNlbGFibGU6IHRydWUsXG4gIFx0XHRcdHZpZXc6IHdpbmRvdyxcbiAgXHRcdFx0Ly8gZGV0YWlsOiAxLFxuICBcdFx0XHRzY3JlZW5YOiBlLnNjcmVlblgsXG4gIFx0XHRcdHNjcmVlblk6IGUuc2NyZWVuWSxcbiAgXHRcdFx0Y2xpZW50WDogZS5jbGllbnRYLFxuICBcdFx0XHRjbGllbnRZOiBlLmNsaWVudFksXG4gIFx0XHRcdC8vIGJ1dHRvbjogMixcbiAgXHRcdFx0Ly8gYnV0dG9uczogMlxuICBcdFx0fSk7XG5cbiAgXHRcdHNpbXVsYXRlZEV2ZW50Ll9zaW11bGF0ZWQgPSB0cnVlO1xuXG4gIFx0XHRlLnRhcmdldC5kaXNwYXRjaEV2ZW50KHNpbXVsYXRlZEV2ZW50KTtcbiAgXHR9XG4gIH0pO1xuXG4gIC8vIEBzZWN0aW9uIEhhbmRsZXJzXG4gIC8vIEBwcm9wZXJ0eSB0YXBIb2xkOiBIYW5kbGVyXG4gIC8vIExvbmcgdGFwIGhhbmRsZXIgdG8gc2ltdWxhdGUgYGNvbnRleHRtZW51YCBldmVudCAodXNlZnVsIGluIG1vYmlsZSBTYWZhcmkpLlxuICBNYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAndGFwSG9sZCcsIFRhcEhvbGQpO1xuXG4gIC8qXG4gICAqIEwuSGFuZGxlci5Ub3VjaFpvb20gaXMgdXNlZCBieSBMLk1hcCB0byBhZGQgcGluY2ggem9vbSBvbiBzdXBwb3J0ZWQgbW9iaWxlIGJyb3dzZXJzLlxuICAgKi9cblxuICAvLyBAbmFtZXNwYWNlIE1hcFxuICAvLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG4gIE1hcC5tZXJnZU9wdGlvbnMoe1xuICBcdC8vIEBzZWN0aW9uIFRvdWNoIGludGVyYWN0aW9uIG9wdGlvbnNcbiAgXHQvLyBAb3B0aW9uIHRvdWNoWm9vbTogQm9vbGVhbnxTdHJpbmcgPSAqXG4gIFx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgYnkgdG91Y2gtZHJhZ2dpbmcgd2l0aCB0d28gZmluZ2Vycy4gSWZcbiAgXHQvLyBwYXNzZWQgYCdjZW50ZXInYCwgaXQgd2lsbCB6b29tIHRvIHRoZSBjZW50ZXIgb2YgdGhlIHZpZXcgcmVnYXJkbGVzcyBvZlxuICBcdC8vIHdoZXJlIHRoZSB0b3VjaCBldmVudHMgKGZpbmdlcnMpIHdlcmUuIEVuYWJsZWQgZm9yIHRvdWNoLWNhcGFibGUgd2ViXG4gIFx0Ly8gYnJvd3NlcnMuXG4gIFx0dG91Y2hab29tOiBCcm93c2VyLnRvdWNoLFxuXG4gIFx0Ly8gQG9wdGlvbiBib3VuY2VBdFpvb21MaW1pdHM6IEJvb2xlYW4gPSB0cnVlXG4gIFx0Ly8gU2V0IGl0IHRvIGZhbHNlIGlmIHlvdSBkb24ndCB3YW50IHRoZSBtYXAgdG8gem9vbSBiZXlvbmQgbWluL21heCB6b29tXG4gIFx0Ly8gYW5kIHRoZW4gYm91bmNlIGJhY2sgd2hlbiBwaW5jaC16b29taW5nLlxuICBcdGJvdW5jZUF0Wm9vbUxpbWl0czogdHJ1ZVxuICB9KTtcblxuICB2YXIgVG91Y2hab29tID0gSGFuZGxlci5leHRlbmQoe1xuICBcdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRhZGRDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtdG91Y2gtem9vbScpO1xuICBcdFx0b24odGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaFN0YXJ0LCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJlbW92ZUNsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC10b3VjaC16b29tJyk7XG4gIFx0XHRvZmYodGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaFN0YXJ0LCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0X29uVG91Y2hTdGFydDogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG4gIFx0XHRpZiAoIWUudG91Y2hlcyB8fCBlLnRvdWNoZXMubGVuZ3RoICE9PSAyIHx8IG1hcC5fYW5pbWF0aW5nWm9vbSB8fCB0aGlzLl96b29taW5nKSB7IHJldHVybjsgfVxuXG4gIFx0XHR2YXIgcDEgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzBdKSxcbiAgXHRcdCAgICBwMiA9IG1hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLnRvdWNoZXNbMV0pO1xuXG4gIFx0XHR0aGlzLl9jZW50ZXJQb2ludCA9IG1hcC5nZXRTaXplKCkuX2RpdmlkZUJ5KDIpO1xuICBcdFx0dGhpcy5fc3RhcnRMYXRMbmcgPSBtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyh0aGlzLl9jZW50ZXJQb2ludCk7XG4gIFx0XHRpZiAobWFwLm9wdGlvbnMudG91Y2hab29tICE9PSAnY2VudGVyJykge1xuICBcdFx0XHR0aGlzLl9waW5jaFN0YXJ0TGF0TG5nID0gbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcocDEuYWRkKHAyKS5fZGl2aWRlQnkoMikpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl9zdGFydERpc3QgPSBwMS5kaXN0YW5jZVRvKHAyKTtcbiAgXHRcdHRoaXMuX3N0YXJ0Wm9vbSA9IG1hcC5nZXRab29tKCk7XG5cbiAgXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XG4gIFx0XHR0aGlzLl96b29taW5nID0gdHJ1ZTtcblxuICBcdFx0bWFwLl9zdG9wKCk7XG5cbiAgXHRcdG9uKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUsIHRoaXMpO1xuICBcdFx0b24oZG9jdW1lbnQsICd0b3VjaGVuZCB0b3VjaGNhbmNlbCcsIHRoaXMuX29uVG91Y2hFbmQsIHRoaXMpO1xuXG4gIFx0XHRwcmV2ZW50RGVmYXVsdChlKTtcbiAgXHR9LFxuXG4gIFx0X29uVG91Y2hNb3ZlOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0aWYgKCFlLnRvdWNoZXMgfHwgZS50b3VjaGVzLmxlbmd0aCAhPT0gMiB8fCAhdGhpcy5fem9vbWluZykgeyByZXR1cm47IH1cblxuICBcdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcbiAgXHRcdCAgICBwMSA9IG1hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLnRvdWNoZXNbMF0pLFxuICBcdFx0ICAgIHAyID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1sxXSksXG4gIFx0XHQgICAgc2NhbGUgPSBwMS5kaXN0YW5jZVRvKHAyKSAvIHRoaXMuX3N0YXJ0RGlzdDtcblxuICBcdFx0dGhpcy5fem9vbSA9IG1hcC5nZXRTY2FsZVpvb20oc2NhbGUsIHRoaXMuX3N0YXJ0Wm9vbSk7XG5cbiAgXHRcdGlmICghbWFwLm9wdGlvbnMuYm91bmNlQXRab29tTGltaXRzICYmIChcbiAgXHRcdFx0KHRoaXMuX3pvb20gPCBtYXAuZ2V0TWluWm9vbSgpICYmIHNjYWxlIDwgMSkgfHxcbiAgXHRcdFx0KHRoaXMuX3pvb20gPiBtYXAuZ2V0TWF4Wm9vbSgpICYmIHNjYWxlID4gMSkpKSB7XG4gIFx0XHRcdHRoaXMuX3pvb20gPSBtYXAuX2xpbWl0Wm9vbSh0aGlzLl96b29tKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKG1hcC5vcHRpb25zLnRvdWNoWm9vbSA9PT0gJ2NlbnRlcicpIHtcbiAgXHRcdFx0dGhpcy5fY2VudGVyID0gdGhpcy5fc3RhcnRMYXRMbmc7XG4gIFx0XHRcdGlmIChzY2FsZSA9PT0gMSkgeyByZXR1cm47IH1cbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdC8vIEdldCBkZWx0YSBmcm9tIHBpbmNoIHRvIGNlbnRlciwgc28gY2VudGVyTGF0TG5nIGlzIGRlbHRhIGFwcGxpZWQgdG8gaW5pdGlhbCBwaW5jaExhdExuZ1xuICBcdFx0XHR2YXIgZGVsdGEgPSBwMS5fYWRkKHAyKS5fZGl2aWRlQnkoMikuX3N1YnRyYWN0KHRoaXMuX2NlbnRlclBvaW50KTtcbiAgXHRcdFx0aWYgKHNjYWxlID09PSAxICYmIGRlbHRhLnggPT09IDAgJiYgZGVsdGEueSA9PT0gMCkgeyByZXR1cm47IH1cbiAgXHRcdFx0dGhpcy5fY2VudGVyID0gbWFwLnVucHJvamVjdChtYXAucHJvamVjdCh0aGlzLl9waW5jaFN0YXJ0TGF0TG5nLCB0aGlzLl96b29tKS5zdWJ0cmFjdChkZWx0YSksIHRoaXMuX3pvb20pO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIXRoaXMuX21vdmVkKSB7XG4gIFx0XHRcdG1hcC5fbW92ZVN0YXJ0KHRydWUsIGZhbHNlKTtcbiAgXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xuICBcdFx0fVxuXG4gIFx0XHRjYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xuXG4gIFx0XHR2YXIgbW92ZUZuID0gYmluZChtYXAuX21vdmUsIG1hcCwgdGhpcy5fY2VudGVyLCB0aGlzLl96b29tLCB7cGluY2g6IHRydWUsIHJvdW5kOiBmYWxzZX0sIHVuZGVmaW5lZCk7XG4gIFx0XHR0aGlzLl9hbmltUmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUobW92ZUZuLCB0aGlzLCB0cnVlKTtcblxuICBcdFx0cHJldmVudERlZmF1bHQoZSk7XG4gIFx0fSxcblxuICBcdF9vblRvdWNoRW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMuX21vdmVkIHx8ICF0aGlzLl96b29taW5nKSB7XG4gIFx0XHRcdHRoaXMuX3pvb21pbmcgPSBmYWxzZTtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl96b29taW5nID0gZmFsc2U7XG4gIFx0XHRjYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xuXG4gIFx0XHRvZmYoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSwgdGhpcyk7XG4gIFx0XHRvZmYoZG9jdW1lbnQsICd0b3VjaGVuZCB0b3VjaGNhbmNlbCcsIHRoaXMuX29uVG91Y2hFbmQsIHRoaXMpO1xuXG4gIFx0XHQvLyBQaW5jaCB1cGRhdGVzIEdyaWRMYXllcnMnIGxldmVscyBvbmx5IHdoZW4gem9vbVNuYXAgaXMgb2ZmLCBzbyB6b29tU25hcCBiZWNvbWVzIG5vVXBkYXRlLlxuICBcdFx0aWYgKHRoaXMuX21hcC5vcHRpb25zLnpvb21BbmltYXRpb24pIHtcbiAgXHRcdFx0dGhpcy5fbWFwLl9hbmltYXRlWm9vbSh0aGlzLl9jZW50ZXIsIHRoaXMuX21hcC5fbGltaXRab29tKHRoaXMuX3pvb20pLCB0cnVlLCB0aGlzLl9tYXAub3B0aW9ucy56b29tU25hcCk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aGlzLl9tYXAuX3Jlc2V0Vmlldyh0aGlzLl9jZW50ZXIsIHRoaXMuX21hcC5fbGltaXRab29tKHRoaXMuX3pvb20pKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH0pO1xuXG4gIC8vIEBzZWN0aW9uIEhhbmRsZXJzXG4gIC8vIEBwcm9wZXJ0eSB0b3VjaFpvb206IEhhbmRsZXJcbiAgLy8gVG91Y2ggem9vbSBoYW5kbGVyLlxuICBNYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAndG91Y2hab29tJywgVG91Y2hab29tKTtcblxuICBNYXAuQm94Wm9vbSA9IEJveFpvb207XG4gIE1hcC5Eb3VibGVDbGlja1pvb20gPSBEb3VibGVDbGlja1pvb207XG4gIE1hcC5EcmFnID0gRHJhZztcbiAgTWFwLktleWJvYXJkID0gS2V5Ym9hcmQ7XG4gIE1hcC5TY3JvbGxXaGVlbFpvb20gPSBTY3JvbGxXaGVlbFpvb207XG4gIE1hcC5UYXBIb2xkID0gVGFwSG9sZDtcbiAgTWFwLlRvdWNoWm9vbSA9IFRvdWNoWm9vbTtcblxuICBleHBvcnRzLkJvdW5kcyA9IEJvdW5kcztcbiAgZXhwb3J0cy5Ccm93c2VyID0gQnJvd3NlcjtcbiAgZXhwb3J0cy5DUlMgPSBDUlM7XG4gIGV4cG9ydHMuQ2FudmFzID0gQ2FudmFzO1xuICBleHBvcnRzLkNpcmNsZSA9IENpcmNsZTtcbiAgZXhwb3J0cy5DaXJjbGVNYXJrZXIgPSBDaXJjbGVNYXJrZXI7XG4gIGV4cG9ydHMuQ2xhc3MgPSBDbGFzcztcbiAgZXhwb3J0cy5Db250cm9sID0gQ29udHJvbDtcbiAgZXhwb3J0cy5EaXZJY29uID0gRGl2SWNvbjtcbiAgZXhwb3J0cy5EaXZPdmVybGF5ID0gRGl2T3ZlcmxheTtcbiAgZXhwb3J0cy5Eb21FdmVudCA9IERvbUV2ZW50O1xuICBleHBvcnRzLkRvbVV0aWwgPSBEb21VdGlsO1xuICBleHBvcnRzLkRyYWdnYWJsZSA9IERyYWdnYWJsZTtcbiAgZXhwb3J0cy5FdmVudGVkID0gRXZlbnRlZDtcbiAgZXhwb3J0cy5GZWF0dXJlR3JvdXAgPSBGZWF0dXJlR3JvdXA7XG4gIGV4cG9ydHMuR2VvSlNPTiA9IEdlb0pTT047XG4gIGV4cG9ydHMuR3JpZExheWVyID0gR3JpZExheWVyO1xuICBleHBvcnRzLkhhbmRsZXIgPSBIYW5kbGVyO1xuICBleHBvcnRzLkljb24gPSBJY29uO1xuICBleHBvcnRzLkltYWdlT3ZlcmxheSA9IEltYWdlT3ZlcmxheTtcbiAgZXhwb3J0cy5MYXRMbmcgPSBMYXRMbmc7XG4gIGV4cG9ydHMuTGF0TG5nQm91bmRzID0gTGF0TG5nQm91bmRzO1xuICBleHBvcnRzLkxheWVyID0gTGF5ZXI7XG4gIGV4cG9ydHMuTGF5ZXJHcm91cCA9IExheWVyR3JvdXA7XG4gIGV4cG9ydHMuTGluZVV0aWwgPSBMaW5lVXRpbDtcbiAgZXhwb3J0cy5NYXAgPSBNYXA7XG4gIGV4cG9ydHMuTWFya2VyID0gTWFya2VyO1xuICBleHBvcnRzLk1peGluID0gTWl4aW47XG4gIGV4cG9ydHMuUGF0aCA9IFBhdGg7XG4gIGV4cG9ydHMuUG9pbnQgPSBQb2ludDtcbiAgZXhwb3J0cy5Qb2x5VXRpbCA9IFBvbHlVdGlsO1xuICBleHBvcnRzLlBvbHlnb24gPSBQb2x5Z29uO1xuICBleHBvcnRzLlBvbHlsaW5lID0gUG9seWxpbmU7XG4gIGV4cG9ydHMuUG9wdXAgPSBQb3B1cDtcbiAgZXhwb3J0cy5Qb3NBbmltYXRpb24gPSBQb3NBbmltYXRpb247XG4gIGV4cG9ydHMuUHJvamVjdGlvbiA9IGluZGV4O1xuICBleHBvcnRzLlJlY3RhbmdsZSA9IFJlY3RhbmdsZTtcbiAgZXhwb3J0cy5SZW5kZXJlciA9IFJlbmRlcmVyO1xuICBleHBvcnRzLlNWRyA9IFNWRztcbiAgZXhwb3J0cy5TVkdPdmVybGF5ID0gU1ZHT3ZlcmxheTtcbiAgZXhwb3J0cy5UaWxlTGF5ZXIgPSBUaWxlTGF5ZXI7XG4gIGV4cG9ydHMuVG9vbHRpcCA9IFRvb2x0aXA7XG4gIGV4cG9ydHMuVHJhbnNmb3JtYXRpb24gPSBUcmFuc2Zvcm1hdGlvbjtcbiAgZXhwb3J0cy5VdGlsID0gVXRpbDtcbiAgZXhwb3J0cy5WaWRlb092ZXJsYXkgPSBWaWRlb092ZXJsYXk7XG4gIGV4cG9ydHMuYmluZCA9IGJpbmQ7XG4gIGV4cG9ydHMuYm91bmRzID0gdG9Cb3VuZHM7XG4gIGV4cG9ydHMuY2FudmFzID0gY2FudmFzO1xuICBleHBvcnRzLmNpcmNsZSA9IGNpcmNsZTtcbiAgZXhwb3J0cy5jaXJjbGVNYXJrZXIgPSBjaXJjbGVNYXJrZXI7XG4gIGV4cG9ydHMuY29udHJvbCA9IGNvbnRyb2w7XG4gIGV4cG9ydHMuZGl2SWNvbiA9IGRpdkljb247XG4gIGV4cG9ydHMuZXh0ZW5kID0gZXh0ZW5kO1xuICBleHBvcnRzLmZlYXR1cmVHcm91cCA9IGZlYXR1cmVHcm91cDtcbiAgZXhwb3J0cy5nZW9KU09OID0gZ2VvSlNPTjtcbiAgZXhwb3J0cy5nZW9Kc29uID0gZ2VvSnNvbjtcbiAgZXhwb3J0cy5ncmlkTGF5ZXIgPSBncmlkTGF5ZXI7XG4gIGV4cG9ydHMuaWNvbiA9IGljb247XG4gIGV4cG9ydHMuaW1hZ2VPdmVybGF5ID0gaW1hZ2VPdmVybGF5O1xuICBleHBvcnRzLmxhdExuZyA9IHRvTGF0TG5nO1xuICBleHBvcnRzLmxhdExuZ0JvdW5kcyA9IHRvTGF0TG5nQm91bmRzO1xuICBleHBvcnRzLmxheWVyR3JvdXAgPSBsYXllckdyb3VwO1xuICBleHBvcnRzLm1hcCA9IGNyZWF0ZU1hcDtcbiAgZXhwb3J0cy5tYXJrZXIgPSBtYXJrZXI7XG4gIGV4cG9ydHMucG9pbnQgPSB0b1BvaW50O1xuICBleHBvcnRzLnBvbHlnb24gPSBwb2x5Z29uO1xuICBleHBvcnRzLnBvbHlsaW5lID0gcG9seWxpbmU7XG4gIGV4cG9ydHMucG9wdXAgPSBwb3B1cDtcbiAgZXhwb3J0cy5yZWN0YW5nbGUgPSByZWN0YW5nbGU7XG4gIGV4cG9ydHMuc2V0T3B0aW9ucyA9IHNldE9wdGlvbnM7XG4gIGV4cG9ydHMuc3RhbXAgPSBzdGFtcDtcbiAgZXhwb3J0cy5zdmcgPSBzdmc7XG4gIGV4cG9ydHMuc3ZnT3ZlcmxheSA9IHN2Z092ZXJsYXk7XG4gIGV4cG9ydHMudGlsZUxheWVyID0gdGlsZUxheWVyO1xuICBleHBvcnRzLnRvb2x0aXAgPSB0b29sdGlwO1xuICBleHBvcnRzLnRyYW5zZm9ybWF0aW9uID0gdG9UcmFuc2Zvcm1hdGlvbjtcbiAgZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgZXhwb3J0cy52aWRlb092ZXJsYXkgPSB2aWRlb092ZXJsYXk7XG5cbiAgdmFyIG9sZEwgPSB3aW5kb3cuTDtcbiAgZXhwb3J0cy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gIFx0d2luZG93LkwgPSBvbGRMO1xuICBcdHJldHVybiB0aGlzO1xuICB9XG4gIC8vIEFsd2F5cyBleHBvcnQgdXMgdG8gd2luZG93IGdsb2JhbCAoc2VlICMyMzY0KVxuICB3aW5kb3cuTCA9IGV4cG9ydHM7XG5cbn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxlYWZsZXQtc3JjLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/leaflet/dist/leaflet-src.js\n");

/***/ }),

/***/ "./node_modules/leaflet/dist/leaflet.js":
/*!**********************************************!*\
  !*** ./node_modules/leaflet/dist/leaflet.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("/* @preserve\n * Leaflet 1.9.3, a JS library for interactive maps. https://leafletjs.com\n * (c) 2010-2022 Vladimir Agafonkin, (c) 2010-2011 CloudMade\n */\n!function(t,e){ true?e(exports):0}(this,function(t){\"use strict\";function l(t){for(var e,i,n=1,o=arguments.length;n<o;n++)for(e in i=arguments[n])t[e]=i[e];return t}var R=Object.create||function(t){return N.prototype=t,new N};function N(){}function a(t,e){var i,n=Array.prototype.slice;return t.bind?t.bind.apply(t,n.call(arguments,1)):(i=n.call(arguments,2),function(){return t.apply(e,i.length?i.concat(n.call(arguments)):arguments)})}var D=0;function h(t){return\"_leaflet_id\"in t||(t._leaflet_id=++D),t._leaflet_id}function j(t,e,i){var n,o,s=function(){n=!1,o&&(r.apply(i,o),o=!1)},r=function(){n?o=arguments:(t.apply(i,arguments),setTimeout(s,e),n=!0)};return r}function H(t,e,i){var n=e[1],e=e[0],o=n-e;return t===n&&i?t:((t-e)%o+o)%o+e}function u(){return!1}function i(t,e){return!1===e?t:(e=Math.pow(10,void 0===e?6:e),Math.round(t*e)/e)}function F(t){return t.trim?t.trim():t.replace(/^\\s+|\\s+$/g,\"\")}function W(t){return F(t).split(/\\s+/)}function c(t,e){for(var i in Object.prototype.hasOwnProperty.call(t,\"options\")||(t.options=t.options?R(t.options):{}),e)t.options[i]=e[i];return t.options}function U(t,e,i){var n,o=[];for(n in t)o.push(encodeURIComponent(i?n.toUpperCase():n)+\"=\"+encodeURIComponent(t[n]));return(e&&-1!==e.indexOf(\"?\")?\"&\":\"?\")+o.join(\"&\")}var V=/\\{ *([\\w_ -]+) *\\}/g;function q(t,i){return t.replace(V,function(t,e){e=i[e];if(void 0===e)throw new Error(\"No value provided for variable \"+t);return e=\"function\"==typeof e?e(i):e})}var d=Array.isArray||function(t){return\"[object Array]\"===Object.prototype.toString.call(t)};function G(t,e){for(var i=0;i<t.length;i++)if(t[i]===e)return i;return-1}var K=\"data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=\";function Y(t){return window[\"webkit\"+t]||window[\"moz\"+t]||window[\"ms\"+t]}var X=0;function J(t){var e=+new Date,i=Math.max(0,16-(e-X));return X=e+i,window.setTimeout(t,i)}var $=window.requestAnimationFrame||Y(\"RequestAnimationFrame\")||J,Q=window.cancelAnimationFrame||Y(\"CancelAnimationFrame\")||Y(\"CancelRequestAnimationFrame\")||function(t){window.clearTimeout(t)};function x(t,e,i){if(!i||$!==J)return $.call(window,a(t,e));t.call(e)}function r(t){t&&Q.call(window,t)}var tt={__proto__:null,extend:l,create:R,bind:a,get lastId(){return D},stamp:h,throttle:j,wrapNum:H,falseFn:u,formatNum:i,trim:F,splitWords:W,setOptions:c,getParamString:U,template:q,isArray:d,indexOf:G,emptyImageUrl:K,requestFn:$,cancelFn:Q,requestAnimFrame:x,cancelAnimFrame:r};function et(){}et.extend=function(t){function e(){c(this),this.initialize&&this.initialize.apply(this,arguments),this.callInitHooks()}var i,n=e.__super__=this.prototype,o=R(n);for(i in(o.constructor=e).prototype=o,this)Object.prototype.hasOwnProperty.call(this,i)&&\"prototype\"!==i&&\"__super__\"!==i&&(e[i]=this[i]);if(t.statics&&l(e,t.statics),t.includes){var s=t.includes;if(\"undefined\"!=typeof L&&L&&L.Mixin){s=d(s)?s:[s];for(var r=0;r<s.length;r++)s[r]===L.Mixin.Events&&console.warn(\"Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.\",(new Error).stack)}l.apply(null,[o].concat(t.includes))}return l(o,t),delete o.statics,delete o.includes,o.options&&(o.options=n.options?R(n.options):{},l(o.options,t.options)),o._initHooks=[],o.callInitHooks=function(){if(!this._initHooksCalled){n.callInitHooks&&n.callInitHooks.call(this),this._initHooksCalled=!0;for(var t=0,e=o._initHooks.length;t<e;t++)o._initHooks[t].call(this)}},e},et.include=function(t){var e=this.prototype.options;return l(this.prototype,t),t.options&&(this.prototype.options=e,this.mergeOptions(t.options)),this},et.mergeOptions=function(t){return l(this.prototype.options,t),this},et.addInitHook=function(t){var e=Array.prototype.slice.call(arguments,1),i=\"function\"==typeof t?t:function(){this[t].apply(this,e)};return this.prototype._initHooks=this.prototype._initHooks||[],this.prototype._initHooks.push(i),this};var e={on:function(t,e,i){if(\"object\"==typeof t)for(var n in t)this._on(n,t[n],e);else for(var o=0,s=(t=W(t)).length;o<s;o++)this._on(t[o],e,i);return this},off:function(t,e,i){if(arguments.length)if(\"object\"==typeof t)for(var n in t)this._off(n,t[n],e);else{t=W(t);for(var o=1===arguments.length,s=0,r=t.length;s<r;s++)o?this._off(t[s]):this._off(t[s],e,i)}else delete this._events;return this},_on:function(t,e,i,n){\"function\"!=typeof e?console.warn(\"wrong listener type: \"+typeof e):!1===this._listens(t,e,i)&&(e={fn:e,ctx:i=i===this?void 0:i},n&&(e.once=!0),this._events=this._events||{},this._events[t]=this._events[t]||[],this._events[t].push(e))},_off:function(t,e,i){var n,o,s;if(this._events&&(n=this._events[t]))if(1===arguments.length){if(this._firingCount)for(o=0,s=n.length;o<s;o++)n[o].fn=u;delete this._events[t]}else\"function\"!=typeof e?console.warn(\"wrong listener type: \"+typeof e):!1!==(e=this._listens(t,e,i))&&(i=n[e],this._firingCount&&(i.fn=u,this._events[t]=n=n.slice()),n.splice(e,1))},fire:function(t,e,i){if(this.listens(t,i)){var n=l({},e,{type:t,target:this,sourceTarget:e&&e.sourceTarget||this});if(this._events){var o=this._events[t];if(o){this._firingCount=this._firingCount+1||1;for(var s=0,r=o.length;s<r;s++){var a=o[s],h=a.fn;a.once&&this.off(t,h,a.ctx),h.call(a.ctx||this,n)}this._firingCount--}}i&&this._propagateEvent(n)}return this},listens:function(t,e,i,n){\"string\"!=typeof t&&console.warn('\"string\" type argument expected');var o=e,s=(\"function\"!=typeof e&&(n=!!e,i=o=void 0),this._events&&this._events[t]);if(s&&s.length&&!1!==this._listens(t,o,i))return!0;if(n)for(var r in this._eventParents)if(this._eventParents[r].listens(t,e,i,n))return!0;return!1},_listens:function(t,e,i){if(this._events){var n=this._events[t]||[];if(!e)return!!n.length;i===this&&(i=void 0);for(var o=0,s=n.length;o<s;o++)if(n[o].fn===e&&n[o].ctx===i)return o}return!1},once:function(t,e,i){if(\"object\"==typeof t)for(var n in t)this._on(n,t[n],e,!0);else for(var o=0,s=(t=W(t)).length;o<s;o++)this._on(t[o],e,i,!0);return this},addEventParent:function(t){return this._eventParents=this._eventParents||{},this._eventParents[h(t)]=t,this},removeEventParent:function(t){return this._eventParents&&delete this._eventParents[h(t)],this},_propagateEvent:function(t){for(var e in this._eventParents)this._eventParents[e].fire(t.type,l({layer:t.target,propagatedFrom:t.target},t),!0)}},it=(e.addEventListener=e.on,e.removeEventListener=e.clearAllEventListeners=e.off,e.addOneTimeEventListener=e.once,e.fireEvent=e.fire,e.hasEventListeners=e.listens,et.extend(e));function p(t,e,i){this.x=i?Math.round(t):t,this.y=i?Math.round(e):e}var nt=Math.trunc||function(t){return 0<t?Math.floor(t):Math.ceil(t)};function m(t,e,i){return t instanceof p?t:d(t)?new p(t[0],t[1]):null==t?t:\"object\"==typeof t&&\"x\"in t&&\"y\"in t?new p(t.x,t.y):new p(t,e,i)}function f(t,e){if(t)for(var i=e?[t,e]:t,n=0,o=i.length;n<o;n++)this.extend(i[n])}function _(t,e){return!t||t instanceof f?t:new f(t,e)}function s(t,e){if(t)for(var i=e?[t,e]:t,n=0,o=i.length;n<o;n++)this.extend(i[n])}function g(t,e){return t instanceof s?t:new s(t,e)}function v(t,e,i){if(isNaN(t)||isNaN(e))throw new Error(\"Invalid LatLng object: (\"+t+\", \"+e+\")\");this.lat=+t,this.lng=+e,void 0!==i&&(this.alt=+i)}function w(t,e,i){return t instanceof v?t:d(t)&&\"object\"!=typeof t[0]?3===t.length?new v(t[0],t[1],t[2]):2===t.length?new v(t[0],t[1]):null:null==t?t:\"object\"==typeof t&&\"lat\"in t?new v(t.lat,\"lng\"in t?t.lng:t.lon,t.alt):void 0===e?null:new v(t,e,i)}p.prototype={clone:function(){return new p(this.x,this.y)},add:function(t){return this.clone()._add(m(t))},_add:function(t){return this.x+=t.x,this.y+=t.y,this},subtract:function(t){return this.clone()._subtract(m(t))},_subtract:function(t){return this.x-=t.x,this.y-=t.y,this},divideBy:function(t){return this.clone()._divideBy(t)},_divideBy:function(t){return this.x/=t,this.y/=t,this},multiplyBy:function(t){return this.clone()._multiplyBy(t)},_multiplyBy:function(t){return this.x*=t,this.y*=t,this},scaleBy:function(t){return new p(this.x*t.x,this.y*t.y)},unscaleBy:function(t){return new p(this.x/t.x,this.y/t.y)},round:function(){return this.clone()._round()},_round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this},floor:function(){return this.clone()._floor()},_floor:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this},ceil:function(){return this.clone()._ceil()},_ceil:function(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this},trunc:function(){return this.clone()._trunc()},_trunc:function(){return this.x=nt(this.x),this.y=nt(this.y),this},distanceTo:function(t){var e=(t=m(t)).x-this.x,t=t.y-this.y;return Math.sqrt(e*e+t*t)},equals:function(t){return(t=m(t)).x===this.x&&t.y===this.y},contains:function(t){return t=m(t),Math.abs(t.x)<=Math.abs(this.x)&&Math.abs(t.y)<=Math.abs(this.y)},toString:function(){return\"Point(\"+i(this.x)+\", \"+i(this.y)+\")\"}},f.prototype={extend:function(t){var e,i;if(t){if(t instanceof p||\"number\"==typeof t[0]||\"x\"in t)e=i=m(t);else if(e=(t=_(t)).min,i=t.max,!e||!i)return this;this.min||this.max?(this.min.x=Math.min(e.x,this.min.x),this.max.x=Math.max(i.x,this.max.x),this.min.y=Math.min(e.y,this.min.y),this.max.y=Math.max(i.y,this.max.y)):(this.min=e.clone(),this.max=i.clone())}return this},getCenter:function(t){return m((this.min.x+this.max.x)/2,(this.min.y+this.max.y)/2,t)},getBottomLeft:function(){return m(this.min.x,this.max.y)},getTopRight:function(){return m(this.max.x,this.min.y)},getTopLeft:function(){return this.min},getBottomRight:function(){return this.max},getSize:function(){return this.max.subtract(this.min)},contains:function(t){var e,i;return(t=(\"number\"==typeof t[0]||t instanceof p?m:_)(t))instanceof f?(e=t.min,i=t.max):e=i=t,e.x>=this.min.x&&i.x<=this.max.x&&e.y>=this.min.y&&i.y<=this.max.y},intersects:function(t){t=_(t);var e=this.min,i=this.max,n=t.min,t=t.max,o=t.x>=e.x&&n.x<=i.x,t=t.y>=e.y&&n.y<=i.y;return o&&t},overlaps:function(t){t=_(t);var e=this.min,i=this.max,n=t.min,t=t.max,o=t.x>e.x&&n.x<i.x,t=t.y>e.y&&n.y<i.y;return o&&t},isValid:function(){return!(!this.min||!this.max)},pad:function(t){var e=this.min,i=this.max,n=Math.abs(e.x-i.x)*t,t=Math.abs(e.y-i.y)*t;return _(m(e.x-n,e.y-t),m(i.x+n,i.y+t))},equals:function(t){return!!t&&(t=_(t),this.min.equals(t.getTopLeft())&&this.max.equals(t.getBottomRight()))}},s.prototype={extend:function(t){var e,i,n=this._southWest,o=this._northEast;if(t instanceof v)i=e=t;else{if(!(t instanceof s))return t?this.extend(w(t)||g(t)):this;if(e=t._southWest,i=t._northEast,!e||!i)return this}return n||o?(n.lat=Math.min(e.lat,n.lat),n.lng=Math.min(e.lng,n.lng),o.lat=Math.max(i.lat,o.lat),o.lng=Math.max(i.lng,o.lng)):(this._southWest=new v(e.lat,e.lng),this._northEast=new v(i.lat,i.lng)),this},pad:function(t){var e=this._southWest,i=this._northEast,n=Math.abs(e.lat-i.lat)*t,t=Math.abs(e.lng-i.lng)*t;return new s(new v(e.lat-n,e.lng-t),new v(i.lat+n,i.lng+t))},getCenter:function(){return new v((this._southWest.lat+this._northEast.lat)/2,(this._southWest.lng+this._northEast.lng)/2)},getSouthWest:function(){return this._southWest},getNorthEast:function(){return this._northEast},getNorthWest:function(){return new v(this.getNorth(),this.getWest())},getSouthEast:function(){return new v(this.getSouth(),this.getEast())},getWest:function(){return this._southWest.lng},getSouth:function(){return this._southWest.lat},getEast:function(){return this._northEast.lng},getNorth:function(){return this._northEast.lat},contains:function(t){t=(\"number\"==typeof t[0]||t instanceof v||\"lat\"in t?w:g)(t);var e,i,n=this._southWest,o=this._northEast;return t instanceof s?(e=t.getSouthWest(),i=t.getNorthEast()):e=i=t,e.lat>=n.lat&&i.lat<=o.lat&&e.lng>=n.lng&&i.lng<=o.lng},intersects:function(t){t=g(t);var e=this._southWest,i=this._northEast,n=t.getSouthWest(),t=t.getNorthEast(),o=t.lat>=e.lat&&n.lat<=i.lat,t=t.lng>=e.lng&&n.lng<=i.lng;return o&&t},overlaps:function(t){t=g(t);var e=this._southWest,i=this._northEast,n=t.getSouthWest(),t=t.getNorthEast(),o=t.lat>e.lat&&n.lat<i.lat,t=t.lng>e.lng&&n.lng<i.lng;return o&&t},toBBoxString:function(){return[this.getWest(),this.getSouth(),this.getEast(),this.getNorth()].join(\",\")},equals:function(t,e){return!!t&&(t=g(t),this._southWest.equals(t.getSouthWest(),e)&&this._northEast.equals(t.getNorthEast(),e))},isValid:function(){return!(!this._southWest||!this._northEast)}};var ot={latLngToPoint:function(t,e){t=this.projection.project(t),e=this.scale(e);return this.transformation._transform(t,e)},pointToLatLng:function(t,e){e=this.scale(e),t=this.transformation.untransform(t,e);return this.projection.unproject(t)},project:function(t){return this.projection.project(t)},unproject:function(t){return this.projection.unproject(t)},scale:function(t){return 256*Math.pow(2,t)},zoom:function(t){return Math.log(t/256)/Math.LN2},getProjectedBounds:function(t){var e;return this.infinite?null:(e=this.projection.bounds,t=this.scale(t),new f(this.transformation.transform(e.min,t),this.transformation.transform(e.max,t)))},infinite:!(v.prototype={equals:function(t,e){return!!t&&(t=w(t),Math.max(Math.abs(this.lat-t.lat),Math.abs(this.lng-t.lng))<=(void 0===e?1e-9:e))},toString:function(t){return\"LatLng(\"+i(this.lat,t)+\", \"+i(this.lng,t)+\")\"},distanceTo:function(t){return st.distance(this,w(t))},wrap:function(){return st.wrapLatLng(this)},toBounds:function(t){var t=180*t/40075017,e=t/Math.cos(Math.PI/180*this.lat);return g([this.lat-t,this.lng-e],[this.lat+t,this.lng+e])},clone:function(){return new v(this.lat,this.lng,this.alt)}}),wrapLatLng:function(t){var e=this.wrapLng?H(t.lng,this.wrapLng,!0):t.lng;return new v(this.wrapLat?H(t.lat,this.wrapLat,!0):t.lat,e,t.alt)},wrapLatLngBounds:function(t){var e=t.getCenter(),i=this.wrapLatLng(e),n=e.lat-i.lat,e=e.lng-i.lng;return 0==n&&0==e?t:(i=t.getSouthWest(),t=t.getNorthEast(),new s(new v(i.lat-n,i.lng-e),new v(t.lat-n,t.lng-e)))}},st=l({},ot,{wrapLng:[-180,180],R:6371e3,distance:function(t,e){var i=Math.PI/180,n=t.lat*i,o=e.lat*i,s=Math.sin((e.lat-t.lat)*i/2),e=Math.sin((e.lng-t.lng)*i/2),t=s*s+Math.cos(n)*Math.cos(o)*e*e,i=2*Math.atan2(Math.sqrt(t),Math.sqrt(1-t));return this.R*i}}),rt=6378137,rt={R:rt,MAX_LATITUDE:85.0511287798,project:function(t){var e=Math.PI/180,i=this.MAX_LATITUDE,i=Math.max(Math.min(i,t.lat),-i),i=Math.sin(i*e);return new p(this.R*t.lng*e,this.R*Math.log((1+i)/(1-i))/2)},unproject:function(t){var e=180/Math.PI;return new v((2*Math.atan(Math.exp(t.y/this.R))-Math.PI/2)*e,t.x*e/this.R)},bounds:new f([-(rt=rt*Math.PI),-rt],[rt,rt])};function at(t,e,i,n){d(t)?(this._a=t[0],this._b=t[1],this._c=t[2],this._d=t[3]):(this._a=t,this._b=e,this._c=i,this._d=n)}function ht(t,e,i,n){return new at(t,e,i,n)}at.prototype={transform:function(t,e){return this._transform(t.clone(),e)},_transform:function(t,e){return t.x=(e=e||1)*(this._a*t.x+this._b),t.y=e*(this._c*t.y+this._d),t},untransform:function(t,e){return new p((t.x/(e=e||1)-this._b)/this._a,(t.y/e-this._d)/this._c)}};var lt=l({},st,{code:\"EPSG:3857\",projection:rt,transformation:ht(lt=.5/(Math.PI*rt.R),.5,-lt,.5)}),ut=l({},lt,{code:\"EPSG:900913\"});function ct(t){return document.createElementNS(\"http://www.w3.org/2000/svg\",t)}function dt(t,e){for(var i,n,o,s,r=\"\",a=0,h=t.length;a<h;a++){for(i=0,n=(o=t[a]).length;i<n;i++)r+=(i?\"L\":\"M\")+(s=o[i]).x+\" \"+s.y;r+=e?b.svg?\"z\":\"x\":\"\"}return r||\"M0 0\"}var _t=document.documentElement.style,pt=\"ActiveXObject\"in window,mt=pt&&!document.addEventListener,n=\"msLaunchUri\"in navigator&&!(\"documentMode\"in document),ft=y(\"webkit\"),gt=y(\"android\"),vt=y(\"android 2\")||y(\"android 3\"),yt=parseInt(/WebKit\\/([0-9]+)|$/.exec(navigator.userAgent)[1],10),yt=gt&&y(\"Google\")&&yt<537&&!(\"AudioNode\"in window),xt=!!window.opera,wt=!n&&y(\"chrome\"),bt=y(\"gecko\")&&!ft&&!xt&&!pt,Pt=!wt&&y(\"safari\"),Lt=y(\"phantom\"),o=\"OTransition\"in _t,Tt=0===navigator.platform.indexOf(\"Win\"),Mt=pt&&\"transition\"in _t,zt=\"WebKitCSSMatrix\"in window&&\"m11\"in new window.WebKitCSSMatrix&&!vt,_t=\"MozPerspective\"in _t,Ct=!window.L_DISABLE_3D&&(Mt||zt||_t)&&!o&&!Lt,Zt=\"undefined\"!=typeof orientation||y(\"mobile\"),St=Zt&&ft,Et=Zt&&zt,kt=!window.PointerEvent&&window.MSPointerEvent,Ot=!(!window.PointerEvent&&!kt),At=\"ontouchstart\"in window||!!window.TouchEvent,Bt=!window.L_NO_TOUCH&&(At||Ot),It=Zt&&xt,Rt=Zt&&bt,Nt=1<(window.devicePixelRatio||window.screen.deviceXDPI/window.screen.logicalXDPI),Dt=function(){var t=!1;try{var e=Object.defineProperty({},\"passive\",{get:function(){t=!0}});window.addEventListener(\"testPassiveEventSupport\",u,e),window.removeEventListener(\"testPassiveEventSupport\",u,e)}catch(t){}return t}(),jt=!!document.createElement(\"canvas\").getContext,Ht=!(!document.createElementNS||!ct(\"svg\").createSVGRect),Ft=!!Ht&&((Ft=document.createElement(\"div\")).innerHTML=\"<svg/>\",\"http://www.w3.org/2000/svg\"===(Ft.firstChild&&Ft.firstChild.namespaceURI));function y(t){return 0<=navigator.userAgent.toLowerCase().indexOf(t)}var b={ie:pt,ielt9:mt,edge:n,webkit:ft,android:gt,android23:vt,androidStock:yt,opera:xt,chrome:wt,gecko:bt,safari:Pt,phantom:Lt,opera12:o,win:Tt,ie3d:Mt,webkit3d:zt,gecko3d:_t,any3d:Ct,mobile:Zt,mobileWebkit:St,mobileWebkit3d:Et,msPointer:kt,pointer:Ot,touch:Bt,touchNative:At,mobileOpera:It,mobileGecko:Rt,retina:Nt,passiveEvents:Dt,canvas:jt,svg:Ht,vml:!Ht&&function(){try{var t=document.createElement(\"div\"),e=(t.innerHTML='<v:shape adj=\"1\"/>',t.firstChild);return e.style.behavior=\"url(#default#VML)\",e&&\"object\"==typeof e.adj}catch(t){return!1}}(),inlineSvg:Ft,mac:0===navigator.platform.indexOf(\"Mac\"),linux:0===navigator.platform.indexOf(\"Linux\")},Wt=b.msPointer?\"MSPointerDown\":\"pointerdown\",Ut=b.msPointer?\"MSPointerMove\":\"pointermove\",Vt=b.msPointer?\"MSPointerUp\":\"pointerup\",qt=b.msPointer?\"MSPointerCancel\":\"pointercancel\",Gt={touchstart:Wt,touchmove:Ut,touchend:Vt,touchcancel:qt},Kt={touchstart:function(t,e){e.MSPOINTER_TYPE_TOUCH&&e.pointerType===e.MSPOINTER_TYPE_TOUCH&&O(e);ee(t,e)},touchmove:ee,touchend:ee,touchcancel:ee},Yt={},Xt=!1;function Jt(t,e,i){return\"touchstart\"!==e||Xt||(document.addEventListener(Wt,$t,!0),document.addEventListener(Ut,Qt,!0),document.addEventListener(Vt,te,!0),document.addEventListener(qt,te,!0),Xt=!0),Kt[e]?(i=Kt[e].bind(this,i),t.addEventListener(Gt[e],i,!1),i):(console.warn(\"wrong event specified:\",e),u)}function $t(t){Yt[t.pointerId]=t}function Qt(t){Yt[t.pointerId]&&(Yt[t.pointerId]=t)}function te(t){delete Yt[t.pointerId]}function ee(t,e){if(e.pointerType!==(e.MSPOINTER_TYPE_MOUSE||\"mouse\")){for(var i in e.touches=[],Yt)e.touches.push(Yt[i]);e.changedTouches=[e],t(e)}}var ie=200;function ne(t,i){t.addEventListener(\"dblclick\",i);var n,o=0;function e(t){var e;1!==t.detail?n=t.detail:\"mouse\"===t.pointerType||t.sourceCapabilities&&!t.sourceCapabilities.firesTouchEvents||((e=Ne(t)).some(function(t){return t instanceof HTMLLabelElement&&t.attributes.for})&&!e.some(function(t){return t instanceof HTMLInputElement||t instanceof HTMLSelectElement})||((e=Date.now())-o<=ie?2===++n&&i(function(t){var e,i,n={};for(i in t)e=t[i],n[i]=e&&e.bind?e.bind(t):e;return(t=n).type=\"dblclick\",n.detail=2,n.isTrusted=!1,n._simulated=!0,n}(t)):n=1,o=e))}return t.addEventListener(\"click\",e),{dblclick:i,simDblclick:e}}var oe,se,re,ae,he,le,ue=we([\"transform\",\"webkitTransform\",\"OTransform\",\"MozTransform\",\"msTransform\"]),ce=we([\"webkitTransition\",\"transition\",\"OTransition\",\"MozTransition\",\"msTransition\"]),de=\"webkitTransition\"===ce||\"OTransition\"===ce?ce+\"End\":\"transitionend\";function _e(t){return\"string\"==typeof t?document.getElementById(t):t}function pe(t,e){var i=t.style[e]||t.currentStyle&&t.currentStyle[e];return\"auto\"===(i=i&&\"auto\"!==i||!document.defaultView?i:(t=document.defaultView.getComputedStyle(t,null))?t[e]:null)?null:i}function P(t,e,i){t=document.createElement(t);return t.className=e||\"\",i&&i.appendChild(t),t}function T(t){var e=t.parentNode;e&&e.removeChild(t)}function me(t){for(;t.firstChild;)t.removeChild(t.firstChild)}function fe(t){var e=t.parentNode;e&&e.lastChild!==t&&e.appendChild(t)}function ge(t){var e=t.parentNode;e&&e.firstChild!==t&&e.insertBefore(t,e.firstChild)}function ve(t,e){return void 0!==t.classList?t.classList.contains(e):0<(t=xe(t)).length&&new RegExp(\"(^|\\\\s)\"+e+\"(\\\\s|$)\").test(t)}function M(t,e){var i;if(void 0!==t.classList)for(var n=W(e),o=0,s=n.length;o<s;o++)t.classList.add(n[o]);else ve(t,e)||ye(t,((i=xe(t))?i+\" \":\"\")+e)}function z(t,e){void 0!==t.classList?t.classList.remove(e):ye(t,F((\" \"+xe(t)+\" \").replace(\" \"+e+\" \",\" \")))}function ye(t,e){void 0===t.className.baseVal?t.className=e:t.className.baseVal=e}function xe(t){return void 0===(t=t.correspondingElement?t.correspondingElement:t).className.baseVal?t.className:t.className.baseVal}function C(t,e){if(\"opacity\"in t.style)t.style.opacity=e;else if(\"filter\"in t.style){var i=!1,n=\"DXImageTransform.Microsoft.Alpha\";try{i=t.filters.item(n)}catch(t){if(1===e)return}e=Math.round(100*e),i?(i.Enabled=100!==e,i.Opacity=e):t.style.filter+=\" progid:\"+n+\"(opacity=\"+e+\")\"}}function we(t){for(var e=document.documentElement.style,i=0;i<t.length;i++)if(t[i]in e)return t[i];return!1}function be(t,e,i){e=e||new p(0,0);t.style[ue]=(b.ie3d?\"translate(\"+e.x+\"px,\"+e.y+\"px)\":\"translate3d(\"+e.x+\"px,\"+e.y+\"px,0)\")+(i?\" scale(\"+i+\")\":\"\")}function Z(t,e){t._leaflet_pos=e,b.any3d?be(t,e):(t.style.left=e.x+\"px\",t.style.top=e.y+\"px\")}function Pe(t){return t._leaflet_pos||new p(0,0)}function Le(){S(window,\"dragstart\",O)}function Te(){k(window,\"dragstart\",O)}function Me(t){for(;-1===t.tabIndex;)t=t.parentNode;t.style&&(ze(),le=(he=t).style.outline,t.style.outline=\"none\",S(window,\"keydown\",ze))}function ze(){he&&(he.style.outline=le,le=he=void 0,k(window,\"keydown\",ze))}function Ce(t){for(;!((t=t.parentNode).offsetWidth&&t.offsetHeight||t===document.body););return t}function Ze(t){var e=t.getBoundingClientRect();return{x:e.width/t.offsetWidth||1,y:e.height/t.offsetHeight||1,boundingClientRect:e}}ae=\"onselectstart\"in document?(re=function(){S(window,\"selectstart\",O)},function(){k(window,\"selectstart\",O)}):(se=we([\"userSelect\",\"WebkitUserSelect\",\"OUserSelect\",\"MozUserSelect\",\"msUserSelect\"]),re=function(){var t;se&&(t=document.documentElement.style,oe=t[se],t[se]=\"none\")},function(){se&&(document.documentElement.style[se]=oe,oe=void 0)});pt={__proto__:null,TRANSFORM:ue,TRANSITION:ce,TRANSITION_END:de,get:_e,getStyle:pe,create:P,remove:T,empty:me,toFront:fe,toBack:ge,hasClass:ve,addClass:M,removeClass:z,setClass:ye,getClass:xe,setOpacity:C,testProp:we,setTransform:be,setPosition:Z,getPosition:Pe,get disableTextSelection(){return re},get enableTextSelection(){return ae},disableImageDrag:Le,enableImageDrag:Te,preventOutline:Me,restoreOutline:ze,getSizedParentNode:Ce,getScale:Ze};function S(t,e,i,n){if(e&&\"object\"==typeof e)for(var o in e)ke(t,o,e[o],i);else for(var s=0,r=(e=W(e)).length;s<r;s++)ke(t,e[s],i,n);return this}var E=\"_leaflet_events\";function k(t,e,i,n){if(1===arguments.length)Se(t),delete t[E];else if(e&&\"object\"==typeof e)for(var o in e)Oe(t,o,e[o],i);else if(e=W(e),2===arguments.length)Se(t,function(t){return-1!==G(e,t)});else for(var s=0,r=e.length;s<r;s++)Oe(t,e[s],i,n);return this}function Se(t,e){for(var i in t[E]){var n=i.split(/\\d/)[0];e&&!e(n)||Oe(t,n,null,null,i)}}var Ee={mouseenter:\"mouseover\",mouseleave:\"mouseout\",wheel:!(\"onwheel\"in window)&&\"mousewheel\"};function ke(e,t,i,n){var o,s,r=t+h(i)+(n?\"_\"+h(n):\"\");e[E]&&e[E][r]||(s=o=function(t){return i.call(n||e,t||window.event)},!b.touchNative&&b.pointer&&0===t.indexOf(\"touch\")?o=Jt(e,t,o):b.touch&&\"dblclick\"===t?o=ne(e,o):\"addEventListener\"in e?\"touchstart\"===t||\"touchmove\"===t||\"wheel\"===t||\"mousewheel\"===t?e.addEventListener(Ee[t]||t,o,!!b.passiveEvents&&{passive:!1}):\"mouseenter\"===t||\"mouseleave\"===t?e.addEventListener(Ee[t],o=function(t){t=t||window.event,Fe(e,t)&&s(t)},!1):e.addEventListener(t,s,!1):e.attachEvent(\"on\"+t,o),e[E]=e[E]||{},e[E][r]=o)}function Oe(t,e,i,n,o){o=o||e+h(i)+(n?\"_\"+h(n):\"\");var s,r,i=t[E]&&t[E][o];i&&(!b.touchNative&&b.pointer&&0===e.indexOf(\"touch\")?(n=t,r=i,Gt[s=e]?n.removeEventListener(Gt[s],r,!1):console.warn(\"wrong event specified:\",s)):b.touch&&\"dblclick\"===e?(n=i,(r=t).removeEventListener(\"dblclick\",n.dblclick),r.removeEventListener(\"click\",n.simDblclick)):\"removeEventListener\"in t?t.removeEventListener(Ee[e]||e,i,!1):t.detachEvent(\"on\"+e,i),t[E][o]=null)}function Ae(t){return t.stopPropagation?t.stopPropagation():t.originalEvent?t.originalEvent._stopped=!0:t.cancelBubble=!0,this}function Be(t){return ke(t,\"wheel\",Ae),this}function Ie(t){return S(t,\"mousedown touchstart dblclick contextmenu\",Ae),t._leaflet_disable_click=!0,this}function O(t){return t.preventDefault?t.preventDefault():t.returnValue=!1,this}function Re(t){return O(t),Ae(t),this}function Ne(t){if(t.composedPath)return t.composedPath();for(var e=[],i=t.target;i;)e.push(i),i=i.parentNode;return e}function De(t,e){var i,n;return e?(n=(i=Ze(e)).boundingClientRect,new p((t.clientX-n.left)/i.x-e.clientLeft,(t.clientY-n.top)/i.y-e.clientTop)):new p(t.clientX,t.clientY)}var je=b.linux&&b.chrome?window.devicePixelRatio:b.mac?3*window.devicePixelRatio:0<window.devicePixelRatio?2*window.devicePixelRatio:1;function He(t){return b.edge?t.wheelDeltaY/2:t.deltaY&&0===t.deltaMode?-t.deltaY/je:t.deltaY&&1===t.deltaMode?20*-t.deltaY:t.deltaY&&2===t.deltaMode?60*-t.deltaY:t.deltaX||t.deltaZ?0:t.wheelDelta?(t.wheelDeltaY||t.wheelDelta)/2:t.detail&&Math.abs(t.detail)<32765?20*-t.detail:t.detail?t.detail/-32765*60:0}function Fe(t,e){var i=e.relatedTarget;if(!i)return!0;try{for(;i&&i!==t;)i=i.parentNode}catch(t){return!1}return i!==t}var mt={__proto__:null,on:S,off:k,stopPropagation:Ae,disableScrollPropagation:Be,disableClickPropagation:Ie,preventDefault:O,stop:Re,getPropagationPath:Ne,getMousePosition:De,getWheelDelta:He,isExternalTarget:Fe,addListener:S,removeListener:k},We=it.extend({run:function(t,e,i,n){this.stop(),this._el=t,this._inProgress=!0,this._duration=i||.25,this._easeOutPower=1/Math.max(n||.5,.2),this._startPos=Pe(t),this._offset=e.subtract(this._startPos),this._startTime=+new Date,this.fire(\"start\"),this._animate()},stop:function(){this._inProgress&&(this._step(!0),this._complete())},_animate:function(){this._animId=x(this._animate,this),this._step()},_step:function(t){var e=+new Date-this._startTime,i=1e3*this._duration;e<i?this._runFrame(this._easeOut(e/i),t):(this._runFrame(1),this._complete())},_runFrame:function(t,e){t=this._startPos.add(this._offset.multiplyBy(t));e&&t._round(),Z(this._el,t),this.fire(\"step\")},_complete:function(){r(this._animId),this._inProgress=!1,this.fire(\"end\")},_easeOut:function(t){return 1-Math.pow(1-t,this._easeOutPower)}}),A=it.extend({options:{crs:lt,center:void 0,zoom:void 0,minZoom:void 0,maxZoom:void 0,layers:[],maxBounds:void 0,renderer:void 0,zoomAnimation:!0,zoomAnimationThreshold:4,fadeAnimation:!0,markerZoomAnimation:!0,transform3DLimit:8388608,zoomSnap:1,zoomDelta:1,trackResize:!0},initialize:function(t,e){e=c(this,e),this._handlers=[],this._layers={},this._zoomBoundLayers={},this._sizeChanged=!0,this._initContainer(t),this._initLayout(),this._onResize=a(this._onResize,this),this._initEvents(),e.maxBounds&&this.setMaxBounds(e.maxBounds),void 0!==e.zoom&&(this._zoom=this._limitZoom(e.zoom)),e.center&&void 0!==e.zoom&&this.setView(w(e.center),e.zoom,{reset:!0}),this.callInitHooks(),this._zoomAnimated=ce&&b.any3d&&!b.mobileOpera&&this.options.zoomAnimation,this._zoomAnimated&&(this._createAnimProxy(),S(this._proxy,de,this._catchTransitionEnd,this)),this._addLayers(this.options.layers)},setView:function(t,e,i){if((e=void 0===e?this._zoom:this._limitZoom(e),t=this._limitCenter(w(t),e,this.options.maxBounds),i=i||{},this._stop(),this._loaded&&!i.reset&&!0!==i)&&(void 0!==i.animate&&(i.zoom=l({animate:i.animate},i.zoom),i.pan=l({animate:i.animate,duration:i.duration},i.pan)),this._zoom!==e?this._tryAnimatedZoom&&this._tryAnimatedZoom(t,e,i.zoom):this._tryAnimatedPan(t,i.pan)))return clearTimeout(this._sizeTimer),this;return this._resetView(t,e,i.pan&&i.pan.noMoveStart),this},setZoom:function(t,e){return this._loaded?this.setView(this.getCenter(),t,{zoom:e}):(this._zoom=t,this)},zoomIn:function(t,e){return t=t||(b.any3d?this.options.zoomDelta:1),this.setZoom(this._zoom+t,e)},zoomOut:function(t,e){return t=t||(b.any3d?this.options.zoomDelta:1),this.setZoom(this._zoom-t,e)},setZoomAround:function(t,e,i){var n=this.getZoomScale(e),o=this.getSize().divideBy(2),t=(t instanceof p?t:this.latLngToContainerPoint(t)).subtract(o).multiplyBy(1-1/n),n=this.containerPointToLatLng(o.add(t));return this.setView(n,e,{zoom:i})},_getBoundsCenterZoom:function(t,e){e=e||{},t=t.getBounds?t.getBounds():g(t);var i=m(e.paddingTopLeft||e.padding||[0,0]),n=m(e.paddingBottomRight||e.padding||[0,0]),o=this.getBoundsZoom(t,!1,i.add(n));return(o=\"number\"==typeof e.maxZoom?Math.min(e.maxZoom,o):o)===1/0?{center:t.getCenter(),zoom:o}:(e=n.subtract(i).divideBy(2),n=this.project(t.getSouthWest(),o),i=this.project(t.getNorthEast(),o),{center:this.unproject(n.add(i).divideBy(2).add(e),o),zoom:o})},fitBounds:function(t,e){if((t=g(t)).isValid())return t=this._getBoundsCenterZoom(t,e),this.setView(t.center,t.zoom,e);throw new Error(\"Bounds are not valid.\")},fitWorld:function(t){return this.fitBounds([[-90,-180],[90,180]],t)},panTo:function(t,e){return this.setView(t,this._zoom,{pan:e})},panBy:function(t,e){var i;return e=e||{},(t=m(t).round()).x||t.y?(!0===e.animate||this.getSize().contains(t)?(this._panAnim||(this._panAnim=new We,this._panAnim.on({step:this._onPanTransitionStep,end:this._onPanTransitionEnd},this)),e.noMoveStart||this.fire(\"movestart\"),!1!==e.animate?(M(this._mapPane,\"leaflet-pan-anim\"),i=this._getMapPanePos().subtract(t).round(),this._panAnim.run(this._mapPane,i,e.duration||.25,e.easeLinearity)):(this._rawPanBy(t),this.fire(\"move\").fire(\"moveend\"))):this._resetView(this.unproject(this.project(this.getCenter()).add(t)),this.getZoom()),this):this.fire(\"moveend\")},flyTo:function(n,o,t){if(!1===(t=t||{}).animate||!b.any3d)return this.setView(n,o,t);this._stop();var s=this.project(this.getCenter()),r=this.project(n),e=this.getSize(),a=this._zoom,h=(n=w(n),o=void 0===o?a:o,Math.max(e.x,e.y)),i=h*this.getZoomScale(a,o),l=r.distanceTo(s)||1,u=1.42,c=u*u;function d(t){t=(i*i-h*h+(t?-1:1)*c*c*l*l)/(2*(t?i:h)*c*l),t=Math.sqrt(t*t+1)-t;return t<1e-9?-18:Math.log(t)}function _(t){return(Math.exp(t)-Math.exp(-t))/2}function p(t){return(Math.exp(t)+Math.exp(-t))/2}var m=d(0);function f(t){return h*(p(m)*(_(t=m+u*t)/p(t))-_(m))/c}var g=Date.now(),v=(d(1)-m)/u,y=t.duration?1e3*t.duration:1e3*v*.8;return this._moveStart(!0,t.noMoveStart),function t(){var e=(Date.now()-g)/y,i=(1-Math.pow(1-e,1.5))*v;e<=1?(this._flyToFrame=x(t,this),this._move(this.unproject(s.add(r.subtract(s).multiplyBy(f(i)/l)),a),this.getScaleZoom(h/(e=i,h*(p(m)/p(m+u*e))),a),{flyTo:!0})):this._move(n,o)._moveEnd(!0)}.call(this),this},flyToBounds:function(t,e){t=this._getBoundsCenterZoom(t,e);return this.flyTo(t.center,t.zoom,e)},setMaxBounds:function(t){return t=g(t),this.listens(\"moveend\",this._panInsideMaxBounds)&&this.off(\"moveend\",this._panInsideMaxBounds),t.isValid()?(this.options.maxBounds=t,this._loaded&&this._panInsideMaxBounds(),this.on(\"moveend\",this._panInsideMaxBounds)):(this.options.maxBounds=null,this)},setMinZoom:function(t){var e=this.options.minZoom;return this.options.minZoom=t,this._loaded&&e!==t&&(this.fire(\"zoomlevelschange\"),this.getZoom()<this.options.minZoom)?this.setZoom(t):this},setMaxZoom:function(t){var e=this.options.maxZoom;return this.options.maxZoom=t,this._loaded&&e!==t&&(this.fire(\"zoomlevelschange\"),this.getZoom()>this.options.maxZoom)?this.setZoom(t):this},panInsideBounds:function(t,e){this._enforcingBounds=!0;var i=this.getCenter(),t=this._limitCenter(i,this._zoom,g(t));return i.equals(t)||this.panTo(t,e),this._enforcingBounds=!1,this},panInside:function(t,e){var i=m((e=e||{}).paddingTopLeft||e.padding||[0,0]),n=m(e.paddingBottomRight||e.padding||[0,0]),o=this.project(this.getCenter()),t=this.project(t),s=this.getPixelBounds(),i=_([s.min.add(i),s.max.subtract(n)]),s=i.getSize();return i.contains(t)||(this._enforcingBounds=!0,n=t.subtract(i.getCenter()),i=i.extend(t).getSize().subtract(s),o.x+=n.x<0?-i.x:i.x,o.y+=n.y<0?-i.y:i.y,this.panTo(this.unproject(o),e),this._enforcingBounds=!1),this},invalidateSize:function(t){if(!this._loaded)return this;t=l({animate:!1,pan:!0},!0===t?{animate:!0}:t);var e=this.getSize(),i=(this._sizeChanged=!0,this._lastCenter=null,this.getSize()),n=e.divideBy(2).round(),o=i.divideBy(2).round(),n=n.subtract(o);return n.x||n.y?(t.animate&&t.pan?this.panBy(n):(t.pan&&this._rawPanBy(n),this.fire(\"move\"),t.debounceMoveend?(clearTimeout(this._sizeTimer),this._sizeTimer=setTimeout(a(this.fire,this,\"moveend\"),200)):this.fire(\"moveend\")),this.fire(\"resize\",{oldSize:e,newSize:i})):this},stop:function(){return this.setZoom(this._limitZoom(this._zoom)),this.options.zoomSnap||this.fire(\"viewreset\"),this._stop()},locate:function(t){var e,i;return t=this._locateOptions=l({timeout:1e4,watch:!1},t),\"geolocation\"in navigator?(e=a(this._handleGeolocationResponse,this),i=a(this._handleGeolocationError,this),t.watch?this._locationWatchId=navigator.geolocation.watchPosition(e,i,t):navigator.geolocation.getCurrentPosition(e,i,t)):this._handleGeolocationError({code:0,message:\"Geolocation not supported.\"}),this},stopLocate:function(){return navigator.geolocation&&navigator.geolocation.clearWatch&&navigator.geolocation.clearWatch(this._locationWatchId),this._locateOptions&&(this._locateOptions.setView=!1),this},_handleGeolocationError:function(t){var e;this._container._leaflet_id&&(e=t.code,t=t.message||(1===e?\"permission denied\":2===e?\"position unavailable\":\"timeout\"),this._locateOptions.setView&&!this._loaded&&this.fitWorld(),this.fire(\"locationerror\",{code:e,message:\"Geolocation error: \"+t+\".\"}))},_handleGeolocationResponse:function(t){if(this._container._leaflet_id){var e,i,n=new v(t.coords.latitude,t.coords.longitude),o=n.toBounds(2*t.coords.accuracy),s=this._locateOptions,r=(s.setView&&(e=this.getBoundsZoom(o),this.setView(n,s.maxZoom?Math.min(e,s.maxZoom):e)),{latlng:n,bounds:o,timestamp:t.timestamp});for(i in t.coords)\"number\"==typeof t.coords[i]&&(r[i]=t.coords[i]);this.fire(\"locationfound\",r)}},addHandler:function(t,e){return e&&(e=this[t]=new e(this),this._handlers.push(e),this.options[t]&&e.enable()),this},remove:function(){if(this._initEvents(!0),this.options.maxBounds&&this.off(\"moveend\",this._panInsideMaxBounds),this._containerId!==this._container._leaflet_id)throw new Error(\"Map container is being reused by another instance\");try{delete this._container._leaflet_id,delete this._containerId}catch(t){this._container._leaflet_id=void 0,this._containerId=void 0}for(var t in void 0!==this._locationWatchId&&this.stopLocate(),this._stop(),T(this._mapPane),this._clearControlPos&&this._clearControlPos(),this._resizeRequest&&(r(this._resizeRequest),this._resizeRequest=null),this._clearHandlers(),this._loaded&&this.fire(\"unload\"),this._layers)this._layers[t].remove();for(t in this._panes)T(this._panes[t]);return this._layers=[],this._panes=[],delete this._mapPane,delete this._renderer,this},createPane:function(t,e){e=P(\"div\",\"leaflet-pane\"+(t?\" leaflet-\"+t.replace(\"Pane\",\"\")+\"-pane\":\"\"),e||this._mapPane);return t&&(this._panes[t]=e),e},getCenter:function(){return this._checkIfLoaded(),this._lastCenter&&!this._moved()?this._lastCenter.clone():this.layerPointToLatLng(this._getCenterLayerPoint())},getZoom:function(){return this._zoom},getBounds:function(){var t=this.getPixelBounds();return new s(this.unproject(t.getBottomLeft()),this.unproject(t.getTopRight()))},getMinZoom:function(){return void 0===this.options.minZoom?this._layersMinZoom||0:this.options.minZoom},getMaxZoom:function(){return void 0===this.options.maxZoom?void 0===this._layersMaxZoom?1/0:this._layersMaxZoom:this.options.maxZoom},getBoundsZoom:function(t,e,i){t=g(t),i=m(i||[0,0]);var n=this.getZoom()||0,o=this.getMinZoom(),s=this.getMaxZoom(),r=t.getNorthWest(),t=t.getSouthEast(),i=this.getSize().subtract(i),t=_(this.project(t,n),this.project(r,n)).getSize(),r=b.any3d?this.options.zoomSnap:1,a=i.x/t.x,i=i.y/t.y,t=e?Math.max(a,i):Math.min(a,i),n=this.getScaleZoom(t,n);return r&&(n=Math.round(n/(r/100))*(r/100),n=e?Math.ceil(n/r)*r:Math.floor(n/r)*r),Math.max(o,Math.min(s,n))},getSize:function(){return this._size&&!this._sizeChanged||(this._size=new p(this._container.clientWidth||0,this._container.clientHeight||0),this._sizeChanged=!1),this._size.clone()},getPixelBounds:function(t,e){t=this._getTopLeftPoint(t,e);return new f(t,t.add(this.getSize()))},getPixelOrigin:function(){return this._checkIfLoaded(),this._pixelOrigin},getPixelWorldBounds:function(t){return this.options.crs.getProjectedBounds(void 0===t?this.getZoom():t)},getPane:function(t){return\"string\"==typeof t?this._panes[t]:t},getPanes:function(){return this._panes},getContainer:function(){return this._container},getZoomScale:function(t,e){var i=this.options.crs;return e=void 0===e?this._zoom:e,i.scale(t)/i.scale(e)},getScaleZoom:function(t,e){var i=this.options.crs,t=(e=void 0===e?this._zoom:e,i.zoom(t*i.scale(e)));return isNaN(t)?1/0:t},project:function(t,e){return e=void 0===e?this._zoom:e,this.options.crs.latLngToPoint(w(t),e)},unproject:function(t,e){return e=void 0===e?this._zoom:e,this.options.crs.pointToLatLng(m(t),e)},layerPointToLatLng:function(t){t=m(t).add(this.getPixelOrigin());return this.unproject(t)},latLngToLayerPoint:function(t){return this.project(w(t))._round()._subtract(this.getPixelOrigin())},wrapLatLng:function(t){return this.options.crs.wrapLatLng(w(t))},wrapLatLngBounds:function(t){return this.options.crs.wrapLatLngBounds(g(t))},distance:function(t,e){return this.options.crs.distance(w(t),w(e))},containerPointToLayerPoint:function(t){return m(t).subtract(this._getMapPanePos())},layerPointToContainerPoint:function(t){return m(t).add(this._getMapPanePos())},containerPointToLatLng:function(t){t=this.containerPointToLayerPoint(m(t));return this.layerPointToLatLng(t)},latLngToContainerPoint:function(t){return this.layerPointToContainerPoint(this.latLngToLayerPoint(w(t)))},mouseEventToContainerPoint:function(t){return De(t,this._container)},mouseEventToLayerPoint:function(t){return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(t))},mouseEventToLatLng:function(t){return this.layerPointToLatLng(this.mouseEventToLayerPoint(t))},_initContainer:function(t){t=this._container=_e(t);if(!t)throw new Error(\"Map container not found.\");if(t._leaflet_id)throw new Error(\"Map container is already initialized.\");S(t,\"scroll\",this._onScroll,this),this._containerId=h(t)},_initLayout:function(){var t=this._container,e=(this._fadeAnimated=this.options.fadeAnimation&&b.any3d,M(t,\"leaflet-container\"+(b.touch?\" leaflet-touch\":\"\")+(b.retina?\" leaflet-retina\":\"\")+(b.ielt9?\" leaflet-oldie\":\"\")+(b.safari?\" leaflet-safari\":\"\")+(this._fadeAnimated?\" leaflet-fade-anim\":\"\")),pe(t,\"position\"));\"absolute\"!==e&&\"relative\"!==e&&\"fixed\"!==e&&\"sticky\"!==e&&(t.style.position=\"relative\"),this._initPanes(),this._initControlPos&&this._initControlPos()},_initPanes:function(){var t=this._panes={};this._paneRenderers={},this._mapPane=this.createPane(\"mapPane\",this._container),Z(this._mapPane,new p(0,0)),this.createPane(\"tilePane\"),this.createPane(\"overlayPane\"),this.createPane(\"shadowPane\"),this.createPane(\"markerPane\"),this.createPane(\"tooltipPane\"),this.createPane(\"popupPane\"),this.options.markerZoomAnimation||(M(t.markerPane,\"leaflet-zoom-hide\"),M(t.shadowPane,\"leaflet-zoom-hide\"))},_resetView:function(t,e,i){Z(this._mapPane,new p(0,0));var n=!this._loaded,o=(this._loaded=!0,e=this._limitZoom(e),this.fire(\"viewprereset\"),this._zoom!==e);this._moveStart(o,i)._move(t,e)._moveEnd(o),this.fire(\"viewreset\"),n&&this.fire(\"load\")},_moveStart:function(t,e){return t&&this.fire(\"zoomstart\"),e||this.fire(\"movestart\"),this},_move:function(t,e,i,n){void 0===e&&(e=this._zoom);var o=this._zoom!==e;return this._zoom=e,this._lastCenter=t,this._pixelOrigin=this._getNewPixelOrigin(t),n?i&&i.pinch&&this.fire(\"zoom\",i):((o||i&&i.pinch)&&this.fire(\"zoom\",i),this.fire(\"move\",i)),this},_moveEnd:function(t){return t&&this.fire(\"zoomend\"),this.fire(\"moveend\")},_stop:function(){return r(this._flyToFrame),this._panAnim&&this._panAnim.stop(),this},_rawPanBy:function(t){Z(this._mapPane,this._getMapPanePos().subtract(t))},_getZoomSpan:function(){return this.getMaxZoom()-this.getMinZoom()},_panInsideMaxBounds:function(){this._enforcingBounds||this.panInsideBounds(this.options.maxBounds)},_checkIfLoaded:function(){if(!this._loaded)throw new Error(\"Set map center and zoom first.\")},_initEvents:function(t){this._targets={};var e=t?k:S;e((this._targets[h(this._container)]=this)._container,\"click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress keydown keyup\",this._handleDOMEvent,this),this.options.trackResize&&e(window,\"resize\",this._onResize,this),b.any3d&&this.options.transform3DLimit&&(t?this.off:this.on).call(this,\"moveend\",this._onMoveEnd)},_onResize:function(){r(this._resizeRequest),this._resizeRequest=x(function(){this.invalidateSize({debounceMoveend:!0})},this)},_onScroll:function(){this._container.scrollTop=0,this._container.scrollLeft=0},_onMoveEnd:function(){var t=this._getMapPanePos();Math.max(Math.abs(t.x),Math.abs(t.y))>=this.options.transform3DLimit&&this._resetView(this.getCenter(),this.getZoom())},_findEventTargets:function(t,e){for(var i,n=[],o=\"mouseout\"===e||\"mouseover\"===e,s=t.target||t.srcElement,r=!1;s;){if((i=this._targets[h(s)])&&(\"click\"===e||\"preclick\"===e)&&this._draggableMoved(i)){r=!0;break}if(i&&i.listens(e,!0)){if(o&&!Fe(s,t))break;if(n.push(i),o)break}if(s===this._container)break;s=s.parentNode}return n=n.length||r||o||!this.listens(e,!0)?n:[this]},_isClickDisabled:function(t){for(;t&&t!==this._container;){if(t._leaflet_disable_click)return!0;t=t.parentNode}},_handleDOMEvent:function(t){var e,i=t.target||t.srcElement;!this._loaded||i._leaflet_disable_events||\"click\"===t.type&&this._isClickDisabled(i)||(\"mousedown\"===(e=t.type)&&Me(i),this._fireDOMEvent(t,e))},_mouseEvents:[\"click\",\"dblclick\",\"mouseover\",\"mouseout\",\"contextmenu\"],_fireDOMEvent:function(t,e,i){\"click\"===t.type&&((a=l({},t)).type=\"preclick\",this._fireDOMEvent(a,a.type,i));var n=this._findEventTargets(t,e);if(i){for(var o=[],s=0;s<i.length;s++)i[s].listens(e,!0)&&o.push(i[s]);n=o.concat(n)}if(n.length){\"contextmenu\"===e&&O(t);var r,a=n[0],h={originalEvent:t};for(\"keypress\"!==t.type&&\"keydown\"!==t.type&&\"keyup\"!==t.type&&(r=a.getLatLng&&(!a._radius||a._radius<=10),h.containerPoint=r?this.latLngToContainerPoint(a.getLatLng()):this.mouseEventToContainerPoint(t),h.layerPoint=this.containerPointToLayerPoint(h.containerPoint),h.latlng=r?a.getLatLng():this.layerPointToLatLng(h.layerPoint)),s=0;s<n.length;s++)if(n[s].fire(e,h,!0),h.originalEvent._stopped||!1===n[s].options.bubblingMouseEvents&&-1!==G(this._mouseEvents,e))return}},_draggableMoved:function(t){return(t=t.dragging&&t.dragging.enabled()?t:this).dragging&&t.dragging.moved()||this.boxZoom&&this.boxZoom.moved()},_clearHandlers:function(){for(var t=0,e=this._handlers.length;t<e;t++)this._handlers[t].disable()},whenReady:function(t,e){return this._loaded?t.call(e||this,{target:this}):this.on(\"load\",t,e),this},_getMapPanePos:function(){return Pe(this._mapPane)||new p(0,0)},_moved:function(){var t=this._getMapPanePos();return t&&!t.equals([0,0])},_getTopLeftPoint:function(t,e){return(t&&void 0!==e?this._getNewPixelOrigin(t,e):this.getPixelOrigin()).subtract(this._getMapPanePos())},_getNewPixelOrigin:function(t,e){var i=this.getSize()._divideBy(2);return this.project(t,e)._subtract(i)._add(this._getMapPanePos())._round()},_latLngToNewLayerPoint:function(t,e,i){i=this._getNewPixelOrigin(i,e);return this.project(t,e)._subtract(i)},_latLngBoundsToNewLayerBounds:function(t,e,i){i=this._getNewPixelOrigin(i,e);return _([this.project(t.getSouthWest(),e)._subtract(i),this.project(t.getNorthWest(),e)._subtract(i),this.project(t.getSouthEast(),e)._subtract(i),this.project(t.getNorthEast(),e)._subtract(i)])},_getCenterLayerPoint:function(){return this.containerPointToLayerPoint(this.getSize()._divideBy(2))},_getCenterOffset:function(t){return this.latLngToLayerPoint(t).subtract(this._getCenterLayerPoint())},_limitCenter:function(t,e,i){var n,o;return!i||(n=this.project(t,e),o=this.getSize().divideBy(2),o=new f(n.subtract(o),n.add(o)),o=this._getBoundsOffset(o,i,e),Math.abs(o.x)<=1&&Math.abs(o.y)<=1)?t:this.unproject(n.add(o),e)},_limitOffset:function(t,e){var i;return e?(i=new f((i=this.getPixelBounds()).min.add(t),i.max.add(t)),t.add(this._getBoundsOffset(i,e))):t},_getBoundsOffset:function(t,e,i){e=_(this.project(e.getNorthEast(),i),this.project(e.getSouthWest(),i)),i=e.min.subtract(t.min),e=e.max.subtract(t.max);return new p(this._rebound(i.x,-e.x),this._rebound(i.y,-e.y))},_rebound:function(t,e){return 0<t+e?Math.round(t-e)/2:Math.max(0,Math.ceil(t))-Math.max(0,Math.floor(e))},_limitZoom:function(t){var e=this.getMinZoom(),i=this.getMaxZoom(),n=b.any3d?this.options.zoomSnap:1;return n&&(t=Math.round(t/n)*n),Math.max(e,Math.min(i,t))},_onPanTransitionStep:function(){this.fire(\"move\")},_onPanTransitionEnd:function(){z(this._mapPane,\"leaflet-pan-anim\"),this.fire(\"moveend\")},_tryAnimatedPan:function(t,e){t=this._getCenterOffset(t)._trunc();return!(!0!==(e&&e.animate)&&!this.getSize().contains(t))&&(this.panBy(t,e),!0)},_createAnimProxy:function(){var t=this._proxy=P(\"div\",\"leaflet-proxy leaflet-zoom-animated\");this._panes.mapPane.appendChild(t),this.on(\"zoomanim\",function(t){var e=ue,i=this._proxy.style[e];be(this._proxy,this.project(t.center,t.zoom),this.getZoomScale(t.zoom,1)),i===this._proxy.style[e]&&this._animatingZoom&&this._onZoomTransitionEnd()},this),this.on(\"load moveend\",this._animMoveEnd,this),this._on(\"unload\",this._destroyAnimProxy,this)},_destroyAnimProxy:function(){T(this._proxy),this.off(\"load moveend\",this._animMoveEnd,this),delete this._proxy},_animMoveEnd:function(){var t=this.getCenter(),e=this.getZoom();be(this._proxy,this.project(t,e),this.getZoomScale(e,1))},_catchTransitionEnd:function(t){this._animatingZoom&&0<=t.propertyName.indexOf(\"transform\")&&this._onZoomTransitionEnd()},_nothingToAnimate:function(){return!this._container.getElementsByClassName(\"leaflet-zoom-animated\").length},_tryAnimatedZoom:function(t,e,i){if(!this._animatingZoom){if(i=i||{},!this._zoomAnimated||!1===i.animate||this._nothingToAnimate()||Math.abs(e-this._zoom)>this.options.zoomAnimationThreshold)return!1;var n=this.getZoomScale(e),n=this._getCenterOffset(t)._divideBy(1-1/n);if(!0!==i.animate&&!this.getSize().contains(n))return!1;x(function(){this._moveStart(!0,!1)._animateZoom(t,e,!0)},this)}return!0},_animateZoom:function(t,e,i,n){this._mapPane&&(i&&(this._animatingZoom=!0,this._animateToCenter=t,this._animateToZoom=e,M(this._mapPane,\"leaflet-zoom-anim\")),this.fire(\"zoomanim\",{center:t,zoom:e,noUpdate:n}),this._tempFireZoomEvent||(this._tempFireZoomEvent=this._zoom!==this._animateToZoom),this._move(this._animateToCenter,this._animateToZoom,void 0,!0),setTimeout(a(this._onZoomTransitionEnd,this),250))},_onZoomTransitionEnd:function(){this._animatingZoom&&(this._mapPane&&z(this._mapPane,\"leaflet-zoom-anim\"),this._animatingZoom=!1,this._move(this._animateToCenter,this._animateToZoom,void 0,!0),this._tempFireZoomEvent&&this.fire(\"zoom\"),delete this._tempFireZoomEvent,this.fire(\"move\"),this._moveEnd(!0))}});function Ue(t){return new B(t)}var Ve,B=et.extend({options:{position:\"topright\"},initialize:function(t){c(this,t)},getPosition:function(){return this.options.position},setPosition:function(t){var e=this._map;return e&&e.removeControl(this),this.options.position=t,e&&e.addControl(this),this},getContainer:function(){return this._container},addTo:function(t){this.remove(),this._map=t;var e=this._container=this.onAdd(t),i=this.getPosition(),t=t._controlCorners[i];return M(e,\"leaflet-control\"),-1!==i.indexOf(\"bottom\")?t.insertBefore(e,t.firstChild):t.appendChild(e),this._map.on(\"unload\",this.remove,this),this},remove:function(){return this._map&&(T(this._container),this.onRemove&&this.onRemove(this._map),this._map.off(\"unload\",this.remove,this),this._map=null),this},_refocusOnMap:function(t){this._map&&t&&0<t.screenX&&0<t.screenY&&this._map.getContainer().focus()}}),qe=(A.include({addControl:function(t){return t.addTo(this),this},removeControl:function(t){return t.remove(),this},_initControlPos:function(){var i=this._controlCorners={},n=\"leaflet-\",o=this._controlContainer=P(\"div\",n+\"control-container\",this._container);function t(t,e){i[t+e]=P(\"div\",n+t+\" \"+n+e,o)}t(\"top\",\"left\"),t(\"top\",\"right\"),t(\"bottom\",\"left\"),t(\"bottom\",\"right\")},_clearControlPos:function(){for(var t in this._controlCorners)T(this._controlCorners[t]);T(this._controlContainer),delete this._controlCorners,delete this._controlContainer}}),B.extend({options:{collapsed:!0,position:\"topright\",autoZIndex:!0,hideSingleBase:!1,sortLayers:!1,sortFunction:function(t,e,i,n){return i<n?-1:n<i?1:0}},initialize:function(t,e,i){for(var n in c(this,i),this._layerControlInputs=[],this._layers=[],this._lastZIndex=0,this._handlingClick=!1,t)this._addLayer(t[n],n);for(n in e)this._addLayer(e[n],n,!0)},onAdd:function(t){this._initLayout(),this._update(),(this._map=t).on(\"zoomend\",this._checkDisabledLayers,this);for(var e=0;e<this._layers.length;e++)this._layers[e].layer.on(\"add remove\",this._onLayerChange,this);return this._container},addTo:function(t){return B.prototype.addTo.call(this,t),this._expandIfNotCollapsed()},onRemove:function(){this._map.off(\"zoomend\",this._checkDisabledLayers,this);for(var t=0;t<this._layers.length;t++)this._layers[t].layer.off(\"add remove\",this._onLayerChange,this)},addBaseLayer:function(t,e){return this._addLayer(t,e),this._map?this._update():this},addOverlay:function(t,e){return this._addLayer(t,e,!0),this._map?this._update():this},removeLayer:function(t){t.off(\"add remove\",this._onLayerChange,this);t=this._getLayer(h(t));return t&&this._layers.splice(this._layers.indexOf(t),1),this._map?this._update():this},expand:function(){M(this._container,\"leaflet-control-layers-expanded\"),this._section.style.height=null;var t=this._map.getSize().y-(this._container.offsetTop+50);return t<this._section.clientHeight?(M(this._section,\"leaflet-control-layers-scrollbar\"),this._section.style.height=t+\"px\"):z(this._section,\"leaflet-control-layers-scrollbar\"),this._checkDisabledLayers(),this},collapse:function(){return z(this._container,\"leaflet-control-layers-expanded\"),this},_initLayout:function(){var t=\"leaflet-control-layers\",e=this._container=P(\"div\",t),i=this.options.collapsed,n=(e.setAttribute(\"aria-haspopup\",!0),Ie(e),Be(e),this._section=P(\"section\",t+\"-list\")),o=(i&&(this._map.on(\"click\",this.collapse,this),S(e,{mouseenter:this._expandSafely,mouseleave:this.collapse},this)),this._layersLink=P(\"a\",t+\"-toggle\",e));o.href=\"#\",o.title=\"Layers\",o.setAttribute(\"role\",\"button\"),S(o,{keydown:function(t){13===t.keyCode&&this._expandSafely()},click:function(t){O(t),this._expandSafely()}},this),i||this.expand(),this._baseLayersList=P(\"div\",t+\"-base\",n),this._separator=P(\"div\",t+\"-separator\",n),this._overlaysList=P(\"div\",t+\"-overlays\",n),e.appendChild(n)},_getLayer:function(t){for(var e=0;e<this._layers.length;e++)if(this._layers[e]&&h(this._layers[e].layer)===t)return this._layers[e]},_addLayer:function(t,e,i){this._map&&t.on(\"add remove\",this._onLayerChange,this),this._layers.push({layer:t,name:e,overlay:i}),this.options.sortLayers&&this._layers.sort(a(function(t,e){return this.options.sortFunction(t.layer,e.layer,t.name,e.name)},this)),this.options.autoZIndex&&t.setZIndex&&(this._lastZIndex++,t.setZIndex(this._lastZIndex)),this._expandIfNotCollapsed()},_update:function(){if(this._container){me(this._baseLayersList),me(this._overlaysList),this._layerControlInputs=[];for(var t,e,i,n=0,o=0;o<this._layers.length;o++)i=this._layers[o],this._addItem(i),e=e||i.overlay,t=t||!i.overlay,n+=i.overlay?0:1;this.options.hideSingleBase&&(this._baseLayersList.style.display=(t=t&&1<n)?\"\":\"none\"),this._separator.style.display=e&&t?\"\":\"none\"}return this},_onLayerChange:function(t){this._handlingClick||this._update();var e=this._getLayer(h(t.target)),t=e.overlay?\"add\"===t.type?\"overlayadd\":\"overlayremove\":\"add\"===t.type?\"baselayerchange\":null;t&&this._map.fire(t,e)},_createRadioElement:function(t,e){t='<input type=\"radio\" class=\"leaflet-control-layers-selector\" name=\"'+t+'\"'+(e?' checked=\"checked\"':\"\")+\"/>\",e=document.createElement(\"div\");return e.innerHTML=t,e.firstChild},_addItem:function(t){var e,i=document.createElement(\"label\"),n=this._map.hasLayer(t.layer),n=(t.overlay?((e=document.createElement(\"input\")).type=\"checkbox\",e.className=\"leaflet-control-layers-selector\",e.defaultChecked=n):e=this._createRadioElement(\"leaflet-base-layers_\"+h(this),n),this._layerControlInputs.push(e),e.layerId=h(t.layer),S(e,\"click\",this._onInputClick,this),document.createElement(\"span\")),o=(n.innerHTML=\" \"+t.name,document.createElement(\"span\"));return i.appendChild(o),o.appendChild(e),o.appendChild(n),(t.overlay?this._overlaysList:this._baseLayersList).appendChild(i),this._checkDisabledLayers(),i},_onInputClick:function(){var t,e,i=this._layerControlInputs,n=[],o=[];this._handlingClick=!0;for(var s=i.length-1;0<=s;s--)t=i[s],e=this._getLayer(t.layerId).layer,t.checked?n.push(e):t.checked||o.push(e);for(s=0;s<o.length;s++)this._map.hasLayer(o[s])&&this._map.removeLayer(o[s]);for(s=0;s<n.length;s++)this._map.hasLayer(n[s])||this._map.addLayer(n[s]);this._handlingClick=!1,this._refocusOnMap()},_checkDisabledLayers:function(){for(var t,e,i=this._layerControlInputs,n=this._map.getZoom(),o=i.length-1;0<=o;o--)t=i[o],e=this._getLayer(t.layerId).layer,t.disabled=void 0!==e.options.minZoom&&n<e.options.minZoom||void 0!==e.options.maxZoom&&n>e.options.maxZoom},_expandIfNotCollapsed:function(){return this._map&&!this.options.collapsed&&this.expand(),this},_expandSafely:function(){var t=this._section;S(t,\"click\",O),this.expand(),setTimeout(function(){k(t,\"click\",O)})}})),Ge=B.extend({options:{position:\"topleft\",zoomInText:'<span aria-hidden=\"true\">+</span>',zoomInTitle:\"Zoom in\",zoomOutText:'<span aria-hidden=\"true\">&#x2212;</span>',zoomOutTitle:\"Zoom out\"},onAdd:function(t){var e=\"leaflet-control-zoom\",i=P(\"div\",e+\" leaflet-bar\"),n=this.options;return this._zoomInButton=this._createButton(n.zoomInText,n.zoomInTitle,e+\"-in\",i,this._zoomIn),this._zoomOutButton=this._createButton(n.zoomOutText,n.zoomOutTitle,e+\"-out\",i,this._zoomOut),this._updateDisabled(),t.on(\"zoomend zoomlevelschange\",this._updateDisabled,this),i},onRemove:function(t){t.off(\"zoomend zoomlevelschange\",this._updateDisabled,this)},disable:function(){return this._disabled=!0,this._updateDisabled(),this},enable:function(){return this._disabled=!1,this._updateDisabled(),this},_zoomIn:function(t){!this._disabled&&this._map._zoom<this._map.getMaxZoom()&&this._map.zoomIn(this._map.options.zoomDelta*(t.shiftKey?3:1))},_zoomOut:function(t){!this._disabled&&this._map._zoom>this._map.getMinZoom()&&this._map.zoomOut(this._map.options.zoomDelta*(t.shiftKey?3:1))},_createButton:function(t,e,i,n,o){i=P(\"a\",i,n);return i.innerHTML=t,i.href=\"#\",i.title=e,i.setAttribute(\"role\",\"button\"),i.setAttribute(\"aria-label\",e),Ie(i),S(i,\"click\",Re),S(i,\"click\",o,this),S(i,\"click\",this._refocusOnMap,this),i},_updateDisabled:function(){var t=this._map,e=\"leaflet-disabled\";z(this._zoomInButton,e),z(this._zoomOutButton,e),this._zoomInButton.setAttribute(\"aria-disabled\",\"false\"),this._zoomOutButton.setAttribute(\"aria-disabled\",\"false\"),!this._disabled&&t._zoom!==t.getMinZoom()||(M(this._zoomOutButton,e),this._zoomOutButton.setAttribute(\"aria-disabled\",\"true\")),!this._disabled&&t._zoom!==t.getMaxZoom()||(M(this._zoomInButton,e),this._zoomInButton.setAttribute(\"aria-disabled\",\"true\"))}}),Ke=(A.mergeOptions({zoomControl:!0}),A.addInitHook(function(){this.options.zoomControl&&(this.zoomControl=new Ge,this.addControl(this.zoomControl))}),B.extend({options:{position:\"bottomleft\",maxWidth:100,metric:!0,imperial:!0},onAdd:function(t){var e=\"leaflet-control-scale\",i=P(\"div\",e),n=this.options;return this._addScales(n,e+\"-line\",i),t.on(n.updateWhenIdle?\"moveend\":\"move\",this._update,this),t.whenReady(this._update,this),i},onRemove:function(t){t.off(this.options.updateWhenIdle?\"moveend\":\"move\",this._update,this)},_addScales:function(t,e,i){t.metric&&(this._mScale=P(\"div\",e,i)),t.imperial&&(this._iScale=P(\"div\",e,i))},_update:function(){var t=this._map,e=t.getSize().y/2,t=t.distance(t.containerPointToLatLng([0,e]),t.containerPointToLatLng([this.options.maxWidth,e]));this._updateScales(t)},_updateScales:function(t){this.options.metric&&t&&this._updateMetric(t),this.options.imperial&&t&&this._updateImperial(t)},_updateMetric:function(t){var e=this._getRoundNum(t);this._updateScale(this._mScale,e<1e3?e+\" m\":e/1e3+\" km\",e/t)},_updateImperial:function(t){var e,i,t=3.2808399*t;5280<t?(i=this._getRoundNum(e=t/5280),this._updateScale(this._iScale,i+\" mi\",i/e)):(i=this._getRoundNum(t),this._updateScale(this._iScale,i+\" ft\",i/t))},_updateScale:function(t,e,i){t.style.width=Math.round(this.options.maxWidth*i)+\"px\",t.innerHTML=e},_getRoundNum:function(t){var e=Math.pow(10,(Math.floor(t)+\"\").length-1),t=t/e;return e*(t=10<=t?10:5<=t?5:3<=t?3:2<=t?2:1)}})),Ye=B.extend({options:{position:\"bottomright\",prefix:'<a href=\"https://leafletjs.com\" title=\"A JavaScript library for interactive maps\">'+(b.inlineSvg?'<svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" width=\"12\" height=\"8\" viewBox=\"0 0 12 8\" class=\"leaflet-attribution-flag\"><path fill=\"#4C7BE1\" d=\"M0 0h12v4H0z\"/><path fill=\"#FFD500\" d=\"M0 4h12v3H0z\"/><path fill=\"#E0BC00\" d=\"M0 7h12v1H0z\"/></svg> ':\"\")+\"Leaflet</a>\"},initialize:function(t){c(this,t),this._attributions={}},onAdd:function(t){for(var e in(t.attributionControl=this)._container=P(\"div\",\"leaflet-control-attribution\"),Ie(this._container),t._layers)t._layers[e].getAttribution&&this.addAttribution(t._layers[e].getAttribution());return this._update(),t.on(\"layeradd\",this._addAttribution,this),this._container},onRemove:function(t){t.off(\"layeradd\",this._addAttribution,this)},_addAttribution:function(t){t.layer.getAttribution&&(this.addAttribution(t.layer.getAttribution()),t.layer.once(\"remove\",function(){this.removeAttribution(t.layer.getAttribution())},this))},setPrefix:function(t){return this.options.prefix=t,this._update(),this},addAttribution:function(t){return t&&(this._attributions[t]||(this._attributions[t]=0),this._attributions[t]++,this._update()),this},removeAttribution:function(t){return t&&this._attributions[t]&&(this._attributions[t]--,this._update()),this},_update:function(){if(this._map){var t,e=[];for(t in this._attributions)this._attributions[t]&&e.push(t);var i=[];this.options.prefix&&i.push(this.options.prefix),e.length&&i.push(e.join(\", \")),this._container.innerHTML=i.join(' <span aria-hidden=\"true\">|</span> ')}}}),n=(A.mergeOptions({attributionControl:!0}),A.addInitHook(function(){this.options.attributionControl&&(new Ye).addTo(this)}),B.Layers=qe,B.Zoom=Ge,B.Scale=Ke,B.Attribution=Ye,Ue.layers=function(t,e,i){return new qe(t,e,i)},Ue.zoom=function(t){return new Ge(t)},Ue.scale=function(t){return new Ke(t)},Ue.attribution=function(t){return new Ye(t)},et.extend({initialize:function(t){this._map=t},enable:function(){return this._enabled||(this._enabled=!0,this.addHooks()),this},disable:function(){return this._enabled&&(this._enabled=!1,this.removeHooks()),this},enabled:function(){return!!this._enabled}})),ft=(n.addTo=function(t,e){return t.addHandler(e,this),this},{Events:e}),Xe=b.touch?\"touchstart mousedown\":\"mousedown\",Je=it.extend({options:{clickTolerance:3},initialize:function(t,e,i,n){c(this,n),this._element=t,this._dragStartTarget=e||t,this._preventOutline=i},enable:function(){this._enabled||(S(this._dragStartTarget,Xe,this._onDown,this),this._enabled=!0)},disable:function(){this._enabled&&(Je._dragging===this&&this.finishDrag(!0),k(this._dragStartTarget,Xe,this._onDown,this),this._enabled=!1,this._moved=!1)},_onDown:function(t){var e,i;this._enabled&&(this._moved=!1,ve(this._element,\"leaflet-zoom-anim\")||(t.touches&&1!==t.touches.length?Je._dragging===this&&this.finishDrag():Je._dragging||t.shiftKey||1!==t.which&&1!==t.button&&!t.touches||((Je._dragging=this)._preventOutline&&Me(this._element),Le(),re(),this._moving||(this.fire(\"down\"),i=t.touches?t.touches[0]:t,e=Ce(this._element),this._startPoint=new p(i.clientX,i.clientY),this._startPos=Pe(this._element),this._parentScale=Ze(e),i=\"mousedown\"===t.type,S(document,i?\"mousemove\":\"touchmove\",this._onMove,this),S(document,i?\"mouseup\":\"touchend touchcancel\",this._onUp,this)))))},_onMove:function(t){var e;this._enabled&&(t.touches&&1<t.touches.length?this._moved=!0:!(e=new p((e=t.touches&&1===t.touches.length?t.touches[0]:t).clientX,e.clientY)._subtract(this._startPoint)).x&&!e.y||Math.abs(e.x)+Math.abs(e.y)<this.options.clickTolerance||(e.x/=this._parentScale.x,e.y/=this._parentScale.y,O(t),this._moved||(this.fire(\"dragstart\"),this._moved=!0,M(document.body,\"leaflet-dragging\"),this._lastTarget=t.target||t.srcElement,window.SVGElementInstance&&this._lastTarget instanceof window.SVGElementInstance&&(this._lastTarget=this._lastTarget.correspondingUseElement),M(this._lastTarget,\"leaflet-drag-target\")),this._newPos=this._startPos.add(e),this._moving=!0,this._lastEvent=t,this._updatePosition()))},_updatePosition:function(){var t={originalEvent:this._lastEvent};this.fire(\"predrag\",t),Z(this._element,this._newPos),this.fire(\"drag\",t)},_onUp:function(){this._enabled&&this.finishDrag()},finishDrag:function(t){z(document.body,\"leaflet-dragging\"),this._lastTarget&&(z(this._lastTarget,\"leaflet-drag-target\"),this._lastTarget=null),k(document,\"mousemove touchmove\",this._onMove,this),k(document,\"mouseup touchend touchcancel\",this._onUp,this),Te(),ae(),this._moved&&this._moving&&this.fire(\"dragend\",{noInertia:t,distance:this._newPos.distanceTo(this._startPos)}),this._moving=!1,Je._dragging=!1}});function $e(t,e){if(e&&t.length){var i=t=function(t,e){for(var i=[t[0]],n=1,o=0,s=t.length;n<s;n++)(function(t,e){var i=e.x-t.x,e=e.y-t.y;return i*i+e*e})(t[n],t[o])>e&&(i.push(t[n]),o=n);o<s-1&&i.push(t[s-1]);return i}(t,e=e*e),n=i.length,o=new(typeof Uint8Array!=void 0+\"\"?Uint8Array:Array)(n);o[0]=o[n-1]=1,function t(e,i,n,o,s){var r,a,h,l=0;for(a=o+1;a<=s-1;a++)h=ni(e[a],e[o],e[s],!0),l<h&&(r=a,l=h);n<l&&(i[r]=1,t(e,i,n,o,r),t(e,i,n,r,s))}(i,o,e,0,n-1);var s,r=[];for(s=0;s<n;s++)o[s]&&r.push(i[s]);return r}return t.slice()}function Qe(t,e,i){return Math.sqrt(ni(t,e,i,!0))}function ti(t,e,i,n,o){var s,r,a,h=n?Ve:ii(t,i),l=ii(e,i);for(Ve=l;;){if(!(h|l))return[t,e];if(h&l)return!1;a=ii(r=ei(t,e,s=h||l,i,o),i),s===h?(t=r,h=a):(e=r,l=a)}}function ei(t,e,i,n,o){var s,r,a=e.x-t.x,e=e.y-t.y,h=n.min,n=n.max;return 8&i?(s=t.x+a*(n.y-t.y)/e,r=n.y):4&i?(s=t.x+a*(h.y-t.y)/e,r=h.y):2&i?(s=n.x,r=t.y+e*(n.x-t.x)/a):1&i&&(s=h.x,r=t.y+e*(h.x-t.x)/a),new p(s,r,o)}function ii(t,e){var i=0;return t.x<e.min.x?i|=1:t.x>e.max.x&&(i|=2),t.y<e.min.y?i|=4:t.y>e.max.y&&(i|=8),i}function ni(t,e,i,n){var o=e.x,e=e.y,s=i.x-o,r=i.y-e,a=s*s+r*r;return 0<a&&(1<(a=((t.x-o)*s+(t.y-e)*r)/a)?(o=i.x,e=i.y):0<a&&(o+=s*a,e+=r*a)),s=t.x-o,r=t.y-e,n?s*s+r*r:new p(o,e)}function I(t){return!d(t[0])||\"object\"!=typeof t[0][0]&&void 0!==t[0][0]}function oi(t){return console.warn(\"Deprecated use of _flat, please use L.LineUtil.isFlat instead.\"),I(t)}function si(t,e){var i,n,o,s,r;if(!t||0===t.length)throw new Error(\"latlngs not passed\");I(t)||(console.warn(\"latlngs are not flat! Only the first ring will be used\"),t=t[0]);var a,h=[];for(a in t)h.push(e.project(w(t[a])));for(var l=h.length,u=0,c=0;u<l-1;u++)c+=h[u].distanceTo(h[u+1])/2;if(0===c)r=h[0];else for(i=u=0;u<l-1;u++)if(n=h[u],o=h[u+1],c<(i+=s=n.distanceTo(o))){r=[o.x-(s=(i-c)/s)*(o.x-n.x),o.y-s*(o.y-n.y)];break}return e.unproject(m(r))}gt={__proto__:null,simplify:$e,pointToSegmentDistance:Qe,closestPointOnSegment:function(t,e,i){return ni(t,e,i)},clipSegment:ti,_getEdgeIntersection:ei,_getBitCode:ii,_sqClosestPointOnSegment:ni,isFlat:I,_flat:oi,polylineCenter:si};function ri(t,e,i){for(var n,o,s,r,a,h,l,u=[1,4,2,8],c=0,d=t.length;c<d;c++)t[c]._code=ii(t[c],e);for(s=0;s<4;s++){for(h=u[s],n=[],c=0,o=(d=t.length)-1;c<d;o=c++)r=t[c],a=t[o],r._code&h?a._code&h||((l=ei(a,r,h,e,i))._code=ii(l,e),n.push(l)):(a._code&h&&((l=ei(a,r,h,e,i))._code=ii(l,e),n.push(l)),n.push(r));t=n}return t}function ai(t,e){var i,n,o,s,r,a;if(!t||0===t.length)throw new Error(\"latlngs not passed\");I(t)||(console.warn(\"latlngs are not flat! Only the first ring will be used\"),t=t[0]);var h,l=[];for(h in t)l.push(e.project(w(t[h])));for(var u=l.length,c=s=r=0,d=0,_=u-1;d<u;_=d++)i=l[d],n=l[_],o=i.y*n.x-n.y*i.x,s+=(i.x+n.x)*o,r+=(i.y+n.y)*o,c+=3*o;return a=0===c?l[0]:[s/c,r/c],e.unproject(m(a))}var vt={__proto__:null,clipPolygon:ri,polygonCenter:ai},yt={project:function(t){return new p(t.lng,t.lat)},unproject:function(t){return new v(t.y,t.x)},bounds:new f([-180,-90],[180,90])},xt={R:6378137,R_MINOR:6356752.314245179,bounds:new f([-20037508.34279,-15496570.73972],[20037508.34279,18764656.23138]),project:function(t){var e=Math.PI/180,i=this.R,n=t.lat*e,o=this.R_MINOR/i,o=Math.sqrt(1-o*o),s=o*Math.sin(n),s=Math.tan(Math.PI/4-n/2)/Math.pow((1-s)/(1+s),o/2),n=-i*Math.log(Math.max(s,1e-10));return new p(t.lng*e*i,n)},unproject:function(t){for(var e,i=180/Math.PI,n=this.R,o=this.R_MINOR/n,s=Math.sqrt(1-o*o),r=Math.exp(-t.y/n),a=Math.PI/2-2*Math.atan(r),h=0,l=.1;h<15&&1e-7<Math.abs(l);h++)e=s*Math.sin(a),e=Math.pow((1-e)/(1+e),s/2),a+=l=Math.PI/2-2*Math.atan(r*e)-a;return new v(a*i,t.x*i/n)}},wt={__proto__:null,LonLat:yt,Mercator:xt,SphericalMercator:rt},Pt=l({},st,{code:\"EPSG:3395\",projection:xt,transformation:ht(bt=.5/(Math.PI*xt.R),.5,-bt,.5)}),hi=l({},st,{code:\"EPSG:4326\",projection:yt,transformation:ht(1/180,1,-1/180,.5)}),Lt=l({},ot,{projection:yt,transformation:ht(1,0,-1,0),scale:function(t){return Math.pow(2,t)},zoom:function(t){return Math.log(t)/Math.LN2},distance:function(t,e){var i=e.lng-t.lng,e=e.lat-t.lat;return Math.sqrt(i*i+e*e)},infinite:!0}),o=(ot.Earth=st,ot.EPSG3395=Pt,ot.EPSG3857=lt,ot.EPSG900913=ut,ot.EPSG4326=hi,ot.Simple=Lt,it.extend({options:{pane:\"overlayPane\",attribution:null,bubblingMouseEvents:!0},addTo:function(t){return t.addLayer(this),this},remove:function(){return this.removeFrom(this._map||this._mapToAdd)},removeFrom:function(t){return t&&t.removeLayer(this),this},getPane:function(t){return this._map.getPane(t?this.options[t]||t:this.options.pane)},addInteractiveTarget:function(t){return this._map._targets[h(t)]=this},removeInteractiveTarget:function(t){return delete this._map._targets[h(t)],this},getAttribution:function(){return this.options.attribution},_layerAdd:function(t){var e,i=t.target;i.hasLayer(this)&&(this._map=i,this._zoomAnimated=i._zoomAnimated,this.getEvents&&(e=this.getEvents(),i.on(e,this),this.once(\"remove\",function(){i.off(e,this)},this)),this.onAdd(i),this.fire(\"add\"),i.fire(\"layeradd\",{layer:this}))}})),li=(A.include({addLayer:function(t){var e;if(t._layerAdd)return e=h(t),this._layers[e]||((this._layers[e]=t)._mapToAdd=this,t.beforeAdd&&t.beforeAdd(this),this.whenReady(t._layerAdd,t)),this;throw new Error(\"The provided object is not a Layer.\")},removeLayer:function(t){var e=h(t);return this._layers[e]&&(this._loaded&&t.onRemove(this),delete this._layers[e],this._loaded&&(this.fire(\"layerremove\",{layer:t}),t.fire(\"remove\")),t._map=t._mapToAdd=null),this},hasLayer:function(t){return h(t)in this._layers},eachLayer:function(t,e){for(var i in this._layers)t.call(e,this._layers[i]);return this},_addLayers:function(t){for(var e=0,i=(t=t?d(t)?t:[t]:[]).length;e<i;e++)this.addLayer(t[e])},_addZoomLimit:function(t){isNaN(t.options.maxZoom)&&isNaN(t.options.minZoom)||(this._zoomBoundLayers[h(t)]=t,this._updateZoomLevels())},_removeZoomLimit:function(t){t=h(t);this._zoomBoundLayers[t]&&(delete this._zoomBoundLayers[t],this._updateZoomLevels())},_updateZoomLevels:function(){var t,e=1/0,i=-1/0,n=this._getZoomSpan();for(t in this._zoomBoundLayers)var o=this._zoomBoundLayers[t].options,e=void 0===o.minZoom?e:Math.min(e,o.minZoom),i=void 0===o.maxZoom?i:Math.max(i,o.maxZoom);this._layersMaxZoom=i===-1/0?void 0:i,this._layersMinZoom=e===1/0?void 0:e,n!==this._getZoomSpan()&&this.fire(\"zoomlevelschange\"),void 0===this.options.maxZoom&&this._layersMaxZoom&&this.getZoom()>this._layersMaxZoom&&this.setZoom(this._layersMaxZoom),void 0===this.options.minZoom&&this._layersMinZoom&&this.getZoom()<this._layersMinZoom&&this.setZoom(this._layersMinZoom)}}),o.extend({initialize:function(t,e){var i,n;if(c(this,e),this._layers={},t)for(i=0,n=t.length;i<n;i++)this.addLayer(t[i])},addLayer:function(t){var e=this.getLayerId(t);return this._layers[e]=t,this._map&&this._map.addLayer(t),this},removeLayer:function(t){t=t in this._layers?t:this.getLayerId(t);return this._map&&this._layers[t]&&this._map.removeLayer(this._layers[t]),delete this._layers[t],this},hasLayer:function(t){return(\"number\"==typeof t?t:this.getLayerId(t))in this._layers},clearLayers:function(){return this.eachLayer(this.removeLayer,this)},invoke:function(t){var e,i,n=Array.prototype.slice.call(arguments,1);for(e in this._layers)(i=this._layers[e])[t]&&i[t].apply(i,n);return this},onAdd:function(t){this.eachLayer(t.addLayer,t)},onRemove:function(t){this.eachLayer(t.removeLayer,t)},eachLayer:function(t,e){for(var i in this._layers)t.call(e,this._layers[i]);return this},getLayer:function(t){return this._layers[t]},getLayers:function(){var t=[];return this.eachLayer(t.push,t),t},setZIndex:function(t){return this.invoke(\"setZIndex\",t)},getLayerId:h})),ui=li.extend({addLayer:function(t){return this.hasLayer(t)?this:(t.addEventParent(this),li.prototype.addLayer.call(this,t),this.fire(\"layeradd\",{layer:t}))},removeLayer:function(t){return this.hasLayer(t)?((t=t in this._layers?this._layers[t]:t).removeEventParent(this),li.prototype.removeLayer.call(this,t),this.fire(\"layerremove\",{layer:t})):this},setStyle:function(t){return this.invoke(\"setStyle\",t)},bringToFront:function(){return this.invoke(\"bringToFront\")},bringToBack:function(){return this.invoke(\"bringToBack\")},getBounds:function(){var t,e=new s;for(t in this._layers){var i=this._layers[t];e.extend(i.getBounds?i.getBounds():i.getLatLng())}return e}}),ci=et.extend({options:{popupAnchor:[0,0],tooltipAnchor:[0,0],crossOrigin:!1},initialize:function(t){c(this,t)},createIcon:function(t){return this._createIcon(\"icon\",t)},createShadow:function(t){return this._createIcon(\"shadow\",t)},_createIcon:function(t,e){var i=this._getIconUrl(t);if(i)return i=this._createImg(i,e&&\"IMG\"===e.tagName?e:null),this._setIconStyles(i,t),!this.options.crossOrigin&&\"\"!==this.options.crossOrigin||(i.crossOrigin=!0===this.options.crossOrigin?\"\":this.options.crossOrigin),i;if(\"icon\"===t)throw new Error(\"iconUrl not set in Icon options (see the docs).\");return null},_setIconStyles:function(t,e){var i=this.options,n=i[e+\"Size\"],n=m(n=\"number\"==typeof n?[n,n]:n),o=m(\"shadow\"===e&&i.shadowAnchor||i.iconAnchor||n&&n.divideBy(2,!0));t.className=\"leaflet-marker-\"+e+\" \"+(i.className||\"\"),o&&(t.style.marginLeft=-o.x+\"px\",t.style.marginTop=-o.y+\"px\"),n&&(t.style.width=n.x+\"px\",t.style.height=n.y+\"px\")},_createImg:function(t,e){return(e=e||document.createElement(\"img\")).src=t,e},_getIconUrl:function(t){return b.retina&&this.options[t+\"RetinaUrl\"]||this.options[t+\"Url\"]}});var di=ci.extend({options:{iconUrl:\"marker-icon.png\",iconRetinaUrl:\"marker-icon-2x.png\",shadowUrl:\"marker-shadow.png\",iconSize:[25,41],iconAnchor:[12,41],popupAnchor:[1,-34],tooltipAnchor:[16,-28],shadowSize:[41,41]},_getIconUrl:function(t){return\"string\"!=typeof di.imagePath&&(di.imagePath=this._detectIconPath()),(this.options.imagePath||di.imagePath)+ci.prototype._getIconUrl.call(this,t)},_stripUrl:function(t){function e(t,e,i){return(e=e.exec(t))&&e[i]}return(t=e(t,/^url\\((['\"])?(.+)\\1\\)$/,2))&&e(t,/^(.*)marker-icon\\.png$/,1)},_detectIconPath:function(){var t=P(\"div\",\"leaflet-default-icon-path\",document.body),e=pe(t,\"background-image\")||pe(t,\"backgroundImage\");return document.body.removeChild(t),(e=this._stripUrl(e))?e:(t=document.querySelector('link[href$=\"leaflet.css\"]'))?t.href.substring(0,t.href.length-\"leaflet.css\".length-1):\"\"}}),_i=n.extend({initialize:function(t){this._marker=t},addHooks:function(){var t=this._marker._icon;this._draggable||(this._draggable=new Je(t,t,!0)),this._draggable.on({dragstart:this._onDragStart,predrag:this._onPreDrag,drag:this._onDrag,dragend:this._onDragEnd},this).enable(),M(t,\"leaflet-marker-draggable\")},removeHooks:function(){this._draggable.off({dragstart:this._onDragStart,predrag:this._onPreDrag,drag:this._onDrag,dragend:this._onDragEnd},this).disable(),this._marker._icon&&z(this._marker._icon,\"leaflet-marker-draggable\")},moved:function(){return this._draggable&&this._draggable._moved},_adjustPan:function(t){var e=this._marker,i=e._map,n=this._marker.options.autoPanSpeed,o=this._marker.options.autoPanPadding,s=Pe(e._icon),r=i.getPixelBounds(),a=i.getPixelOrigin(),a=_(r.min._subtract(a).add(o),r.max._subtract(a).subtract(o));a.contains(s)||(o=m((Math.max(a.max.x,s.x)-a.max.x)/(r.max.x-a.max.x)-(Math.min(a.min.x,s.x)-a.min.x)/(r.min.x-a.min.x),(Math.max(a.max.y,s.y)-a.max.y)/(r.max.y-a.max.y)-(Math.min(a.min.y,s.y)-a.min.y)/(r.min.y-a.min.y)).multiplyBy(n),i.panBy(o,{animate:!1}),this._draggable._newPos._add(o),this._draggable._startPos._add(o),Z(e._icon,this._draggable._newPos),this._onDrag(t),this._panRequest=x(this._adjustPan.bind(this,t)))},_onDragStart:function(){this._oldLatLng=this._marker.getLatLng(),this._marker.closePopup&&this._marker.closePopup(),this._marker.fire(\"movestart\").fire(\"dragstart\")},_onPreDrag:function(t){this._marker.options.autoPan&&(r(this._panRequest),this._panRequest=x(this._adjustPan.bind(this,t)))},_onDrag:function(t){var e=this._marker,i=e._shadow,n=Pe(e._icon),o=e._map.layerPointToLatLng(n);i&&Z(i,n),e._latlng=o,t.latlng=o,t.oldLatLng=this._oldLatLng,e.fire(\"move\",t).fire(\"drag\",t)},_onDragEnd:function(t){r(this._panRequest),delete this._oldLatLng,this._marker.fire(\"moveend\").fire(\"dragend\",t)}}),pi=o.extend({options:{icon:new di,interactive:!0,keyboard:!0,title:\"\",alt:\"Marker\",zIndexOffset:0,opacity:1,riseOnHover:!1,riseOffset:250,pane:\"markerPane\",shadowPane:\"shadowPane\",bubblingMouseEvents:!1,autoPanOnFocus:!0,draggable:!1,autoPan:!1,autoPanPadding:[50,50],autoPanSpeed:10},initialize:function(t,e){c(this,e),this._latlng=w(t)},onAdd:function(t){this._zoomAnimated=this._zoomAnimated&&t.options.markerZoomAnimation,this._zoomAnimated&&t.on(\"zoomanim\",this._animateZoom,this),this._initIcon(),this.update()},onRemove:function(t){this.dragging&&this.dragging.enabled()&&(this.options.draggable=!0,this.dragging.removeHooks()),delete this.dragging,this._zoomAnimated&&t.off(\"zoomanim\",this._animateZoom,this),this._removeIcon(),this._removeShadow()},getEvents:function(){return{zoom:this.update,viewreset:this.update}},getLatLng:function(){return this._latlng},setLatLng:function(t){var e=this._latlng;return this._latlng=w(t),this.update(),this.fire(\"move\",{oldLatLng:e,latlng:this._latlng})},setZIndexOffset:function(t){return this.options.zIndexOffset=t,this.update()},getIcon:function(){return this.options.icon},setIcon:function(t){return this.options.icon=t,this._map&&(this._initIcon(),this.update()),this._popup&&this.bindPopup(this._popup,this._popup.options),this},getElement:function(){return this._icon},update:function(){var t;return this._icon&&this._map&&(t=this._map.latLngToLayerPoint(this._latlng).round(),this._setPos(t)),this},_initIcon:function(){var t=this.options,e=\"leaflet-zoom-\"+(this._zoomAnimated?\"animated\":\"hide\"),i=t.icon.createIcon(this._icon),n=!1,i=(i!==this._icon&&(this._icon&&this._removeIcon(),n=!0,t.title&&(i.title=t.title),\"IMG\"===i.tagName&&(i.alt=t.alt||\"\")),M(i,e),t.keyboard&&(i.tabIndex=\"0\",i.setAttribute(\"role\",\"button\")),this._icon=i,t.riseOnHover&&this.on({mouseover:this._bringToFront,mouseout:this._resetZIndex}),this.options.autoPanOnFocus&&S(i,\"focus\",this._panOnFocus,this),t.icon.createShadow(this._shadow)),o=!1;i!==this._shadow&&(this._removeShadow(),o=!0),i&&(M(i,e),i.alt=\"\"),this._shadow=i,t.opacity<1&&this._updateOpacity(),n&&this.getPane().appendChild(this._icon),this._initInteraction(),i&&o&&this.getPane(t.shadowPane).appendChild(this._shadow)},_removeIcon:function(){this.options.riseOnHover&&this.off({mouseover:this._bringToFront,mouseout:this._resetZIndex}),this.options.autoPanOnFocus&&k(this._icon,\"focus\",this._panOnFocus,this),T(this._icon),this.removeInteractiveTarget(this._icon),this._icon=null},_removeShadow:function(){this._shadow&&T(this._shadow),this._shadow=null},_setPos:function(t){this._icon&&Z(this._icon,t),this._shadow&&Z(this._shadow,t),this._zIndex=t.y+this.options.zIndexOffset,this._resetZIndex()},_updateZIndex:function(t){this._icon&&(this._icon.style.zIndex=this._zIndex+t)},_animateZoom:function(t){t=this._map._latLngToNewLayerPoint(this._latlng,t.zoom,t.center).round();this._setPos(t)},_initInteraction:function(){var t;this.options.interactive&&(M(this._icon,\"leaflet-interactive\"),this.addInteractiveTarget(this._icon),_i&&(t=this.options.draggable,this.dragging&&(t=this.dragging.enabled(),this.dragging.disable()),this.dragging=new _i(this),t&&this.dragging.enable()))},setOpacity:function(t){return this.options.opacity=t,this._map&&this._updateOpacity(),this},_updateOpacity:function(){var t=this.options.opacity;this._icon&&C(this._icon,t),this._shadow&&C(this._shadow,t)},_bringToFront:function(){this._updateZIndex(this.options.riseOffset)},_resetZIndex:function(){this._updateZIndex(0)},_panOnFocus:function(){var t,e,i=this._map;i&&(t=(e=this.options.icon.options).iconSize?m(e.iconSize):m(0,0),e=e.iconAnchor?m(e.iconAnchor):m(0,0),i.panInside(this._latlng,{paddingTopLeft:e,paddingBottomRight:t.subtract(e)}))},_getPopupAnchor:function(){return this.options.icon.options.popupAnchor},_getTooltipAnchor:function(){return this.options.icon.options.tooltipAnchor}});var mi=o.extend({options:{stroke:!0,color:\"#3388ff\",weight:3,opacity:1,lineCap:\"round\",lineJoin:\"round\",dashArray:null,dashOffset:null,fill:!1,fillColor:null,fillOpacity:.2,fillRule:\"evenodd\",interactive:!0,bubblingMouseEvents:!0},beforeAdd:function(t){this._renderer=t.getRenderer(this)},onAdd:function(){this._renderer._initPath(this),this._reset(),this._renderer._addPath(this)},onRemove:function(){this._renderer._removePath(this)},redraw:function(){return this._map&&this._renderer._updatePath(this),this},setStyle:function(t){return c(this,t),this._renderer&&(this._renderer._updateStyle(this),this.options.stroke&&t&&Object.prototype.hasOwnProperty.call(t,\"weight\")&&this._updateBounds()),this},bringToFront:function(){return this._renderer&&this._renderer._bringToFront(this),this},bringToBack:function(){return this._renderer&&this._renderer._bringToBack(this),this},getElement:function(){return this._path},_reset:function(){this._project(),this._update()},_clickTolerance:function(){return(this.options.stroke?this.options.weight/2:0)+(this._renderer.options.tolerance||0)}}),fi=mi.extend({options:{fill:!0,radius:10},initialize:function(t,e){c(this,e),this._latlng=w(t),this._radius=this.options.radius},setLatLng:function(t){var e=this._latlng;return this._latlng=w(t),this.redraw(),this.fire(\"move\",{oldLatLng:e,latlng:this._latlng})},getLatLng:function(){return this._latlng},setRadius:function(t){return this.options.radius=this._radius=t,this.redraw()},getRadius:function(){return this._radius},setStyle:function(t){var e=t&&t.radius||this._radius;return mi.prototype.setStyle.call(this,t),this.setRadius(e),this},_project:function(){this._point=this._map.latLngToLayerPoint(this._latlng),this._updateBounds()},_updateBounds:function(){var t=this._radius,e=this._radiusY||t,i=this._clickTolerance(),t=[t+i,e+i];this._pxBounds=new f(this._point.subtract(t),this._point.add(t))},_update:function(){this._map&&this._updatePath()},_updatePath:function(){this._renderer._updateCircle(this)},_empty:function(){return this._radius&&!this._renderer._bounds.intersects(this._pxBounds)},_containsPoint:function(t){return t.distanceTo(this._point)<=this._radius+this._clickTolerance()}});var gi=fi.extend({initialize:function(t,e,i){if(c(this,e=\"number\"==typeof e?l({},i,{radius:e}):e),this._latlng=w(t),isNaN(this.options.radius))throw new Error(\"Circle radius cannot be NaN\");this._mRadius=this.options.radius},setRadius:function(t){return this._mRadius=t,this.redraw()},getRadius:function(){return this._mRadius},getBounds:function(){var t=[this._radius,this._radiusY||this._radius];return new s(this._map.layerPointToLatLng(this._point.subtract(t)),this._map.layerPointToLatLng(this._point.add(t)))},setStyle:mi.prototype.setStyle,_project:function(){var t,e,i,n,o,s=this._latlng.lng,r=this._latlng.lat,a=this._map,h=a.options.crs;h.distance===st.distance?(n=Math.PI/180,o=this._mRadius/st.R/n,t=a.project([r+o,s]),e=a.project([r-o,s]),e=t.add(e).divideBy(2),i=a.unproject(e).lat,n=Math.acos((Math.cos(o*n)-Math.sin(r*n)*Math.sin(i*n))/(Math.cos(r*n)*Math.cos(i*n)))/n,!isNaN(n)&&0!==n||(n=o/Math.cos(Math.PI/180*r)),this._point=e.subtract(a.getPixelOrigin()),this._radius=isNaN(n)?0:e.x-a.project([i,s-n]).x,this._radiusY=e.y-t.y):(o=h.unproject(h.project(this._latlng).subtract([this._mRadius,0])),this._point=a.latLngToLayerPoint(this._latlng),this._radius=this._point.x-a.latLngToLayerPoint(o).x),this._updateBounds()}});var vi=mi.extend({options:{smoothFactor:1,noClip:!1},initialize:function(t,e){c(this,e),this._setLatLngs(t)},getLatLngs:function(){return this._latlngs},setLatLngs:function(t){return this._setLatLngs(t),this.redraw()},isEmpty:function(){return!this._latlngs.length},closestLayerPoint:function(t){for(var e=1/0,i=null,n=ni,o=0,s=this._parts.length;o<s;o++)for(var r=this._parts[o],a=1,h=r.length;a<h;a++){var l,u,c=n(t,l=r[a-1],u=r[a],!0);c<e&&(e=c,i=n(t,l,u))}return i&&(i.distance=Math.sqrt(e)),i},getCenter:function(){if(this._map)return si(this._defaultShape(),this._map.options.crs);throw new Error(\"Must add layer to map before using getCenter()\")},getBounds:function(){return this._bounds},addLatLng:function(t,e){return e=e||this._defaultShape(),t=w(t),e.push(t),this._bounds.extend(t),this.redraw()},_setLatLngs:function(t){this._bounds=new s,this._latlngs=this._convertLatLngs(t)},_defaultShape:function(){return I(this._latlngs)?this._latlngs:this._latlngs[0]},_convertLatLngs:function(t){for(var e=[],i=I(t),n=0,o=t.length;n<o;n++)i?(e[n]=w(t[n]),this._bounds.extend(e[n])):e[n]=this._convertLatLngs(t[n]);return e},_project:function(){var t=new f;this._rings=[],this._projectLatlngs(this._latlngs,this._rings,t),this._bounds.isValid()&&t.isValid()&&(this._rawPxBounds=t,this._updateBounds())},_updateBounds:function(){var t=this._clickTolerance(),t=new p(t,t);this._rawPxBounds&&(this._pxBounds=new f([this._rawPxBounds.min.subtract(t),this._rawPxBounds.max.add(t)]))},_projectLatlngs:function(t,e,i){var n,o,s=t[0]instanceof v,r=t.length;if(s){for(o=[],n=0;n<r;n++)o[n]=this._map.latLngToLayerPoint(t[n]),i.extend(o[n]);e.push(o)}else for(n=0;n<r;n++)this._projectLatlngs(t[n],e,i)},_clipPoints:function(){var t=this._renderer._bounds;if(this._parts=[],this._pxBounds&&this._pxBounds.intersects(t))if(this.options.noClip)this._parts=this._rings;else for(var e,i,n,o,s=this._parts,r=0,a=0,h=this._rings.length;r<h;r++)for(e=0,i=(o=this._rings[r]).length;e<i-1;e++)(n=ti(o[e],o[e+1],t,e,!0))&&(s[a]=s[a]||[],s[a].push(n[0]),n[1]===o[e+1]&&e!==i-2||(s[a].push(n[1]),a++))},_simplifyPoints:function(){for(var t=this._parts,e=this.options.smoothFactor,i=0,n=t.length;i<n;i++)t[i]=$e(t[i],e)},_update:function(){this._map&&(this._clipPoints(),this._simplifyPoints(),this._updatePath())},_updatePath:function(){this._renderer._updatePoly(this)},_containsPoint:function(t,e){var i,n,o,s,r,a,h=this._clickTolerance();if(this._pxBounds&&this._pxBounds.contains(t))for(i=0,s=this._parts.length;i<s;i++)for(n=0,o=(r=(a=this._parts[i]).length)-1;n<r;o=n++)if((e||0!==n)&&Qe(t,a[o],a[n])<=h)return!0;return!1}});vi._flat=oi;var yi=vi.extend({options:{fill:!0},isEmpty:function(){return!this._latlngs.length||!this._latlngs[0].length},getCenter:function(){if(this._map)return ai(this._defaultShape(),this._map.options.crs);throw new Error(\"Must add layer to map before using getCenter()\")},_convertLatLngs:function(t){var t=vi.prototype._convertLatLngs.call(this,t),e=t.length;return 2<=e&&t[0]instanceof v&&t[0].equals(t[e-1])&&t.pop(),t},_setLatLngs:function(t){vi.prototype._setLatLngs.call(this,t),I(this._latlngs)&&(this._latlngs=[this._latlngs])},_defaultShape:function(){return(I(this._latlngs[0])?this._latlngs:this._latlngs[0])[0]},_clipPoints:function(){var t=this._renderer._bounds,e=this.options.weight,e=new p(e,e),t=new f(t.min.subtract(e),t.max.add(e));if(this._parts=[],this._pxBounds&&this._pxBounds.intersects(t))if(this.options.noClip)this._parts=this._rings;else for(var i,n=0,o=this._rings.length;n<o;n++)(i=ri(this._rings[n],t,!0)).length&&this._parts.push(i)},_updatePath:function(){this._renderer._updatePoly(this,!0)},_containsPoint:function(t){var e,i,n,o,s,r,a,h,l=!1;if(!this._pxBounds||!this._pxBounds.contains(t))return!1;for(o=0,a=this._parts.length;o<a;o++)for(s=0,r=(h=(e=this._parts[o]).length)-1;s<h;r=s++)i=e[s],n=e[r],i.y>t.y!=n.y>t.y&&t.x<(n.x-i.x)*(t.y-i.y)/(n.y-i.y)+i.x&&(l=!l);return l||vi.prototype._containsPoint.call(this,t,!0)}});var xi=ui.extend({initialize:function(t,e){c(this,e),this._layers={},t&&this.addData(t)},addData:function(t){var e,i,n,o=d(t)?t:t.features;if(o){for(e=0,i=o.length;e<i;e++)((n=o[e]).geometries||n.geometry||n.features||n.coordinates)&&this.addData(n);return this}var s,r=this.options;return(!r.filter||r.filter(t))&&(s=wi(t,r))?(s.feature=Ci(t),s.defaultOptions=s.options,this.resetStyle(s),r.onEachFeature&&r.onEachFeature(t,s),this.addLayer(s)):this},resetStyle:function(t){return void 0===t?this.eachLayer(this.resetStyle,this):(t.options=l({},t.defaultOptions),this._setLayerStyle(t,this.options.style),this)},setStyle:function(e){return this.eachLayer(function(t){this._setLayerStyle(t,e)},this)},_setLayerStyle:function(t,e){t.setStyle&&(\"function\"==typeof e&&(e=e(t.feature)),t.setStyle(e))}});function wi(t,e){var i,n,o,s,r=\"Feature\"===t.type?t.geometry:t,a=r?r.coordinates:null,h=[],l=e&&e.pointToLayer,u=e&&e.coordsToLatLng||Pi;if(!a&&!r)return null;switch(r.type){case\"Point\":return bi(l,t,i=u(a),e);case\"MultiPoint\":for(o=0,s=a.length;o<s;o++)i=u(a[o]),h.push(bi(l,t,i,e));return new ui(h);case\"LineString\":case\"MultiLineString\":return n=Li(a,\"LineString\"===r.type?0:1,u),new vi(n,e);case\"Polygon\":case\"MultiPolygon\":return n=Li(a,\"Polygon\"===r.type?1:2,u),new yi(n,e);case\"GeometryCollection\":for(o=0,s=r.geometries.length;o<s;o++){var c=wi({geometry:r.geometries[o],type:\"Feature\",properties:t.properties},e);c&&h.push(c)}return new ui(h);case\"FeatureCollection\":for(o=0,s=r.features.length;o<s;o++){var d=wi(r.features[o],e);d&&h.push(d)}return new ui(h);default:throw new Error(\"Invalid GeoJSON object.\")}}function bi(t,e,i,n){return t?t(e,i):new pi(i,n&&n.markersInheritOptions&&n)}function Pi(t){return new v(t[1],t[0],t[2])}function Li(t,e,i){for(var n,o=[],s=0,r=t.length;s<r;s++)n=e?Li(t[s],e-1,i):(i||Pi)(t[s]),o.push(n);return o}function Ti(t,e){return void 0!==(t=w(t)).alt?[i(t.lng,e),i(t.lat,e),i(t.alt,e)]:[i(t.lng,e),i(t.lat,e)]}function Mi(t,e,i,n){for(var o=[],s=0,r=t.length;s<r;s++)o.push(e?Mi(t[s],I(t[s])?0:e-1,i,n):Ti(t[s],n));return!e&&i&&o.push(o[0].slice()),o}function zi(t,e){return t.feature?l({},t.feature,{geometry:e}):Ci(e)}function Ci(t){return\"Feature\"===t.type||\"FeatureCollection\"===t.type?t:{type:\"Feature\",properties:{},geometry:t}}Tt={toGeoJSON:function(t){return zi(this,{type:\"Point\",coordinates:Ti(this.getLatLng(),t)})}};function Zi(t,e){return new xi(t,e)}pi.include(Tt),gi.include(Tt),fi.include(Tt),vi.include({toGeoJSON:function(t){var e=!I(this._latlngs);return zi(this,{type:(e?\"Multi\":\"\")+\"LineString\",coordinates:Mi(this._latlngs,e?1:0,!1,t)})}}),yi.include({toGeoJSON:function(t){var e=!I(this._latlngs),i=e&&!I(this._latlngs[0]),t=Mi(this._latlngs,i?2:e?1:0,!0,t);return zi(this,{type:(i?\"Multi\":\"\")+\"Polygon\",coordinates:t=e?t:[t]})}}),li.include({toMultiPoint:function(e){var i=[];return this.eachLayer(function(t){i.push(t.toGeoJSON(e).geometry.coordinates)}),zi(this,{type:\"MultiPoint\",coordinates:i})},toGeoJSON:function(e){var i,n,t=this.feature&&this.feature.geometry&&this.feature.geometry.type;return\"MultiPoint\"===t?this.toMultiPoint(e):(i=\"GeometryCollection\"===t,n=[],this.eachLayer(function(t){t.toGeoJSON&&(t=t.toGeoJSON(e),i?n.push(t.geometry):\"FeatureCollection\"===(t=Ci(t)).type?n.push.apply(n,t.features):n.push(t))}),i?zi(this,{geometries:n,type:\"GeometryCollection\"}):{type:\"FeatureCollection\",features:n})}});var Mt=Zi,Si=o.extend({options:{opacity:1,alt:\"\",interactive:!1,crossOrigin:!1,errorOverlayUrl:\"\",zIndex:1,className:\"\"},initialize:function(t,e,i){this._url=t,this._bounds=g(e),c(this,i)},onAdd:function(){this._image||(this._initImage(),this.options.opacity<1&&this._updateOpacity()),this.options.interactive&&(M(this._image,\"leaflet-interactive\"),this.addInteractiveTarget(this._image)),this.getPane().appendChild(this._image),this._reset()},onRemove:function(){T(this._image),this.options.interactive&&this.removeInteractiveTarget(this._image)},setOpacity:function(t){return this.options.opacity=t,this._image&&this._updateOpacity(),this},setStyle:function(t){return t.opacity&&this.setOpacity(t.opacity),this},bringToFront:function(){return this._map&&fe(this._image),this},bringToBack:function(){return this._map&&ge(this._image),this},setUrl:function(t){return this._url=t,this._image&&(this._image.src=t),this},setBounds:function(t){return this._bounds=g(t),this._map&&this._reset(),this},getEvents:function(){var t={zoom:this._reset,viewreset:this._reset};return this._zoomAnimated&&(t.zoomanim=this._animateZoom),t},setZIndex:function(t){return this.options.zIndex=t,this._updateZIndex(),this},getBounds:function(){return this._bounds},getElement:function(){return this._image},_initImage:function(){var t=\"IMG\"===this._url.tagName,e=this._image=t?this._url:P(\"img\");M(e,\"leaflet-image-layer\"),this._zoomAnimated&&M(e,\"leaflet-zoom-animated\"),this.options.className&&M(e,this.options.className),e.onselectstart=u,e.onmousemove=u,e.onload=a(this.fire,this,\"load\"),e.onerror=a(this._overlayOnError,this,\"error\"),!this.options.crossOrigin&&\"\"!==this.options.crossOrigin||(e.crossOrigin=!0===this.options.crossOrigin?\"\":this.options.crossOrigin),this.options.zIndex&&this._updateZIndex(),t?this._url=e.src:(e.src=this._url,e.alt=this.options.alt)},_animateZoom:function(t){var e=this._map.getZoomScale(t.zoom),t=this._map._latLngBoundsToNewLayerBounds(this._bounds,t.zoom,t.center).min;be(this._image,t,e)},_reset:function(){var t=this._image,e=new f(this._map.latLngToLayerPoint(this._bounds.getNorthWest()),this._map.latLngToLayerPoint(this._bounds.getSouthEast())),i=e.getSize();Z(t,e.min),t.style.width=i.x+\"px\",t.style.height=i.y+\"px\"},_updateOpacity:function(){C(this._image,this.options.opacity)},_updateZIndex:function(){this._image&&void 0!==this.options.zIndex&&null!==this.options.zIndex&&(this._image.style.zIndex=this.options.zIndex)},_overlayOnError:function(){this.fire(\"error\");var t=this.options.errorOverlayUrl;t&&this._url!==t&&(this._url=t,this._image.src=t)},getCenter:function(){return this._bounds.getCenter()}}),Ei=Si.extend({options:{autoplay:!0,loop:!0,keepAspectRatio:!0,muted:!1,playsInline:!0},_initImage:function(){var t=\"VIDEO\"===this._url.tagName,e=this._image=t?this._url:P(\"video\");if(M(e,\"leaflet-image-layer\"),this._zoomAnimated&&M(e,\"leaflet-zoom-animated\"),this.options.className&&M(e,this.options.className),e.onselectstart=u,e.onmousemove=u,e.onloadeddata=a(this.fire,this,\"load\"),t){for(var i=e.getElementsByTagName(\"source\"),n=[],o=0;o<i.length;o++)n.push(i[o].src);this._url=0<i.length?n:[e.src]}else{d(this._url)||(this._url=[this._url]),!this.options.keepAspectRatio&&Object.prototype.hasOwnProperty.call(e.style,\"objectFit\")&&(e.style.objectFit=\"fill\"),e.autoplay=!!this.options.autoplay,e.loop=!!this.options.loop,e.muted=!!this.options.muted,e.playsInline=!!this.options.playsInline;for(var s=0;s<this._url.length;s++){var r=P(\"source\");r.src=this._url[s],e.appendChild(r)}}}});var ki=Si.extend({_initImage:function(){var t=this._image=this._url;M(t,\"leaflet-image-layer\"),this._zoomAnimated&&M(t,\"leaflet-zoom-animated\"),this.options.className&&M(t,this.options.className),t.onselectstart=u,t.onmousemove=u}});var Oi=o.extend({options:{interactive:!1,offset:[0,0],className:\"\",pane:void 0,content:\"\"},initialize:function(t,e){t&&(t instanceof v||d(t))?(this._latlng=w(t),c(this,e)):(c(this,t),this._source=e),this.options.content&&(this._content=this.options.content)},openOn:function(t){return(t=arguments.length?t:this._source._map).hasLayer(this)||t.addLayer(this),this},close:function(){return this._map&&this._map.removeLayer(this),this},toggle:function(t){return this._map?this.close():(arguments.length?this._source=t:t=this._source,this._prepareOpen(),this.openOn(t._map)),this},onAdd:function(t){this._zoomAnimated=t._zoomAnimated,this._container||this._initLayout(),t._fadeAnimated&&C(this._container,0),clearTimeout(this._removeTimeout),this.getPane().appendChild(this._container),this.update(),t._fadeAnimated&&C(this._container,1),this.bringToFront(),this.options.interactive&&(M(this._container,\"leaflet-interactive\"),this.addInteractiveTarget(this._container))},onRemove:function(t){t._fadeAnimated?(C(this._container,0),this._removeTimeout=setTimeout(a(T,void 0,this._container),200)):T(this._container),this.options.interactive&&(z(this._container,\"leaflet-interactive\"),this.removeInteractiveTarget(this._container))},getLatLng:function(){return this._latlng},setLatLng:function(t){return this._latlng=w(t),this._map&&(this._updatePosition(),this._adjustPan()),this},getContent:function(){return this._content},setContent:function(t){return this._content=t,this.update(),this},getElement:function(){return this._container},update:function(){this._map&&(this._container.style.visibility=\"hidden\",this._updateContent(),this._updateLayout(),this._updatePosition(),this._container.style.visibility=\"\",this._adjustPan())},getEvents:function(){var t={zoom:this._updatePosition,viewreset:this._updatePosition};return this._zoomAnimated&&(t.zoomanim=this._animateZoom),t},isOpen:function(){return!!this._map&&this._map.hasLayer(this)},bringToFront:function(){return this._map&&fe(this._container),this},bringToBack:function(){return this._map&&ge(this._container),this},_prepareOpen:function(t){if(!(i=this._source)._map)return!1;if(i instanceof ui){var e,i=null,n=this._source._layers;for(e in n)if(n[e]._map){i=n[e];break}if(!i)return!1;this._source=i}if(!t)if(i.getCenter)t=i.getCenter();else if(i.getLatLng)t=i.getLatLng();else{if(!i.getBounds)throw new Error(\"Unable to get source layer LatLng.\");t=i.getBounds().getCenter()}return this.setLatLng(t),this._map&&this.update(),!0},_updateContent:function(){if(this._content){var t=this._contentNode,e=\"function\"==typeof this._content?this._content(this._source||this):this._content;if(\"string\"==typeof e)t.innerHTML=e;else{for(;t.hasChildNodes();)t.removeChild(t.firstChild);t.appendChild(e)}this.fire(\"contentupdate\")}},_updatePosition:function(){var t,e,i;this._map&&(e=this._map.latLngToLayerPoint(this._latlng),t=m(this.options.offset),i=this._getAnchor(),this._zoomAnimated?Z(this._container,e.add(i)):t=t.add(e).add(i),e=this._containerBottom=-t.y,i=this._containerLeft=-Math.round(this._containerWidth/2)+t.x,this._container.style.bottom=e+\"px\",this._container.style.left=i+\"px\")},_getAnchor:function(){return[0,0]}}),Ai=(A.include({_initOverlay:function(t,e,i,n){var o=e;return o instanceof t||(o=new t(n).setContent(e)),i&&o.setLatLng(i),o}}),o.include({_initOverlay:function(t,e,i,n){var o=i;return o instanceof t?(c(o,n),o._source=this):(o=e&&!n?e:new t(n,this)).setContent(i),o}}),Oi.extend({options:{pane:\"popupPane\",offset:[0,7],maxWidth:300,minWidth:50,maxHeight:null,autoPan:!0,autoPanPaddingTopLeft:null,autoPanPaddingBottomRight:null,autoPanPadding:[5,5],keepInView:!1,closeButton:!0,autoClose:!0,closeOnEscapeKey:!0,className:\"\"},openOn:function(t){return!(t=arguments.length?t:this._source._map).hasLayer(this)&&t._popup&&t._popup.options.autoClose&&t.removeLayer(t._popup),t._popup=this,Oi.prototype.openOn.call(this,t)},onAdd:function(t){Oi.prototype.onAdd.call(this,t),t.fire(\"popupopen\",{popup:this}),this._source&&(this._source.fire(\"popupopen\",{popup:this},!0),this._source instanceof mi||this._source.on(\"preclick\",Ae))},onRemove:function(t){Oi.prototype.onRemove.call(this,t),t.fire(\"popupclose\",{popup:this}),this._source&&(this._source.fire(\"popupclose\",{popup:this},!0),this._source instanceof mi||this._source.off(\"preclick\",Ae))},getEvents:function(){var t=Oi.prototype.getEvents.call(this);return(void 0!==this.options.closeOnClick?this.options.closeOnClick:this._map.options.closePopupOnClick)&&(t.preclick=this.close),this.options.keepInView&&(t.moveend=this._adjustPan),t},_initLayout:function(){var t=\"leaflet-popup\",e=this._container=P(\"div\",t+\" \"+(this.options.className||\"\")+\" leaflet-zoom-animated\"),i=this._wrapper=P(\"div\",t+\"-content-wrapper\",e);this._contentNode=P(\"div\",t+\"-content\",i),Ie(e),Be(this._contentNode),S(e,\"contextmenu\",Ae),this._tipContainer=P(\"div\",t+\"-tip-container\",e),this._tip=P(\"div\",t+\"-tip\",this._tipContainer),this.options.closeButton&&((i=this._closeButton=P(\"a\",t+\"-close-button\",e)).setAttribute(\"role\",\"button\"),i.setAttribute(\"aria-label\",\"Close popup\"),i.href=\"#close\",i.innerHTML='<span aria-hidden=\"true\">&#215;</span>',S(i,\"click\",function(t){O(t),this.close()},this))},_updateLayout:function(){var t=this._contentNode,e=t.style,i=(e.width=\"\",e.whiteSpace=\"nowrap\",t.offsetWidth),i=Math.min(i,this.options.maxWidth),i=(i=Math.max(i,this.options.minWidth),e.width=i+1+\"px\",e.whiteSpace=\"\",e.height=\"\",t.offsetHeight),n=this.options.maxHeight,o=\"leaflet-popup-scrolled\";(n&&n<i?(e.height=n+\"px\",M):z)(t,o),this._containerWidth=this._container.offsetWidth},_animateZoom:function(t){var t=this._map._latLngToNewLayerPoint(this._latlng,t.zoom,t.center),e=this._getAnchor();Z(this._container,t.add(e))},_adjustPan:function(){var t,e,i,n,o,s,r,a;this.options.autoPan&&(this._map._panAnim&&this._map._panAnim.stop(),this._autopanning?this._autopanning=!1:(t=this._map,e=parseInt(pe(this._container,\"marginBottom\"),10)||0,e=this._container.offsetHeight+e,a=this._containerWidth,(i=new p(this._containerLeft,-e-this._containerBottom))._add(Pe(this._container)),i=t.layerPointToContainerPoint(i),o=m(this.options.autoPanPadding),n=m(this.options.autoPanPaddingTopLeft||o),o=m(this.options.autoPanPaddingBottomRight||o),s=t.getSize(),r=0,i.x+a+o.x>s.x&&(r=i.x+a-s.x+o.x),i.x-r-n.x<(a=0)&&(r=i.x-n.x),i.y+e+o.y>s.y&&(a=i.y+e-s.y+o.y),i.y-a-n.y<0&&(a=i.y-n.y),(r||a)&&(this.options.keepInView&&(this._autopanning=!0),t.fire(\"autopanstart\").panBy([r,a]))))},_getAnchor:function(){return m(this._source&&this._source._getPopupAnchor?this._source._getPopupAnchor():[0,0])}})),Bi=(A.mergeOptions({closePopupOnClick:!0}),A.include({openPopup:function(t,e,i){return this._initOverlay(Ai,t,e,i).openOn(this),this},closePopup:function(t){return(t=arguments.length?t:this._popup)&&t.close(),this}}),o.include({bindPopup:function(t,e){return this._popup=this._initOverlay(Ai,this._popup,t,e),this._popupHandlersAdded||(this.on({click:this._openPopup,keypress:this._onKeyPress,remove:this.closePopup,move:this._movePopup}),this._popupHandlersAdded=!0),this},unbindPopup:function(){return this._popup&&(this.off({click:this._openPopup,keypress:this._onKeyPress,remove:this.closePopup,move:this._movePopup}),this._popupHandlersAdded=!1,this._popup=null),this},openPopup:function(t){return this._popup&&(this instanceof ui||(this._popup._source=this),this._popup._prepareOpen(t||this._latlng)&&this._popup.openOn(this._map)),this},closePopup:function(){return this._popup&&this._popup.close(),this},togglePopup:function(){return this._popup&&this._popup.toggle(this),this},isPopupOpen:function(){return!!this._popup&&this._popup.isOpen()},setPopupContent:function(t){return this._popup&&this._popup.setContent(t),this},getPopup:function(){return this._popup},_openPopup:function(t){var e;this._popup&&this._map&&(Re(t),e=t.layer||t.target,this._popup._source!==e||e instanceof mi?(this._popup._source=e,this.openPopup(t.latlng)):this._map.hasLayer(this._popup)?this.closePopup():this.openPopup(t.latlng))},_movePopup:function(t){this._popup.setLatLng(t.latlng)},_onKeyPress:function(t){13===t.originalEvent.keyCode&&this._openPopup(t)}}),Oi.extend({options:{pane:\"tooltipPane\",offset:[0,0],direction:\"auto\",permanent:!1,sticky:!1,opacity:.9},onAdd:function(t){Oi.prototype.onAdd.call(this,t),this.setOpacity(this.options.opacity),t.fire(\"tooltipopen\",{tooltip:this}),this._source&&(this.addEventParent(this._source),this._source.fire(\"tooltipopen\",{tooltip:this},!0))},onRemove:function(t){Oi.prototype.onRemove.call(this,t),t.fire(\"tooltipclose\",{tooltip:this}),this._source&&(this.removeEventParent(this._source),this._source.fire(\"tooltipclose\",{tooltip:this},!0))},getEvents:function(){var t=Oi.prototype.getEvents.call(this);return this.options.permanent||(t.preclick=this.close),t},_initLayout:function(){var t=\"leaflet-tooltip \"+(this.options.className||\"\")+\" leaflet-zoom-\"+(this._zoomAnimated?\"animated\":\"hide\");this._contentNode=this._container=P(\"div\",t),this._container.setAttribute(\"role\",\"tooltip\"),this._container.setAttribute(\"id\",\"leaflet-tooltip-\"+h(this))},_updateLayout:function(){},_adjustPan:function(){},_setPosition:function(t){var e,i=this._map,n=this._container,o=i.latLngToContainerPoint(i.getCenter()),i=i.layerPointToContainerPoint(t),s=this.options.direction,r=n.offsetWidth,a=n.offsetHeight,h=m(this.options.offset),l=this._getAnchor(),i=\"top\"===s?(e=r/2,a):\"bottom\"===s?(e=r/2,0):(e=\"center\"===s?r/2:\"right\"===s?0:\"left\"===s?r:i.x<o.x?(s=\"right\",0):(s=\"left\",r+2*(h.x+l.x)),a/2);t=t.subtract(m(e,i,!0)).add(h).add(l),z(n,\"leaflet-tooltip-right\"),z(n,\"leaflet-tooltip-left\"),z(n,\"leaflet-tooltip-top\"),z(n,\"leaflet-tooltip-bottom\"),M(n,\"leaflet-tooltip-\"+s),Z(n,t)},_updatePosition:function(){var t=this._map.latLngToLayerPoint(this._latlng);this._setPosition(t)},setOpacity:function(t){this.options.opacity=t,this._container&&C(this._container,t)},_animateZoom:function(t){t=this._map._latLngToNewLayerPoint(this._latlng,t.zoom,t.center);this._setPosition(t)},_getAnchor:function(){return m(this._source&&this._source._getTooltipAnchor&&!this.options.sticky?this._source._getTooltipAnchor():[0,0])}})),Ii=(A.include({openTooltip:function(t,e,i){return this._initOverlay(Bi,t,e,i).openOn(this),this},closeTooltip:function(t){return t.close(),this}}),o.include({bindTooltip:function(t,e){return this._tooltip&&this.isTooltipOpen()&&this.unbindTooltip(),this._tooltip=this._initOverlay(Bi,this._tooltip,t,e),this._initTooltipInteractions(),this._tooltip.options.permanent&&this._map&&this._map.hasLayer(this)&&this.openTooltip(),this},unbindTooltip:function(){return this._tooltip&&(this._initTooltipInteractions(!0),this.closeTooltip(),this._tooltip=null),this},_initTooltipInteractions:function(t){var e,i;!t&&this._tooltipHandlersAdded||(e=t?\"off\":\"on\",i={remove:this.closeTooltip,move:this._moveTooltip},this._tooltip.options.permanent?i.add=this._openTooltip:(i.mouseover=this._openTooltip,i.mouseout=this.closeTooltip,i.click=this._openTooltip,this._map?this._addFocusListeners():i.add=this._addFocusListeners),this._tooltip.options.sticky&&(i.mousemove=this._moveTooltip),this[e](i),this._tooltipHandlersAdded=!t)},openTooltip:function(t){return this._tooltip&&(this instanceof ui||(this._tooltip._source=this),this._tooltip._prepareOpen(t)&&(this._tooltip.openOn(this._map),this.getElement?this._setAriaDescribedByOnLayer(this):this.eachLayer&&this.eachLayer(this._setAriaDescribedByOnLayer,this))),this},closeTooltip:function(){if(this._tooltip)return this._tooltip.close()},toggleTooltip:function(){return this._tooltip&&this._tooltip.toggle(this),this},isTooltipOpen:function(){return this._tooltip.isOpen()},setTooltipContent:function(t){return this._tooltip&&this._tooltip.setContent(t),this},getTooltip:function(){return this._tooltip},_addFocusListeners:function(){this.getElement?this._addFocusListenersOnLayer(this):this.eachLayer&&this.eachLayer(this._addFocusListenersOnLayer,this)},_addFocusListenersOnLayer:function(t){var e=t.getElement();e&&(S(e,\"focus\",function(){this._tooltip._source=t,this.openTooltip()},this),S(e,\"blur\",this.closeTooltip,this))},_setAriaDescribedByOnLayer:function(t){t=t.getElement();t&&t.setAttribute(\"aria-describedby\",this._tooltip._container.id)},_openTooltip:function(t){!this._tooltip||!this._map||this._map.dragging&&this._map.dragging.moving()||(this._tooltip._source=t.layer||t.target,this.openTooltip(this._tooltip.options.sticky?t.latlng:void 0))},_moveTooltip:function(t){var e=t.latlng;this._tooltip.options.sticky&&t.originalEvent&&(t=this._map.mouseEventToContainerPoint(t.originalEvent),t=this._map.containerPointToLayerPoint(t),e=this._map.layerPointToLatLng(t)),this._tooltip.setLatLng(e)}}),ci.extend({options:{iconSize:[12,12],html:!1,bgPos:null,className:\"leaflet-div-icon\"},createIcon:function(t){var t=t&&\"DIV\"===t.tagName?t:document.createElement(\"div\"),e=this.options;return e.html instanceof Element?(me(t),t.appendChild(e.html)):t.innerHTML=!1!==e.html?e.html:\"\",e.bgPos&&(e=m(e.bgPos),t.style.backgroundPosition=-e.x+\"px \"+-e.y+\"px\"),this._setIconStyles(t,\"icon\"),t},createShadow:function(){return null}}));ci.Default=di;var Ri=o.extend({options:{tileSize:256,opacity:1,updateWhenIdle:b.mobile,updateWhenZooming:!0,updateInterval:200,zIndex:1,bounds:null,minZoom:0,maxZoom:void 0,maxNativeZoom:void 0,minNativeZoom:void 0,noWrap:!1,pane:\"tilePane\",className:\"\",keepBuffer:2},initialize:function(t){c(this,t)},onAdd:function(){this._initContainer(),this._levels={},this._tiles={},this._resetView()},beforeAdd:function(t){t._addZoomLimit(this)},onRemove:function(t){this._removeAllTiles(),T(this._container),t._removeZoomLimit(this),this._container=null,this._tileZoom=void 0},bringToFront:function(){return this._map&&(fe(this._container),this._setAutoZIndex(Math.max)),this},bringToBack:function(){return this._map&&(ge(this._container),this._setAutoZIndex(Math.min)),this},getContainer:function(){return this._container},setOpacity:function(t){return this.options.opacity=t,this._updateOpacity(),this},setZIndex:function(t){return this.options.zIndex=t,this._updateZIndex(),this},isLoading:function(){return this._loading},redraw:function(){var t;return this._map&&(this._removeAllTiles(),(t=this._clampZoom(this._map.getZoom()))!==this._tileZoom&&(this._tileZoom=t,this._updateLevels()),this._update()),this},getEvents:function(){var t={viewprereset:this._invalidateAll,viewreset:this._resetView,zoom:this._resetView,moveend:this._onMoveEnd};return this.options.updateWhenIdle||(this._onMove||(this._onMove=j(this._onMoveEnd,this.options.updateInterval,this)),t.move=this._onMove),this._zoomAnimated&&(t.zoomanim=this._animateZoom),t},createTile:function(){return document.createElement(\"div\")},getTileSize:function(){var t=this.options.tileSize;return t instanceof p?t:new p(t,t)},_updateZIndex:function(){this._container&&void 0!==this.options.zIndex&&null!==this.options.zIndex&&(this._container.style.zIndex=this.options.zIndex)},_setAutoZIndex:function(t){for(var e,i=this.getPane().children,n=-t(-1/0,1/0),o=0,s=i.length;o<s;o++)e=i[o].style.zIndex,i[o]!==this._container&&e&&(n=t(n,+e));isFinite(n)&&(this.options.zIndex=n+t(-1,1),this._updateZIndex())},_updateOpacity:function(){if(this._map&&!b.ielt9){C(this._container,this.options.opacity);var t,e=+new Date,i=!1,n=!1;for(t in this._tiles){var o,s=this._tiles[t];s.current&&s.loaded&&(o=Math.min(1,(e-s.loaded)/200),C(s.el,o),o<1?i=!0:(s.active?n=!0:this._onOpaqueTile(s),s.active=!0))}n&&!this._noPrune&&this._pruneTiles(),i&&(r(this._fadeFrame),this._fadeFrame=x(this._updateOpacity,this))}},_onOpaqueTile:u,_initContainer:function(){this._container||(this._container=P(\"div\",\"leaflet-layer \"+(this.options.className||\"\")),this._updateZIndex(),this.options.opacity<1&&this._updateOpacity(),this.getPane().appendChild(this._container))},_updateLevels:function(){var t=this._tileZoom,e=this.options.maxZoom;if(void 0!==t){for(var i in this._levels)i=Number(i),this._levels[i].el.children.length||i===t?(this._levels[i].el.style.zIndex=e-Math.abs(t-i),this._onUpdateLevel(i)):(T(this._levels[i].el),this._removeTilesAtZoom(i),this._onRemoveLevel(i),delete this._levels[i]);var n=this._levels[t],o=this._map;return n||((n=this._levels[t]={}).el=P(\"div\",\"leaflet-tile-container leaflet-zoom-animated\",this._container),n.el.style.zIndex=e,n.origin=o.project(o.unproject(o.getPixelOrigin()),t).round(),n.zoom=t,this._setZoomTransform(n,o.getCenter(),o.getZoom()),u(n.el.offsetWidth),this._onCreateLevel(n)),this._level=n}},_onUpdateLevel:u,_onRemoveLevel:u,_onCreateLevel:u,_pruneTiles:function(){if(this._map){var t,e,i,n=this._map.getZoom();if(n>this.options.maxZoom||n<this.options.minZoom)this._removeAllTiles();else{for(t in this._tiles)(i=this._tiles[t]).retain=i.current;for(t in this._tiles)(i=this._tiles[t]).current&&!i.active&&(e=i.coords,this._retainParent(e.x,e.y,e.z,e.z-5)||this._retainChildren(e.x,e.y,e.z,e.z+2));for(t in this._tiles)this._tiles[t].retain||this._removeTile(t)}}},_removeTilesAtZoom:function(t){for(var e in this._tiles)this._tiles[e].coords.z===t&&this._removeTile(e)},_removeAllTiles:function(){for(var t in this._tiles)this._removeTile(t)},_invalidateAll:function(){for(var t in this._levels)T(this._levels[t].el),this._onRemoveLevel(Number(t)),delete this._levels[t];this._removeAllTiles(),this._tileZoom=void 0},_retainParent:function(t,e,i,n){var t=Math.floor(t/2),e=Math.floor(e/2),i=i-1,o=new p(+t,+e),o=(o.z=i,this._tileCoordsToKey(o)),o=this._tiles[o];return o&&o.active?o.retain=!0:(o&&o.loaded&&(o.retain=!0),n<i&&this._retainParent(t,e,i,n))},_retainChildren:function(t,e,i,n){for(var o=2*t;o<2*t+2;o++)for(var s=2*e;s<2*e+2;s++){var r=new p(o,s),r=(r.z=i+1,this._tileCoordsToKey(r)),r=this._tiles[r];r&&r.active?r.retain=!0:(r&&r.loaded&&(r.retain=!0),i+1<n&&this._retainChildren(o,s,i+1,n))}},_resetView:function(t){t=t&&(t.pinch||t.flyTo);this._setView(this._map.getCenter(),this._map.getZoom(),t,t)},_animateZoom:function(t){this._setView(t.center,t.zoom,!0,t.noUpdate)},_clampZoom:function(t){var e=this.options;return void 0!==e.minNativeZoom&&t<e.minNativeZoom?e.minNativeZoom:void 0!==e.maxNativeZoom&&e.maxNativeZoom<t?e.maxNativeZoom:t},_setView:function(t,e,i,n){var o=Math.round(e),o=void 0!==this.options.maxZoom&&o>this.options.maxZoom||void 0!==this.options.minZoom&&o<this.options.minZoom?void 0:this._clampZoom(o),s=this.options.updateWhenZooming&&o!==this._tileZoom;n&&!s||(this._tileZoom=o,this._abortLoading&&this._abortLoading(),this._updateLevels(),this._resetGrid(),void 0!==o&&this._update(t),i||this._pruneTiles(),this._noPrune=!!i),this._setZoomTransforms(t,e)},_setZoomTransforms:function(t,e){for(var i in this._levels)this._setZoomTransform(this._levels[i],t,e)},_setZoomTransform:function(t,e,i){var n=this._map.getZoomScale(i,t.zoom),e=t.origin.multiplyBy(n).subtract(this._map._getNewPixelOrigin(e,i)).round();b.any3d?be(t.el,e,n):Z(t.el,e)},_resetGrid:function(){var t=this._map,e=t.options.crs,i=this._tileSize=this.getTileSize(),n=this._tileZoom,o=this._map.getPixelWorldBounds(this._tileZoom);o&&(this._globalTileRange=this._pxBoundsToTileRange(o)),this._wrapX=e.wrapLng&&!this.options.noWrap&&[Math.floor(t.project([0,e.wrapLng[0]],n).x/i.x),Math.ceil(t.project([0,e.wrapLng[1]],n).x/i.y)],this._wrapY=e.wrapLat&&!this.options.noWrap&&[Math.floor(t.project([e.wrapLat[0],0],n).y/i.x),Math.ceil(t.project([e.wrapLat[1],0],n).y/i.y)]},_onMoveEnd:function(){this._map&&!this._map._animatingZoom&&this._update()},_getTiledPixelBounds:function(t){var e=this._map,i=e._animatingZoom?Math.max(e._animateToZoom,e.getZoom()):e.getZoom(),i=e.getZoomScale(i,this._tileZoom),t=e.project(t,this._tileZoom).floor(),e=e.getSize().divideBy(2*i);return new f(t.subtract(e),t.add(e))},_update:function(t){var e=this._map;if(e){var i=this._clampZoom(e.getZoom());if(void 0===t&&(t=e.getCenter()),void 0!==this._tileZoom){var n,e=this._getTiledPixelBounds(t),o=this._pxBoundsToTileRange(e),s=o.getCenter(),r=[],e=this.options.keepBuffer,a=new f(o.getBottomLeft().subtract([e,-e]),o.getTopRight().add([e,-e]));if(!(isFinite(o.min.x)&&isFinite(o.min.y)&&isFinite(o.max.x)&&isFinite(o.max.y)))throw new Error(\"Attempted to load an infinite number of tiles\");for(n in this._tiles){var h=this._tiles[n].coords;h.z===this._tileZoom&&a.contains(new p(h.x,h.y))||(this._tiles[n].current=!1)}if(1<Math.abs(i-this._tileZoom))this._setView(t,i);else{for(var l=o.min.y;l<=o.max.y;l++)for(var u=o.min.x;u<=o.max.x;u++){var c,d=new p(u,l);d.z=this._tileZoom,this._isValidTile(d)&&((c=this._tiles[this._tileCoordsToKey(d)])?c.current=!0:r.push(d))}if(r.sort(function(t,e){return t.distanceTo(s)-e.distanceTo(s)}),0!==r.length){this._loading||(this._loading=!0,this.fire(\"loading\"));for(var _=document.createDocumentFragment(),u=0;u<r.length;u++)this._addTile(r[u],_);this._level.el.appendChild(_)}}}}},_isValidTile:function(t){var e=this._map.options.crs;if(!e.infinite){var i=this._globalTileRange;if(!e.wrapLng&&(t.x<i.min.x||t.x>i.max.x)||!e.wrapLat&&(t.y<i.min.y||t.y>i.max.y))return!1}return!this.options.bounds||(e=this._tileCoordsToBounds(t),g(this.options.bounds).overlaps(e))},_keyToBounds:function(t){return this._tileCoordsToBounds(this._keyToTileCoords(t))},_tileCoordsToNwSe:function(t){var e=this._map,i=this.getTileSize(),n=t.scaleBy(i),i=n.add(i);return[e.unproject(n,t.z),e.unproject(i,t.z)]},_tileCoordsToBounds:function(t){t=this._tileCoordsToNwSe(t),t=new s(t[0],t[1]);return t=this.options.noWrap?t:this._map.wrapLatLngBounds(t)},_tileCoordsToKey:function(t){return t.x+\":\"+t.y+\":\"+t.z},_keyToTileCoords:function(t){var t=t.split(\":\"),e=new p(+t[0],+t[1]);return e.z=+t[2],e},_removeTile:function(t){var e=this._tiles[t];e&&(T(e.el),delete this._tiles[t],this.fire(\"tileunload\",{tile:e.el,coords:this._keyToTileCoords(t)}))},_initTile:function(t){M(t,\"leaflet-tile\");var e=this.getTileSize();t.style.width=e.x+\"px\",t.style.height=e.y+\"px\",t.onselectstart=u,t.onmousemove=u,b.ielt9&&this.options.opacity<1&&C(t,this.options.opacity)},_addTile:function(t,e){var i=this._getTilePos(t),n=this._tileCoordsToKey(t),o=this.createTile(this._wrapCoords(t),a(this._tileReady,this,t));this._initTile(o),this.createTile.length<2&&x(a(this._tileReady,this,t,null,o)),Z(o,i),this._tiles[n]={el:o,coords:t,current:!0},e.appendChild(o),this.fire(\"tileloadstart\",{tile:o,coords:t})},_tileReady:function(t,e,i){e&&this.fire(\"tileerror\",{error:e,tile:i,coords:t});var n=this._tileCoordsToKey(t);(i=this._tiles[n])&&(i.loaded=+new Date,this._map._fadeAnimated?(C(i.el,0),r(this._fadeFrame),this._fadeFrame=x(this._updateOpacity,this)):(i.active=!0,this._pruneTiles()),e||(M(i.el,\"leaflet-tile-loaded\"),this.fire(\"tileload\",{tile:i.el,coords:t})),this._noTilesToLoad()&&(this._loading=!1,this.fire(\"load\"),b.ielt9||!this._map._fadeAnimated?x(this._pruneTiles,this):setTimeout(a(this._pruneTiles,this),250)))},_getTilePos:function(t){return t.scaleBy(this.getTileSize()).subtract(this._level.origin)},_wrapCoords:function(t){var e=new p(this._wrapX?H(t.x,this._wrapX):t.x,this._wrapY?H(t.y,this._wrapY):t.y);return e.z=t.z,e},_pxBoundsToTileRange:function(t){var e=this.getTileSize();return new f(t.min.unscaleBy(e).floor(),t.max.unscaleBy(e).ceil().subtract([1,1]))},_noTilesToLoad:function(){for(var t in this._tiles)if(!this._tiles[t].loaded)return!1;return!0}});var Ni=Ri.extend({options:{minZoom:0,maxZoom:18,subdomains:\"abc\",errorTileUrl:\"\",zoomOffset:0,tms:!1,zoomReverse:!1,detectRetina:!1,crossOrigin:!1,referrerPolicy:!1},initialize:function(t,e){this._url=t,(e=c(this,e)).detectRetina&&b.retina&&0<e.maxZoom?(e.tileSize=Math.floor(e.tileSize/2),e.zoomReverse?(e.zoomOffset--,e.minZoom=Math.min(e.maxZoom,e.minZoom+1)):(e.zoomOffset++,e.maxZoom=Math.max(e.minZoom,e.maxZoom-1)),e.minZoom=Math.max(0,e.minZoom)):e.zoomReverse?e.minZoom=Math.min(e.maxZoom,e.minZoom):e.maxZoom=Math.max(e.minZoom,e.maxZoom),\"string\"==typeof e.subdomains&&(e.subdomains=e.subdomains.split(\"\")),this.on(\"tileunload\",this._onTileRemove)},setUrl:function(t,e){return this._url===t&&void 0===e&&(e=!0),this._url=t,e||this.redraw(),this},createTile:function(t,e){var i=document.createElement(\"img\");return S(i,\"load\",a(this._tileOnLoad,this,e,i)),S(i,\"error\",a(this._tileOnError,this,e,i)),!this.options.crossOrigin&&\"\"!==this.options.crossOrigin||(i.crossOrigin=!0===this.options.crossOrigin?\"\":this.options.crossOrigin),\"string\"==typeof this.options.referrerPolicy&&(i.referrerPolicy=this.options.referrerPolicy),i.alt=\"\",i.src=this.getTileUrl(t),i},getTileUrl:function(t){var e={r:b.retina?\"@2x\":\"\",s:this._getSubdomain(t),x:t.x,y:t.y,z:this._getZoomForUrl()};return this._map&&!this._map.options.crs.infinite&&(t=this._globalTileRange.max.y-t.y,this.options.tms&&(e.y=t),e[\"-y\"]=t),q(this._url,l(e,this.options))},_tileOnLoad:function(t,e){b.ielt9?setTimeout(a(t,this,null,e),0):t(null,e)},_tileOnError:function(t,e,i){var n=this.options.errorTileUrl;n&&e.getAttribute(\"src\")!==n&&(e.src=n),t(i,e)},_onTileRemove:function(t){t.tile.onload=null},_getZoomForUrl:function(){var t=this._tileZoom,e=this.options.maxZoom;return(t=this.options.zoomReverse?e-t:t)+this.options.zoomOffset},_getSubdomain:function(t){t=Math.abs(t.x+t.y)%this.options.subdomains.length;return this.options.subdomains[t]},_abortLoading:function(){var t,e,i;for(t in this._tiles)this._tiles[t].coords.z!==this._tileZoom&&((i=this._tiles[t].el).onload=u,i.onerror=u,i.complete||(i.src=K,e=this._tiles[t].coords,T(i),delete this._tiles[t],this.fire(\"tileabort\",{tile:i,coords:e})))},_removeTile:function(t){var e=this._tiles[t];if(e)return e.el.setAttribute(\"src\",K),Ri.prototype._removeTile.call(this,t)},_tileReady:function(t,e,i){if(this._map&&(!i||i.getAttribute(\"src\")!==K))return Ri.prototype._tileReady.call(this,t,e,i)}});function Di(t,e){return new Ni(t,e)}var ji=Ni.extend({defaultWmsParams:{service:\"WMS\",request:\"GetMap\",layers:\"\",styles:\"\",format:\"image/jpeg\",transparent:!1,version:\"1.1.1\"},options:{crs:null,uppercase:!1},initialize:function(t,e){this._url=t;var i,n=l({},this.defaultWmsParams);for(i in e)i in this.options||(n[i]=e[i]);var t=(e=c(this,e)).detectRetina&&b.retina?2:1,o=this.getTileSize();n.width=o.x*t,n.height=o.y*t,this.wmsParams=n},onAdd:function(t){this._crs=this.options.crs||t.options.crs,this._wmsVersion=parseFloat(this.wmsParams.version);var e=1.3<=this._wmsVersion?\"crs\":\"srs\";this.wmsParams[e]=this._crs.code,Ni.prototype.onAdd.call(this,t)},getTileUrl:function(t){var e=this._tileCoordsToNwSe(t),i=this._crs,i=_(i.project(e[0]),i.project(e[1])),e=i.min,i=i.max,e=(1.3<=this._wmsVersion&&this._crs===hi?[e.y,e.x,i.y,i.x]:[e.x,e.y,i.x,i.y]).join(\",\"),i=Ni.prototype.getTileUrl.call(this,t);return i+U(this.wmsParams,i,this.options.uppercase)+(this.options.uppercase?\"&BBOX=\":\"&bbox=\")+e},setParams:function(t,e){return l(this.wmsParams,t),e||this.redraw(),this}});Ni.WMS=ji,Di.wms=function(t,e){return new ji(t,e)};var Hi=o.extend({options:{padding:.1},initialize:function(t){c(this,t),h(this),this._layers=this._layers||{}},onAdd:function(){this._container||(this._initContainer(),this._zoomAnimated&&M(this._container,\"leaflet-zoom-animated\")),this.getPane().appendChild(this._container),this._update(),this.on(\"update\",this._updatePaths,this)},onRemove:function(){this.off(\"update\",this._updatePaths,this),this._destroyContainer()},getEvents:function(){var t={viewreset:this._reset,zoom:this._onZoom,moveend:this._update,zoomend:this._onZoomEnd};return this._zoomAnimated&&(t.zoomanim=this._onAnimZoom),t},_onAnimZoom:function(t){this._updateTransform(t.center,t.zoom)},_onZoom:function(){this._updateTransform(this._map.getCenter(),this._map.getZoom())},_updateTransform:function(t,e){var i=this._map.getZoomScale(e,this._zoom),n=this._map.getSize().multiplyBy(.5+this.options.padding),o=this._map.project(this._center,e),n=n.multiplyBy(-i).add(o).subtract(this._map._getNewPixelOrigin(t,e));b.any3d?be(this._container,n,i):Z(this._container,n)},_reset:function(){for(var t in this._update(),this._updateTransform(this._center,this._zoom),this._layers)this._layers[t]._reset()},_onZoomEnd:function(){for(var t in this._layers)this._layers[t]._project()},_updatePaths:function(){for(var t in this._layers)this._layers[t]._update()},_update:function(){var t=this.options.padding,e=this._map.getSize(),i=this._map.containerPointToLayerPoint(e.multiplyBy(-t)).round();this._bounds=new f(i,i.add(e.multiplyBy(1+2*t)).round()),this._center=this._map.getCenter(),this._zoom=this._map.getZoom()}}),Fi=Hi.extend({options:{tolerance:0},getEvents:function(){var t=Hi.prototype.getEvents.call(this);return t.viewprereset=this._onViewPreReset,t},_onViewPreReset:function(){this._postponeUpdatePaths=!0},onAdd:function(){Hi.prototype.onAdd.call(this),this._draw()},_initContainer:function(){var t=this._container=document.createElement(\"canvas\");S(t,\"mousemove\",this._onMouseMove,this),S(t,\"click dblclick mousedown mouseup contextmenu\",this._onClick,this),S(t,\"mouseout\",this._handleMouseOut,this),t._leaflet_disable_events=!0,this._ctx=t.getContext(\"2d\")},_destroyContainer:function(){r(this._redrawRequest),delete this._ctx,T(this._container),k(this._container),delete this._container},_updatePaths:function(){if(!this._postponeUpdatePaths){for(var t in this._redrawBounds=null,this._layers)this._layers[t]._update();this._redraw()}},_update:function(){var t,e,i,n;this._map._animatingZoom&&this._bounds||(Hi.prototype._update.call(this),t=this._bounds,e=this._container,i=t.getSize(),n=b.retina?2:1,Z(e,t.min),e.width=n*i.x,e.height=n*i.y,e.style.width=i.x+\"px\",e.style.height=i.y+\"px\",b.retina&&this._ctx.scale(2,2),this._ctx.translate(-t.min.x,-t.min.y),this.fire(\"update\"))},_reset:function(){Hi.prototype._reset.call(this),this._postponeUpdatePaths&&(this._postponeUpdatePaths=!1,this._updatePaths())},_initPath:function(t){this._updateDashArray(t);t=(this._layers[h(t)]=t)._order={layer:t,prev:this._drawLast,next:null};this._drawLast&&(this._drawLast.next=t),this._drawLast=t,this._drawFirst=this._drawFirst||this._drawLast},_addPath:function(t){this._requestRedraw(t)},_removePath:function(t){var e=t._order,i=e.next,e=e.prev;i?i.prev=e:this._drawLast=e,e?e.next=i:this._drawFirst=i,delete t._order,delete this._layers[h(t)],this._requestRedraw(t)},_updatePath:function(t){this._extendRedrawBounds(t),t._project(),t._update(),this._requestRedraw(t)},_updateStyle:function(t){this._updateDashArray(t),this._requestRedraw(t)},_updateDashArray:function(t){if(\"string\"==typeof t.options.dashArray){for(var e,i=t.options.dashArray.split(/[, ]+/),n=[],o=0;o<i.length;o++){if(e=Number(i[o]),isNaN(e))return;n.push(e)}t.options._dashArray=n}else t.options._dashArray=t.options.dashArray},_requestRedraw:function(t){this._map&&(this._extendRedrawBounds(t),this._redrawRequest=this._redrawRequest||x(this._redraw,this))},_extendRedrawBounds:function(t){var e;t._pxBounds&&(e=(t.options.weight||0)+1,this._redrawBounds=this._redrawBounds||new f,this._redrawBounds.extend(t._pxBounds.min.subtract([e,e])),this._redrawBounds.extend(t._pxBounds.max.add([e,e])))},_redraw:function(){this._redrawRequest=null,this._redrawBounds&&(this._redrawBounds.min._floor(),this._redrawBounds.max._ceil()),this._clear(),this._draw(),this._redrawBounds=null},_clear:function(){var t,e=this._redrawBounds;e?(t=e.getSize(),this._ctx.clearRect(e.min.x,e.min.y,t.x,t.y)):(this._ctx.save(),this._ctx.setTransform(1,0,0,1,0,0),this._ctx.clearRect(0,0,this._container.width,this._container.height),this._ctx.restore())},_draw:function(){var t,e,i=this._redrawBounds;this._ctx.save(),i&&(e=i.getSize(),this._ctx.beginPath(),this._ctx.rect(i.min.x,i.min.y,e.x,e.y),this._ctx.clip()),this._drawing=!0;for(var n=this._drawFirst;n;n=n.next)t=n.layer,(!i||t._pxBounds&&t._pxBounds.intersects(i))&&t._updatePath();this._drawing=!1,this._ctx.restore()},_updatePoly:function(t,e){if(this._drawing){var i,n,o,s,r=t._parts,a=r.length,h=this._ctx;if(a){for(h.beginPath(),i=0;i<a;i++){for(n=0,o=r[i].length;n<o;n++)s=r[i][n],h[n?\"lineTo\":\"moveTo\"](s.x,s.y);e&&h.closePath()}this._fillStroke(h,t)}}},_updateCircle:function(t){var e,i,n,o;this._drawing&&!t._empty()&&(e=t._point,i=this._ctx,n=Math.max(Math.round(t._radius),1),1!=(o=(Math.max(Math.round(t._radiusY),1)||n)/n)&&(i.save(),i.scale(1,o)),i.beginPath(),i.arc(e.x,e.y/o,n,0,2*Math.PI,!1),1!=o&&i.restore(),this._fillStroke(i,t))},_fillStroke:function(t,e){var i=e.options;i.fill&&(t.globalAlpha=i.fillOpacity,t.fillStyle=i.fillColor||i.color,t.fill(i.fillRule||\"evenodd\")),i.stroke&&0!==i.weight&&(t.setLineDash&&t.setLineDash(e.options&&e.options._dashArray||[]),t.globalAlpha=i.opacity,t.lineWidth=i.weight,t.strokeStyle=i.color,t.lineCap=i.lineCap,t.lineJoin=i.lineJoin,t.stroke())},_onClick:function(t){for(var e,i,n=this._map.mouseEventToLayerPoint(t),o=this._drawFirst;o;o=o.next)(e=o.layer).options.interactive&&e._containsPoint(n)&&((\"click\"===t.type||\"preclick\"===t.type)&&this._map._draggableMoved(e)||(i=e));this._fireEvent(!!i&&[i],t)},_onMouseMove:function(t){var e;!this._map||this._map.dragging.moving()||this._map._animatingZoom||(e=this._map.mouseEventToLayerPoint(t),this._handleMouseHover(t,e))},_handleMouseOut:function(t){var e=this._hoveredLayer;e&&(z(this._container,\"leaflet-interactive\"),this._fireEvent([e],t,\"mouseout\"),this._hoveredLayer=null,this._mouseHoverThrottled=!1)},_handleMouseHover:function(t,e){if(!this._mouseHoverThrottled){for(var i,n,o=this._drawFirst;o;o=o.next)(i=o.layer).options.interactive&&i._containsPoint(e)&&(n=i);n!==this._hoveredLayer&&(this._handleMouseOut(t),n&&(M(this._container,\"leaflet-interactive\"),this._fireEvent([n],t,\"mouseover\"),this._hoveredLayer=n)),this._fireEvent(!!this._hoveredLayer&&[this._hoveredLayer],t),this._mouseHoverThrottled=!0,setTimeout(a(function(){this._mouseHoverThrottled=!1},this),32)}},_fireEvent:function(t,e,i){this._map._fireDOMEvent(e,i||e.type,t)},_bringToFront:function(t){var e,i,n=t._order;n&&(e=n.next,i=n.prev,e&&((e.prev=i)?i.next=e:e&&(this._drawFirst=e),n.prev=this._drawLast,(this._drawLast.next=n).next=null,this._drawLast=n,this._requestRedraw(t)))},_bringToBack:function(t){var e,i,n=t._order;n&&(e=n.next,(i=n.prev)&&((i.next=e)?e.prev=i:i&&(this._drawLast=i),n.prev=null,n.next=this._drawFirst,this._drawFirst.prev=n,this._drawFirst=n,this._requestRedraw(t)))}});function Wi(t){return b.canvas?new Fi(t):null}var Ui=function(){try{return document.namespaces.add(\"lvml\",\"urn:schemas-microsoft-com:vml\"),function(t){return document.createElement(\"<lvml:\"+t+' class=\"lvml\">')}}catch(t){}return function(t){return document.createElement(\"<\"+t+' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"lvml\">')}}(),zt={_initContainer:function(){this._container=P(\"div\",\"leaflet-vml-container\")},_update:function(){this._map._animatingZoom||(Hi.prototype._update.call(this),this.fire(\"update\"))},_initPath:function(t){var e=t._container=Ui(\"shape\");M(e,\"leaflet-vml-shape \"+(this.options.className||\"\")),e.coordsize=\"1 1\",t._path=Ui(\"path\"),e.appendChild(t._path),this._updateStyle(t),this._layers[h(t)]=t},_addPath:function(t){var e=t._container;this._container.appendChild(e),t.options.interactive&&t.addInteractiveTarget(e)},_removePath:function(t){var e=t._container;T(e),t.removeInteractiveTarget(e),delete this._layers[h(t)]},_updateStyle:function(t){var e=t._stroke,i=t._fill,n=t.options,o=t._container;o.stroked=!!n.stroke,o.filled=!!n.fill,n.stroke?(e=e||(t._stroke=Ui(\"stroke\")),o.appendChild(e),e.weight=n.weight+\"px\",e.color=n.color,e.opacity=n.opacity,n.dashArray?e.dashStyle=d(n.dashArray)?n.dashArray.join(\" \"):n.dashArray.replace(/( *, *)/g,\" \"):e.dashStyle=\"\",e.endcap=n.lineCap.replace(\"butt\",\"flat\"),e.joinstyle=n.lineJoin):e&&(o.removeChild(e),t._stroke=null),n.fill?(i=i||(t._fill=Ui(\"fill\")),o.appendChild(i),i.color=n.fillColor||n.color,i.opacity=n.fillOpacity):i&&(o.removeChild(i),t._fill=null)},_updateCircle:function(t){var e=t._point.round(),i=Math.round(t._radius),n=Math.round(t._radiusY||i);this._setPath(t,t._empty()?\"M0 0\":\"AL \"+e.x+\",\"+e.y+\" \"+i+\",\"+n+\" 0,23592600\")},_setPath:function(t,e){t._path.v=e},_bringToFront:function(t){fe(t._container)},_bringToBack:function(t){ge(t._container)}},Vi=b.vml?Ui:ct,qi=Hi.extend({_initContainer:function(){this._container=Vi(\"svg\"),this._container.setAttribute(\"pointer-events\",\"none\"),this._rootGroup=Vi(\"g\"),this._container.appendChild(this._rootGroup)},_destroyContainer:function(){T(this._container),k(this._container),delete this._container,delete this._rootGroup,delete this._svgSize},_update:function(){var t,e,i;this._map._animatingZoom&&this._bounds||(Hi.prototype._update.call(this),e=(t=this._bounds).getSize(),i=this._container,this._svgSize&&this._svgSize.equals(e)||(this._svgSize=e,i.setAttribute(\"width\",e.x),i.setAttribute(\"height\",e.y)),Z(i,t.min),i.setAttribute(\"viewBox\",[t.min.x,t.min.y,e.x,e.y].join(\" \")),this.fire(\"update\"))},_initPath:function(t){var e=t._path=Vi(\"path\");t.options.className&&M(e,t.options.className),t.options.interactive&&M(e,\"leaflet-interactive\"),this._updateStyle(t),this._layers[h(t)]=t},_addPath:function(t){this._rootGroup||this._initContainer(),this._rootGroup.appendChild(t._path),t.addInteractiveTarget(t._path)},_removePath:function(t){T(t._path),t.removeInteractiveTarget(t._path),delete this._layers[h(t)]},_updatePath:function(t){t._project(),t._update()},_updateStyle:function(t){var e=t._path,t=t.options;e&&(t.stroke?(e.setAttribute(\"stroke\",t.color),e.setAttribute(\"stroke-opacity\",t.opacity),e.setAttribute(\"stroke-width\",t.weight),e.setAttribute(\"stroke-linecap\",t.lineCap),e.setAttribute(\"stroke-linejoin\",t.lineJoin),t.dashArray?e.setAttribute(\"stroke-dasharray\",t.dashArray):e.removeAttribute(\"stroke-dasharray\"),t.dashOffset?e.setAttribute(\"stroke-dashoffset\",t.dashOffset):e.removeAttribute(\"stroke-dashoffset\")):e.setAttribute(\"stroke\",\"none\"),t.fill?(e.setAttribute(\"fill\",t.fillColor||t.color),e.setAttribute(\"fill-opacity\",t.fillOpacity),e.setAttribute(\"fill-rule\",t.fillRule||\"evenodd\")):e.setAttribute(\"fill\",\"none\"))},_updatePoly:function(t,e){this._setPath(t,dt(t._parts,e))},_updateCircle:function(t){var e=t._point,i=Math.max(Math.round(t._radius),1),n=\"a\"+i+\",\"+(Math.max(Math.round(t._radiusY),1)||i)+\" 0 1,0 \",e=t._empty()?\"M0 0\":\"M\"+(e.x-i)+\",\"+e.y+n+2*i+\",0 \"+n+2*-i+\",0 \";this._setPath(t,e)},_setPath:function(t,e){t._path.setAttribute(\"d\",e)},_bringToFront:function(t){fe(t._path)},_bringToBack:function(t){ge(t._path)}});function Gi(t){return b.svg||b.vml?new qi(t):null}b.vml&&qi.include(zt),A.include({getRenderer:function(t){t=(t=t.options.renderer||this._getPaneRenderer(t.options.pane)||this.options.renderer||this._renderer)||(this._renderer=this._createRenderer());return this.hasLayer(t)||this.addLayer(t),t},_getPaneRenderer:function(t){var e;return\"overlayPane\"!==t&&void 0!==t&&(void 0===(e=this._paneRenderers[t])&&(e=this._createRenderer({pane:t}),this._paneRenderers[t]=e),e)},_createRenderer:function(t){return this.options.preferCanvas&&Wi(t)||Gi(t)}});var Ki=yi.extend({initialize:function(t,e){yi.prototype.initialize.call(this,this._boundsToLatLngs(t),e)},setBounds:function(t){return this.setLatLngs(this._boundsToLatLngs(t))},_boundsToLatLngs:function(t){return[(t=g(t)).getSouthWest(),t.getNorthWest(),t.getNorthEast(),t.getSouthEast()]}});qi.create=Vi,qi.pointsToPath=dt,xi.geometryToLayer=wi,xi.coordsToLatLng=Pi,xi.coordsToLatLngs=Li,xi.latLngToCoords=Ti,xi.latLngsToCoords=Mi,xi.getFeature=zi,xi.asFeature=Ci,A.mergeOptions({boxZoom:!0});var _t=n.extend({initialize:function(t){this._map=t,this._container=t._container,this._pane=t._panes.overlayPane,this._resetStateTimeout=0,t.on(\"unload\",this._destroy,this)},addHooks:function(){S(this._container,\"mousedown\",this._onMouseDown,this)},removeHooks:function(){k(this._container,\"mousedown\",this._onMouseDown,this)},moved:function(){return this._moved},_destroy:function(){T(this._pane),delete this._pane},_resetState:function(){this._resetStateTimeout=0,this._moved=!1},_clearDeferredResetState:function(){0!==this._resetStateTimeout&&(clearTimeout(this._resetStateTimeout),this._resetStateTimeout=0)},_onMouseDown:function(t){if(!t.shiftKey||1!==t.which&&1!==t.button)return!1;this._clearDeferredResetState(),this._resetState(),re(),Le(),this._startPoint=this._map.mouseEventToContainerPoint(t),S(document,{contextmenu:Re,mousemove:this._onMouseMove,mouseup:this._onMouseUp,keydown:this._onKeyDown},this)},_onMouseMove:function(t){this._moved||(this._moved=!0,this._box=P(\"div\",\"leaflet-zoom-box\",this._container),M(this._container,\"leaflet-crosshair\"),this._map.fire(\"boxzoomstart\")),this._point=this._map.mouseEventToContainerPoint(t);var t=new f(this._point,this._startPoint),e=t.getSize();Z(this._box,t.min),this._box.style.width=e.x+\"px\",this._box.style.height=e.y+\"px\"},_finish:function(){this._moved&&(T(this._box),z(this._container,\"leaflet-crosshair\")),ae(),Te(),k(document,{contextmenu:Re,mousemove:this._onMouseMove,mouseup:this._onMouseUp,keydown:this._onKeyDown},this)},_onMouseUp:function(t){1!==t.which&&1!==t.button||(this._finish(),this._moved&&(this._clearDeferredResetState(),this._resetStateTimeout=setTimeout(a(this._resetState,this),0),t=new s(this._map.containerPointToLatLng(this._startPoint),this._map.containerPointToLatLng(this._point)),this._map.fitBounds(t).fire(\"boxzoomend\",{boxZoomBounds:t})))},_onKeyDown:function(t){27===t.keyCode&&(this._finish(),this._clearDeferredResetState(),this._resetState())}}),Ct=(A.addInitHook(\"addHandler\",\"boxZoom\",_t),A.mergeOptions({doubleClickZoom:!0}),n.extend({addHooks:function(){this._map.on(\"dblclick\",this._onDoubleClick,this)},removeHooks:function(){this._map.off(\"dblclick\",this._onDoubleClick,this)},_onDoubleClick:function(t){var e=this._map,i=e.getZoom(),n=e.options.zoomDelta,i=t.originalEvent.shiftKey?i-n:i+n;\"center\"===e.options.doubleClickZoom?e.setZoom(i):e.setZoomAround(t.containerPoint,i)}})),Zt=(A.addInitHook(\"addHandler\",\"doubleClickZoom\",Ct),A.mergeOptions({dragging:!0,inertia:!0,inertiaDeceleration:3400,inertiaMaxSpeed:1/0,easeLinearity:.2,worldCopyJump:!1,maxBoundsViscosity:0}),n.extend({addHooks:function(){var t;this._draggable||(t=this._map,this._draggable=new Je(t._mapPane,t._container),this._draggable.on({dragstart:this._onDragStart,drag:this._onDrag,dragend:this._onDragEnd},this),this._draggable.on(\"predrag\",this._onPreDragLimit,this),t.options.worldCopyJump&&(this._draggable.on(\"predrag\",this._onPreDragWrap,this),t.on(\"zoomend\",this._onZoomEnd,this),t.whenReady(this._onZoomEnd,this))),M(this._map._container,\"leaflet-grab leaflet-touch-drag\"),this._draggable.enable(),this._positions=[],this._times=[]},removeHooks:function(){z(this._map._container,\"leaflet-grab\"),z(this._map._container,\"leaflet-touch-drag\"),this._draggable.disable()},moved:function(){return this._draggable&&this._draggable._moved},moving:function(){return this._draggable&&this._draggable._moving},_onDragStart:function(){var t,e=this._map;e._stop(),this._map.options.maxBounds&&this._map.options.maxBoundsViscosity?(t=g(this._map.options.maxBounds),this._offsetLimit=_(this._map.latLngToContainerPoint(t.getNorthWest()).multiplyBy(-1),this._map.latLngToContainerPoint(t.getSouthEast()).multiplyBy(-1).add(this._map.getSize())),this._viscosity=Math.min(1,Math.max(0,this._map.options.maxBoundsViscosity))):this._offsetLimit=null,e.fire(\"movestart\").fire(\"dragstart\"),e.options.inertia&&(this._positions=[],this._times=[])},_onDrag:function(t){var e,i;this._map.options.inertia&&(e=this._lastTime=+new Date,i=this._lastPos=this._draggable._absPos||this._draggable._newPos,this._positions.push(i),this._times.push(e),this._prunePositions(e)),this._map.fire(\"move\",t).fire(\"drag\",t)},_prunePositions:function(t){for(;1<this._positions.length&&50<t-this._times[0];)this._positions.shift(),this._times.shift()},_onZoomEnd:function(){var t=this._map.getSize().divideBy(2),e=this._map.latLngToLayerPoint([0,0]);this._initialWorldOffset=e.subtract(t).x,this._worldWidth=this._map.getPixelWorldBounds().getSize().x},_viscousLimit:function(t,e){return t-(t-e)*this._viscosity},_onPreDragLimit:function(){var t,e;this._viscosity&&this._offsetLimit&&(t=this._draggable._newPos.subtract(this._draggable._startPos),e=this._offsetLimit,t.x<e.min.x&&(t.x=this._viscousLimit(t.x,e.min.x)),t.y<e.min.y&&(t.y=this._viscousLimit(t.y,e.min.y)),t.x>e.max.x&&(t.x=this._viscousLimit(t.x,e.max.x)),t.y>e.max.y&&(t.y=this._viscousLimit(t.y,e.max.y)),this._draggable._newPos=this._draggable._startPos.add(t))},_onPreDragWrap:function(){var t=this._worldWidth,e=Math.round(t/2),i=this._initialWorldOffset,n=this._draggable._newPos.x,o=(n-e+i)%t+e-i,n=(n+e+i)%t-e-i,t=Math.abs(o+i)<Math.abs(n+i)?o:n;this._draggable._absPos=this._draggable._newPos.clone(),this._draggable._newPos.x=t},_onDragEnd:function(t){var e,i,n,o,s=this._map,r=s.options,a=!r.inertia||t.noInertia||this._times.length<2;s.fire(\"dragend\",t),!a&&(this._prunePositions(+new Date),t=this._lastPos.subtract(this._positions[0]),a=(this._lastTime-this._times[0])/1e3,e=r.easeLinearity,a=(t=t.multiplyBy(e/a)).distanceTo([0,0]),i=Math.min(r.inertiaMaxSpeed,a),t=t.multiplyBy(i/a),n=i/(r.inertiaDeceleration*e),(o=t.multiplyBy(-n/2).round()).x||o.y)?(o=s._limitOffset(o,s.options.maxBounds),x(function(){s.panBy(o,{duration:n,easeLinearity:e,noMoveStart:!0,animate:!0})})):s.fire(\"moveend\")}})),St=(A.addInitHook(\"addHandler\",\"dragging\",Zt),A.mergeOptions({keyboard:!0,keyboardPanDelta:80}),n.extend({keyCodes:{left:[37],right:[39],down:[40],up:[38],zoomIn:[187,107,61,171],zoomOut:[189,109,54,173]},initialize:function(t){this._map=t,this._setPanDelta(t.options.keyboardPanDelta),this._setZoomDelta(t.options.zoomDelta)},addHooks:function(){var t=this._map._container;t.tabIndex<=0&&(t.tabIndex=\"0\"),S(t,{focus:this._onFocus,blur:this._onBlur,mousedown:this._onMouseDown},this),this._map.on({focus:this._addHooks,blur:this._removeHooks},this)},removeHooks:function(){this._removeHooks(),k(this._map._container,{focus:this._onFocus,blur:this._onBlur,mousedown:this._onMouseDown},this),this._map.off({focus:this._addHooks,blur:this._removeHooks},this)},_onMouseDown:function(){var t,e,i;this._focused||(i=document.body,t=document.documentElement,e=i.scrollTop||t.scrollTop,i=i.scrollLeft||t.scrollLeft,this._map._container.focus(),window.scrollTo(i,e))},_onFocus:function(){this._focused=!0,this._map.fire(\"focus\")},_onBlur:function(){this._focused=!1,this._map.fire(\"blur\")},_setPanDelta:function(t){for(var e=this._panKeys={},i=this.keyCodes,n=0,o=i.left.length;n<o;n++)e[i.left[n]]=[-1*t,0];for(n=0,o=i.right.length;n<o;n++)e[i.right[n]]=[t,0];for(n=0,o=i.down.length;n<o;n++)e[i.down[n]]=[0,t];for(n=0,o=i.up.length;n<o;n++)e[i.up[n]]=[0,-1*t]},_setZoomDelta:function(t){for(var e=this._zoomKeys={},i=this.keyCodes,n=0,o=i.zoomIn.length;n<o;n++)e[i.zoomIn[n]]=t;for(n=0,o=i.zoomOut.length;n<o;n++)e[i.zoomOut[n]]=-t},_addHooks:function(){S(document,\"keydown\",this._onKeyDown,this)},_removeHooks:function(){k(document,\"keydown\",this._onKeyDown,this)},_onKeyDown:function(t){if(!(t.altKey||t.ctrlKey||t.metaKey)){var e,i,n=t.keyCode,o=this._map;if(n in this._panKeys)o._panAnim&&o._panAnim._inProgress||(i=this._panKeys[n],t.shiftKey&&(i=m(i).multiplyBy(3)),o.options.maxBounds&&(i=o._limitOffset(m(i),o.options.maxBounds)),o.options.worldCopyJump?(e=o.wrapLatLng(o.unproject(o.project(o.getCenter()).add(i))),o.panTo(e)):o.panBy(i));else if(n in this._zoomKeys)o.setZoom(o.getZoom()+(t.shiftKey?3:1)*this._zoomKeys[n]);else{if(27!==n||!o._popup||!o._popup.options.closeOnEscapeKey)return;o.closePopup()}Re(t)}}})),Et=(A.addInitHook(\"addHandler\",\"keyboard\",St),A.mergeOptions({scrollWheelZoom:!0,wheelDebounceTime:40,wheelPxPerZoomLevel:60}),n.extend({addHooks:function(){S(this._map._container,\"wheel\",this._onWheelScroll,this),this._delta=0},removeHooks:function(){k(this._map._container,\"wheel\",this._onWheelScroll,this)},_onWheelScroll:function(t){var e=He(t),i=this._map.options.wheelDebounceTime,e=(this._delta+=e,this._lastMousePos=this._map.mouseEventToContainerPoint(t),this._startTime||(this._startTime=+new Date),Math.max(i-(+new Date-this._startTime),0));clearTimeout(this._timer),this._timer=setTimeout(a(this._performZoom,this),e),Re(t)},_performZoom:function(){var t=this._map,e=t.getZoom(),i=this._map.options.zoomSnap||0,n=(t._stop(),this._delta/(4*this._map.options.wheelPxPerZoomLevel)),n=4*Math.log(2/(1+Math.exp(-Math.abs(n))))/Math.LN2,i=i?Math.ceil(n/i)*i:n,n=t._limitZoom(e+(0<this._delta?i:-i))-e;this._delta=0,this._startTime=null,n&&(\"center\"===t.options.scrollWheelZoom?t.setZoom(e+n):t.setZoomAround(this._lastMousePos,e+n))}})),kt=(A.addInitHook(\"addHandler\",\"scrollWheelZoom\",Et),A.mergeOptions({tapHold:b.touchNative&&b.safari&&b.mobile,tapTolerance:15}),n.extend({addHooks:function(){S(this._map._container,\"touchstart\",this._onDown,this)},removeHooks:function(){k(this._map._container,\"touchstart\",this._onDown,this)},_onDown:function(t){var e;clearTimeout(this._holdTimeout),1===t.touches.length&&(e=t.touches[0],this._startPos=this._newPos=new p(e.clientX,e.clientY),this._holdTimeout=setTimeout(a(function(){this._cancel(),this._isTapValid()&&(S(document,\"touchend\",O),S(document,\"touchend touchcancel\",this._cancelClickPrevent),this._simulateEvent(\"contextmenu\",e))},this),600),S(document,\"touchend touchcancel contextmenu\",this._cancel,this),S(document,\"touchmove\",this._onMove,this))},_cancelClickPrevent:function t(){k(document,\"touchend\",O),k(document,\"touchend touchcancel\",t)},_cancel:function(){clearTimeout(this._holdTimeout),k(document,\"touchend touchcancel contextmenu\",this._cancel,this),k(document,\"touchmove\",this._onMove,this)},_onMove:function(t){t=t.touches[0];this._newPos=new p(t.clientX,t.clientY)},_isTapValid:function(){return this._newPos.distanceTo(this._startPos)<=this._map.options.tapTolerance},_simulateEvent:function(t,e){t=new MouseEvent(t,{bubbles:!0,cancelable:!0,view:window,screenX:e.screenX,screenY:e.screenY,clientX:e.clientX,clientY:e.clientY});t._simulated=!0,e.target.dispatchEvent(t)}})),Ot=(A.addInitHook(\"addHandler\",\"tapHold\",kt),A.mergeOptions({touchZoom:b.touch,bounceAtZoomLimits:!0}),n.extend({addHooks:function(){M(this._map._container,\"leaflet-touch-zoom\"),S(this._map._container,\"touchstart\",this._onTouchStart,this)},removeHooks:function(){z(this._map._container,\"leaflet-touch-zoom\"),k(this._map._container,\"touchstart\",this._onTouchStart,this)},_onTouchStart:function(t){var e,i,n=this._map;!t.touches||2!==t.touches.length||n._animatingZoom||this._zooming||(e=n.mouseEventToContainerPoint(t.touches[0]),i=n.mouseEventToContainerPoint(t.touches[1]),this._centerPoint=n.getSize()._divideBy(2),this._startLatLng=n.containerPointToLatLng(this._centerPoint),\"center\"!==n.options.touchZoom&&(this._pinchStartLatLng=n.containerPointToLatLng(e.add(i)._divideBy(2))),this._startDist=e.distanceTo(i),this._startZoom=n.getZoom(),this._moved=!1,this._zooming=!0,n._stop(),S(document,\"touchmove\",this._onTouchMove,this),S(document,\"touchend touchcancel\",this._onTouchEnd,this),O(t))},_onTouchMove:function(t){if(t.touches&&2===t.touches.length&&this._zooming){var e=this._map,i=e.mouseEventToContainerPoint(t.touches[0]),n=e.mouseEventToContainerPoint(t.touches[1]),o=i.distanceTo(n)/this._startDist;if(this._zoom=e.getScaleZoom(o,this._startZoom),!e.options.bounceAtZoomLimits&&(this._zoom<e.getMinZoom()&&o<1||this._zoom>e.getMaxZoom()&&1<o)&&(this._zoom=e._limitZoom(this._zoom)),\"center\"===e.options.touchZoom){if(this._center=this._startLatLng,1==o)return}else{i=i._add(n)._divideBy(2)._subtract(this._centerPoint);if(1==o&&0===i.x&&0===i.y)return;this._center=e.unproject(e.project(this._pinchStartLatLng,this._zoom).subtract(i),this._zoom)}this._moved||(e._moveStart(!0,!1),this._moved=!0),r(this._animRequest);n=a(e._move,e,this._center,this._zoom,{pinch:!0,round:!1},void 0);this._animRequest=x(n,this,!0),O(t)}},_onTouchEnd:function(){this._moved&&this._zooming?(this._zooming=!1,r(this._animRequest),k(document,\"touchmove\",this._onTouchMove,this),k(document,\"touchend touchcancel\",this._onTouchEnd,this),this._map.options.zoomAnimation?this._map._animateZoom(this._center,this._map._limitZoom(this._zoom),!0,this._map.options.zoomSnap):this._map._resetView(this._center,this._map._limitZoom(this._zoom))):this._zooming=!1}})),Yi=(A.addInitHook(\"addHandler\",\"touchZoom\",Ot),A.BoxZoom=_t,A.DoubleClickZoom=Ct,A.Drag=Zt,A.Keyboard=St,A.ScrollWheelZoom=Et,A.TapHold=kt,A.TouchZoom=Ot,t.Bounds=f,t.Browser=b,t.CRS=ot,t.Canvas=Fi,t.Circle=gi,t.CircleMarker=fi,t.Class=et,t.Control=B,t.DivIcon=Ii,t.DivOverlay=Oi,t.DomEvent=mt,t.DomUtil=pt,t.Draggable=Je,t.Evented=it,t.FeatureGroup=ui,t.GeoJSON=xi,t.GridLayer=Ri,t.Handler=n,t.Icon=ci,t.ImageOverlay=Si,t.LatLng=v,t.LatLngBounds=s,t.Layer=o,t.LayerGroup=li,t.LineUtil=gt,t.Map=A,t.Marker=pi,t.Mixin=ft,t.Path=mi,t.Point=p,t.PolyUtil=vt,t.Polygon=yi,t.Polyline=vi,t.Popup=Ai,t.PosAnimation=We,t.Projection=wt,t.Rectangle=Ki,t.Renderer=Hi,t.SVG=qi,t.SVGOverlay=ki,t.TileLayer=Ni,t.Tooltip=Bi,t.Transformation=at,t.Util=tt,t.VideoOverlay=Ei,t.bind=a,t.bounds=_,t.canvas=Wi,t.circle=function(t,e,i){return new gi(t,e,i)},t.circleMarker=function(t,e){return new fi(t,e)},t.control=Ue,t.divIcon=function(t){return new Ii(t)},t.extend=l,t.featureGroup=function(t,e){return new ui(t,e)},t.geoJSON=Zi,t.geoJson=Mt,t.gridLayer=function(t){return new Ri(t)},t.icon=function(t){return new ci(t)},t.imageOverlay=function(t,e,i){return new Si(t,e,i)},t.latLng=w,t.latLngBounds=g,t.layerGroup=function(t,e){return new li(t,e)},t.map=function(t,e){return new A(t,e)},t.marker=function(t,e){return new pi(t,e)},t.point=m,t.polygon=function(t,e){return new yi(t,e)},t.polyline=function(t,e){return new vi(t,e)},t.popup=function(t,e){return new Ai(t,e)},t.rectangle=function(t,e){return new Ki(t,e)},t.setOptions=c,t.stamp=h,t.svg=Gi,t.svgOverlay=function(t,e,i){return new ki(t,e,i)},t.tileLayer=Di,t.tooltip=function(t,e){return new Bi(t,e)},t.transformation=ht,t.version=\"1.9.3\",t.videoOverlay=function(t,e,i){return new Ei(t,e,i)},window.L);t.noConflict=function(){return window.L=Yi,this},window.L=t});\n//# sourceMappingURL=leaflet.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2xlYWZsZXQuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQW9ELFlBQVksQ0FBK0gsQ0FBQyxrQkFBa0IsYUFBYSxjQUFjLG1DQUFtQyxJQUFJLHNDQUFzQyxTQUFTLGlDQUFpQyw0QkFBNEIsY0FBYyxnQkFBZ0IsOEJBQThCLG9GQUFvRixpRUFBaUUsRUFBRSxRQUFRLGNBQWMsMkRBQTJELGtCQUFrQixxQkFBcUIsNEJBQTRCLGNBQWMsMkRBQTJELFNBQVMsa0JBQWtCLHdCQUF3QixrQ0FBa0MsYUFBYSxTQUFTLGdCQUFnQixpRUFBaUUsY0FBYyxrREFBa0QsY0FBYyx5QkFBeUIsZ0JBQWdCLG9HQUFvRyxzQkFBc0IsaUJBQWlCLGtCQUFrQixXQUFXLHdGQUF3RixtREFBbUQsVUFBVSxlQUFlLEdBQUcsZ0JBQWdCLGlDQUFpQyxPQUFPLG1FQUFtRSxxQ0FBcUMsRUFBRSxpQ0FBaUMsNERBQTRELGdCQUFnQixZQUFZLFdBQVcseUJBQXlCLFNBQVMsc0JBQXNCLDZDQUE2QyxjQUFjLDJEQUEyRCxRQUFRLGNBQWMsdUNBQXVDLG9DQUFvQywwS0FBMEssd0JBQXdCLGtCQUFrQiwwQ0FBMEMsVUFBVSxjQUFjLG9CQUFvQixRQUFRLHFEQUFxRCxTQUFTLGtOQUFrTixlQUFlLHNCQUFzQixhQUFhLG9GQUFvRiwwQ0FBMEMsMElBQTBJLHlDQUF5QyxpQkFBaUIsc0NBQXNDLGFBQWEsWUFBWSxXQUFXLDRMQUE0TCxxQ0FBcUMsZ0dBQWdHLG9FQUFvRSwyQkFBMkIscUVBQXFFLGtDQUFrQyxJQUFJLGdDQUFnQyxHQUFHLHdCQUF3Qiw2QkFBNkIsbUdBQW1HLDZCQUE2Qix3Q0FBd0MsNEJBQTRCLGtGQUFrRix1QkFBdUIsdUdBQXVHLE9BQU8sbUJBQW1CLHdEQUF3RCxtQ0FBbUMsSUFBSSx1QkFBdUIsWUFBWSxxQkFBcUIsNkVBQTZFLEtBQUssT0FBTyw4Q0FBOEMsSUFBSSwwQ0FBMEMseUJBQXlCLFlBQVksdUJBQXVCLG1HQUFtRyw2QkFBNkIsNkNBQTZDLDhEQUE4RCxzQkFBc0IsVUFBVSw4REFBOEQsd0NBQXdDLElBQUksY0FBYyx1QkFBdUIsc0xBQXNMLHNCQUFzQixzQkFBc0IsVUFBVSxJQUFJLHdEQUF3RCxFQUFFLGlCQUFpQixzQkFBc0IsTUFBTSx5Q0FBeUMsdUJBQXVCLElBQUksS0FBSyxrQkFBa0Isa0RBQWtELHFCQUFxQiwyQkFBMkIsWUFBWSwyQkFBMkIsb0VBQW9FLG1GQUFtRixtREFBbUQsd0ZBQXdGLFNBQVMsMEJBQTBCLGlCQUFpQiwwQkFBMEIsdUJBQXVCLHFCQUFxQix1QkFBdUIsSUFBSSwwQ0FBMEMsU0FBUyxzQkFBc0IsMkRBQTJELG1DQUFtQyxJQUFJLDBCQUEwQixZQUFZLDRCQUE0QixnREFBZ0QsaUNBQWlDLCtCQUErQixnRUFBZ0UsNkJBQTZCLHFFQUFxRSx1Q0FBdUMsU0FBUyxrTEFBa0wsa0JBQWtCLGtEQUFrRCwrQkFBK0IsdUNBQXVDLGtCQUFrQix5SEFBeUgsZ0JBQWdCLHdDQUF3QyxJQUFJLHNCQUFzQixnQkFBZ0Isc0NBQXNDLGdCQUFnQix3Q0FBd0MsSUFBSSxzQkFBc0IsZ0JBQWdCLG1DQUFtQyxrQkFBa0IsK0VBQStFLGtEQUFrRCxrQkFBa0Isd09BQXdPLGFBQWEsaUJBQWlCLDRCQUE0QixpQkFBaUIsK0JBQStCLGtCQUFrQixvQ0FBb0Msc0JBQXNCLG9DQUFvQyx1QkFBdUIsb0NBQW9DLHNCQUFzQixpQ0FBaUMsdUJBQXVCLGdDQUFnQyx3QkFBd0IsbUNBQW1DLHlCQUF5QixnQ0FBZ0MscUJBQXFCLG9DQUFvQyx1QkFBdUIsb0NBQW9DLGtCQUFrQiw2QkFBNkIsbUJBQW1CLGdFQUFnRSxrQkFBa0IsNkJBQTZCLG1CQUFtQixnRUFBZ0UsaUJBQWlCLDRCQUE0QixrQkFBa0IsOERBQThELGtCQUFrQiw2QkFBNkIsbUJBQW1CLGdEQUFnRCx3QkFBd0IscUNBQXFDLDBCQUEwQixvQkFBb0Isd0NBQXdDLHNCQUFzQiwrRUFBK0UscUJBQXFCLDZDQUE2QyxjQUFjLG1CQUFtQixRQUFRLE1BQU0sMkRBQTJELGtEQUFrRCw2TUFBNk0sWUFBWSx1QkFBdUIsZ0VBQWdFLDBCQUEwQixnQ0FBZ0Msd0JBQXdCLGdDQUFnQyx1QkFBdUIsZ0JBQWdCLDJCQUEyQixnQkFBZ0Isb0JBQW9CLG1DQUFtQyxzQkFBc0IsUUFBUSxnS0FBZ0ssd0JBQXdCLE9BQU8sb0ZBQW9GLFlBQVksc0JBQXNCLE9BQU8sZ0ZBQWdGLFlBQVksb0JBQW9CLDhCQUE4QixpQkFBaUIsc0VBQXNFLHdDQUF3QyxvQkFBb0IsMEZBQTBGLGNBQWMsbUJBQW1CLDRDQUE0Qyx3QkFBd0IsS0FBSywyREFBMkQsb0RBQW9ELDJNQUEyTSxpQkFBaUIsNEZBQTRGLDREQUE0RCxzQkFBc0Isc0dBQXNHLHlCQUF5Qix1QkFBdUIseUJBQXlCLHVCQUF1Qix5QkFBeUIsNkNBQTZDLHlCQUF5Qiw2Q0FBNkMsb0JBQW9CLDJCQUEyQixxQkFBcUIsMkJBQTJCLG9CQUFvQiwyQkFBMkIscUJBQXFCLDJCQUEyQixzQkFBc0IsNERBQTRELDRDQUE0QywySEFBMkgsd0JBQXdCLE9BQU8sd0lBQXdJLFlBQVksc0JBQXNCLE9BQU8sb0lBQW9JLFlBQVkseUJBQXlCLGdGQUFnRixzQkFBc0IsMkdBQTJHLG9CQUFvQiw4Q0FBOEMsUUFBUSw0QkFBNEIsNkNBQTZDLDJDQUEyQyw2QkFBNkIsdURBQXVELG9DQUFvQyxxQkFBcUIsa0NBQWtDLHVCQUF1QixvQ0FBb0MsbUJBQW1CLHlCQUF5QixrQkFBa0IsZ0NBQWdDLGdDQUFnQyxNQUFNLDBKQUEwSix5QkFBeUIscUJBQXFCLHFHQUFxRyxzQkFBc0IscURBQXFELHdCQUF3Qiw4QkFBOEIsaUJBQWlCLDJCQUEyQixzQkFBc0Isd0RBQXdELDBEQUEwRCxrQkFBa0IsMENBQTBDLHlCQUF5QixrREFBa0Qsa0VBQWtFLDhCQUE4QixxRUFBcUUsa0hBQWtILFFBQVEsS0FBSyxtREFBbUQsZ0xBQWdMLGlCQUFpQixpQkFBaUIsb0RBQW9ELHVGQUF1Riw0REFBNEQsdUJBQXVCLGtCQUFrQiwyRUFBMkUsK0NBQStDLHFCQUFxQixxR0FBcUcscUJBQXFCLHVCQUF1QixjQUFjLHdCQUF3QixvQ0FBb0MsMEJBQTBCLHdFQUF3RSwyQkFBMkIsdUVBQXVFLFdBQVcsS0FBSyxpRkFBaUYsU0FBUyxLQUFLLG1CQUFtQixFQUFFLGVBQWUsZ0VBQWdFLGlCQUFpQixvQ0FBb0MsSUFBSSxLQUFLLDBCQUEwQixJQUFJLHNDQUFzQyxzQkFBc0IsaUJBQWlCLHkvQkFBeS9CLFNBQVMsSUFBSSw4QkFBOEIsWUFBWSxlQUFlLE1BQU0sRUFBRSxpSEFBaUgsVUFBVSxTQUFTLDBQQUEwUCxjQUFjLHVEQUF1RCxPQUFPLDRXQUE0VyxJQUFJLHNGQUFzRixzRUFBc0UsU0FBUyxVQUFVLHdHQUF3Ryx5TEFBeUwsc0RBQXNELEtBQUsseUJBQXlCLHFFQUFxRSxRQUFRLHlDQUF5QyxNQUFNLE9BQU8sbUJBQW1CLCtSQUErUixlQUFlLGtCQUFrQixlQUFlLHFDQUFxQyxlQUFlLHVCQUF1QixpQkFBaUIsc0RBQXNELG1EQUFtRCwyQkFBMkIsV0FBVyxpQkFBaUIsaUNBQWlDLFVBQVUsY0FBYyxNQUFNLDJJQUEySSx1REFBdUQsdUJBQXVCLHFFQUFxRSxnREFBZ0QsYUFBYSw2Q0FBNkMsd0VBQXdFLGVBQWUsc0NBQXNDLDBCQUEwQixxUUFBcVEsZUFBZSxzREFBc0QsaUJBQWlCLG9EQUFvRCw2SEFBNkgsa0JBQWtCLDRCQUE0QiwrQ0FBK0MsY0FBYyxtQkFBbUIsb0JBQW9CLGVBQWUsS0FBSyxhQUFhLDZCQUE2QixlQUFlLG1CQUFtQixxQ0FBcUMsZUFBZSxtQkFBbUIsb0RBQW9ELGlCQUFpQixrSEFBa0gsZ0JBQWdCLE1BQU0sc0RBQXNELElBQUksMEJBQTBCLDJDQUEyQyxnQkFBZ0IsMkZBQTJGLGlCQUFpQixpRUFBaUUsZUFBZSxzSEFBc0gsZ0JBQWdCLHlDQUF5Qyw0QkFBNEIsOENBQThDLElBQUksb0JBQW9CLFNBQVMsZ0JBQWdCLHNHQUFzRyxlQUFlLDZDQUE2QyxXQUFXLDRCQUE0QixTQUFTLG1CQUFtQixnQkFBZ0Isa0hBQWtILGdCQUFnQiw4RUFBOEUsZUFBZSxrQ0FBa0MsY0FBYyx3QkFBd0IsY0FBYyx3QkFBd0IsZUFBZSxLQUFLLGdCQUFnQixnQkFBZ0Isc0ZBQXNGLGNBQWMsOERBQThELGVBQWUsS0FBSyxtRUFBbUUsRUFBRSxTQUFTLGVBQWUsZ0NBQWdDLE9BQU8sOEVBQThFLDZDQUE2QywwQkFBMEIsWUFBWSwwQkFBMEIsdUdBQXVHLE1BQU0sNkRBQTZELFlBQVksc0RBQXNELEVBQUUsSUFBSSw2UkFBNlIsVUFBVSwyQkFBMkIsVUFBVSwrR0FBK0csb0JBQW9CLHVEQUF1RCxtQ0FBbUMsSUFBSSxtQkFBbUIsWUFBWSx3QkFBd0Isb0JBQW9CLDBDQUEwQyw0REFBNEQscURBQXFELGtCQUFrQixFQUFFLDRCQUE0QixJQUFJLG1CQUFtQixZQUFZLGlCQUFpQixtQkFBbUIsdUJBQXVCLCtCQUErQixRQUFRLHdGQUF3RixxQkFBcUIsaUNBQWlDLGdDQUFnQyxvQ0FBb0MsMk9BQTJPLFdBQVcsNEVBQTRFLGdDQUFnQyxxRUFBcUUsWUFBWSx1QkFBdUIsNEJBQTRCLHdCQUF3QixvWEFBb1gsZUFBZSxnSEFBZ0gsZUFBZSw2QkFBNkIsZUFBZSw0RkFBNEYsY0FBYyxpRUFBaUUsZUFBZSx1QkFBdUIsZUFBZSwwQ0FBMEMsd0JBQXdCLEVBQUUsMEJBQTBCLFNBQVMsaUJBQWlCLFFBQVEsa0pBQWtKLHVJQUF1SSxlQUFlLG1TQUFtUyxpQkFBaUIsc0JBQXNCLGVBQWUsSUFBSSxLQUFLLFNBQVMsZ0JBQWdCLFNBQVMsU0FBUyxhQUFhLFFBQVEsMk9BQTJPLGVBQWUsc0JBQXNCLG1PQUFtTyxpQkFBaUIsb0RBQW9ELHFCQUFxQixnREFBZ0QsbUJBQW1CLHFEQUFxRCw4RUFBOEUseUJBQXlCLGlEQUFpRCw4Q0FBOEMsc0JBQXNCLHFEQUFxRCxzQkFBc0IsMkNBQTJDLGVBQWUsU0FBUywyUEFBMlAsMEJBQTBCLDZDQUE2Qyx5QkFBeUIsdVJBQXVSLFNBQVMscU9BQXFPLHlCQUF5Qix5R0FBeUcsK0VBQStFLGtCQUFrQixrQkFBa0Isc0NBQXNDLDBKQUEwSiwwREFBMEQsdUJBQXVCLHFEQUFxRCxPQUFPLHNCQUFzQixzQkFBc0IsNEVBQTRFLHVCQUF1Qiw0RUFBNEUsK0JBQStCLGtMQUFrTCx5QkFBeUIsT0FBTyxFQUFFLG9DQUFvQyxPQUFPLGtDQUFrQyw0SEFBNEgsb0VBQW9FLDRCQUE0QixxR0FBcUcsNERBQTRELEVBQUUseUJBQXlCLDhGQUE4Rix5Q0FBeUMsc0JBQXNCLCtDQUErQyxxQkFBcUIsa0NBQWtDLE1BQU0sRUFBRSxxQkFBcUIsTUFBTSxjQUFjLDZIQUE2SCw0REFBNEQsMFhBQTBYLHVCQUF1QixnQkFBZ0IsK0NBQStDLGFBQWEsZ01BQWdNLGNBQWMsa0VBQWtFLDhCQUE4QixjQUFjLG1DQUFtQyxjQUFjLG1DQUFtQyxXQUFXLGNBQWMseUNBQXlDLG1FQUFtRSxzREFBc0QsaURBQWlELHNKQUFzSixTQUFTLGdDQUFnQyxpQkFBaUIsMkJBQTJCLGlDQUFpQyxxQ0FBcUMsMEJBQTBCLDRRQUE0USx3QkFBd0IsMkJBQTJCLDRJQUE0SSx3QkFBd0IsMkJBQTJCLDRJQUE0SSwrQkFBK0IseUJBQXlCLDhEQUE4RCxrRUFBa0UseUJBQXlCLGdCQUFnQiwrTUFBK00sdU5BQXVOLDRCQUE0Qiw2QkFBNkIsS0FBSyxrQkFBa0IsU0FBUyxXQUFXLElBQUksbUpBQW1KLG9QQUFvUCxvQkFBb0IsUUFBUSxpQkFBaUIsNEdBQTRHLG9CQUFvQixRQUFRLGdDQUFnQyxxQkFBcUIsd1FBQXdRLDRDQUE0QyxPQUFPLHVCQUF1QixtTEFBbUwscUNBQXFDLE1BQU0sOE1BQThNLDJDQUEyQyxHQUFHLHdDQUF3QyxnQ0FBZ0MseU1BQXlNLHdDQUF3QyxFQUFFLG1FQUFtRSw4QkFBOEIsMEJBQTBCLDBGQUEwRixtQkFBbUIsa05BQWtOLElBQUksNERBQTRELFNBQVMsNERBQTRELGlUQUFpVCx1Q0FBdUMsc0ZBQXNGLDBCQUEwQiwyRkFBMkYsK0JBQStCLHNCQUFzQiw0SUFBNEksb0JBQW9CLGtCQUFrQixzQkFBc0IsNEJBQTRCLGdGQUFnRix1QkFBdUIsaUZBQWlGLHVCQUF1QiwrR0FBK0csK0JBQStCLHFCQUFxQixxU0FBcVMsNkdBQTZHLG9CQUFvQixrS0FBa0ssOEJBQThCLDZCQUE2QixzQ0FBc0MsMkJBQTJCLCtDQUErQyxpQ0FBaUMsd0VBQXdFLHFCQUFxQiwwQ0FBMEMscUJBQXFCLG1CQUFtQix5QkFBeUIsdUJBQXVCLDRCQUE0Qix1QkFBdUIsdURBQXVELDRCQUE0QiwwRUFBMEUsc0JBQXNCLHVCQUF1Qix3RUFBd0UseUJBQXlCLHdFQUF3RSxnQ0FBZ0Msa0NBQWtDLHlCQUF5QixnQ0FBZ0Msb0VBQW9FLHdCQUF3Qix5Q0FBeUMsOEJBQThCLCtDQUErQyx3QkFBd0IsNENBQTRDLHdDQUF3Qyw0Q0FBNEMsd0NBQXdDLHVDQUF1QyxvQ0FBb0Msd0NBQXdDLGtDQUFrQyxvQ0FBb0Msc0VBQXNFLHdDQUF3Qyw2QkFBNkIsb0NBQW9DLDJFQUEyRSxnQ0FBZ0MsK0RBQStELDRCQUE0Qix3QkFBd0Isa0RBQWtELDBFQUEwRSx5REFBeUQsd0JBQXdCLG9TQUFvUyx3SkFBd0osdUJBQXVCLHFCQUFxQixzQkFBc0IscVhBQXFYLDRCQUE0Qiw0QkFBNEIsc0dBQXNHLHdGQUF3RiwwQkFBMEIsZ0VBQWdFLHlCQUF5QiwyQkFBMkIscUJBQXFCLHNMQUFzTCxzQkFBc0Isb0RBQW9ELGtCQUFrQixvRUFBb0UsdUJBQXVCLG1EQUFtRCx5QkFBeUIsMkNBQTJDLGdDQUFnQyxvRUFBb0UsMkJBQTJCLG1FQUFtRSx5QkFBeUIsaUJBQWlCLFlBQVksdVZBQXVWLHNCQUFzQix3REFBd0QscUJBQXFCLG1CQUFtQixFQUFFLE9BQU8sc0JBQXNCLHlEQUF5RCx1QkFBdUIsNEJBQTRCLHVIQUF1SCxpQ0FBaUMsK0VBQStFLEVBQUUsRUFBRSxvRkFBb0YsS0FBSyxNQUFNLHVCQUF1QixxQkFBcUIscUJBQXFCLDZCQUE2QixlQUFlLHNEQUFzRCw4QkFBOEIsS0FBSyx1QkFBdUIsRUFBRSxxQ0FBcUMsZ0JBQWdCLDZCQUE2QiwrQkFBK0IsZ0pBQWdKLHNHQUFzRywwQkFBMEIscURBQXFELGtDQUFrQyxNQUFNLGlCQUFpQixXQUFXLHFDQUFxQyxjQUFjLGFBQWEsd0JBQXdCLGdCQUFnQixpQkFBaUIsK1VBQStVLFdBQVcsOEhBQThILDZCQUE2QixtSEFBbUgsMkJBQTJCLG9DQUFvQyxJQUFJLGdDQUFnQyx5QkFBeUIsb0NBQW9DLFlBQVksMkJBQTJCLDJCQUEyQixxQ0FBcUMsbUJBQW1CLDRCQUE0QiwyQkFBMkIsZ0NBQWdDLHlHQUF5RyxrQ0FBa0Msa0NBQWtDLDJFQUEyRSx3Q0FBd0MsK0JBQStCLHNDQUFzQywrQ0FBK0MsK0JBQStCLG9NQUFvTSxpQ0FBaUMsb0VBQW9FLDhCQUE4Qix3RUFBd0UsOEJBQThCLFFBQVEsNExBQTRMLDRCQUE0QixNQUFNLDBHQUEwRyxrQ0FBa0MsdUhBQXVILDhEQUE4RCx3QkFBd0Isa0ZBQWtGLHdCQUF3Qiw4RUFBOEUsMERBQTBELGlDQUFpQyxrQkFBa0IsZ0NBQWdDLHlEQUF5RCwrQkFBK0Isb0NBQW9DLGdGQUFnRiw2QkFBNkIsaUVBQWlFLGtFQUFrRSxnQ0FBZ0MscUpBQXFKLHFHQUFxRyw4QkFBOEIsa0ZBQWtGLHlCQUF5Qix3Q0FBd0MseURBQXlELGlDQUFpQyx5RkFBeUYsOEJBQThCLDhFQUE4RSxrQ0FBa0MseUJBQXlCLFVBQVUsb0lBQW9JLHVFQUF1RSx3REFBd0QsYUFBYSw0Q0FBNEMsT0FBTyxTQUFTLGdDQUFnQyxxSkFBcUosMkJBQTJCLHlNQUF5TSxpQ0FBaUMsaVJBQWlSLEVBQUUsZUFBZSxnQkFBZ0Isb0JBQW9CLFNBQVMsb0JBQW9CLHdCQUF3QixVQUFVLHdCQUF3Qiw2QkFBNkIseUJBQXlCLGdCQUFnQixtRkFBbUYseUJBQXlCLHVCQUF1QixtQkFBbUIsMEJBQTBCLGdGQUFnRixvSkFBb0osbUJBQW1CLDRJQUE0SSwyQkFBMkIsMEVBQTBFLGlCQUFpQix1QkFBdUIsMEJBQTBCLDJCQUEyQix1QkFBdUIsNEJBQTRCLDZCQUE2QixzRkFBc0YsZ0JBQWdCLDhCQUE4Qix3RUFBd0UsNkJBQTZCLDZEQUE2RCxxRkFBcUYsWUFBWSxTQUFTLDhHQUE4Ryx1QkFBdUIsNEJBQTRCLHNJQUFzSSxxQ0FBcUMsbUJBQW1CLDZGQUE2RixZQUFZLHNCQUFzQixvRUFBb0UsdUJBQXVCLG1CQUFtQixtRUFBbUUscUJBQXFCLHdEQUF3RCxZQUFZLHNCQUFzQixxRUFBcUUsNEJBQTRCLHlEQUF5RCwwQkFBMEIsNERBQTRELHlCQUF5Qiw2Q0FBNkMsdUJBQXVCLHVGQUF1RixtQkFBbUIscUZBQXFGLDJEQUEyRCxpTkFBaU4scUJBQXFCLGlFQUFpRSx3QkFBd0Isa09BQWtPLHVEQUF1RCwrQ0FBK0MsaUVBQWlFLG9CQUFvQixxQ0FBcUMsbUJBQW1CLDJCQUEyQix5S0FBeUssdUJBQXVCLFlBQVksc0JBQXNCLDRFQUE0RSwyQkFBMkIsMEVBQTBFLHlCQUF5Qiw2REFBNkQsZ0VBQWdFLDhIQUE4SCxvQkFBb0Isb0JBQW9CLDRFQUE0RSxzQkFBc0Isc0JBQXNCLHVGQUF1RixvSUFBb0ksWUFBWSw0QkFBNEIsb0NBQW9DLGdJQUFnSSx1QkFBdUIsbUNBQW1DLDhJQUE4SSxrQ0FBa0Msc0JBQXNCLDRiQUE0YiwySkFBMkosMEJBQTBCLDZDQUE2Qyx1QkFBdUIscUJBQXFCLEtBQUssc0ZBQXNGLFFBQVEsV0FBVywwREFBMEQsUUFBUSxXQUFXLHVEQUF1RCw0Q0FBNEMsaUNBQWlDLDBFQUEwRSxLQUFLLHlKQUF5SixrQ0FBa0MsOERBQThELDBCQUEwQixvQkFBb0IsbURBQW1ELGVBQWUsR0FBRyxnQkFBZ0IsU0FBUyxzSUFBc0ksaUNBQWlDLG1CQUFtQix3RUFBd0Usa1JBQWtSLHNCQUFzQiw0REFBNEQsb0JBQW9CLHFEQUFxRCxtQkFBbUIscURBQXFELHFCQUFxQix3SEFBd0gsc0JBQXNCLHlIQUF5SCxtQ0FBbUMsYUFBYSwwTEFBMEwsNEJBQTRCLHFDQUFxQyxpYUFBaWEsc0JBQXNCLGVBQWUsMkJBQTJCLHNGQUFzRixZQUFZLFNBQVMseURBQXlELG1CQUFtQiwwREFBMEQsaUlBQWlJLHNCQUFzQixzRUFBc0UsNEJBQTRCLDhFQUE4RSxvQkFBb0Isb0lBQW9JLHNCQUFzQiwyQkFBMkIsZ0dBQWdHLDJCQUEyQiwyQkFBMkIsNkRBQTZELDZCQUE2QixzQkFBc0Isd0pBQXdKLDhCQUE4QixxRUFBcUUsMEJBQTBCLHFEQUFxRCw4Q0FBOEMsZ0JBQWdCLFNBQVMsc1pBQXNaLHdCQUF3QixnQ0FBZ0MsbUJBQW1CLHdNQUF3TSxpRkFBaUYsc0JBQXNCLDRDQUE0Qyw2QkFBNkIsd0dBQXdHLGlEQUFpRCxRQUFRLHVCQUF1QixpREFBaUQsNEJBQTRCLHlHQUF5RywrQkFBK0IsK0VBQStFLG9CQUFvQixjQUFjLFdBQVcsNkRBQTZELFNBQVMsMEpBQTBKLHFCQUFxQixzQkFBc0IsMkJBQTJCLHNEQUFzRCw4RUFBOEUscUJBQXFCLHFCQUFxQixpQkFBaUIsc0JBQXNCLGlCQUFpQiw0QkFBNEIsaUJBQWlCLFlBQVksdUJBQXVCLFlBQVksbUJBQW1CLDhEQUE4RCxvQkFBb0IsaUVBQWlFLG9CQUFvQix1QkFBdUIsNkJBQTZCLGlDQUFpQyxFQUFFLFNBQVMsOERBQThELFNBQVMsaUJBQWlCLDhCQUE4Qiw0RUFBNEUsbUJBQW1CLGdGQUFnRixvQkFBb0Isd0lBQXdJLHFCQUFxQixRQUFRLHdsQkFBd2xCLHFCQUFxQixNQUFNLDJyQkFBMnJCLDRCQUE0QixPQUFPLCtCQUErQix5RUFBeUUsa0JBQWtCLGlDQUFpQyx3QkFBd0IsaVNBQWlTLDZEQUE2RCxtQ0FBbUMsRUFBRSxpQkFBaUIsZ0JBQWdCLHNCQUFzQixvQ0FBb0MsSUFBSSxtQkFBbUIsd0JBQXdCLGVBQWUsbUNBQW1DLHNCQUFzQixTQUFTLDZFQUE2RSxvQ0FBb0MsY0FBYyxVQUFVLE9BQU8sMkNBQTJDLHdDQUF3QyxjQUFjLFdBQVcsUUFBUSxJQUFJLHVCQUF1QixTQUFTLGlCQUFpQixtQkFBbUIsK0JBQStCLHVCQUF1QixtQ0FBbUMsVUFBVSxFQUFFLHNCQUFzQixnQkFBZ0Isd0RBQXdELHVCQUF1Qiw0Q0FBNEMscUpBQXFKLGlCQUFpQixRQUFRLG1GQUFtRixxQkFBcUIsMENBQTBDLG9IQUFvSCxjQUFjLDJEQUEyRCxlQUFlLDJGQUEyRixpQkFBaUIsY0FBYywwREFBMEQsc0ZBQXNGLFdBQVcsc0NBQXNDLDJCQUEyQixNQUFNLGlDQUFpQyxnQkFBZ0IsZUFBZSxNQUFNLGlEQUFpRCw4Q0FBOEMsTUFBTSx5QkFBeUIsSUFBSSwyRkFBMkYsaUJBQWlCLHdIQUF3SCxtQkFBbUIsaURBQWlELElBQUksMEJBQTBCLFFBQVEsSUFBSSxLQUFLLHFDQUFxQyxJQUFJLHdKQUF3SixJQUFJLFNBQVMsaUJBQWlCLGdCQUFnQiwwREFBMEQsc0ZBQXNGLFdBQVcsc0NBQXNDLHFDQUFxQyxJQUFJLDJFQUEyRSxnREFBZ0QsUUFBUSwrQ0FBK0MsS0FBSyxvQkFBb0IsMEJBQTBCLHVCQUF1QixzQkFBc0IsbUNBQW1DLEtBQUssd0lBQXdJLDhLQUE4SywwQkFBMEIsdUJBQXVCLDRIQUE0SCx1QkFBdUIsa0ZBQWtGLDJCQUEyQixLQUFLLDBEQUEwRCxRQUFRLEtBQUssaUZBQWlGLFNBQVMsS0FBSyxvRUFBb0UsU0FBUyxLQUFLLDREQUE0RCxxQkFBcUIsa0JBQWtCLDRCQUE0Qix3QkFBd0IsZ0NBQWdDLDBCQUEwQixhQUFhLHVHQUF1RyxTQUFTLDJEQUEyRCxtQkFBbUIsNkJBQTZCLG1CQUFtQixrREFBa0Qsd0JBQXdCLG1DQUFtQyxxQkFBcUIsaUVBQWlFLGtDQUFrQyxxQ0FBcUMscUNBQXFDLDRDQUE0QywyQkFBMkIsZ0NBQWdDLHVCQUF1QixpQkFBaUIsaUpBQWlKLGNBQWMsMERBQTBELFdBQVcsSUFBSSxrQkFBa0IscUJBQXFCLE1BQU0scUpBQXFKLHVEQUF1RCx5QkFBeUIsV0FBVyx1SEFBdUgsUUFBUSxrREFBa0Qsc0JBQXNCLDJCQUEyQix5QkFBeUIsb0RBQW9ELFlBQVksd0JBQXdCLHlDQUF5QyxJQUFJLHdCQUF3QiwyQkFBMkIsNkdBQTZHLDhCQUE4QixPQUFPLHFGQUFxRiw4QkFBOEIseUNBQXlDLGdLQUFnSyx1WEFBdVgsWUFBWSx5QkFBeUIsUUFBUSw0QkFBNEIsc0JBQXNCLElBQUksd0JBQXdCLHNCQUFzQix5QkFBeUIsK0RBQStELHlCQUF5Qix5Q0FBeUMsc0dBQXNHLHNCQUFzQiwrREFBK0Qsd0JBQXdCLDZDQUE2QyxvQkFBb0Isa0RBQWtELDhEQUE4RCxZQUFZLG1CQUFtQiw2QkFBNkIsc0JBQXNCLGdDQUFnQyx5QkFBeUIsb0RBQW9ELFlBQVksc0JBQXNCLHVCQUF1QixzQkFBc0IsU0FBUyxrQ0FBa0MsdUJBQXVCLGtDQUFrQyxjQUFjLGlCQUFpQixxQkFBcUIsOEdBQThHLFFBQVEsR0FBRyx5QkFBeUIsd0pBQXdKLFFBQVEsUUFBUSxzQkFBc0IsaUNBQWlDLHlCQUF5QixtQ0FBbUMsd0JBQXdCLGtDQUFrQyxzQkFBc0IsY0FBYyx1QkFBdUIsc0JBQXNCLGtEQUFrRCxVQUFVLGdCQUFnQixTQUFTLHFEQUFxRCx3QkFBd0IsVUFBVSx3QkFBd0Isa0NBQWtDLDBCQUEwQixvQ0FBb0MsMkJBQTJCLDBCQUEwQiw0TkFBNE4saUZBQWlGLFlBQVksOEJBQThCLHdJQUF3SSx3S0FBd0ssMEJBQTBCLG1EQUFtRCx5QkFBeUIscUVBQXFFLEVBQUUsa0JBQWtCLFNBQVMsNkxBQTZMLHlCQUF5Qix3SkFBd0osdUJBQXVCLGtCQUFrQiwwQkFBMEIsMkVBQTJFLDRCQUE0Qiw2R0FBNkcsaUxBQWlMLGVBQWUsdUJBQXVCLGVBQWUscUJBQXFCLHlCQUF5QixzRUFBc0UsOEZBQThGLGdEQUFnRCx3QkFBd0IscUJBQXFCLDhGQUE4RixzRkFBc0Ysa0JBQWtCLCtDQUErQyx3QkFBd0IsNE5BQTROLHNQQUFzUCxXQUFXLHlLQUF5Syx5QkFBeUIsNklBQTZJLHdCQUF3QixxR0FBcUcscUJBQXFCLDRFQUE0RSw2RkFBNkYsd0JBQXdCLDJGQUEyRixlQUFlLFNBQVMsc1FBQXNRLDBCQUEwQiw0QkFBNEIsbUJBQW1CLGdLQUFnSyxzQkFBc0IsME5BQTBOLHNCQUFzQixPQUFPLHdDQUF3QyxzQkFBc0Isb0JBQW9CLHVCQUF1QixtQkFBbUIseURBQXlELGdDQUFnQyxFQUFFLDZCQUE2QixpREFBaUQsb0JBQW9CLHlCQUF5QixxQkFBcUIseUlBQXlJLHVCQUF1QixrQkFBa0IsbUJBQW1CLE1BQU0sMEdBQTBHLHNCQUFzQixtVkFBbVYsd0RBQXdELDBHQUEwRyxrUEFBa1Asd0JBQXdCLG9DQUFvQyx3REFBd0Qsa0pBQWtKLDBCQUEwQixnREFBZ0QscUJBQXFCLDJIQUEySCwyQkFBMkIscURBQXFELDBCQUEwQix5RUFBeUUsZ0JBQWdCLDZCQUE2QixNQUFNLDZQQUE2UCx3QkFBd0Isb0VBQW9FLDJCQUEyQiwyQkFBMkIsNERBQTRELDBCQUEwQiw0Q0FBNEMseUJBQXlCLHNCQUFzQix3QkFBd0Isb0JBQW9CLGtJQUFrSSxrREFBa0QsR0FBRyw0QkFBNEIsNkNBQTZDLDhCQUE4QixnREFBZ0QsRUFBRSxpQkFBaUIsU0FBUyw0TUFBNE0sdUJBQXVCLG1DQUFtQyxrQkFBa0IsMkVBQTJFLHFCQUFxQixpQ0FBaUMsbUJBQW1CLHdEQUF3RCxzQkFBc0IseUtBQXlLLHlCQUF5QiwrREFBK0Qsd0JBQXdCLDhEQUE4RCx1QkFBdUIsa0JBQWtCLG1CQUFtQiwrQkFBK0IsNEJBQTRCLDJGQUEyRixnQkFBZ0IsU0FBUyxrQkFBa0IsMEJBQTBCLDZEQUE2RCx1QkFBdUIsbUJBQW1CLHlEQUF5RCxnQ0FBZ0MsRUFBRSxzQkFBc0Isb0JBQW9CLHVCQUF1Qix3REFBd0Qsc0JBQXNCLG9CQUFvQixzQkFBc0IsZ0NBQWdDLGlFQUFpRSxxQkFBcUIsNEVBQTRFLDBCQUEwQiwyRUFBMkUsaUVBQWlFLG9CQUFvQiw4QkFBOEIsd0JBQXdCLG1DQUFtQyxtQkFBbUIsd0VBQXdFLDRCQUE0Qix1RUFBdUUsRUFBRSxrQkFBa0IsMkJBQTJCLG1DQUFtQyxJQUFJLFNBQVMsaUdBQWlHLGtDQUFrQyx1QkFBdUIscUNBQXFDLHNCQUFzQixxQkFBcUIsc0JBQXNCLGlEQUFpRCxxSEFBcUgsb0RBQW9ELGdGQUFnRixnbEJBQWdsQixFQUFFLGtCQUFrQixTQUFTLHlCQUF5QiwwQkFBMEIsOEJBQThCLHVCQUF1QixxQkFBcUIsd0JBQXdCLHlDQUF5QyxvQkFBb0IsNEJBQTRCLCtCQUErQixtREFBbUQsSUFBSSw0Q0FBNEMsSUFBSSxLQUFLLGtDQUFrQyxzQkFBc0Isc0NBQXNDLHNCQUFzQixtRUFBbUUsa0VBQWtFLHNCQUFzQixvQkFBb0IseUJBQXlCLHVGQUF1Rix5QkFBeUIseURBQXlELDBCQUEwQix1REFBdUQsNkJBQTZCLG1DQUFtQyxJQUFJLCtFQUErRSxTQUFTLHFCQUFxQixZQUFZLGlKQUFpSiwwQkFBMEIsMENBQTBDLDRHQUE0RyxpQ0FBaUMsc0NBQXNDLE1BQU0sYUFBYSxJQUFJLDJEQUEyRCxVQUFVLGFBQWEsSUFBSSxtQ0FBbUMsd0JBQXdCLDZCQUE2Qiw4R0FBOEcsZ0VBQWdFLElBQUksd0NBQXdDLE1BQU0sOEdBQThHLDRCQUE0QixpRUFBaUUsSUFBSSxvQkFBb0Isb0JBQW9CLDBFQUEwRSx3QkFBd0IsaUNBQWlDLDhCQUE4Qix5Q0FBeUMsMkVBQTJFLElBQUksOENBQThDLElBQUksaURBQWlELFVBQVUsRUFBRSxZQUFZLGtCQUFrQixTQUFTLFFBQVEsb0JBQW9CLHNEQUFzRCxzQkFBc0IsbUVBQW1FLGtFQUFrRSw2QkFBNkIsMkRBQTJELDhEQUE4RCx5QkFBeUIsd0ZBQXdGLDBCQUEwQiw4REFBOEQsd0JBQXdCLHdHQUF3Ryw4R0FBOEcsd0NBQXdDLElBQUksNERBQTRELHdCQUF3QixvQ0FBb0MsNEJBQTRCLHlCQUF5Qix5REFBeUQsNkJBQTZCLElBQUksOENBQThDLElBQUksb0ZBQW9GLHVEQUF1RCxFQUFFLGtCQUFrQix5QkFBeUIseUJBQXlCLG9CQUFvQixxQkFBcUIsOEJBQThCLE1BQU0sbUJBQW1CLElBQUksa0ZBQWtGLFlBQVkscUJBQXFCLHdLQUF3Syx3QkFBd0Isc0VBQXNFLG1FQUFtRSxzQkFBc0Isa0NBQWtDLHlCQUF5QixPQUFPLDhCQUE4QixvRUFBb0UsRUFBRSxpQkFBaUIsd0hBQXdILHNCQUFzQixlQUFlLG9DQUFvQyxvQ0FBb0MsSUFBSSxrQ0FBa0MsaUJBQWlCLDhGQUE4RixxRkFBcUYsdURBQXVELElBQUksS0FBSyxVQUFVLGdFQUFnRSxJQUFJLGFBQWEsaUJBQWlCLG9EQUFvRCxJQUFJLEtBQUssMEJBQTBCLGFBQWEsaUJBQWlCLG9EQUFvRCxxQkFBcUIsd0RBQXdELGVBQWUsNkJBQTZCLG1CQUFtQiw4QkFBOEIsSUFBSSwrQ0FBK0MsU0FBUyxpQkFBaUIsd0ZBQXdGLHFCQUFxQiw0QkFBNEIsSUFBSSxvREFBb0Qsb0NBQW9DLGlCQUFpQixxQkFBcUIsWUFBWSxXQUFXLFFBQVEsZUFBZSwwREFBMEQsNEJBQTRCLGFBQWEsSUFBSSxzQkFBc0IsZ0JBQWdCLGdEQUFnRCxJQUFJLGlCQUFpQixtQkFBbUIseURBQXlELHNCQUFzQix3QkFBd0IsZ0JBQWdCLDBFQUEwRSxHQUFHLGNBQWMsc0JBQXNCLHFGQUFxRixnQkFBZ0Isb0RBQW9ELEdBQUcsY0FBYyx5QkFBeUIsU0FBUyxrQ0FBa0MsNENBQTRDLFdBQVcsZ0NBQWdDLEVBQUUsdUJBQXVCLDBFQUEwRSx3R0FBd0csK0hBQStILGFBQWEsdUNBQXVDLEdBQUcsb0NBQW9DLEdBQUcsRUFBRSx1QkFBdUIsU0FBUyx3RkFBd0YsNEJBQTRCLHdDQUF3QyxrQkFBa0IsNk9BQTZPLHFCQUFxQixtRkFBbUYsd0JBQXdCLHNFQUFzRSxzQkFBc0Isa0RBQWtELHlCQUF5Qix1Q0FBdUMsd0JBQXdCLHVDQUF1QyxvQkFBb0IseURBQXlELHVCQUF1Qix1REFBdUQsc0JBQXNCLE9BQU8sd0NBQXdDLDREQUE0RCx1QkFBdUIsdURBQXVELHNCQUFzQixvQkFBb0IsdUJBQXVCLG1CQUFtQix1QkFBdUIsbUVBQW1FLDRkQUE0ZCwwQkFBMEIsaUhBQWlILG9CQUFvQixtQkFBbUIsNkpBQTZKLDBEQUEwRCwyQkFBMkIsb0NBQW9DLDBCQUEwQixzSEFBc0gsNEJBQTRCLG1CQUFtQixtQ0FBbUMsa0RBQWtELHNCQUFzQixpQ0FBaUMsZ0JBQWdCLFNBQVMsK0RBQStELHVCQUF1Qix1RUFBdUUsZ05BQWdOLG9EQUFvRCxXQUFXLHFCQUFxQiwrQkFBK0IsS0FBSywrUkFBK1IsWUFBWSxtQkFBbUIsS0FBSyxrQkFBa0IsdUNBQXVDLEVBQUUsa0JBQWtCLHNCQUFzQiw0QkFBNEIsbUtBQW1LLEVBQUUsaUJBQWlCLFNBQVMsZ0VBQWdFLDBCQUEwQiw4SUFBOEksb0JBQW9CLHFGQUFxRixrQkFBa0IsbURBQW1ELG9CQUFvQiw0SEFBNEgsbUJBQW1CLG1YQUFtWCxzQkFBc0IsNk9BQTZPLHNCQUFzQixvQkFBb0IsdUJBQXVCLG9GQUFvRix1QkFBdUIscUJBQXFCLHdCQUF3QiwwQ0FBMEMsdUJBQXVCLHVCQUF1QixtQkFBbUIsK0tBQStLLHNCQUFzQixPQUFPLDBEQUEwRCw0REFBNEQsbUJBQW1CLDRDQUE0Qyx5QkFBeUIsMkNBQTJDLHdCQUF3QiwyQ0FBMkMsMEJBQTBCLG1DQUFtQyxvQkFBb0Isb0NBQW9DLHlCQUF5QixPQUFPLE1BQU0sZUFBZSxlQUFlLHFDQUFxQyxvQ0FBb0MsS0FBSyxzRUFBc0UsNEJBQTRCLHFEQUFxRCwyQkFBMkIsa0JBQWtCLDJHQUEyRyxvQ0FBb0MsS0FBSyxLQUFLLGtCQUFrQiw2QkFBNkIsaUJBQWlCLDRCQUE0Qiw0QkFBNEIsVUFBVSx5VUFBeVUsdUJBQXVCLGFBQWEsaUJBQWlCLCtCQUErQixRQUFRLHVFQUF1RSxhQUFhLCtCQUErQixRQUFRLHlGQUF5RixhQUFhLFNBQVMsMk9BQTJPLG9CQUFvQiw2S0FBNkssbUJBQW1CLG9EQUFvRCxXQUFXLGdEQUFnRCxXQUFXLGlFQUFpRSxzQkFBc0Isd0RBQXdELFdBQVcsaURBQWlELFdBQVcsa0VBQWtFLHNCQUFzQix3Q0FBd0MseUxBQXlMLHdCQUF3Qiw2SkFBNkosNllBQTZZLGlDQUFpQyxrQkFBa0IsUUFBUSwwQkFBMEIsaVJBQWlSLHFGQUFxRiwwQkFBMEIseUZBQXlGLDRCQUE0Qix1QkFBdUIsb0JBQW9CLCtyQkFBK3JCLHVCQUF1QiwyRkFBMkYsdUJBQXVCLHFCQUFxQixhQUFhLDBCQUEwQixxREFBcUQsd0JBQXdCLDBEQUEwRCxhQUFhLHdCQUF3Qiw2RkFBNkYsNEZBQTRGLG9DQUFvQyx3QkFBd0IsK0JBQStCLDRGQUE0RixxREFBcUQsdUJBQXVCLG1KQUFtSix1QkFBdUIsNkNBQTZDLHdCQUF3QixrREFBa0Qsd0JBQXdCLDBDQUEwQyw2QkFBNkIsbURBQW1ELHFCQUFxQixtQkFBbUIsd0JBQXdCLE1BQU0seU5BQXlOLHdCQUF3QixnQ0FBZ0MseUJBQXlCLGtEQUFrRCxhQUFhLFNBQVMsbUZBQW1GLG1CQUFtQiw0RkFBNEYsYUFBYSxvRkFBb0YsYUFBYSxNQUFNLHNCQUFzQiwwREFBMEQsYUFBYSx3RkFBd0YsYUFBYSxNQUFNLHNCQUFzQix3Q0FBd0MseURBQXlELHdCQUF3Qiw4R0FBOEcsMEpBQTBKLDJCQUEyQix3QkFBd0IsMEJBQTBCLHVXQUF1Vyx5TEFBeUwsNEJBQTRCLGlEQUFpRCxxQkFBcUIsd0JBQXdCLDZEQUE2RCwwQkFBMEIsaUVBQWlFLHFCQUFxQix1QkFBdUIscUhBQXFILGtCQUFrQiw0QkFBNEIscURBQXFELDBCQUEwQix1QkFBdUIsYUFBYSwwQkFBMEIscVBBQXFQLDBCQUEwQixzR0FBc0csc0NBQXNDLFFBQVEsbURBQW1ELGdEQUFnRCwwVEFBMFQseUJBQXlCLDBRQUEwUSx5QkFBeUIsOENBQThDLDBCQUEwQixzREFBc0QsMEJBQTBCLDhCQUE4QiwrQkFBK0IsdURBQXVELHVCQUF1QixxQkFBcUIsK0JBQStCLHlIQUF5SCx1Q0FBdUMscUJBQXFCLDJCQUEyQiwyQ0FBMkMsMkNBQTJDLHdDQUF3QyxpQkFBaUIsa0VBQWtFLDBCQUEwQixzTEFBc0wsMEJBQTBCLGVBQWUsaU5BQWlOLGFBQWEsU0FBUyxpRUFBaUUsd0JBQXdCLDBFQUEwRSx5TUFBeU0seUJBQXlCLGFBQWEsR0FBRyxjQUFjLGlCQUFpQixTQUFTLG1PQUFtTyx3QkFBd0IsVUFBVSxrQkFBa0IscUNBQXFDLGVBQWUsbUJBQW1CLHVCQUF1QixzQkFBc0Isc0JBQXNCLDhHQUE4Ryx5QkFBeUIsMkVBQTJFLHdCQUF3QiwyRUFBMkUseUJBQXlCLHVCQUF1Qix3QkFBd0IseURBQXlELHVCQUF1Qix1REFBdUQsc0JBQXNCLHFCQUFxQixtQkFBbUIsTUFBTSxrS0FBa0ssc0JBQXNCLE9BQU8seUdBQXlHLGdNQUFnTSx1QkFBdUIscUNBQXFDLHdCQUF3Qiw0QkFBNEIsbUNBQW1DLDBCQUEwQiw4SEFBOEgsNEJBQTRCLGtFQUFrRSxJQUFJLCtEQUErRCxrRUFBa0UsMkJBQTJCLHdCQUF3Qix3Q0FBd0MsNEJBQTRCLHNCQUFzQix1QkFBdUIsMkhBQTJILDJHQUEyRywyQ0FBMkMseU1BQXlNLDBCQUEwQiw0Q0FBNEMsZUFBZSwwUEFBMFAsa0NBQWtDLGdDQUFnQyx1UkFBdVIsMkVBQTJFLGNBQWMsZ0NBQWdDLHlFQUF5RSxLQUFLLHlEQUF5RCx3SkFBd0osa0VBQWtFLGdDQUFnQywwRUFBMEUsNEJBQTRCLDZDQUE2QywyQkFBMkIsc0dBQXNHLDZDQUE2QyxpQ0FBaUMsaUhBQWlILDZGQUE2RixtQ0FBbUMsY0FBYyxRQUFRLGtCQUFrQixRQUFRLEtBQUssdUVBQXVFLDZGQUE2Rix3QkFBd0Isd0JBQXdCLDZEQUE2RCwwQkFBMEIsNkNBQTZDLHdCQUF3QixtQkFBbUIsaUlBQWlJLDRCQUE0QixrTkFBa04sMk1BQTJNLGtDQUFrQyxzRUFBc0UsbUNBQW1DLG9IQUFvSCwrQkFBK0IsdUJBQXVCLHFJQUFxSSxvVkFBb1YsdUJBQXVCLHFEQUFxRCxrQ0FBa0MsMkxBQTJMLHFDQUFxQyxxQkFBcUIsZ0JBQWdCLE1BQU0sbUNBQW1DLDBEQUEwRCwyTEFBMkwsa0pBQWtKLHNCQUFzQiw0QkFBNEIsOEVBQThFLG1EQUFtRCxLQUFLLGtCQUFrQixXQUFXLHNCQUFzQixXQUFXLEtBQUssbUJBQW1CLDRHQUE0Ryx3QkFBd0IsdUNBQXVDLGdCQUFnQix1REFBdUQsZ0RBQWdELFdBQVcsMEJBQTBCLGtDQUFrQywwQkFBMEIsNEJBQTRCLGdCQUFnQiw0QkFBNEIsMkZBQTJGLCtGQUErRiwwQkFBMEIsMERBQTBELCtCQUErQiwrREFBK0QsOENBQThDLGlDQUFpQywrQ0FBK0MsNkRBQTZELDhCQUE4QiwyQkFBMkIsOEJBQThCLHdDQUF3QyxtQkFBbUIseUJBQXlCLHFCQUFxQiwwREFBMEQsMENBQTBDLEdBQUcsdUJBQXVCLG9CQUFvQix5QkFBeUIsNElBQTRJLHdCQUF3QixzSEFBc0gsdUdBQXVHLHlCQUF5Qiw2Q0FBNkMsZ0JBQWdCLEVBQUUsNEJBQTRCLDBCQUEwQix3QkFBd0IsRUFBRSwrQkFBK0Isb09BQW9PLG1CQUFtQixvS0FBb0sseUJBQXlCLGtFQUFrRSx5QkFBeUIsbUZBQW1GLGlCQUFpQixrQ0FBa0MseUJBQXlCLG1GQUFtRiwyQkFBMkIsNERBQTRELFVBQVUsRUFBRSxrQkFBa0IsU0FBUywwSUFBMEksMEJBQTBCLG9kQUFvZCxzQkFBc0IsMkVBQTJFLDBCQUEwQixvQ0FBb0MsZ1dBQWdXLHdCQUF3QixPQUFPLGlGQUFpRiwwSkFBMEosMkJBQTJCLGlEQUFpRCw4QkFBOEIsZ0NBQWdDLCtDQUErQywyQkFBMkIsbUJBQW1CLDJCQUEyQiw0Q0FBNEMsaUVBQWlFLDJCQUEyQixtREFBbUQsa0NBQWtDLDBCQUEwQixVQUFVLDBNQUEwTSxnQkFBZ0IsSUFBSSx5QkFBeUIscUJBQXFCLDZFQUE2RSw0QkFBNEIsK0ZBQStGLEVBQUUsaUJBQWlCLG1CQUFtQixrQkFBa0Isa0JBQWtCLHNHQUFzRyxVQUFVLHNCQUFzQiwwQkFBMEIsWUFBWSxZQUFZLHdCQUF3QiwwQ0FBMEMsb0VBQW9FLDhDQUE4QyxtQkFBbUIsOEZBQThGLHdDQUF3QyxpRUFBaUUsd0JBQXdCLGdPQUFnTyxpR0FBaUcseUJBQXlCLGtEQUFrRCxFQUFFLCtCQUErQixvQkFBb0IsaUJBQWlCLFNBQVMsV0FBVyx3QkFBd0IsZ0RBQWdELGtCQUFrQiw0TUFBNE0scUJBQXFCLG1FQUFtRSxzQkFBc0IsT0FBTyxzRkFBc0YsMkRBQTJELHlCQUF5Qix1Q0FBdUMsb0JBQW9CLGlFQUFpRSxnQ0FBZ0MsK01BQStNLHFEQUFxRCxtQkFBbUIsaUhBQWlILHVCQUF1QixxREFBcUQseUJBQXlCLG9EQUFvRCxvQkFBb0Isa0hBQWtILDRIQUE0SCxnQkFBZ0IsU0FBUyxZQUFZLHNCQUFzQix3Q0FBd0MsNkNBQTZDLDRCQUE0Qiw2QkFBNkIsa0JBQWtCLDJDQUEyQywyQkFBMkIsdURBQXVELG1OQUFtTiw4QkFBOEIscUdBQXFHLHlCQUF5QiwrQkFBK0IsNEVBQTRFLGdCQUFnQixvQkFBb0IsWUFBWSx5VEFBeVQsbUJBQW1CLDZHQUE2Ryx1QkFBdUIseUJBQXlCLGlDQUFpQyx1Q0FBdUMseUdBQXlHLHNCQUFzQix1QkFBdUIseUJBQXlCLGlDQUFpQywwSEFBMEgseUJBQXlCLDRFQUE0RSwwQkFBMEIsZ0RBQWdELDhCQUE4Qix5Q0FBeUMsd0RBQXdELFdBQVcsS0FBSyxrQ0FBa0MsVUFBVSx1QkFBdUIsOENBQThDLDRCQUE0Qix1R0FBdUcsaUNBQWlDLE1BQU0sdU1BQXVNLG9CQUFvQixpS0FBaUssbUJBQW1CLDJCQUEyQixnTkFBZ04sa0JBQWtCLDZCQUE2QixvSUFBb0ksMEJBQTBCLEVBQUUsaUZBQWlGLHFDQUFxQywyQkFBMkIsa0JBQWtCLDhDQUE4QyxNQUFNLHNCQUFzQixJQUFJLEtBQUssc0JBQXNCLElBQUksOENBQThDLGlCQUFpQix3QkFBd0IsMkJBQTJCLFlBQVksMlBBQTJQLDJCQUEyQixnQkFBZ0IseVRBQXlULHNCQUFzQixvRUFBb0UsRUFBRSw4SUFBOEksNEJBQTRCLDBCQUEwQixNQUFNLHVJQUF1SSw2QkFBNkIseUJBQXlCLHFJQUFxSSxpQ0FBaUMsK0JBQStCLDhCQUE4QixFQUFFLHFFQUFxRSwyUUFBMlEsNkJBQTZCLFlBQVksNEJBQTRCLHVDQUF1QywyQkFBMkIsbUJBQW1CLHVLQUF1SywwQkFBMEIsbUJBQW1CLDBLQUEwSyxFQUFFLGVBQWUsK0JBQStCLGtCQUFrQixJQUFJLG1GQUFtRiw0REFBNEQsVUFBVSxtQkFBbUIsNkZBQTZGLE9BQU8sMEJBQTBCLGlEQUFpRCxvQkFBb0IsZ0ZBQWdGLHVCQUF1QiwrQkFBK0IsNkpBQTZKLHNCQUFzQixtQkFBbUIsZ0ZBQWdGLHlCQUF5QixtQkFBbUIsNERBQTRELDBCQUEwQixxREFBcUQsOGZBQThmLDJCQUEyQiwyRUFBMkUsK0VBQStFLHdCQUF3QixZQUFZLDJCQUEyQixpQkFBaUIsMEJBQTBCLGtCQUFrQiw4QkFBOEIsMEJBQTBCLHFKQUFxSiw4QkFBOEIseUdBQXlHLG9CQUFvQixVQUFVLHlVQUF5VSx1QkFBdUIseUJBQXlCLDBJQUEwSSxzQkFBc0IsNEdBQTRHLHlCQUF5Qix3RUFBd0UseUJBQXlCLHlCQUF5QiwwQkFBMEIsMEJBQTBCLG9uQkFBb25CLDJCQUEyQixnQ0FBZ0MsMkJBQTJCLGtMQUFrTCxtQkFBbUIsd0JBQXdCLDRCQUE0QiwyQkFBMkIsWUFBWSwwQkFBMEIsYUFBYSxFQUFFLGVBQWUsbUNBQW1DLGlDQUFpQyx3QkFBd0IsZ0pBQWdKLDRDQUE0Qyw4QkFBOEIsTUFBTSxvR0FBb0csT0FBTywrQkFBK0IsNkJBQTZCLGdEQUFnRCxFQUFFLGtCQUFrQix5QkFBeUIsOERBQThELHVCQUF1QixpREFBaUQsOEJBQThCLG9GQUFvRixFQUFFLDZMQUE2TCxXQUFXLEVBQUUsaUJBQWlCLHVCQUF1QixxSUFBcUkscUJBQXFCLHNEQUFzRCx3QkFBd0Isc0RBQXNELGtCQUFrQixtQkFBbUIscUJBQXFCLGdDQUFnQyx3QkFBd0IseUNBQXlDLHFDQUFxQywrRkFBK0YsMEJBQTBCLG1EQUFtRCxrSUFBa0ksMkZBQTJGLE9BQU8sMEJBQTBCLDhNQUE4TSx3REFBd0Qsa0ZBQWtGLG9CQUFvQix5RkFBeUYsMkZBQTJGLE9BQU8sd0JBQXdCLDRTQUE0UyxnQkFBZ0IsSUFBSSx3QkFBd0IscUZBQXFGLCtEQUErRCxtQkFBbUIsWUFBWSxvQkFBb0Isa0RBQWtELHdCQUF3QixtREFBbUQsNEJBQTRCLHVGQUF1Rix1RkFBdUYsd0VBQXdFLDJIQUEySCxZQUFZLG9CQUFvQixNQUFNLGtHQUFrRyxzRUFBc0UsOFVBQThVLHdCQUF3Qiw4R0FBOEcsa0JBQWtCLCtDQUErQyxtQkFBbUIsZ0RBQWdELHlCQUF5QixrQkFBa0Isa2VBQWtlLHFCQUFxQixRQUFRLHFPQUFxTyw2QkFBNkIsS0FBSyw4Q0FBOEMsNkNBQTZDLHVCQUF1Qiw0RUFBNEUsc0dBQXNHLDZCQUE2QiwrQkFBK0IsNEJBQTRCLFFBQVEsNlhBQTZYLDJCQUEyQixrS0FBa0ssb0ZBQW9GLHdCQUF3QixvRkFBb0YsdVhBQXVYLFdBQVcscURBQXFELEVBQUUsc0JBQXNCLGlFQUFpRSxnQ0FBZ0MsWUFBWSxVQUFVLHdGQUF3Rix3QkFBd0Isa0dBQWtHLHFCQUFxQiwyQkFBMkIscUNBQXFDLGtFQUFrRSxxQkFBcUIsNENBQTRDLE9BQU8sd0JBQXdCLDRDQUE0QyxrRUFBa0Usc0JBQXNCLDRDQUE0QyxPQUFPLHlCQUF5QixVQUFVLHNLQUFzSyxxQkFBcUIseUNBQXlDLG9CQUFvQix3Q0FBd0MsMEJBQTBCLDBCQUEwQixxQ0FBcUMsSUFBSSwwQkFBMEIseUJBQXlCLElBQUksd0JBQXdCLHdCQUF3QixJQUFJLHVCQUF1QixzQkFBc0IsSUFBSSx3QkFBd0IsMkJBQTJCLDJCQUEyQix1Q0FBdUMsSUFBSSxxQkFBcUIsMkJBQTJCLElBQUksdUJBQXVCLHNCQUFzQiwyQ0FBMkMseUJBQXlCLDJDQUEyQyx3QkFBd0Isc0NBQXNDLGdDQUFnQyxpU0FBaVMsc0ZBQXNGLEtBQUssZ0VBQWdFLGVBQWUsUUFBUSxpRUFBaUUsK0RBQStELFlBQVksb0JBQW9CLHVFQUF1RSx3QkFBd0IseURBQXlELDRCQUE0Qix1TkFBdU4sb0ZBQW9GLHlCQUF5QixzUEFBc1AscUlBQXFJLHdFQUF3RSwwREFBMEQsWUFBWSxvQkFBb0IsdURBQXVELHdCQUF3Qix1REFBdUQscUJBQXFCLE1BQU0sdUtBQXVLLCtKQUErSix3SEFBd0gsa0NBQWtDLDhEQUE4RCxvQkFBb0IsMklBQTJJLHFCQUFxQixlQUFlLHdDQUF3Qyx3QkFBd0IsK0VBQStFLDhCQUE4QixvQkFBb0IsNkdBQTZHLEVBQUUsMkNBQTJDLGdFQUFnRSx3Q0FBd0MsWUFBWSxvQkFBb0IsMEdBQTBHLHdCQUF3QiwwR0FBMEcsMkJBQTJCLG9CQUFvQixva0JBQW9rQiwwQkFBMEIsbURBQW1ELDRJQUE0SSx1TkFBdU4sOENBQThDLEtBQUssc0RBQXNELGlDQUFpQyw4RkFBOEYsdUVBQXVFLHVDQUF1QyxrQkFBa0IsU0FBUyxxQ0FBcUMsd0JBQXdCLHFZQUFxWSxnekJBQWd6QixxQkFBcUIsOEJBQThCLG1CQUFtQixvQ0FBb0MsaUJBQWlCLHlDQUF5QyxtQkFBbUIsbURBQW1ELGlCQUFpQixvQkFBb0IsaUJBQWlCLGdDQUFnQyxxQkFBcUIsd0RBQXdELG1CQUFtQixxQkFBcUIsa0JBQWtCLHdCQUF3QixtQkFBbUIsbUNBQW1DLG1CQUFtQiwwQkFBMEIsbUJBQW1CLHVCQUF1QixtQkFBbUIsMkJBQTJCLG1CQUFtQixnRUFBZ0UscUJBQXFCLHdDQUF3QyxtQkFBbUIsc0VBQXNFLHFCQUFxQixXQUFXLHdCQUF3Qix3QkFBd0IsWUFBWTtBQUM1bCtJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvZGlzdC9sZWFmbGV0LmpzPzhiYzIiXSwic291cmNlc0NvbnRlbnQiOlsiLyogQHByZXNlcnZlXG4gKiBMZWFmbGV0IDEuOS4zLCBhIEpTIGxpYnJhcnkgZm9yIGludGVyYWN0aXZlIG1hcHMuIGh0dHBzOi8vbGVhZmxldGpzLmNvbVxuICogKGMpIDIwMTAtMjAyMiBWbGFkaW1pciBBZ2Fmb25raW4sIChjKSAyMDEwLTIwMTEgQ2xvdWRNYWRlXG4gKi9cbiFmdW5jdGlvbih0LGUpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlP2UoZXhwb3J0cyk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXCJleHBvcnRzXCJdLGUpOmUoKHQ9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbFRoaXM/Z2xvYmFsVGhpczp0fHxzZWxmKS5sZWFmbGV0PXt9KX0odGhpcyxmdW5jdGlvbih0KXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBsKHQpe2Zvcih2YXIgZSxpLG49MSxvPWFyZ3VtZW50cy5sZW5ndGg7bjxvO24rKylmb3IoZSBpbiBpPWFyZ3VtZW50c1tuXSl0W2VdPWlbZV07cmV0dXJuIHR9dmFyIFI9T2JqZWN0LmNyZWF0ZXx8ZnVuY3Rpb24odCl7cmV0dXJuIE4ucHJvdG90eXBlPXQsbmV3IE59O2Z1bmN0aW9uIE4oKXt9ZnVuY3Rpb24gYSh0LGUpe3ZhciBpLG49QXJyYXkucHJvdG90eXBlLnNsaWNlO3JldHVybiB0LmJpbmQ/dC5iaW5kLmFwcGx5KHQsbi5jYWxsKGFyZ3VtZW50cywxKSk6KGk9bi5jYWxsKGFyZ3VtZW50cywyKSxmdW5jdGlvbigpe3JldHVybiB0LmFwcGx5KGUsaS5sZW5ndGg/aS5jb25jYXQobi5jYWxsKGFyZ3VtZW50cykpOmFyZ3VtZW50cyl9KX12YXIgRD0wO2Z1bmN0aW9uIGgodCl7cmV0dXJuXCJfbGVhZmxldF9pZFwiaW4gdHx8KHQuX2xlYWZsZXRfaWQ9KytEKSx0Ll9sZWFmbGV0X2lkfWZ1bmN0aW9uIGoodCxlLGkpe3ZhciBuLG8scz1mdW5jdGlvbigpe249ITEsbyYmKHIuYXBwbHkoaSxvKSxvPSExKX0scj1mdW5jdGlvbigpe24/bz1hcmd1bWVudHM6KHQuYXBwbHkoaSxhcmd1bWVudHMpLHNldFRpbWVvdXQocyxlKSxuPSEwKX07cmV0dXJuIHJ9ZnVuY3Rpb24gSCh0LGUsaSl7dmFyIG49ZVsxXSxlPWVbMF0sbz1uLWU7cmV0dXJuIHQ9PT1uJiZpP3Q6KCh0LWUpJW8rbyklbytlfWZ1bmN0aW9uIHUoKXtyZXR1cm4hMX1mdW5jdGlvbiBpKHQsZSl7cmV0dXJuITE9PT1lP3Q6KGU9TWF0aC5wb3coMTAsdm9pZCAwPT09ZT82OmUpLE1hdGgucm91bmQodCplKS9lKX1mdW5jdGlvbiBGKHQpe3JldHVybiB0LnRyaW0/dC50cmltKCk6dC5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLFwiXCIpfWZ1bmN0aW9uIFcodCl7cmV0dXJuIEYodCkuc3BsaXQoL1xccysvKX1mdW5jdGlvbiBjKHQsZSl7Zm9yKHZhciBpIGluIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LFwib3B0aW9uc1wiKXx8KHQub3B0aW9ucz10Lm9wdGlvbnM/Uih0Lm9wdGlvbnMpOnt9KSxlKXQub3B0aW9uc1tpXT1lW2ldO3JldHVybiB0Lm9wdGlvbnN9ZnVuY3Rpb24gVSh0LGUsaSl7dmFyIG4sbz1bXTtmb3IobiBpbiB0KW8ucHVzaChlbmNvZGVVUklDb21wb25lbnQoaT9uLnRvVXBwZXJDYXNlKCk6bikrXCI9XCIrZW5jb2RlVVJJQ29tcG9uZW50KHRbbl0pKTtyZXR1cm4oZSYmLTEhPT1lLmluZGV4T2YoXCI/XCIpP1wiJlwiOlwiP1wiKStvLmpvaW4oXCImXCIpfXZhciBWPS9cXHsgKihbXFx3XyAtXSspICpcXH0vZztmdW5jdGlvbiBxKHQsaSl7cmV0dXJuIHQucmVwbGFjZShWLGZ1bmN0aW9uKHQsZSl7ZT1pW2VdO2lmKHZvaWQgMD09PWUpdGhyb3cgbmV3IEVycm9yKFwiTm8gdmFsdWUgcHJvdmlkZWQgZm9yIHZhcmlhYmxlIFwiK3QpO3JldHVybiBlPVwiZnVuY3Rpb25cIj09dHlwZW9mIGU/ZShpKTplfSl9dmFyIGQ9QXJyYXkuaXNBcnJheXx8ZnVuY3Rpb24odCl7cmV0dXJuXCJbb2JqZWN0IEFycmF5XVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpfTtmdW5jdGlvbiBHKHQsZSl7Zm9yKHZhciBpPTA7aTx0Lmxlbmd0aDtpKyspaWYodFtpXT09PWUpcmV0dXJuIGk7cmV0dXJuLTF9dmFyIEs9XCJkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUFEL0FDd0FBQUFBQVFBQkFBQUNBRHM9XCI7ZnVuY3Rpb24gWSh0KXtyZXR1cm4gd2luZG93W1wid2Via2l0XCIrdF18fHdpbmRvd1tcIm1velwiK3RdfHx3aW5kb3dbXCJtc1wiK3RdfXZhciBYPTA7ZnVuY3Rpb24gSih0KXt2YXIgZT0rbmV3IERhdGUsaT1NYXRoLm1heCgwLDE2LShlLVgpKTtyZXR1cm4gWD1lK2ksd2luZG93LnNldFRpbWVvdXQodCxpKX12YXIgJD13aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lfHxZKFwiUmVxdWVzdEFuaW1hdGlvbkZyYW1lXCIpfHxKLFE9d2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lfHxZKFwiQ2FuY2VsQW5pbWF0aW9uRnJhbWVcIil8fFkoXCJDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIil8fGZ1bmN0aW9uKHQpe3dpbmRvdy5jbGVhclRpbWVvdXQodCl9O2Z1bmN0aW9uIHgodCxlLGkpe2lmKCFpfHwkIT09SilyZXR1cm4gJC5jYWxsKHdpbmRvdyxhKHQsZSkpO3QuY2FsbChlKX1mdW5jdGlvbiByKHQpe3QmJlEuY2FsbCh3aW5kb3csdCl9dmFyIHR0PXtfX3Byb3RvX186bnVsbCxleHRlbmQ6bCxjcmVhdGU6UixiaW5kOmEsZ2V0IGxhc3RJZCgpe3JldHVybiBEfSxzdGFtcDpoLHRocm90dGxlOmosd3JhcE51bTpILGZhbHNlRm46dSxmb3JtYXROdW06aSx0cmltOkYsc3BsaXRXb3JkczpXLHNldE9wdGlvbnM6YyxnZXRQYXJhbVN0cmluZzpVLHRlbXBsYXRlOnEsaXNBcnJheTpkLGluZGV4T2Y6RyxlbXB0eUltYWdlVXJsOksscmVxdWVzdEZuOiQsY2FuY2VsRm46USxyZXF1ZXN0QW5pbUZyYW1lOngsY2FuY2VsQW5pbUZyYW1lOnJ9O2Z1bmN0aW9uIGV0KCl7fWV0LmV4dGVuZD1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7Yyh0aGlzKSx0aGlzLmluaXRpYWxpemUmJnRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLGFyZ3VtZW50cyksdGhpcy5jYWxsSW5pdEhvb2tzKCl9dmFyIGksbj1lLl9fc3VwZXJfXz10aGlzLnByb3RvdHlwZSxvPVIobik7Zm9yKGkgaW4oby5jb25zdHJ1Y3Rvcj1lKS5wcm90b3R5cGU9byx0aGlzKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLGkpJiZcInByb3RvdHlwZVwiIT09aSYmXCJfX3N1cGVyX19cIiE9PWkmJihlW2ldPXRoaXNbaV0pO2lmKHQuc3RhdGljcyYmbChlLHQuc3RhdGljcyksdC5pbmNsdWRlcyl7dmFyIHM9dC5pbmNsdWRlcztpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgTCYmTCYmTC5NaXhpbil7cz1kKHMpP3M6W3NdO2Zvcih2YXIgcj0wO3I8cy5sZW5ndGg7cisrKXNbcl09PT1MLk1peGluLkV2ZW50cyYmY29uc29sZS53YXJuKFwiRGVwcmVjYXRlZCBpbmNsdWRlIG9mIEwuTWl4aW4uRXZlbnRzOiB0aGlzIHByb3BlcnR5IHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgcmVsZWFzZXMsIHBsZWFzZSBpbmhlcml0IGZyb20gTC5FdmVudGVkIGluc3RlYWQuXCIsKG5ldyBFcnJvcikuc3RhY2spfWwuYXBwbHkobnVsbCxbb10uY29uY2F0KHQuaW5jbHVkZXMpKX1yZXR1cm4gbChvLHQpLGRlbGV0ZSBvLnN0YXRpY3MsZGVsZXRlIG8uaW5jbHVkZXMsby5vcHRpb25zJiYoby5vcHRpb25zPW4ub3B0aW9ucz9SKG4ub3B0aW9ucyk6e30sbChvLm9wdGlvbnMsdC5vcHRpb25zKSksby5faW5pdEhvb2tzPVtdLG8uY2FsbEluaXRIb29rcz1mdW5jdGlvbigpe2lmKCF0aGlzLl9pbml0SG9va3NDYWxsZWQpe24uY2FsbEluaXRIb29rcyYmbi5jYWxsSW5pdEhvb2tzLmNhbGwodGhpcyksdGhpcy5faW5pdEhvb2tzQ2FsbGVkPSEwO2Zvcih2YXIgdD0wLGU9by5faW5pdEhvb2tzLmxlbmd0aDt0PGU7dCsrKW8uX2luaXRIb29rc1t0XS5jYWxsKHRoaXMpfX0sZX0sZXQuaW5jbHVkZT1mdW5jdGlvbih0KXt2YXIgZT10aGlzLnByb3RvdHlwZS5vcHRpb25zO3JldHVybiBsKHRoaXMucHJvdG90eXBlLHQpLHQub3B0aW9ucyYmKHRoaXMucHJvdG90eXBlLm9wdGlvbnM9ZSx0aGlzLm1lcmdlT3B0aW9ucyh0Lm9wdGlvbnMpKSx0aGlzfSxldC5tZXJnZU9wdGlvbnM9ZnVuY3Rpb24odCl7cmV0dXJuIGwodGhpcy5wcm90b3R5cGUub3B0aW9ucyx0KSx0aGlzfSxldC5hZGRJbml0SG9vaz1mdW5jdGlvbih0KXt2YXIgZT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSksaT1cImZ1bmN0aW9uXCI9PXR5cGVvZiB0P3Q6ZnVuY3Rpb24oKXt0aGlzW3RdLmFwcGx5KHRoaXMsZSl9O3JldHVybiB0aGlzLnByb3RvdHlwZS5faW5pdEhvb2tzPXRoaXMucHJvdG90eXBlLl9pbml0SG9va3N8fFtdLHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MucHVzaChpKSx0aGlzfTt2YXIgZT17b246ZnVuY3Rpb24odCxlLGkpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiB0KWZvcih2YXIgbiBpbiB0KXRoaXMuX29uKG4sdFtuXSxlKTtlbHNlIGZvcih2YXIgbz0wLHM9KHQ9Vyh0KSkubGVuZ3RoO288cztvKyspdGhpcy5fb24odFtvXSxlLGkpO3JldHVybiB0aGlzfSxvZmY6ZnVuY3Rpb24odCxlLGkpe2lmKGFyZ3VtZW50cy5sZW5ndGgpaWYoXCJvYmplY3RcIj09dHlwZW9mIHQpZm9yKHZhciBuIGluIHQpdGhpcy5fb2ZmKG4sdFtuXSxlKTtlbHNle3Q9Vyh0KTtmb3IodmFyIG89MT09PWFyZ3VtZW50cy5sZW5ndGgscz0wLHI9dC5sZW5ndGg7czxyO3MrKylvP3RoaXMuX29mZih0W3NdKTp0aGlzLl9vZmYodFtzXSxlLGkpfWVsc2UgZGVsZXRlIHRoaXMuX2V2ZW50cztyZXR1cm4gdGhpc30sX29uOmZ1bmN0aW9uKHQsZSxpLG4pe1wiZnVuY3Rpb25cIiE9dHlwZW9mIGU/Y29uc29sZS53YXJuKFwid3JvbmcgbGlzdGVuZXIgdHlwZTogXCIrdHlwZW9mIGUpOiExPT09dGhpcy5fbGlzdGVucyh0LGUsaSkmJihlPXtmbjplLGN0eDppPWk9PT10aGlzP3ZvaWQgMDppfSxuJiYoZS5vbmNlPSEwKSx0aGlzLl9ldmVudHM9dGhpcy5fZXZlbnRzfHx7fSx0aGlzLl9ldmVudHNbdF09dGhpcy5fZXZlbnRzW3RdfHxbXSx0aGlzLl9ldmVudHNbdF0ucHVzaChlKSl9LF9vZmY6ZnVuY3Rpb24odCxlLGkpe3ZhciBuLG8scztpZih0aGlzLl9ldmVudHMmJihuPXRoaXMuX2V2ZW50c1t0XSkpaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKHRoaXMuX2ZpcmluZ0NvdW50KWZvcihvPTAscz1uLmxlbmd0aDtvPHM7bysrKW5bb10uZm49dTtkZWxldGUgdGhpcy5fZXZlbnRzW3RdfWVsc2VcImZ1bmN0aW9uXCIhPXR5cGVvZiBlP2NvbnNvbGUud2FybihcIndyb25nIGxpc3RlbmVyIHR5cGU6IFwiK3R5cGVvZiBlKTohMSE9PShlPXRoaXMuX2xpc3RlbnModCxlLGkpKSYmKGk9bltlXSx0aGlzLl9maXJpbmdDb3VudCYmKGkuZm49dSx0aGlzLl9ldmVudHNbdF09bj1uLnNsaWNlKCkpLG4uc3BsaWNlKGUsMSkpfSxmaXJlOmZ1bmN0aW9uKHQsZSxpKXtpZih0aGlzLmxpc3RlbnModCxpKSl7dmFyIG49bCh7fSxlLHt0eXBlOnQsdGFyZ2V0OnRoaXMsc291cmNlVGFyZ2V0OmUmJmUuc291cmNlVGFyZ2V0fHx0aGlzfSk7aWYodGhpcy5fZXZlbnRzKXt2YXIgbz10aGlzLl9ldmVudHNbdF07aWYobyl7dGhpcy5fZmlyaW5nQ291bnQ9dGhpcy5fZmlyaW5nQ291bnQrMXx8MTtmb3IodmFyIHM9MCxyPW8ubGVuZ3RoO3M8cjtzKyspe3ZhciBhPW9bc10saD1hLmZuO2Eub25jZSYmdGhpcy5vZmYodCxoLGEuY3R4KSxoLmNhbGwoYS5jdHh8fHRoaXMsbil9dGhpcy5fZmlyaW5nQ291bnQtLX19aSYmdGhpcy5fcHJvcGFnYXRlRXZlbnQobil9cmV0dXJuIHRoaXN9LGxpc3RlbnM6ZnVuY3Rpb24odCxlLGksbil7XCJzdHJpbmdcIiE9dHlwZW9mIHQmJmNvbnNvbGUud2FybignXCJzdHJpbmdcIiB0eXBlIGFyZ3VtZW50IGV4cGVjdGVkJyk7dmFyIG89ZSxzPShcImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiYobj0hIWUsaT1vPXZvaWQgMCksdGhpcy5fZXZlbnRzJiZ0aGlzLl9ldmVudHNbdF0pO2lmKHMmJnMubGVuZ3RoJiYhMSE9PXRoaXMuX2xpc3RlbnModCxvLGkpKXJldHVybiEwO2lmKG4pZm9yKHZhciByIGluIHRoaXMuX2V2ZW50UGFyZW50cylpZih0aGlzLl9ldmVudFBhcmVudHNbcl0ubGlzdGVucyh0LGUsaSxuKSlyZXR1cm4hMDtyZXR1cm4hMX0sX2xpc3RlbnM6ZnVuY3Rpb24odCxlLGkpe2lmKHRoaXMuX2V2ZW50cyl7dmFyIG49dGhpcy5fZXZlbnRzW3RdfHxbXTtpZighZSlyZXR1cm4hIW4ubGVuZ3RoO2k9PT10aGlzJiYoaT12b2lkIDApO2Zvcih2YXIgbz0wLHM9bi5sZW5ndGg7bzxzO28rKylpZihuW29dLmZuPT09ZSYmbltvXS5jdHg9PT1pKXJldHVybiBvfXJldHVybiExfSxvbmNlOmZ1bmN0aW9uKHQsZSxpKXtpZihcIm9iamVjdFwiPT10eXBlb2YgdClmb3IodmFyIG4gaW4gdCl0aGlzLl9vbihuLHRbbl0sZSwhMCk7ZWxzZSBmb3IodmFyIG89MCxzPSh0PVcodCkpLmxlbmd0aDtvPHM7bysrKXRoaXMuX29uKHRbb10sZSxpLCEwKTtyZXR1cm4gdGhpc30sYWRkRXZlbnRQYXJlbnQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX2V2ZW50UGFyZW50cz10aGlzLl9ldmVudFBhcmVudHN8fHt9LHRoaXMuX2V2ZW50UGFyZW50c1toKHQpXT10LHRoaXN9LHJlbW92ZUV2ZW50UGFyZW50OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9ldmVudFBhcmVudHMmJmRlbGV0ZSB0aGlzLl9ldmVudFBhcmVudHNbaCh0KV0sdGhpc30sX3Byb3BhZ2F0ZUV2ZW50OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZSBpbiB0aGlzLl9ldmVudFBhcmVudHMpdGhpcy5fZXZlbnRQYXJlbnRzW2VdLmZpcmUodC50eXBlLGwoe2xheWVyOnQudGFyZ2V0LHByb3BhZ2F0ZWRGcm9tOnQudGFyZ2V0fSx0KSwhMCl9fSxpdD0oZS5hZGRFdmVudExpc3RlbmVyPWUub24sZS5yZW1vdmVFdmVudExpc3RlbmVyPWUuY2xlYXJBbGxFdmVudExpc3RlbmVycz1lLm9mZixlLmFkZE9uZVRpbWVFdmVudExpc3RlbmVyPWUub25jZSxlLmZpcmVFdmVudD1lLmZpcmUsZS5oYXNFdmVudExpc3RlbmVycz1lLmxpc3RlbnMsZXQuZXh0ZW5kKGUpKTtmdW5jdGlvbiBwKHQsZSxpKXt0aGlzLng9aT9NYXRoLnJvdW5kKHQpOnQsdGhpcy55PWk/TWF0aC5yb3VuZChlKTplfXZhciBudD1NYXRoLnRydW5jfHxmdW5jdGlvbih0KXtyZXR1cm4gMDx0P01hdGguZmxvb3IodCk6TWF0aC5jZWlsKHQpfTtmdW5jdGlvbiBtKHQsZSxpKXtyZXR1cm4gdCBpbnN0YW5jZW9mIHA/dDpkKHQpP25ldyBwKHRbMF0sdFsxXSk6bnVsbD09dD90Olwib2JqZWN0XCI9PXR5cGVvZiB0JiZcInhcImluIHQmJlwieVwiaW4gdD9uZXcgcCh0LngsdC55KTpuZXcgcCh0LGUsaSl9ZnVuY3Rpb24gZih0LGUpe2lmKHQpZm9yKHZhciBpPWU/W3QsZV06dCxuPTAsbz1pLmxlbmd0aDtuPG87bisrKXRoaXMuZXh0ZW5kKGlbbl0pfWZ1bmN0aW9uIF8odCxlKXtyZXR1cm4hdHx8dCBpbnN0YW5jZW9mIGY/dDpuZXcgZih0LGUpfWZ1bmN0aW9uIHModCxlKXtpZih0KWZvcih2YXIgaT1lP1t0LGVdOnQsbj0wLG89aS5sZW5ndGg7bjxvO24rKyl0aGlzLmV4dGVuZChpW25dKX1mdW5jdGlvbiBnKHQsZSl7cmV0dXJuIHQgaW5zdGFuY2VvZiBzP3Q6bmV3IHModCxlKX1mdW5jdGlvbiB2KHQsZSxpKXtpZihpc05hTih0KXx8aXNOYU4oZSkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBMYXRMbmcgb2JqZWN0OiAoXCIrdCtcIiwgXCIrZStcIilcIik7dGhpcy5sYXQ9K3QsdGhpcy5sbmc9K2Usdm9pZCAwIT09aSYmKHRoaXMuYWx0PStpKX1mdW5jdGlvbiB3KHQsZSxpKXtyZXR1cm4gdCBpbnN0YW5jZW9mIHY/dDpkKHQpJiZcIm9iamVjdFwiIT10eXBlb2YgdFswXT8zPT09dC5sZW5ndGg/bmV3IHYodFswXSx0WzFdLHRbMl0pOjI9PT10Lmxlbmd0aD9uZXcgdih0WzBdLHRbMV0pOm51bGw6bnVsbD09dD90Olwib2JqZWN0XCI9PXR5cGVvZiB0JiZcImxhdFwiaW4gdD9uZXcgdih0LmxhdCxcImxuZ1wiaW4gdD90LmxuZzp0Lmxvbix0LmFsdCk6dm9pZCAwPT09ZT9udWxsOm5ldyB2KHQsZSxpKX1wLnByb3RvdHlwZT17Y2xvbmU6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHAodGhpcy54LHRoaXMueSl9LGFkZDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jbG9uZSgpLl9hZGQobSh0KSl9LF9hZGQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMueCs9dC54LHRoaXMueSs9dC55LHRoaXN9LHN1YnRyYWN0OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNsb25lKCkuX3N1YnRyYWN0KG0odCkpfSxfc3VidHJhY3Q6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMueC09dC54LHRoaXMueS09dC55LHRoaXN9LGRpdmlkZUJ5OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNsb25lKCkuX2RpdmlkZUJ5KHQpfSxfZGl2aWRlQnk6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMueC89dCx0aGlzLnkvPXQsdGhpc30sbXVsdGlwbHlCeTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jbG9uZSgpLl9tdWx0aXBseUJ5KHQpfSxfbXVsdGlwbHlCeTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy54Kj10LHRoaXMueSo9dCx0aGlzfSxzY2FsZUJ5OmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgcCh0aGlzLngqdC54LHRoaXMueSp0LnkpfSx1bnNjYWxlQnk6ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBwKHRoaXMueC90LngsdGhpcy55L3QueSl9LHJvdW5kOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2xvbmUoKS5fcm91bmQoKX0sX3JvdW5kOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMueD1NYXRoLnJvdW5kKHRoaXMueCksdGhpcy55PU1hdGgucm91bmQodGhpcy55KSx0aGlzfSxmbG9vcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNsb25lKCkuX2Zsb29yKCl9LF9mbG9vcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLng9TWF0aC5mbG9vcih0aGlzLngpLHRoaXMueT1NYXRoLmZsb29yKHRoaXMueSksdGhpc30sY2VpbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNsb25lKCkuX2NlaWwoKX0sX2NlaWw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy54PU1hdGguY2VpbCh0aGlzLngpLHRoaXMueT1NYXRoLmNlaWwodGhpcy55KSx0aGlzfSx0cnVuYzpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNsb25lKCkuX3RydW5jKCl9LF90cnVuYzpmdW5jdGlvbigpe3JldHVybiB0aGlzLng9bnQodGhpcy54KSx0aGlzLnk9bnQodGhpcy55KSx0aGlzfSxkaXN0YW5jZVRvOmZ1bmN0aW9uKHQpe3ZhciBlPSh0PW0odCkpLngtdGhpcy54LHQ9dC55LXRoaXMueTtyZXR1cm4gTWF0aC5zcXJ0KGUqZSt0KnQpfSxlcXVhbHM6ZnVuY3Rpb24odCl7cmV0dXJuKHQ9bSh0KSkueD09PXRoaXMueCYmdC55PT09dGhpcy55fSxjb250YWluczpmdW5jdGlvbih0KXtyZXR1cm4gdD1tKHQpLE1hdGguYWJzKHQueCk8PU1hdGguYWJzKHRoaXMueCkmJk1hdGguYWJzKHQueSk8PU1hdGguYWJzKHRoaXMueSl9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuXCJQb2ludChcIitpKHRoaXMueCkrXCIsIFwiK2kodGhpcy55KStcIilcIn19LGYucHJvdG90eXBlPXtleHRlbmQ6ZnVuY3Rpb24odCl7dmFyIGUsaTtpZih0KXtpZih0IGluc3RhbmNlb2YgcHx8XCJudW1iZXJcIj09dHlwZW9mIHRbMF18fFwieFwiaW4gdCllPWk9bSh0KTtlbHNlIGlmKGU9KHQ9Xyh0KSkubWluLGk9dC5tYXgsIWV8fCFpKXJldHVybiB0aGlzO3RoaXMubWlufHx0aGlzLm1heD8odGhpcy5taW4ueD1NYXRoLm1pbihlLngsdGhpcy5taW4ueCksdGhpcy5tYXgueD1NYXRoLm1heChpLngsdGhpcy5tYXgueCksdGhpcy5taW4ueT1NYXRoLm1pbihlLnksdGhpcy5taW4ueSksdGhpcy5tYXgueT1NYXRoLm1heChpLnksdGhpcy5tYXgueSkpOih0aGlzLm1pbj1lLmNsb25lKCksdGhpcy5tYXg9aS5jbG9uZSgpKX1yZXR1cm4gdGhpc30sZ2V0Q2VudGVyOmZ1bmN0aW9uKHQpe3JldHVybiBtKCh0aGlzLm1pbi54K3RoaXMubWF4LngpLzIsKHRoaXMubWluLnkrdGhpcy5tYXgueSkvMix0KX0sZ2V0Qm90dG9tTGVmdDpmdW5jdGlvbigpe3JldHVybiBtKHRoaXMubWluLngsdGhpcy5tYXgueSl9LGdldFRvcFJpZ2h0OmZ1bmN0aW9uKCl7cmV0dXJuIG0odGhpcy5tYXgueCx0aGlzLm1pbi55KX0sZ2V0VG9wTGVmdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1pbn0sZ2V0Qm90dG9tUmlnaHQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXh9LGdldFNpemU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXguc3VidHJhY3QodGhpcy5taW4pfSxjb250YWluczpmdW5jdGlvbih0KXt2YXIgZSxpO3JldHVybih0PShcIm51bWJlclwiPT10eXBlb2YgdFswXXx8dCBpbnN0YW5jZW9mIHA/bTpfKSh0KSlpbnN0YW5jZW9mIGY/KGU9dC5taW4saT10Lm1heCk6ZT1pPXQsZS54Pj10aGlzLm1pbi54JiZpLng8PXRoaXMubWF4LngmJmUueT49dGhpcy5taW4ueSYmaS55PD10aGlzLm1heC55fSxpbnRlcnNlY3RzOmZ1bmN0aW9uKHQpe3Q9Xyh0KTt2YXIgZT10aGlzLm1pbixpPXRoaXMubWF4LG49dC5taW4sdD10Lm1heCxvPXQueD49ZS54JiZuLng8PWkueCx0PXQueT49ZS55JiZuLnk8PWkueTtyZXR1cm4gbyYmdH0sb3ZlcmxhcHM6ZnVuY3Rpb24odCl7dD1fKHQpO3ZhciBlPXRoaXMubWluLGk9dGhpcy5tYXgsbj10Lm1pbix0PXQubWF4LG89dC54PmUueCYmbi54PGkueCx0PXQueT5lLnkmJm4ueTxpLnk7cmV0dXJuIG8mJnR9LGlzVmFsaWQ6ZnVuY3Rpb24oKXtyZXR1cm4hKCF0aGlzLm1pbnx8IXRoaXMubWF4KX0scGFkOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMubWluLGk9dGhpcy5tYXgsbj1NYXRoLmFicyhlLngtaS54KSp0LHQ9TWF0aC5hYnMoZS55LWkueSkqdDtyZXR1cm4gXyhtKGUueC1uLGUueS10KSxtKGkueCtuLGkueSt0KSl9LGVxdWFsczpmdW5jdGlvbih0KXtyZXR1cm4hIXQmJih0PV8odCksdGhpcy5taW4uZXF1YWxzKHQuZ2V0VG9wTGVmdCgpKSYmdGhpcy5tYXguZXF1YWxzKHQuZ2V0Qm90dG9tUmlnaHQoKSkpfX0scy5wcm90b3R5cGU9e2V4dGVuZDpmdW5jdGlvbih0KXt2YXIgZSxpLG49dGhpcy5fc291dGhXZXN0LG89dGhpcy5fbm9ydGhFYXN0O2lmKHQgaW5zdGFuY2VvZiB2KWk9ZT10O2Vsc2V7aWYoISh0IGluc3RhbmNlb2YgcykpcmV0dXJuIHQ/dGhpcy5leHRlbmQodyh0KXx8Zyh0KSk6dGhpcztpZihlPXQuX3NvdXRoV2VzdCxpPXQuX25vcnRoRWFzdCwhZXx8IWkpcmV0dXJuIHRoaXN9cmV0dXJuIG58fG8/KG4ubGF0PU1hdGgubWluKGUubGF0LG4ubGF0KSxuLmxuZz1NYXRoLm1pbihlLmxuZyxuLmxuZyksby5sYXQ9TWF0aC5tYXgoaS5sYXQsby5sYXQpLG8ubG5nPU1hdGgubWF4KGkubG5nLG8ubG5nKSk6KHRoaXMuX3NvdXRoV2VzdD1uZXcgdihlLmxhdCxlLmxuZyksdGhpcy5fbm9ydGhFYXN0PW5ldyB2KGkubGF0LGkubG5nKSksdGhpc30scGFkOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuX3NvdXRoV2VzdCxpPXRoaXMuX25vcnRoRWFzdCxuPU1hdGguYWJzKGUubGF0LWkubGF0KSp0LHQ9TWF0aC5hYnMoZS5sbmctaS5sbmcpKnQ7cmV0dXJuIG5ldyBzKG5ldyB2KGUubGF0LW4sZS5sbmctdCksbmV3IHYoaS5sYXQrbixpLmxuZyt0KSl9LGdldENlbnRlcjpmdW5jdGlvbigpe3JldHVybiBuZXcgdigodGhpcy5fc291dGhXZXN0LmxhdCt0aGlzLl9ub3J0aEVhc3QubGF0KS8yLCh0aGlzLl9zb3V0aFdlc3QubG5nK3RoaXMuX25vcnRoRWFzdC5sbmcpLzIpfSxnZXRTb3V0aFdlc3Q6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc291dGhXZXN0fSxnZXROb3J0aEVhc3Q6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbm9ydGhFYXN0fSxnZXROb3J0aFdlc3Q6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHYodGhpcy5nZXROb3J0aCgpLHRoaXMuZ2V0V2VzdCgpKX0sZ2V0U291dGhFYXN0OmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyB2KHRoaXMuZ2V0U291dGgoKSx0aGlzLmdldEVhc3QoKSl9LGdldFdlc3Q6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc291dGhXZXN0LmxuZ30sZ2V0U291dGg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc291dGhXZXN0LmxhdH0sZ2V0RWFzdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9ub3J0aEVhc3QubG5nfSxnZXROb3J0aDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9ub3J0aEVhc3QubGF0fSxjb250YWluczpmdW5jdGlvbih0KXt0PShcIm51bWJlclwiPT10eXBlb2YgdFswXXx8dCBpbnN0YW5jZW9mIHZ8fFwibGF0XCJpbiB0P3c6ZykodCk7dmFyIGUsaSxuPXRoaXMuX3NvdXRoV2VzdCxvPXRoaXMuX25vcnRoRWFzdDtyZXR1cm4gdCBpbnN0YW5jZW9mIHM/KGU9dC5nZXRTb3V0aFdlc3QoKSxpPXQuZ2V0Tm9ydGhFYXN0KCkpOmU9aT10LGUubGF0Pj1uLmxhdCYmaS5sYXQ8PW8ubGF0JiZlLmxuZz49bi5sbmcmJmkubG5nPD1vLmxuZ30saW50ZXJzZWN0czpmdW5jdGlvbih0KXt0PWcodCk7dmFyIGU9dGhpcy5fc291dGhXZXN0LGk9dGhpcy5fbm9ydGhFYXN0LG49dC5nZXRTb3V0aFdlc3QoKSx0PXQuZ2V0Tm9ydGhFYXN0KCksbz10LmxhdD49ZS5sYXQmJm4ubGF0PD1pLmxhdCx0PXQubG5nPj1lLmxuZyYmbi5sbmc8PWkubG5nO3JldHVybiBvJiZ0fSxvdmVybGFwczpmdW5jdGlvbih0KXt0PWcodCk7dmFyIGU9dGhpcy5fc291dGhXZXN0LGk9dGhpcy5fbm9ydGhFYXN0LG49dC5nZXRTb3V0aFdlc3QoKSx0PXQuZ2V0Tm9ydGhFYXN0KCksbz10LmxhdD5lLmxhdCYmbi5sYXQ8aS5sYXQsdD10LmxuZz5lLmxuZyYmbi5sbmc8aS5sbmc7cmV0dXJuIG8mJnR9LHRvQkJveFN0cmluZzpmdW5jdGlvbigpe3JldHVyblt0aGlzLmdldFdlc3QoKSx0aGlzLmdldFNvdXRoKCksdGhpcy5nZXRFYXN0KCksdGhpcy5nZXROb3J0aCgpXS5qb2luKFwiLFwiKX0sZXF1YWxzOmZ1bmN0aW9uKHQsZSl7cmV0dXJuISF0JiYodD1nKHQpLHRoaXMuX3NvdXRoV2VzdC5lcXVhbHModC5nZXRTb3V0aFdlc3QoKSxlKSYmdGhpcy5fbm9ydGhFYXN0LmVxdWFscyh0LmdldE5vcnRoRWFzdCgpLGUpKX0saXNWYWxpZDpmdW5jdGlvbigpe3JldHVybiEoIXRoaXMuX3NvdXRoV2VzdHx8IXRoaXMuX25vcnRoRWFzdCl9fTt2YXIgb3Q9e2xhdExuZ1RvUG9pbnQ6ZnVuY3Rpb24odCxlKXt0PXRoaXMucHJvamVjdGlvbi5wcm9qZWN0KHQpLGU9dGhpcy5zY2FsZShlKTtyZXR1cm4gdGhpcy50cmFuc2Zvcm1hdGlvbi5fdHJhbnNmb3JtKHQsZSl9LHBvaW50VG9MYXRMbmc6ZnVuY3Rpb24odCxlKXtlPXRoaXMuc2NhbGUoZSksdD10aGlzLnRyYW5zZm9ybWF0aW9uLnVudHJhbnNmb3JtKHQsZSk7cmV0dXJuIHRoaXMucHJvamVjdGlvbi51bnByb2plY3QodCl9LHByb2plY3Q6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucHJvamVjdGlvbi5wcm9qZWN0KHQpfSx1bnByb2plY3Q6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucHJvamVjdGlvbi51bnByb2plY3QodCl9LHNjYWxlOmZ1bmN0aW9uKHQpe3JldHVybiAyNTYqTWF0aC5wb3coMix0KX0sem9vbTpmdW5jdGlvbih0KXtyZXR1cm4gTWF0aC5sb2codC8yNTYpL01hdGguTE4yfSxnZXRQcm9qZWN0ZWRCb3VuZHM6ZnVuY3Rpb24odCl7dmFyIGU7cmV0dXJuIHRoaXMuaW5maW5pdGU/bnVsbDooZT10aGlzLnByb2plY3Rpb24uYm91bmRzLHQ9dGhpcy5zY2FsZSh0KSxuZXcgZih0aGlzLnRyYW5zZm9ybWF0aW9uLnRyYW5zZm9ybShlLm1pbix0KSx0aGlzLnRyYW5zZm9ybWF0aW9uLnRyYW5zZm9ybShlLm1heCx0KSkpfSxpbmZpbml0ZTohKHYucHJvdG90eXBlPXtlcXVhbHM6ZnVuY3Rpb24odCxlKXtyZXR1cm4hIXQmJih0PXcodCksTWF0aC5tYXgoTWF0aC5hYnModGhpcy5sYXQtdC5sYXQpLE1hdGguYWJzKHRoaXMubG5nLXQubG5nKSk8PSh2b2lkIDA9PT1lPzFlLTk6ZSkpfSx0b1N0cmluZzpmdW5jdGlvbih0KXtyZXR1cm5cIkxhdExuZyhcIitpKHRoaXMubGF0LHQpK1wiLCBcIitpKHRoaXMubG5nLHQpK1wiKVwifSxkaXN0YW5jZVRvOmZ1bmN0aW9uKHQpe3JldHVybiBzdC5kaXN0YW5jZSh0aGlzLHcodCkpfSx3cmFwOmZ1bmN0aW9uKCl7cmV0dXJuIHN0LndyYXBMYXRMbmcodGhpcyl9LHRvQm91bmRzOmZ1bmN0aW9uKHQpe3ZhciB0PTE4MCp0LzQwMDc1MDE3LGU9dC9NYXRoLmNvcyhNYXRoLlBJLzE4MCp0aGlzLmxhdCk7cmV0dXJuIGcoW3RoaXMubGF0LXQsdGhpcy5sbmctZV0sW3RoaXMubGF0K3QsdGhpcy5sbmcrZV0pfSxjbG9uZTpmdW5jdGlvbigpe3JldHVybiBuZXcgdih0aGlzLmxhdCx0aGlzLmxuZyx0aGlzLmFsdCl9fSksd3JhcExhdExuZzpmdW5jdGlvbih0KXt2YXIgZT10aGlzLndyYXBMbmc/SCh0LmxuZyx0aGlzLndyYXBMbmcsITApOnQubG5nO3JldHVybiBuZXcgdih0aGlzLndyYXBMYXQ/SCh0LmxhdCx0aGlzLndyYXBMYXQsITApOnQubGF0LGUsdC5hbHQpfSx3cmFwTGF0TG5nQm91bmRzOmZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0Q2VudGVyKCksaT10aGlzLndyYXBMYXRMbmcoZSksbj1lLmxhdC1pLmxhdCxlPWUubG5nLWkubG5nO3JldHVybiAwPT1uJiYwPT1lP3Q6KGk9dC5nZXRTb3V0aFdlc3QoKSx0PXQuZ2V0Tm9ydGhFYXN0KCksbmV3IHMobmV3IHYoaS5sYXQtbixpLmxuZy1lKSxuZXcgdih0LmxhdC1uLHQubG5nLWUpKSl9fSxzdD1sKHt9LG90LHt3cmFwTG5nOlstMTgwLDE4MF0sUjo2MzcxZTMsZGlzdGFuY2U6ZnVuY3Rpb24odCxlKXt2YXIgaT1NYXRoLlBJLzE4MCxuPXQubGF0Kmksbz1lLmxhdCppLHM9TWF0aC5zaW4oKGUubGF0LXQubGF0KSppLzIpLGU9TWF0aC5zaW4oKGUubG5nLXQubG5nKSppLzIpLHQ9cypzK01hdGguY29zKG4pKk1hdGguY29zKG8pKmUqZSxpPTIqTWF0aC5hdGFuMihNYXRoLnNxcnQodCksTWF0aC5zcXJ0KDEtdCkpO3JldHVybiB0aGlzLlIqaX19KSxydD02Mzc4MTM3LHJ0PXtSOnJ0LE1BWF9MQVRJVFVERTo4NS4wNTExMjg3Nzk4LHByb2plY3Q6ZnVuY3Rpb24odCl7dmFyIGU9TWF0aC5QSS8xODAsaT10aGlzLk1BWF9MQVRJVFVERSxpPU1hdGgubWF4KE1hdGgubWluKGksdC5sYXQpLC1pKSxpPU1hdGguc2luKGkqZSk7cmV0dXJuIG5ldyBwKHRoaXMuUip0LmxuZyplLHRoaXMuUipNYXRoLmxvZygoMStpKS8oMS1pKSkvMil9LHVucHJvamVjdDpmdW5jdGlvbih0KXt2YXIgZT0xODAvTWF0aC5QSTtyZXR1cm4gbmV3IHYoKDIqTWF0aC5hdGFuKE1hdGguZXhwKHQueS90aGlzLlIpKS1NYXRoLlBJLzIpKmUsdC54KmUvdGhpcy5SKX0sYm91bmRzOm5ldyBmKFstKHJ0PXJ0Kk1hdGguUEkpLC1ydF0sW3J0LHJ0XSl9O2Z1bmN0aW9uIGF0KHQsZSxpLG4pe2QodCk/KHRoaXMuX2E9dFswXSx0aGlzLl9iPXRbMV0sdGhpcy5fYz10WzJdLHRoaXMuX2Q9dFszXSk6KHRoaXMuX2E9dCx0aGlzLl9iPWUsdGhpcy5fYz1pLHRoaXMuX2Q9bil9ZnVuY3Rpb24gaHQodCxlLGksbil7cmV0dXJuIG5ldyBhdCh0LGUsaSxuKX1hdC5wcm90b3R5cGU9e3RyYW5zZm9ybTpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLl90cmFuc2Zvcm0odC5jbG9uZSgpLGUpfSxfdHJhbnNmb3JtOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQueD0oZT1lfHwxKSoodGhpcy5fYSp0LngrdGhpcy5fYiksdC55PWUqKHRoaXMuX2MqdC55K3RoaXMuX2QpLHR9LHVudHJhbnNmb3JtOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIG5ldyBwKCh0LngvKGU9ZXx8MSktdGhpcy5fYikvdGhpcy5fYSwodC55L2UtdGhpcy5fZCkvdGhpcy5fYyl9fTt2YXIgbHQ9bCh7fSxzdCx7Y29kZTpcIkVQU0c6Mzg1N1wiLHByb2plY3Rpb246cnQsdHJhbnNmb3JtYXRpb246aHQobHQ9LjUvKE1hdGguUEkqcnQuUiksLjUsLWx0LC41KX0pLHV0PWwoe30sbHQse2NvZGU6XCJFUFNHOjkwMDkxM1wifSk7ZnVuY3Rpb24gY3QodCl7cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsdCl9ZnVuY3Rpb24gZHQodCxlKXtmb3IodmFyIGksbixvLHMscj1cIlwiLGE9MCxoPXQubGVuZ3RoO2E8aDthKyspe2ZvcihpPTAsbj0obz10W2FdKS5sZW5ndGg7aTxuO2krKylyKz0oaT9cIkxcIjpcIk1cIikrKHM9b1tpXSkueCtcIiBcIitzLnk7cis9ZT9iLnN2Zz9cInpcIjpcInhcIjpcIlwifXJldHVybiByfHxcIk0wIDBcIn12YXIgX3Q9ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLHB0PVwiQWN0aXZlWE9iamVjdFwiaW4gd2luZG93LG10PXB0JiYhZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcixuPVwibXNMYXVuY2hVcmlcImluIG5hdmlnYXRvciYmIShcImRvY3VtZW50TW9kZVwiaW4gZG9jdW1lbnQpLGZ0PXkoXCJ3ZWJraXRcIiksZ3Q9eShcImFuZHJvaWRcIiksdnQ9eShcImFuZHJvaWQgMlwiKXx8eShcImFuZHJvaWQgM1wiKSx5dD1wYXJzZUludCgvV2ViS2l0XFwvKFswLTldKyl8JC8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KVsxXSwxMCkseXQ9Z3QmJnkoXCJHb29nbGVcIikmJnl0PDUzNyYmIShcIkF1ZGlvTm9kZVwiaW4gd2luZG93KSx4dD0hIXdpbmRvdy5vcGVyYSx3dD0hbiYmeShcImNocm9tZVwiKSxidD15KFwiZ2Vja29cIikmJiFmdCYmIXh0JiYhcHQsUHQ9IXd0JiZ5KFwic2FmYXJpXCIpLEx0PXkoXCJwaGFudG9tXCIpLG89XCJPVHJhbnNpdGlvblwiaW4gX3QsVHQ9MD09PW5hdmlnYXRvci5wbGF0Zm9ybS5pbmRleE9mKFwiV2luXCIpLE10PXB0JiZcInRyYW5zaXRpb25cImluIF90LHp0PVwiV2ViS2l0Q1NTTWF0cml4XCJpbiB3aW5kb3cmJlwibTExXCJpbiBuZXcgd2luZG93LldlYktpdENTU01hdHJpeCYmIXZ0LF90PVwiTW96UGVyc3BlY3RpdmVcImluIF90LEN0PSF3aW5kb3cuTF9ESVNBQkxFXzNEJiYoTXR8fHp0fHxfdCkmJiFvJiYhTHQsWnQ9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIG9yaWVudGF0aW9ufHx5KFwibW9iaWxlXCIpLFN0PVp0JiZmdCxFdD1adCYmenQsa3Q9IXdpbmRvdy5Qb2ludGVyRXZlbnQmJndpbmRvdy5NU1BvaW50ZXJFdmVudCxPdD0hKCF3aW5kb3cuUG9pbnRlckV2ZW50JiYha3QpLEF0PVwib250b3VjaHN0YXJ0XCJpbiB3aW5kb3d8fCEhd2luZG93LlRvdWNoRXZlbnQsQnQ9IXdpbmRvdy5MX05PX1RPVUNIJiYoQXR8fE90KSxJdD1adCYmeHQsUnQ9WnQmJmJ0LE50PTE8KHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvfHx3aW5kb3cuc2NyZWVuLmRldmljZVhEUEkvd2luZG93LnNjcmVlbi5sb2dpY2FsWERQSSksRHQ9ZnVuY3Rpb24oKXt2YXIgdD0hMTt0cnl7dmFyIGU9T2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LFwicGFzc2l2ZVwiLHtnZXQ6ZnVuY3Rpb24oKXt0PSEwfX0pO3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidGVzdFBhc3NpdmVFdmVudFN1cHBvcnRcIix1LGUpLHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidGVzdFBhc3NpdmVFdmVudFN1cHBvcnRcIix1LGUpfWNhdGNoKHQpe31yZXR1cm4gdH0oKSxqdD0hIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikuZ2V0Q29udGV4dCxIdD0hKCFkb2N1bWVudC5jcmVhdGVFbGVtZW50TlN8fCFjdChcInN2Z1wiKS5jcmVhdGVTVkdSZWN0KSxGdD0hIUh0JiYoKEZ0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpLmlubmVySFRNTD1cIjxzdmcvPlwiLFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj09PShGdC5maXJzdENoaWxkJiZGdC5maXJzdENoaWxkLm5hbWVzcGFjZVVSSSkpO2Z1bmN0aW9uIHkodCl7cmV0dXJuIDA8PW5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKHQpfXZhciBiPXtpZTpwdCxpZWx0OTptdCxlZGdlOm4sd2Via2l0OmZ0LGFuZHJvaWQ6Z3QsYW5kcm9pZDIzOnZ0LGFuZHJvaWRTdG9jazp5dCxvcGVyYTp4dCxjaHJvbWU6d3QsZ2Vja286YnQsc2FmYXJpOlB0LHBoYW50b206THQsb3BlcmExMjpvLHdpbjpUdCxpZTNkOk10LHdlYmtpdDNkOnp0LGdlY2tvM2Q6X3QsYW55M2Q6Q3QsbW9iaWxlOlp0LG1vYmlsZVdlYmtpdDpTdCxtb2JpbGVXZWJraXQzZDpFdCxtc1BvaW50ZXI6a3QscG9pbnRlcjpPdCx0b3VjaDpCdCx0b3VjaE5hdGl2ZTpBdCxtb2JpbGVPcGVyYTpJdCxtb2JpbGVHZWNrbzpSdCxyZXRpbmE6TnQscGFzc2l2ZUV2ZW50czpEdCxjYW52YXM6anQsc3ZnOkh0LHZtbDohSHQmJmZ1bmN0aW9uKCl7dHJ5e3ZhciB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksZT0odC5pbm5lckhUTUw9Jzx2OnNoYXBlIGFkaj1cIjFcIi8+Jyx0LmZpcnN0Q2hpbGQpO3JldHVybiBlLnN0eWxlLmJlaGF2aW9yPVwidXJsKCNkZWZhdWx0I1ZNTClcIixlJiZcIm9iamVjdFwiPT10eXBlb2YgZS5hZGp9Y2F0Y2godCl7cmV0dXJuITF9fSgpLGlubGluZVN2ZzpGdCxtYWM6MD09PW5hdmlnYXRvci5wbGF0Zm9ybS5pbmRleE9mKFwiTWFjXCIpLGxpbnV4OjA9PT1uYXZpZ2F0b3IucGxhdGZvcm0uaW5kZXhPZihcIkxpbnV4XCIpfSxXdD1iLm1zUG9pbnRlcj9cIk1TUG9pbnRlckRvd25cIjpcInBvaW50ZXJkb3duXCIsVXQ9Yi5tc1BvaW50ZXI/XCJNU1BvaW50ZXJNb3ZlXCI6XCJwb2ludGVybW92ZVwiLFZ0PWIubXNQb2ludGVyP1wiTVNQb2ludGVyVXBcIjpcInBvaW50ZXJ1cFwiLHF0PWIubXNQb2ludGVyP1wiTVNQb2ludGVyQ2FuY2VsXCI6XCJwb2ludGVyY2FuY2VsXCIsR3Q9e3RvdWNoc3RhcnQ6V3QsdG91Y2htb3ZlOlV0LHRvdWNoZW5kOlZ0LHRvdWNoY2FuY2VsOnF0fSxLdD17dG91Y2hzdGFydDpmdW5jdGlvbih0LGUpe2UuTVNQT0lOVEVSX1RZUEVfVE9VQ0gmJmUucG9pbnRlclR5cGU9PT1lLk1TUE9JTlRFUl9UWVBFX1RPVUNIJiZPKGUpO2VlKHQsZSl9LHRvdWNobW92ZTplZSx0b3VjaGVuZDplZSx0b3VjaGNhbmNlbDplZX0sWXQ9e30sWHQ9ITE7ZnVuY3Rpb24gSnQodCxlLGkpe3JldHVyblwidG91Y2hzdGFydFwiIT09ZXx8WHR8fChkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFd0LCR0LCEwKSxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFV0LFF0LCEwKSxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFZ0LHRlLCEwKSxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKHF0LHRlLCEwKSxYdD0hMCksS3RbZV0/KGk9S3RbZV0uYmluZCh0aGlzLGkpLHQuYWRkRXZlbnRMaXN0ZW5lcihHdFtlXSxpLCExKSxpKTooY29uc29sZS53YXJuKFwid3JvbmcgZXZlbnQgc3BlY2lmaWVkOlwiLGUpLHUpfWZ1bmN0aW9uICR0KHQpe1l0W3QucG9pbnRlcklkXT10fWZ1bmN0aW9uIFF0KHQpe1l0W3QucG9pbnRlcklkXSYmKFl0W3QucG9pbnRlcklkXT10KX1mdW5jdGlvbiB0ZSh0KXtkZWxldGUgWXRbdC5wb2ludGVySWRdfWZ1bmN0aW9uIGVlKHQsZSl7aWYoZS5wb2ludGVyVHlwZSE9PShlLk1TUE9JTlRFUl9UWVBFX01PVVNFfHxcIm1vdXNlXCIpKXtmb3IodmFyIGkgaW4gZS50b3VjaGVzPVtdLFl0KWUudG91Y2hlcy5wdXNoKFl0W2ldKTtlLmNoYW5nZWRUb3VjaGVzPVtlXSx0KGUpfX12YXIgaWU9MjAwO2Z1bmN0aW9uIG5lKHQsaSl7dC5hZGRFdmVudExpc3RlbmVyKFwiZGJsY2xpY2tcIixpKTt2YXIgbixvPTA7ZnVuY3Rpb24gZSh0KXt2YXIgZTsxIT09dC5kZXRhaWw/bj10LmRldGFpbDpcIm1vdXNlXCI9PT10LnBvaW50ZXJUeXBlfHx0LnNvdXJjZUNhcGFiaWxpdGllcyYmIXQuc291cmNlQ2FwYWJpbGl0aWVzLmZpcmVzVG91Y2hFdmVudHN8fCgoZT1OZSh0KSkuc29tZShmdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIEhUTUxMYWJlbEVsZW1lbnQmJnQuYXR0cmlidXRlcy5mb3J9KSYmIWUuc29tZShmdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnR8fHQgaW5zdGFuY2VvZiBIVE1MU2VsZWN0RWxlbWVudH0pfHwoKGU9RGF0ZS5ub3coKSktbzw9aWU/Mj09PSsrbiYmaShmdW5jdGlvbih0KXt2YXIgZSxpLG49e307Zm9yKGkgaW4gdCllPXRbaV0sbltpXT1lJiZlLmJpbmQ/ZS5iaW5kKHQpOmU7cmV0dXJuKHQ9bikudHlwZT1cImRibGNsaWNrXCIsbi5kZXRhaWw9MixuLmlzVHJ1c3RlZD0hMSxuLl9zaW11bGF0ZWQ9ITAsbn0odCkpOm49MSxvPWUpKX1yZXR1cm4gdC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIixlKSx7ZGJsY2xpY2s6aSxzaW1EYmxjbGljazplfX12YXIgb2Usc2UscmUsYWUsaGUsbGUsdWU9d2UoW1widHJhbnNmb3JtXCIsXCJ3ZWJraXRUcmFuc2Zvcm1cIixcIk9UcmFuc2Zvcm1cIixcIk1velRyYW5zZm9ybVwiLFwibXNUcmFuc2Zvcm1cIl0pLGNlPXdlKFtcIndlYmtpdFRyYW5zaXRpb25cIixcInRyYW5zaXRpb25cIixcIk9UcmFuc2l0aW9uXCIsXCJNb3pUcmFuc2l0aW9uXCIsXCJtc1RyYW5zaXRpb25cIl0pLGRlPVwid2Via2l0VHJhbnNpdGlvblwiPT09Y2V8fFwiT1RyYW5zaXRpb25cIj09PWNlP2NlK1wiRW5kXCI6XCJ0cmFuc2l0aW9uZW5kXCI7ZnVuY3Rpb24gX2UodCl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHQ/ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodCk6dH1mdW5jdGlvbiBwZSh0LGUpe3ZhciBpPXQuc3R5bGVbZV18fHQuY3VycmVudFN0eWxlJiZ0LmN1cnJlbnRTdHlsZVtlXTtyZXR1cm5cImF1dG9cIj09PShpPWkmJlwiYXV0b1wiIT09aXx8IWRvY3VtZW50LmRlZmF1bHRWaWV3P2k6KHQ9ZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSh0LG51bGwpKT90W2VdOm51bGwpP251bGw6aX1mdW5jdGlvbiBQKHQsZSxpKXt0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodCk7cmV0dXJuIHQuY2xhc3NOYW1lPWV8fFwiXCIsaSYmaS5hcHBlbmRDaGlsZCh0KSx0fWZ1bmN0aW9uIFQodCl7dmFyIGU9dC5wYXJlbnROb2RlO2UmJmUucmVtb3ZlQ2hpbGQodCl9ZnVuY3Rpb24gbWUodCl7Zm9yKDt0LmZpcnN0Q2hpbGQ7KXQucmVtb3ZlQ2hpbGQodC5maXJzdENoaWxkKX1mdW5jdGlvbiBmZSh0KXt2YXIgZT10LnBhcmVudE5vZGU7ZSYmZS5sYXN0Q2hpbGQhPT10JiZlLmFwcGVuZENoaWxkKHQpfWZ1bmN0aW9uIGdlKHQpe3ZhciBlPXQucGFyZW50Tm9kZTtlJiZlLmZpcnN0Q2hpbGQhPT10JiZlLmluc2VydEJlZm9yZSh0LGUuZmlyc3RDaGlsZCl9ZnVuY3Rpb24gdmUodCxlKXtyZXR1cm4gdm9pZCAwIT09dC5jbGFzc0xpc3Q/dC5jbGFzc0xpc3QuY29udGFpbnMoZSk6MDwodD14ZSh0KSkubGVuZ3RoJiZuZXcgUmVnRXhwKFwiKF58XFxcXHMpXCIrZStcIihcXFxcc3wkKVwiKS50ZXN0KHQpfWZ1bmN0aW9uIE0odCxlKXt2YXIgaTtpZih2b2lkIDAhPT10LmNsYXNzTGlzdClmb3IodmFyIG49VyhlKSxvPTAscz1uLmxlbmd0aDtvPHM7bysrKXQuY2xhc3NMaXN0LmFkZChuW29dKTtlbHNlIHZlKHQsZSl8fHllKHQsKChpPXhlKHQpKT9pK1wiIFwiOlwiXCIpK2UpfWZ1bmN0aW9uIHoodCxlKXt2b2lkIDAhPT10LmNsYXNzTGlzdD90LmNsYXNzTGlzdC5yZW1vdmUoZSk6eWUodCxGKChcIiBcIit4ZSh0KStcIiBcIikucmVwbGFjZShcIiBcIitlK1wiIFwiLFwiIFwiKSkpfWZ1bmN0aW9uIHllKHQsZSl7dm9pZCAwPT09dC5jbGFzc05hbWUuYmFzZVZhbD90LmNsYXNzTmFtZT1lOnQuY2xhc3NOYW1lLmJhc2VWYWw9ZX1mdW5jdGlvbiB4ZSh0KXtyZXR1cm4gdm9pZCAwPT09KHQ9dC5jb3JyZXNwb25kaW5nRWxlbWVudD90LmNvcnJlc3BvbmRpbmdFbGVtZW50OnQpLmNsYXNzTmFtZS5iYXNlVmFsP3QuY2xhc3NOYW1lOnQuY2xhc3NOYW1lLmJhc2VWYWx9ZnVuY3Rpb24gQyh0LGUpe2lmKFwib3BhY2l0eVwiaW4gdC5zdHlsZSl0LnN0eWxlLm9wYWNpdHk9ZTtlbHNlIGlmKFwiZmlsdGVyXCJpbiB0LnN0eWxlKXt2YXIgaT0hMSxuPVwiRFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQWxwaGFcIjt0cnl7aT10LmZpbHRlcnMuaXRlbShuKX1jYXRjaCh0KXtpZigxPT09ZSlyZXR1cm59ZT1NYXRoLnJvdW5kKDEwMCplKSxpPyhpLkVuYWJsZWQ9MTAwIT09ZSxpLk9wYWNpdHk9ZSk6dC5zdHlsZS5maWx0ZXIrPVwiIHByb2dpZDpcIituK1wiKG9wYWNpdHk9XCIrZStcIilcIn19ZnVuY3Rpb24gd2UodCl7Zm9yKHZhciBlPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSxpPTA7aTx0Lmxlbmd0aDtpKyspaWYodFtpXWluIGUpcmV0dXJuIHRbaV07cmV0dXJuITF9ZnVuY3Rpb24gYmUodCxlLGkpe2U9ZXx8bmV3IHAoMCwwKTt0LnN0eWxlW3VlXT0oYi5pZTNkP1widHJhbnNsYXRlKFwiK2UueCtcInB4LFwiK2UueStcInB4KVwiOlwidHJhbnNsYXRlM2QoXCIrZS54K1wicHgsXCIrZS55K1wicHgsMClcIikrKGk/XCIgc2NhbGUoXCIraStcIilcIjpcIlwiKX1mdW5jdGlvbiBaKHQsZSl7dC5fbGVhZmxldF9wb3M9ZSxiLmFueTNkP2JlKHQsZSk6KHQuc3R5bGUubGVmdD1lLngrXCJweFwiLHQuc3R5bGUudG9wPWUueStcInB4XCIpfWZ1bmN0aW9uIFBlKHQpe3JldHVybiB0Ll9sZWFmbGV0X3Bvc3x8bmV3IHAoMCwwKX1mdW5jdGlvbiBMZSgpe1Mod2luZG93LFwiZHJhZ3N0YXJ0XCIsTyl9ZnVuY3Rpb24gVGUoKXtrKHdpbmRvdyxcImRyYWdzdGFydFwiLE8pfWZ1bmN0aW9uIE1lKHQpe2Zvcig7LTE9PT10LnRhYkluZGV4Oyl0PXQucGFyZW50Tm9kZTt0LnN0eWxlJiYoemUoKSxsZT0oaGU9dCkuc3R5bGUub3V0bGluZSx0LnN0eWxlLm91dGxpbmU9XCJub25lXCIsUyh3aW5kb3csXCJrZXlkb3duXCIsemUpKX1mdW5jdGlvbiB6ZSgpe2hlJiYoaGUuc3R5bGUub3V0bGluZT1sZSxsZT1oZT12b2lkIDAsayh3aW5kb3csXCJrZXlkb3duXCIsemUpKX1mdW5jdGlvbiBDZSh0KXtmb3IoOyEoKHQ9dC5wYXJlbnROb2RlKS5vZmZzZXRXaWR0aCYmdC5vZmZzZXRIZWlnaHR8fHQ9PT1kb2N1bWVudC5ib2R5KTspO3JldHVybiB0fWZ1bmN0aW9uIFplKHQpe3ZhciBlPXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7cmV0dXJue3g6ZS53aWR0aC90Lm9mZnNldFdpZHRofHwxLHk6ZS5oZWlnaHQvdC5vZmZzZXRIZWlnaHR8fDEsYm91bmRpbmdDbGllbnRSZWN0OmV9fWFlPVwib25zZWxlY3RzdGFydFwiaW4gZG9jdW1lbnQ/KHJlPWZ1bmN0aW9uKCl7Uyh3aW5kb3csXCJzZWxlY3RzdGFydFwiLE8pfSxmdW5jdGlvbigpe2sod2luZG93LFwic2VsZWN0c3RhcnRcIixPKX0pOihzZT13ZShbXCJ1c2VyU2VsZWN0XCIsXCJXZWJraXRVc2VyU2VsZWN0XCIsXCJPVXNlclNlbGVjdFwiLFwiTW96VXNlclNlbGVjdFwiLFwibXNVc2VyU2VsZWN0XCJdKSxyZT1mdW5jdGlvbigpe3ZhciB0O3NlJiYodD1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUsb2U9dFtzZV0sdFtzZV09XCJub25lXCIpfSxmdW5jdGlvbigpe3NlJiYoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlW3NlXT1vZSxvZT12b2lkIDApfSk7cHQ9e19fcHJvdG9fXzpudWxsLFRSQU5TRk9STTp1ZSxUUkFOU0lUSU9OOmNlLFRSQU5TSVRJT05fRU5EOmRlLGdldDpfZSxnZXRTdHlsZTpwZSxjcmVhdGU6UCxyZW1vdmU6VCxlbXB0eTptZSx0b0Zyb250OmZlLHRvQmFjazpnZSxoYXNDbGFzczp2ZSxhZGRDbGFzczpNLHJlbW92ZUNsYXNzOnosc2V0Q2xhc3M6eWUsZ2V0Q2xhc3M6eGUsc2V0T3BhY2l0eTpDLHRlc3RQcm9wOndlLHNldFRyYW5zZm9ybTpiZSxzZXRQb3NpdGlvbjpaLGdldFBvc2l0aW9uOlBlLGdldCBkaXNhYmxlVGV4dFNlbGVjdGlvbigpe3JldHVybiByZX0sZ2V0IGVuYWJsZVRleHRTZWxlY3Rpb24oKXtyZXR1cm4gYWV9LGRpc2FibGVJbWFnZURyYWc6TGUsZW5hYmxlSW1hZ2VEcmFnOlRlLHByZXZlbnRPdXRsaW5lOk1lLHJlc3RvcmVPdXRsaW5lOnplLGdldFNpemVkUGFyZW50Tm9kZTpDZSxnZXRTY2FsZTpaZX07ZnVuY3Rpb24gUyh0LGUsaSxuKXtpZihlJiZcIm9iamVjdFwiPT10eXBlb2YgZSlmb3IodmFyIG8gaW4gZSlrZSh0LG8sZVtvXSxpKTtlbHNlIGZvcih2YXIgcz0wLHI9KGU9VyhlKSkubGVuZ3RoO3M8cjtzKyspa2UodCxlW3NdLGksbik7cmV0dXJuIHRoaXN9dmFyIEU9XCJfbGVhZmxldF9ldmVudHNcIjtmdW5jdGlvbiBrKHQsZSxpLG4pe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKVNlKHQpLGRlbGV0ZSB0W0VdO2Vsc2UgaWYoZSYmXCJvYmplY3RcIj09dHlwZW9mIGUpZm9yKHZhciBvIGluIGUpT2UodCxvLGVbb10saSk7ZWxzZSBpZihlPVcoZSksMj09PWFyZ3VtZW50cy5sZW5ndGgpU2UodCxmdW5jdGlvbih0KXtyZXR1cm4tMSE9PUcoZSx0KX0pO2Vsc2UgZm9yKHZhciBzPTAscj1lLmxlbmd0aDtzPHI7cysrKU9lKHQsZVtzXSxpLG4pO3JldHVybiB0aGlzfWZ1bmN0aW9uIFNlKHQsZSl7Zm9yKHZhciBpIGluIHRbRV0pe3ZhciBuPWkuc3BsaXQoL1xcZC8pWzBdO2UmJiFlKG4pfHxPZSh0LG4sbnVsbCxudWxsLGkpfX12YXIgRWU9e21vdXNlZW50ZXI6XCJtb3VzZW92ZXJcIixtb3VzZWxlYXZlOlwibW91c2VvdXRcIix3aGVlbDohKFwib253aGVlbFwiaW4gd2luZG93KSYmXCJtb3VzZXdoZWVsXCJ9O2Z1bmN0aW9uIGtlKGUsdCxpLG4pe3ZhciBvLHMscj10K2goaSkrKG4/XCJfXCIraChuKTpcIlwiKTtlW0VdJiZlW0VdW3JdfHwocz1vPWZ1bmN0aW9uKHQpe3JldHVybiBpLmNhbGwobnx8ZSx0fHx3aW5kb3cuZXZlbnQpfSwhYi50b3VjaE5hdGl2ZSYmYi5wb2ludGVyJiYwPT09dC5pbmRleE9mKFwidG91Y2hcIik/bz1KdChlLHQsbyk6Yi50b3VjaCYmXCJkYmxjbGlja1wiPT09dD9vPW5lKGUsbyk6XCJhZGRFdmVudExpc3RlbmVyXCJpbiBlP1widG91Y2hzdGFydFwiPT09dHx8XCJ0b3VjaG1vdmVcIj09PXR8fFwid2hlZWxcIj09PXR8fFwibW91c2V3aGVlbFwiPT09dD9lLmFkZEV2ZW50TGlzdGVuZXIoRWVbdF18fHQsbywhIWIucGFzc2l2ZUV2ZW50cyYme3Bhc3NpdmU6ITF9KTpcIm1vdXNlZW50ZXJcIj09PXR8fFwibW91c2VsZWF2ZVwiPT09dD9lLmFkZEV2ZW50TGlzdGVuZXIoRWVbdF0sbz1mdW5jdGlvbih0KXt0PXR8fHdpbmRvdy5ldmVudCxGZShlLHQpJiZzKHQpfSwhMSk6ZS5hZGRFdmVudExpc3RlbmVyKHQscywhMSk6ZS5hdHRhY2hFdmVudChcIm9uXCIrdCxvKSxlW0VdPWVbRV18fHt9LGVbRV1bcl09byl9ZnVuY3Rpb24gT2UodCxlLGksbixvKXtvPW98fGUraChpKSsobj9cIl9cIitoKG4pOlwiXCIpO3ZhciBzLHIsaT10W0VdJiZ0W0VdW29dO2kmJighYi50b3VjaE5hdGl2ZSYmYi5wb2ludGVyJiYwPT09ZS5pbmRleE9mKFwidG91Y2hcIik/KG49dCxyPWksR3Rbcz1lXT9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoR3Rbc10sciwhMSk6Y29uc29sZS53YXJuKFwid3JvbmcgZXZlbnQgc3BlY2lmaWVkOlwiLHMpKTpiLnRvdWNoJiZcImRibGNsaWNrXCI9PT1lPyhuPWksKHI9dCkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImRibGNsaWNrXCIsbi5kYmxjbGljayksci5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIixuLnNpbURibGNsaWNrKSk6XCJyZW1vdmVFdmVudExpc3RlbmVyXCJpbiB0P3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihFZVtlXXx8ZSxpLCExKTp0LmRldGFjaEV2ZW50KFwib25cIitlLGkpLHRbRV1bb109bnVsbCl9ZnVuY3Rpb24gQWUodCl7cmV0dXJuIHQuc3RvcFByb3BhZ2F0aW9uP3Quc3RvcFByb3BhZ2F0aW9uKCk6dC5vcmlnaW5hbEV2ZW50P3Qub3JpZ2luYWxFdmVudC5fc3RvcHBlZD0hMDp0LmNhbmNlbEJ1YmJsZT0hMCx0aGlzfWZ1bmN0aW9uIEJlKHQpe3JldHVybiBrZSh0LFwid2hlZWxcIixBZSksdGhpc31mdW5jdGlvbiBJZSh0KXtyZXR1cm4gUyh0LFwibW91c2Vkb3duIHRvdWNoc3RhcnQgZGJsY2xpY2sgY29udGV4dG1lbnVcIixBZSksdC5fbGVhZmxldF9kaXNhYmxlX2NsaWNrPSEwLHRoaXN9ZnVuY3Rpb24gTyh0KXtyZXR1cm4gdC5wcmV2ZW50RGVmYXVsdD90LnByZXZlbnREZWZhdWx0KCk6dC5yZXR1cm5WYWx1ZT0hMSx0aGlzfWZ1bmN0aW9uIFJlKHQpe3JldHVybiBPKHQpLEFlKHQpLHRoaXN9ZnVuY3Rpb24gTmUodCl7aWYodC5jb21wb3NlZFBhdGgpcmV0dXJuIHQuY29tcG9zZWRQYXRoKCk7Zm9yKHZhciBlPVtdLGk9dC50YXJnZXQ7aTspZS5wdXNoKGkpLGk9aS5wYXJlbnROb2RlO3JldHVybiBlfWZ1bmN0aW9uIERlKHQsZSl7dmFyIGksbjtyZXR1cm4gZT8obj0oaT1aZShlKSkuYm91bmRpbmdDbGllbnRSZWN0LG5ldyBwKCh0LmNsaWVudFgtbi5sZWZ0KS9pLngtZS5jbGllbnRMZWZ0LCh0LmNsaWVudFktbi50b3ApL2kueS1lLmNsaWVudFRvcCkpOm5ldyBwKHQuY2xpZW50WCx0LmNsaWVudFkpfXZhciBqZT1iLmxpbnV4JiZiLmNocm9tZT93aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbzpiLm1hYz8zKndpbmRvdy5kZXZpY2VQaXhlbFJhdGlvOjA8d2luZG93LmRldmljZVBpeGVsUmF0aW8/Mip3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbzoxO2Z1bmN0aW9uIEhlKHQpe3JldHVybiBiLmVkZ2U/dC53aGVlbERlbHRhWS8yOnQuZGVsdGFZJiYwPT09dC5kZWx0YU1vZGU/LXQuZGVsdGFZL2plOnQuZGVsdGFZJiYxPT09dC5kZWx0YU1vZGU/MjAqLXQuZGVsdGFZOnQuZGVsdGFZJiYyPT09dC5kZWx0YU1vZGU/NjAqLXQuZGVsdGFZOnQuZGVsdGFYfHx0LmRlbHRhWj8wOnQud2hlZWxEZWx0YT8odC53aGVlbERlbHRhWXx8dC53aGVlbERlbHRhKS8yOnQuZGV0YWlsJiZNYXRoLmFicyh0LmRldGFpbCk8MzI3NjU/MjAqLXQuZGV0YWlsOnQuZGV0YWlsP3QuZGV0YWlsLy0zMjc2NSo2MDowfWZ1bmN0aW9uIEZlKHQsZSl7dmFyIGk9ZS5yZWxhdGVkVGFyZ2V0O2lmKCFpKXJldHVybiEwO3RyeXtmb3IoO2kmJmkhPT10OylpPWkucGFyZW50Tm9kZX1jYXRjaCh0KXtyZXR1cm4hMX1yZXR1cm4gaSE9PXR9dmFyIG10PXtfX3Byb3RvX186bnVsbCxvbjpTLG9mZjprLHN0b3BQcm9wYWdhdGlvbjpBZSxkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb246QmUsZGlzYWJsZUNsaWNrUHJvcGFnYXRpb246SWUscHJldmVudERlZmF1bHQ6TyxzdG9wOlJlLGdldFByb3BhZ2F0aW9uUGF0aDpOZSxnZXRNb3VzZVBvc2l0aW9uOkRlLGdldFdoZWVsRGVsdGE6SGUsaXNFeHRlcm5hbFRhcmdldDpGZSxhZGRMaXN0ZW5lcjpTLHJlbW92ZUxpc3RlbmVyOmt9LFdlPWl0LmV4dGVuZCh7cnVuOmZ1bmN0aW9uKHQsZSxpLG4pe3RoaXMuc3RvcCgpLHRoaXMuX2VsPXQsdGhpcy5faW5Qcm9ncmVzcz0hMCx0aGlzLl9kdXJhdGlvbj1pfHwuMjUsdGhpcy5fZWFzZU91dFBvd2VyPTEvTWF0aC5tYXgobnx8LjUsLjIpLHRoaXMuX3N0YXJ0UG9zPVBlKHQpLHRoaXMuX29mZnNldD1lLnN1YnRyYWN0KHRoaXMuX3N0YXJ0UG9zKSx0aGlzLl9zdGFydFRpbWU9K25ldyBEYXRlLHRoaXMuZmlyZShcInN0YXJ0XCIpLHRoaXMuX2FuaW1hdGUoKX0sc3RvcDpmdW5jdGlvbigpe3RoaXMuX2luUHJvZ3Jlc3MmJih0aGlzLl9zdGVwKCEwKSx0aGlzLl9jb21wbGV0ZSgpKX0sX2FuaW1hdGU6ZnVuY3Rpb24oKXt0aGlzLl9hbmltSWQ9eCh0aGlzLl9hbmltYXRlLHRoaXMpLHRoaXMuX3N0ZXAoKX0sX3N0ZXA6ZnVuY3Rpb24odCl7dmFyIGU9K25ldyBEYXRlLXRoaXMuX3N0YXJ0VGltZSxpPTFlMyp0aGlzLl9kdXJhdGlvbjtlPGk/dGhpcy5fcnVuRnJhbWUodGhpcy5fZWFzZU91dChlL2kpLHQpOih0aGlzLl9ydW5GcmFtZSgxKSx0aGlzLl9jb21wbGV0ZSgpKX0sX3J1bkZyYW1lOmZ1bmN0aW9uKHQsZSl7dD10aGlzLl9zdGFydFBvcy5hZGQodGhpcy5fb2Zmc2V0Lm11bHRpcGx5QnkodCkpO2UmJnQuX3JvdW5kKCksWih0aGlzLl9lbCx0KSx0aGlzLmZpcmUoXCJzdGVwXCIpfSxfY29tcGxldGU6ZnVuY3Rpb24oKXtyKHRoaXMuX2FuaW1JZCksdGhpcy5faW5Qcm9ncmVzcz0hMSx0aGlzLmZpcmUoXCJlbmRcIil9LF9lYXNlT3V0OmZ1bmN0aW9uKHQpe3JldHVybiAxLU1hdGgucG93KDEtdCx0aGlzLl9lYXNlT3V0UG93ZXIpfX0pLEE9aXQuZXh0ZW5kKHtvcHRpb25zOntjcnM6bHQsY2VudGVyOnZvaWQgMCx6b29tOnZvaWQgMCxtaW5ab29tOnZvaWQgMCxtYXhab29tOnZvaWQgMCxsYXllcnM6W10sbWF4Qm91bmRzOnZvaWQgMCxyZW5kZXJlcjp2b2lkIDAsem9vbUFuaW1hdGlvbjohMCx6b29tQW5pbWF0aW9uVGhyZXNob2xkOjQsZmFkZUFuaW1hdGlvbjohMCxtYXJrZXJab29tQW5pbWF0aW9uOiEwLHRyYW5zZm9ybTNETGltaXQ6ODM4ODYwOCx6b29tU25hcDoxLHpvb21EZWx0YToxLHRyYWNrUmVzaXplOiEwfSxpbml0aWFsaXplOmZ1bmN0aW9uKHQsZSl7ZT1jKHRoaXMsZSksdGhpcy5faGFuZGxlcnM9W10sdGhpcy5fbGF5ZXJzPXt9LHRoaXMuX3pvb21Cb3VuZExheWVycz17fSx0aGlzLl9zaXplQ2hhbmdlZD0hMCx0aGlzLl9pbml0Q29udGFpbmVyKHQpLHRoaXMuX2luaXRMYXlvdXQoKSx0aGlzLl9vblJlc2l6ZT1hKHRoaXMuX29uUmVzaXplLHRoaXMpLHRoaXMuX2luaXRFdmVudHMoKSxlLm1heEJvdW5kcyYmdGhpcy5zZXRNYXhCb3VuZHMoZS5tYXhCb3VuZHMpLHZvaWQgMCE9PWUuem9vbSYmKHRoaXMuX3pvb209dGhpcy5fbGltaXRab29tKGUuem9vbSkpLGUuY2VudGVyJiZ2b2lkIDAhPT1lLnpvb20mJnRoaXMuc2V0Vmlldyh3KGUuY2VudGVyKSxlLnpvb20se3Jlc2V0OiEwfSksdGhpcy5jYWxsSW5pdEhvb2tzKCksdGhpcy5fem9vbUFuaW1hdGVkPWNlJiZiLmFueTNkJiYhYi5tb2JpbGVPcGVyYSYmdGhpcy5vcHRpb25zLnpvb21BbmltYXRpb24sdGhpcy5fem9vbUFuaW1hdGVkJiYodGhpcy5fY3JlYXRlQW5pbVByb3h5KCksUyh0aGlzLl9wcm94eSxkZSx0aGlzLl9jYXRjaFRyYW5zaXRpb25FbmQsdGhpcykpLHRoaXMuX2FkZExheWVycyh0aGlzLm9wdGlvbnMubGF5ZXJzKX0sc2V0VmlldzpmdW5jdGlvbih0LGUsaSl7aWYoKGU9dm9pZCAwPT09ZT90aGlzLl96b29tOnRoaXMuX2xpbWl0Wm9vbShlKSx0PXRoaXMuX2xpbWl0Q2VudGVyKHcodCksZSx0aGlzLm9wdGlvbnMubWF4Qm91bmRzKSxpPWl8fHt9LHRoaXMuX3N0b3AoKSx0aGlzLl9sb2FkZWQmJiFpLnJlc2V0JiYhMCE9PWkpJiYodm9pZCAwIT09aS5hbmltYXRlJiYoaS56b29tPWwoe2FuaW1hdGU6aS5hbmltYXRlfSxpLnpvb20pLGkucGFuPWwoe2FuaW1hdGU6aS5hbmltYXRlLGR1cmF0aW9uOmkuZHVyYXRpb259LGkucGFuKSksdGhpcy5fem9vbSE9PWU/dGhpcy5fdHJ5QW5pbWF0ZWRab29tJiZ0aGlzLl90cnlBbmltYXRlZFpvb20odCxlLGkuem9vbSk6dGhpcy5fdHJ5QW5pbWF0ZWRQYW4odCxpLnBhbikpKXJldHVybiBjbGVhclRpbWVvdXQodGhpcy5fc2l6ZVRpbWVyKSx0aGlzO3JldHVybiB0aGlzLl9yZXNldFZpZXcodCxlLGkucGFuJiZpLnBhbi5ub01vdmVTdGFydCksdGhpc30sc2V0Wm9vbTpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLl9sb2FkZWQ/dGhpcy5zZXRWaWV3KHRoaXMuZ2V0Q2VudGVyKCksdCx7em9vbTplfSk6KHRoaXMuX3pvb209dCx0aGlzKX0sem9vbUluOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQ9dHx8KGIuYW55M2Q/dGhpcy5vcHRpb25zLnpvb21EZWx0YToxKSx0aGlzLnNldFpvb20odGhpcy5fem9vbSt0LGUpfSx6b29tT3V0OmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQ9dHx8KGIuYW55M2Q/dGhpcy5vcHRpb25zLnpvb21EZWx0YToxKSx0aGlzLnNldFpvb20odGhpcy5fem9vbS10LGUpfSxzZXRab29tQXJvdW5kOmZ1bmN0aW9uKHQsZSxpKXt2YXIgbj10aGlzLmdldFpvb21TY2FsZShlKSxvPXRoaXMuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLHQ9KHQgaW5zdGFuY2VvZiBwP3Q6dGhpcy5sYXRMbmdUb0NvbnRhaW5lclBvaW50KHQpKS5zdWJ0cmFjdChvKS5tdWx0aXBseUJ5KDEtMS9uKSxuPXRoaXMuY29udGFpbmVyUG9pbnRUb0xhdExuZyhvLmFkZCh0KSk7cmV0dXJuIHRoaXMuc2V0VmlldyhuLGUse3pvb206aX0pfSxfZ2V0Qm91bmRzQ2VudGVyWm9vbTpmdW5jdGlvbih0LGUpe2U9ZXx8e30sdD10LmdldEJvdW5kcz90LmdldEJvdW5kcygpOmcodCk7dmFyIGk9bShlLnBhZGRpbmdUb3BMZWZ0fHxlLnBhZGRpbmd8fFswLDBdKSxuPW0oZS5wYWRkaW5nQm90dG9tUmlnaHR8fGUucGFkZGluZ3x8WzAsMF0pLG89dGhpcy5nZXRCb3VuZHNab29tKHQsITEsaS5hZGQobikpO3JldHVybihvPVwibnVtYmVyXCI9PXR5cGVvZiBlLm1heFpvb20/TWF0aC5taW4oZS5tYXhab29tLG8pOm8pPT09MS8wP3tjZW50ZXI6dC5nZXRDZW50ZXIoKSx6b29tOm99OihlPW4uc3VidHJhY3QoaSkuZGl2aWRlQnkoMiksbj10aGlzLnByb2plY3QodC5nZXRTb3V0aFdlc3QoKSxvKSxpPXRoaXMucHJvamVjdCh0LmdldE5vcnRoRWFzdCgpLG8pLHtjZW50ZXI6dGhpcy51bnByb2plY3Qobi5hZGQoaSkuZGl2aWRlQnkoMikuYWRkKGUpLG8pLHpvb206b30pfSxmaXRCb3VuZHM6ZnVuY3Rpb24odCxlKXtpZigodD1nKHQpKS5pc1ZhbGlkKCkpcmV0dXJuIHQ9dGhpcy5fZ2V0Qm91bmRzQ2VudGVyWm9vbSh0LGUpLHRoaXMuc2V0Vmlldyh0LmNlbnRlcix0Lnpvb20sZSk7dGhyb3cgbmV3IEVycm9yKFwiQm91bmRzIGFyZSBub3QgdmFsaWQuXCIpfSxmaXRXb3JsZDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5maXRCb3VuZHMoW1stOTAsLTE4MF0sWzkwLDE4MF1dLHQpfSxwYW5UbzpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnNldFZpZXcodCx0aGlzLl96b29tLHtwYW46ZX0pfSxwYW5CeTpmdW5jdGlvbih0LGUpe3ZhciBpO3JldHVybiBlPWV8fHt9LCh0PW0odCkucm91bmQoKSkueHx8dC55PyghMD09PWUuYW5pbWF0ZXx8dGhpcy5nZXRTaXplKCkuY29udGFpbnModCk/KHRoaXMuX3BhbkFuaW18fCh0aGlzLl9wYW5BbmltPW5ldyBXZSx0aGlzLl9wYW5BbmltLm9uKHtzdGVwOnRoaXMuX29uUGFuVHJhbnNpdGlvblN0ZXAsZW5kOnRoaXMuX29uUGFuVHJhbnNpdGlvbkVuZH0sdGhpcykpLGUubm9Nb3ZlU3RhcnR8fHRoaXMuZmlyZShcIm1vdmVzdGFydFwiKSwhMSE9PWUuYW5pbWF0ZT8oTSh0aGlzLl9tYXBQYW5lLFwibGVhZmxldC1wYW4tYW5pbVwiKSxpPXRoaXMuX2dldE1hcFBhbmVQb3MoKS5zdWJ0cmFjdCh0KS5yb3VuZCgpLHRoaXMuX3BhbkFuaW0ucnVuKHRoaXMuX21hcFBhbmUsaSxlLmR1cmF0aW9ufHwuMjUsZS5lYXNlTGluZWFyaXR5KSk6KHRoaXMuX3Jhd1BhbkJ5KHQpLHRoaXMuZmlyZShcIm1vdmVcIikuZmlyZShcIm1vdmVlbmRcIikpKTp0aGlzLl9yZXNldFZpZXcodGhpcy51bnByb2plY3QodGhpcy5wcm9qZWN0KHRoaXMuZ2V0Q2VudGVyKCkpLmFkZCh0KSksdGhpcy5nZXRab29tKCkpLHRoaXMpOnRoaXMuZmlyZShcIm1vdmVlbmRcIil9LGZseVRvOmZ1bmN0aW9uKG4sbyx0KXtpZighMT09PSh0PXR8fHt9KS5hbmltYXRlfHwhYi5hbnkzZClyZXR1cm4gdGhpcy5zZXRWaWV3KG4sbyx0KTt0aGlzLl9zdG9wKCk7dmFyIHM9dGhpcy5wcm9qZWN0KHRoaXMuZ2V0Q2VudGVyKCkpLHI9dGhpcy5wcm9qZWN0KG4pLGU9dGhpcy5nZXRTaXplKCksYT10aGlzLl96b29tLGg9KG49dyhuKSxvPXZvaWQgMD09PW8/YTpvLE1hdGgubWF4KGUueCxlLnkpKSxpPWgqdGhpcy5nZXRab29tU2NhbGUoYSxvKSxsPXIuZGlzdGFuY2VUbyhzKXx8MSx1PTEuNDIsYz11KnU7ZnVuY3Rpb24gZCh0KXt0PShpKmktaCpoKyh0Py0xOjEpKmMqYypsKmwpLygyKih0P2k6aCkqYypsKSx0PU1hdGguc3FydCh0KnQrMSktdDtyZXR1cm4gdDwxZS05Py0xODpNYXRoLmxvZyh0KX1mdW5jdGlvbiBfKHQpe3JldHVybihNYXRoLmV4cCh0KS1NYXRoLmV4cCgtdCkpLzJ9ZnVuY3Rpb24gcCh0KXtyZXR1cm4oTWF0aC5leHAodCkrTWF0aC5leHAoLXQpKS8yfXZhciBtPWQoMCk7ZnVuY3Rpb24gZih0KXtyZXR1cm4gaCoocChtKSooXyh0PW0rdSp0KS9wKHQpKS1fKG0pKS9jfXZhciBnPURhdGUubm93KCksdj0oZCgxKS1tKS91LHk9dC5kdXJhdGlvbj8xZTMqdC5kdXJhdGlvbjoxZTMqdiouODtyZXR1cm4gdGhpcy5fbW92ZVN0YXJ0KCEwLHQubm9Nb3ZlU3RhcnQpLGZ1bmN0aW9uIHQoKXt2YXIgZT0oRGF0ZS5ub3coKS1nKS95LGk9KDEtTWF0aC5wb3coMS1lLDEuNSkpKnY7ZTw9MT8odGhpcy5fZmx5VG9GcmFtZT14KHQsdGhpcyksdGhpcy5fbW92ZSh0aGlzLnVucHJvamVjdChzLmFkZChyLnN1YnRyYWN0KHMpLm11bHRpcGx5QnkoZihpKS9sKSksYSksdGhpcy5nZXRTY2FsZVpvb20oaC8oZT1pLGgqKHAobSkvcChtK3UqZSkpKSxhKSx7Zmx5VG86ITB9KSk6dGhpcy5fbW92ZShuLG8pLl9tb3ZlRW5kKCEwKX0uY2FsbCh0aGlzKSx0aGlzfSxmbHlUb0JvdW5kczpmdW5jdGlvbih0LGUpe3Q9dGhpcy5fZ2V0Qm91bmRzQ2VudGVyWm9vbSh0LGUpO3JldHVybiB0aGlzLmZseVRvKHQuY2VudGVyLHQuem9vbSxlKX0sc2V0TWF4Qm91bmRzOmZ1bmN0aW9uKHQpe3JldHVybiB0PWcodCksdGhpcy5saXN0ZW5zKFwibW92ZWVuZFwiLHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcykmJnRoaXMub2ZmKFwibW92ZWVuZFwiLHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcyksdC5pc1ZhbGlkKCk/KHRoaXMub3B0aW9ucy5tYXhCb3VuZHM9dCx0aGlzLl9sb2FkZWQmJnRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcygpLHRoaXMub24oXCJtb3ZlZW5kXCIsdGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKSk6KHRoaXMub3B0aW9ucy5tYXhCb3VuZHM9bnVsbCx0aGlzKX0sc2V0TWluWm9vbTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLm9wdGlvbnMubWluWm9vbTtyZXR1cm4gdGhpcy5vcHRpb25zLm1pblpvb209dCx0aGlzLl9sb2FkZWQmJmUhPT10JiYodGhpcy5maXJlKFwiem9vbWxldmVsc2NoYW5nZVwiKSx0aGlzLmdldFpvb20oKTx0aGlzLm9wdGlvbnMubWluWm9vbSk/dGhpcy5zZXRab29tKHQpOnRoaXN9LHNldE1heFpvb206ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5vcHRpb25zLm1heFpvb207cmV0dXJuIHRoaXMub3B0aW9ucy5tYXhab29tPXQsdGhpcy5fbG9hZGVkJiZlIT09dCYmKHRoaXMuZmlyZShcInpvb21sZXZlbHNjaGFuZ2VcIiksdGhpcy5nZXRab29tKCk+dGhpcy5vcHRpb25zLm1heFpvb20pP3RoaXMuc2V0Wm9vbSh0KTp0aGlzfSxwYW5JbnNpZGVCb3VuZHM6ZnVuY3Rpb24odCxlKXt0aGlzLl9lbmZvcmNpbmdCb3VuZHM9ITA7dmFyIGk9dGhpcy5nZXRDZW50ZXIoKSx0PXRoaXMuX2xpbWl0Q2VudGVyKGksdGhpcy5fem9vbSxnKHQpKTtyZXR1cm4gaS5lcXVhbHModCl8fHRoaXMucGFuVG8odCxlKSx0aGlzLl9lbmZvcmNpbmdCb3VuZHM9ITEsdGhpc30scGFuSW5zaWRlOmZ1bmN0aW9uKHQsZSl7dmFyIGk9bSgoZT1lfHx7fSkucGFkZGluZ1RvcExlZnR8fGUucGFkZGluZ3x8WzAsMF0pLG49bShlLnBhZGRpbmdCb3R0b21SaWdodHx8ZS5wYWRkaW5nfHxbMCwwXSksbz10aGlzLnByb2plY3QodGhpcy5nZXRDZW50ZXIoKSksdD10aGlzLnByb2plY3QodCkscz10aGlzLmdldFBpeGVsQm91bmRzKCksaT1fKFtzLm1pbi5hZGQoaSkscy5tYXguc3VidHJhY3QobildKSxzPWkuZ2V0U2l6ZSgpO3JldHVybiBpLmNvbnRhaW5zKHQpfHwodGhpcy5fZW5mb3JjaW5nQm91bmRzPSEwLG49dC5zdWJ0cmFjdChpLmdldENlbnRlcigpKSxpPWkuZXh0ZW5kKHQpLmdldFNpemUoKS5zdWJ0cmFjdChzKSxvLngrPW4ueDwwPy1pLng6aS54LG8ueSs9bi55PDA/LWkueTppLnksdGhpcy5wYW5Ubyh0aGlzLnVucHJvamVjdChvKSxlKSx0aGlzLl9lbmZvcmNpbmdCb3VuZHM9ITEpLHRoaXN9LGludmFsaWRhdGVTaXplOmZ1bmN0aW9uKHQpe2lmKCF0aGlzLl9sb2FkZWQpcmV0dXJuIHRoaXM7dD1sKHthbmltYXRlOiExLHBhbjohMH0sITA9PT10P3thbmltYXRlOiEwfTp0KTt2YXIgZT10aGlzLmdldFNpemUoKSxpPSh0aGlzLl9zaXplQ2hhbmdlZD0hMCx0aGlzLl9sYXN0Q2VudGVyPW51bGwsdGhpcy5nZXRTaXplKCkpLG49ZS5kaXZpZGVCeSgyKS5yb3VuZCgpLG89aS5kaXZpZGVCeSgyKS5yb3VuZCgpLG49bi5zdWJ0cmFjdChvKTtyZXR1cm4gbi54fHxuLnk/KHQuYW5pbWF0ZSYmdC5wYW4/dGhpcy5wYW5CeShuKToodC5wYW4mJnRoaXMuX3Jhd1BhbkJ5KG4pLHRoaXMuZmlyZShcIm1vdmVcIiksdC5kZWJvdW5jZU1vdmVlbmQ/KGNsZWFyVGltZW91dCh0aGlzLl9zaXplVGltZXIpLHRoaXMuX3NpemVUaW1lcj1zZXRUaW1lb3V0KGEodGhpcy5maXJlLHRoaXMsXCJtb3ZlZW5kXCIpLDIwMCkpOnRoaXMuZmlyZShcIm1vdmVlbmRcIikpLHRoaXMuZmlyZShcInJlc2l6ZVwiLHtvbGRTaXplOmUsbmV3U2l6ZTppfSkpOnRoaXN9LHN0b3A6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zZXRab29tKHRoaXMuX2xpbWl0Wm9vbSh0aGlzLl96b29tKSksdGhpcy5vcHRpb25zLnpvb21TbmFwfHx0aGlzLmZpcmUoXCJ2aWV3cmVzZXRcIiksdGhpcy5fc3RvcCgpfSxsb2NhdGU6ZnVuY3Rpb24odCl7dmFyIGUsaTtyZXR1cm4gdD10aGlzLl9sb2NhdGVPcHRpb25zPWwoe3RpbWVvdXQ6MWU0LHdhdGNoOiExfSx0KSxcImdlb2xvY2F0aW9uXCJpbiBuYXZpZ2F0b3I/KGU9YSh0aGlzLl9oYW5kbGVHZW9sb2NhdGlvblJlc3BvbnNlLHRoaXMpLGk9YSh0aGlzLl9oYW5kbGVHZW9sb2NhdGlvbkVycm9yLHRoaXMpLHQud2F0Y2g/dGhpcy5fbG9jYXRpb25XYXRjaElkPW5hdmlnYXRvci5nZW9sb2NhdGlvbi53YXRjaFBvc2l0aW9uKGUsaSx0KTpuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uZ2V0Q3VycmVudFBvc2l0aW9uKGUsaSx0KSk6dGhpcy5faGFuZGxlR2VvbG9jYXRpb25FcnJvcih7Y29kZTowLG1lc3NhZ2U6XCJHZW9sb2NhdGlvbiBub3Qgc3VwcG9ydGVkLlwifSksdGhpc30sc3RvcExvY2F0ZTpmdW5jdGlvbigpe3JldHVybiBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24mJm5hdmlnYXRvci5nZW9sb2NhdGlvbi5jbGVhcldhdGNoJiZuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCh0aGlzLl9sb2NhdGlvbldhdGNoSWQpLHRoaXMuX2xvY2F0ZU9wdGlvbnMmJih0aGlzLl9sb2NhdGVPcHRpb25zLnNldFZpZXc9ITEpLHRoaXN9LF9oYW5kbGVHZW9sb2NhdGlvbkVycm9yOmZ1bmN0aW9uKHQpe3ZhciBlO3RoaXMuX2NvbnRhaW5lci5fbGVhZmxldF9pZCYmKGU9dC5jb2RlLHQ9dC5tZXNzYWdlfHwoMT09PWU/XCJwZXJtaXNzaW9uIGRlbmllZFwiOjI9PT1lP1wicG9zaXRpb24gdW5hdmFpbGFibGVcIjpcInRpbWVvdXRcIiksdGhpcy5fbG9jYXRlT3B0aW9ucy5zZXRWaWV3JiYhdGhpcy5fbG9hZGVkJiZ0aGlzLmZpdFdvcmxkKCksdGhpcy5maXJlKFwibG9jYXRpb25lcnJvclwiLHtjb2RlOmUsbWVzc2FnZTpcIkdlb2xvY2F0aW9uIGVycm9yOiBcIit0K1wiLlwifSkpfSxfaGFuZGxlR2VvbG9jYXRpb25SZXNwb25zZTpmdW5jdGlvbih0KXtpZih0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQpe3ZhciBlLGksbj1uZXcgdih0LmNvb3Jkcy5sYXRpdHVkZSx0LmNvb3Jkcy5sb25naXR1ZGUpLG89bi50b0JvdW5kcygyKnQuY29vcmRzLmFjY3VyYWN5KSxzPXRoaXMuX2xvY2F0ZU9wdGlvbnMscj0ocy5zZXRWaWV3JiYoZT10aGlzLmdldEJvdW5kc1pvb20obyksdGhpcy5zZXRWaWV3KG4scy5tYXhab29tP01hdGgubWluKGUscy5tYXhab29tKTplKSkse2xhdGxuZzpuLGJvdW5kczpvLHRpbWVzdGFtcDp0LnRpbWVzdGFtcH0pO2ZvcihpIGluIHQuY29vcmRzKVwibnVtYmVyXCI9PXR5cGVvZiB0LmNvb3Jkc1tpXSYmKHJbaV09dC5jb29yZHNbaV0pO3RoaXMuZmlyZShcImxvY2F0aW9uZm91bmRcIixyKX19LGFkZEhhbmRsZXI6ZnVuY3Rpb24odCxlKXtyZXR1cm4gZSYmKGU9dGhpc1t0XT1uZXcgZSh0aGlzKSx0aGlzLl9oYW5kbGVycy5wdXNoKGUpLHRoaXMub3B0aW9uc1t0XSYmZS5lbmFibGUoKSksdGhpc30scmVtb3ZlOmZ1bmN0aW9uKCl7aWYodGhpcy5faW5pdEV2ZW50cyghMCksdGhpcy5vcHRpb25zLm1heEJvdW5kcyYmdGhpcy5vZmYoXCJtb3ZlZW5kXCIsdGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKSx0aGlzLl9jb250YWluZXJJZCE9PXRoaXMuX2NvbnRhaW5lci5fbGVhZmxldF9pZCl0aHJvdyBuZXcgRXJyb3IoXCJNYXAgY29udGFpbmVyIGlzIGJlaW5nIHJldXNlZCBieSBhbm90aGVyIGluc3RhbmNlXCIpO3RyeXtkZWxldGUgdGhpcy5fY29udGFpbmVyLl9sZWFmbGV0X2lkLGRlbGV0ZSB0aGlzLl9jb250YWluZXJJZH1jYXRjaCh0KXt0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQ9dm9pZCAwLHRoaXMuX2NvbnRhaW5lcklkPXZvaWQgMH1mb3IodmFyIHQgaW4gdm9pZCAwIT09dGhpcy5fbG9jYXRpb25XYXRjaElkJiZ0aGlzLnN0b3BMb2NhdGUoKSx0aGlzLl9zdG9wKCksVCh0aGlzLl9tYXBQYW5lKSx0aGlzLl9jbGVhckNvbnRyb2xQb3MmJnRoaXMuX2NsZWFyQ29udHJvbFBvcygpLHRoaXMuX3Jlc2l6ZVJlcXVlc3QmJihyKHRoaXMuX3Jlc2l6ZVJlcXVlc3QpLHRoaXMuX3Jlc2l6ZVJlcXVlc3Q9bnVsbCksdGhpcy5fY2xlYXJIYW5kbGVycygpLHRoaXMuX2xvYWRlZCYmdGhpcy5maXJlKFwidW5sb2FkXCIpLHRoaXMuX2xheWVycyl0aGlzLl9sYXllcnNbdF0ucmVtb3ZlKCk7Zm9yKHQgaW4gdGhpcy5fcGFuZXMpVCh0aGlzLl9wYW5lc1t0XSk7cmV0dXJuIHRoaXMuX2xheWVycz1bXSx0aGlzLl9wYW5lcz1bXSxkZWxldGUgdGhpcy5fbWFwUGFuZSxkZWxldGUgdGhpcy5fcmVuZGVyZXIsdGhpc30sY3JlYXRlUGFuZTpmdW5jdGlvbih0LGUpe2U9UChcImRpdlwiLFwibGVhZmxldC1wYW5lXCIrKHQ/XCIgbGVhZmxldC1cIit0LnJlcGxhY2UoXCJQYW5lXCIsXCJcIikrXCItcGFuZVwiOlwiXCIpLGV8fHRoaXMuX21hcFBhbmUpO3JldHVybiB0JiYodGhpcy5fcGFuZXNbdF09ZSksZX0sZ2V0Q2VudGVyOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2NoZWNrSWZMb2FkZWQoKSx0aGlzLl9sYXN0Q2VudGVyJiYhdGhpcy5fbW92ZWQoKT90aGlzLl9sYXN0Q2VudGVyLmNsb25lKCk6dGhpcy5sYXllclBvaW50VG9MYXRMbmcodGhpcy5fZ2V0Q2VudGVyTGF5ZXJQb2ludCgpKX0sZ2V0Wm9vbTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl96b29tfSxnZXRCb3VuZHM6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmdldFBpeGVsQm91bmRzKCk7cmV0dXJuIG5ldyBzKHRoaXMudW5wcm9qZWN0KHQuZ2V0Qm90dG9tTGVmdCgpKSx0aGlzLnVucHJvamVjdCh0LmdldFRvcFJpZ2h0KCkpKX0sZ2V0TWluWm9vbTpmdW5jdGlvbigpe3JldHVybiB2b2lkIDA9PT10aGlzLm9wdGlvbnMubWluWm9vbT90aGlzLl9sYXllcnNNaW5ab29tfHwwOnRoaXMub3B0aW9ucy5taW5ab29tfSxnZXRNYXhab29tOmZ1bmN0aW9uKCl7cmV0dXJuIHZvaWQgMD09PXRoaXMub3B0aW9ucy5tYXhab29tP3ZvaWQgMD09PXRoaXMuX2xheWVyc01heFpvb20/MS8wOnRoaXMuX2xheWVyc01heFpvb206dGhpcy5vcHRpb25zLm1heFpvb219LGdldEJvdW5kc1pvb206ZnVuY3Rpb24odCxlLGkpe3Q9Zyh0KSxpPW0oaXx8WzAsMF0pO3ZhciBuPXRoaXMuZ2V0Wm9vbSgpfHwwLG89dGhpcy5nZXRNaW5ab29tKCkscz10aGlzLmdldE1heFpvb20oKSxyPXQuZ2V0Tm9ydGhXZXN0KCksdD10LmdldFNvdXRoRWFzdCgpLGk9dGhpcy5nZXRTaXplKCkuc3VidHJhY3QoaSksdD1fKHRoaXMucHJvamVjdCh0LG4pLHRoaXMucHJvamVjdChyLG4pKS5nZXRTaXplKCkscj1iLmFueTNkP3RoaXMub3B0aW9ucy56b29tU25hcDoxLGE9aS54L3QueCxpPWkueS90LnksdD1lP01hdGgubWF4KGEsaSk6TWF0aC5taW4oYSxpKSxuPXRoaXMuZ2V0U2NhbGVab29tKHQsbik7cmV0dXJuIHImJihuPU1hdGgucm91bmQobi8oci8xMDApKSooci8xMDApLG49ZT9NYXRoLmNlaWwobi9yKSpyOk1hdGguZmxvb3Iobi9yKSpyKSxNYXRoLm1heChvLE1hdGgubWluKHMsbikpfSxnZXRTaXplOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NpemUmJiF0aGlzLl9zaXplQ2hhbmdlZHx8KHRoaXMuX3NpemU9bmV3IHAodGhpcy5fY29udGFpbmVyLmNsaWVudFdpZHRofHwwLHRoaXMuX2NvbnRhaW5lci5jbGllbnRIZWlnaHR8fDApLHRoaXMuX3NpemVDaGFuZ2VkPSExKSx0aGlzLl9zaXplLmNsb25lKCl9LGdldFBpeGVsQm91bmRzOmZ1bmN0aW9uKHQsZSl7dD10aGlzLl9nZXRUb3BMZWZ0UG9pbnQodCxlKTtyZXR1cm4gbmV3IGYodCx0LmFkZCh0aGlzLmdldFNpemUoKSkpfSxnZXRQaXhlbE9yaWdpbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9jaGVja0lmTG9hZGVkKCksdGhpcy5fcGl4ZWxPcmlnaW59LGdldFBpeGVsV29ybGRCb3VuZHM6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMuZ2V0UHJvamVjdGVkQm91bmRzKHZvaWQgMD09PXQ/dGhpcy5nZXRab29tKCk6dCl9LGdldFBhbmU6ZnVuY3Rpb24odCl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHQ/dGhpcy5fcGFuZXNbdF06dH0sZ2V0UGFuZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcGFuZXN9LGdldENvbnRhaW5lcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9jb250YWluZXJ9LGdldFpvb21TY2FsZTpmdW5jdGlvbih0LGUpe3ZhciBpPXRoaXMub3B0aW9ucy5jcnM7cmV0dXJuIGU9dm9pZCAwPT09ZT90aGlzLl96b29tOmUsaS5zY2FsZSh0KS9pLnNjYWxlKGUpfSxnZXRTY2FsZVpvb206ZnVuY3Rpb24odCxlKXt2YXIgaT10aGlzLm9wdGlvbnMuY3JzLHQ9KGU9dm9pZCAwPT09ZT90aGlzLl96b29tOmUsaS56b29tKHQqaS5zY2FsZShlKSkpO3JldHVybiBpc05hTih0KT8xLzA6dH0scHJvamVjdDpmdW5jdGlvbih0LGUpe3JldHVybiBlPXZvaWQgMD09PWU/dGhpcy5fem9vbTplLHRoaXMub3B0aW9ucy5jcnMubGF0TG5nVG9Qb2ludCh3KHQpLGUpfSx1bnByb2plY3Q6ZnVuY3Rpb24odCxlKXtyZXR1cm4gZT12b2lkIDA9PT1lP3RoaXMuX3pvb206ZSx0aGlzLm9wdGlvbnMuY3JzLnBvaW50VG9MYXRMbmcobSh0KSxlKX0sbGF5ZXJQb2ludFRvTGF0TG5nOmZ1bmN0aW9uKHQpe3Q9bSh0KS5hZGQodGhpcy5nZXRQaXhlbE9yaWdpbigpKTtyZXR1cm4gdGhpcy51bnByb2plY3QodCl9LGxhdExuZ1RvTGF5ZXJQb2ludDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5wcm9qZWN0KHcodCkpLl9yb3VuZCgpLl9zdWJ0cmFjdCh0aGlzLmdldFBpeGVsT3JpZ2luKCkpfSx3cmFwTGF0TG5nOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm9wdGlvbnMuY3JzLndyYXBMYXRMbmcodyh0KSl9LHdyYXBMYXRMbmdCb3VuZHM6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMud3JhcExhdExuZ0JvdW5kcyhnKHQpKX0sZGlzdGFuY2U6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5kaXN0YW5jZSh3KHQpLHcoZSkpfSxjb250YWluZXJQb2ludFRvTGF5ZXJQb2ludDpmdW5jdGlvbih0KXtyZXR1cm4gbSh0KS5zdWJ0cmFjdCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpfSxsYXllclBvaW50VG9Db250YWluZXJQb2ludDpmdW5jdGlvbih0KXtyZXR1cm4gbSh0KS5hZGQodGhpcy5fZ2V0TWFwUGFuZVBvcygpKX0sY29udGFpbmVyUG9pbnRUb0xhdExuZzpmdW5jdGlvbih0KXt0PXRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQobSh0KSk7cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKHQpfSxsYXRMbmdUb0NvbnRhaW5lclBvaW50OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHRoaXMubGF0TG5nVG9MYXllclBvaW50KHcodCkpKX0sbW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQ6ZnVuY3Rpb24odCl7cmV0dXJuIERlKHQsdGhpcy5fY29udGFpbmVyKX0sbW91c2VFdmVudFRvTGF5ZXJQb2ludDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCh0aGlzLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KHQpKX0sbW91c2VFdmVudFRvTGF0TG5nOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQodCkpfSxfaW5pdENvbnRhaW5lcjpmdW5jdGlvbih0KXt0PXRoaXMuX2NvbnRhaW5lcj1fZSh0KTtpZighdCl0aHJvdyBuZXcgRXJyb3IoXCJNYXAgY29udGFpbmVyIG5vdCBmb3VuZC5cIik7aWYodC5fbGVhZmxldF9pZCl0aHJvdyBuZXcgRXJyb3IoXCJNYXAgY29udGFpbmVyIGlzIGFscmVhZHkgaW5pdGlhbGl6ZWQuXCIpO1ModCxcInNjcm9sbFwiLHRoaXMuX29uU2Nyb2xsLHRoaXMpLHRoaXMuX2NvbnRhaW5lcklkPWgodCl9LF9pbml0TGF5b3V0OmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fY29udGFpbmVyLGU9KHRoaXMuX2ZhZGVBbmltYXRlZD10aGlzLm9wdGlvbnMuZmFkZUFuaW1hdGlvbiYmYi5hbnkzZCxNKHQsXCJsZWFmbGV0LWNvbnRhaW5lclwiKyhiLnRvdWNoP1wiIGxlYWZsZXQtdG91Y2hcIjpcIlwiKSsoYi5yZXRpbmE/XCIgbGVhZmxldC1yZXRpbmFcIjpcIlwiKSsoYi5pZWx0OT9cIiBsZWFmbGV0LW9sZGllXCI6XCJcIikrKGIuc2FmYXJpP1wiIGxlYWZsZXQtc2FmYXJpXCI6XCJcIikrKHRoaXMuX2ZhZGVBbmltYXRlZD9cIiBsZWFmbGV0LWZhZGUtYW5pbVwiOlwiXCIpKSxwZSh0LFwicG9zaXRpb25cIikpO1wiYWJzb2x1dGVcIiE9PWUmJlwicmVsYXRpdmVcIiE9PWUmJlwiZml4ZWRcIiE9PWUmJlwic3RpY2t5XCIhPT1lJiYodC5zdHlsZS5wb3NpdGlvbj1cInJlbGF0aXZlXCIpLHRoaXMuX2luaXRQYW5lcygpLHRoaXMuX2luaXRDb250cm9sUG9zJiZ0aGlzLl9pbml0Q29udHJvbFBvcygpfSxfaW5pdFBhbmVzOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fcGFuZXM9e307dGhpcy5fcGFuZVJlbmRlcmVycz17fSx0aGlzLl9tYXBQYW5lPXRoaXMuY3JlYXRlUGFuZShcIm1hcFBhbmVcIix0aGlzLl9jb250YWluZXIpLFoodGhpcy5fbWFwUGFuZSxuZXcgcCgwLDApKSx0aGlzLmNyZWF0ZVBhbmUoXCJ0aWxlUGFuZVwiKSx0aGlzLmNyZWF0ZVBhbmUoXCJvdmVybGF5UGFuZVwiKSx0aGlzLmNyZWF0ZVBhbmUoXCJzaGFkb3dQYW5lXCIpLHRoaXMuY3JlYXRlUGFuZShcIm1hcmtlclBhbmVcIiksdGhpcy5jcmVhdGVQYW5lKFwidG9vbHRpcFBhbmVcIiksdGhpcy5jcmVhdGVQYW5lKFwicG9wdXBQYW5lXCIpLHRoaXMub3B0aW9ucy5tYXJrZXJab29tQW5pbWF0aW9ufHwoTSh0Lm1hcmtlclBhbmUsXCJsZWFmbGV0LXpvb20taGlkZVwiKSxNKHQuc2hhZG93UGFuZSxcImxlYWZsZXQtem9vbS1oaWRlXCIpKX0sX3Jlc2V0VmlldzpmdW5jdGlvbih0LGUsaSl7Wih0aGlzLl9tYXBQYW5lLG5ldyBwKDAsMCkpO3ZhciBuPSF0aGlzLl9sb2FkZWQsbz0odGhpcy5fbG9hZGVkPSEwLGU9dGhpcy5fbGltaXRab29tKGUpLHRoaXMuZmlyZShcInZpZXdwcmVyZXNldFwiKSx0aGlzLl96b29tIT09ZSk7dGhpcy5fbW92ZVN0YXJ0KG8saSkuX21vdmUodCxlKS5fbW92ZUVuZChvKSx0aGlzLmZpcmUoXCJ2aWV3cmVzZXRcIiksbiYmdGhpcy5maXJlKFwibG9hZFwiKX0sX21vdmVTdGFydDpmdW5jdGlvbih0LGUpe3JldHVybiB0JiZ0aGlzLmZpcmUoXCJ6b29tc3RhcnRcIiksZXx8dGhpcy5maXJlKFwibW92ZXN0YXJ0XCIpLHRoaXN9LF9tb3ZlOmZ1bmN0aW9uKHQsZSxpLG4pe3ZvaWQgMD09PWUmJihlPXRoaXMuX3pvb20pO3ZhciBvPXRoaXMuX3pvb20hPT1lO3JldHVybiB0aGlzLl96b29tPWUsdGhpcy5fbGFzdENlbnRlcj10LHRoaXMuX3BpeGVsT3JpZ2luPXRoaXMuX2dldE5ld1BpeGVsT3JpZ2luKHQpLG4/aSYmaS5waW5jaCYmdGhpcy5maXJlKFwiem9vbVwiLGkpOigob3x8aSYmaS5waW5jaCkmJnRoaXMuZmlyZShcInpvb21cIixpKSx0aGlzLmZpcmUoXCJtb3ZlXCIsaSkpLHRoaXN9LF9tb3ZlRW5kOmZ1bmN0aW9uKHQpe3JldHVybiB0JiZ0aGlzLmZpcmUoXCJ6b29tZW5kXCIpLHRoaXMuZmlyZShcIm1vdmVlbmRcIil9LF9zdG9wOmZ1bmN0aW9uKCl7cmV0dXJuIHIodGhpcy5fZmx5VG9GcmFtZSksdGhpcy5fcGFuQW5pbSYmdGhpcy5fcGFuQW5pbS5zdG9wKCksdGhpc30sX3Jhd1BhbkJ5OmZ1bmN0aW9uKHQpe1oodGhpcy5fbWFwUGFuZSx0aGlzLl9nZXRNYXBQYW5lUG9zKCkuc3VidHJhY3QodCkpfSxfZ2V0Wm9vbVNwYW46ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRNYXhab29tKCktdGhpcy5nZXRNaW5ab29tKCl9LF9wYW5JbnNpZGVNYXhCb3VuZHM6ZnVuY3Rpb24oKXt0aGlzLl9lbmZvcmNpbmdCb3VuZHN8fHRoaXMucGFuSW5zaWRlQm91bmRzKHRoaXMub3B0aW9ucy5tYXhCb3VuZHMpfSxfY2hlY2tJZkxvYWRlZDpmdW5jdGlvbigpe2lmKCF0aGlzLl9sb2FkZWQpdGhyb3cgbmV3IEVycm9yKFwiU2V0IG1hcCBjZW50ZXIgYW5kIHpvb20gZmlyc3QuXCIpfSxfaW5pdEV2ZW50czpmdW5jdGlvbih0KXt0aGlzLl90YXJnZXRzPXt9O3ZhciBlPXQ/azpTO2UoKHRoaXMuX3RhcmdldHNbaCh0aGlzLl9jb250YWluZXIpXT10aGlzKS5fY29udGFpbmVyLFwiY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlbW92ZSBjb250ZXh0bWVudSBrZXlwcmVzcyBrZXlkb3duIGtleXVwXCIsdGhpcy5faGFuZGxlRE9NRXZlbnQsdGhpcyksdGhpcy5vcHRpb25zLnRyYWNrUmVzaXplJiZlKHdpbmRvdyxcInJlc2l6ZVwiLHRoaXMuX29uUmVzaXplLHRoaXMpLGIuYW55M2QmJnRoaXMub3B0aW9ucy50cmFuc2Zvcm0zRExpbWl0JiYodD90aGlzLm9mZjp0aGlzLm9uKS5jYWxsKHRoaXMsXCJtb3ZlZW5kXCIsdGhpcy5fb25Nb3ZlRW5kKX0sX29uUmVzaXplOmZ1bmN0aW9uKCl7cih0aGlzLl9yZXNpemVSZXF1ZXN0KSx0aGlzLl9yZXNpemVSZXF1ZXN0PXgoZnVuY3Rpb24oKXt0aGlzLmludmFsaWRhdGVTaXplKHtkZWJvdW5jZU1vdmVlbmQ6ITB9KX0sdGhpcyl9LF9vblNjcm9sbDpmdW5jdGlvbigpe3RoaXMuX2NvbnRhaW5lci5zY3JvbGxUb3A9MCx0aGlzLl9jb250YWluZXIuc2Nyb2xsTGVmdD0wfSxfb25Nb3ZlRW5kOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fZ2V0TWFwUGFuZVBvcygpO01hdGgubWF4KE1hdGguYWJzKHQueCksTWF0aC5hYnModC55KSk+PXRoaXMub3B0aW9ucy50cmFuc2Zvcm0zRExpbWl0JiZ0aGlzLl9yZXNldFZpZXcodGhpcy5nZXRDZW50ZXIoKSx0aGlzLmdldFpvb20oKSl9LF9maW5kRXZlbnRUYXJnZXRzOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBpLG49W10sbz1cIm1vdXNlb3V0XCI9PT1lfHxcIm1vdXNlb3ZlclwiPT09ZSxzPXQudGFyZ2V0fHx0LnNyY0VsZW1lbnQscj0hMTtzOyl7aWYoKGk9dGhpcy5fdGFyZ2V0c1toKHMpXSkmJihcImNsaWNrXCI9PT1lfHxcInByZWNsaWNrXCI9PT1lKSYmdGhpcy5fZHJhZ2dhYmxlTW92ZWQoaSkpe3I9ITA7YnJlYWt9aWYoaSYmaS5saXN0ZW5zKGUsITApKXtpZihvJiYhRmUocyx0KSlicmVhaztpZihuLnB1c2goaSksbylicmVha31pZihzPT09dGhpcy5fY29udGFpbmVyKWJyZWFrO3M9cy5wYXJlbnROb2RlfXJldHVybiBuPW4ubGVuZ3RofHxyfHxvfHwhdGhpcy5saXN0ZW5zKGUsITApP246W3RoaXNdfSxfaXNDbGlja0Rpc2FibGVkOmZ1bmN0aW9uKHQpe2Zvcig7dCYmdCE9PXRoaXMuX2NvbnRhaW5lcjspe2lmKHQuX2xlYWZsZXRfZGlzYWJsZV9jbGljaylyZXR1cm4hMDt0PXQucGFyZW50Tm9kZX19LF9oYW5kbGVET01FdmVudDpmdW5jdGlvbih0KXt2YXIgZSxpPXQudGFyZ2V0fHx0LnNyY0VsZW1lbnQ7IXRoaXMuX2xvYWRlZHx8aS5fbGVhZmxldF9kaXNhYmxlX2V2ZW50c3x8XCJjbGlja1wiPT09dC50eXBlJiZ0aGlzLl9pc0NsaWNrRGlzYWJsZWQoaSl8fChcIm1vdXNlZG93blwiPT09KGU9dC50eXBlKSYmTWUoaSksdGhpcy5fZmlyZURPTUV2ZW50KHQsZSkpfSxfbW91c2VFdmVudHM6W1wiY2xpY2tcIixcImRibGNsaWNrXCIsXCJtb3VzZW92ZXJcIixcIm1vdXNlb3V0XCIsXCJjb250ZXh0bWVudVwiXSxfZmlyZURPTUV2ZW50OmZ1bmN0aW9uKHQsZSxpKXtcImNsaWNrXCI9PT10LnR5cGUmJigoYT1sKHt9LHQpKS50eXBlPVwicHJlY2xpY2tcIix0aGlzLl9maXJlRE9NRXZlbnQoYSxhLnR5cGUsaSkpO3ZhciBuPXRoaXMuX2ZpbmRFdmVudFRhcmdldHModCxlKTtpZihpKXtmb3IodmFyIG89W10scz0wO3M8aS5sZW5ndGg7cysrKWlbc10ubGlzdGVucyhlLCEwKSYmby5wdXNoKGlbc10pO249by5jb25jYXQobil9aWYobi5sZW5ndGgpe1wiY29udGV4dG1lbnVcIj09PWUmJk8odCk7dmFyIHIsYT1uWzBdLGg9e29yaWdpbmFsRXZlbnQ6dH07Zm9yKFwia2V5cHJlc3NcIiE9PXQudHlwZSYmXCJrZXlkb3duXCIhPT10LnR5cGUmJlwia2V5dXBcIiE9PXQudHlwZSYmKHI9YS5nZXRMYXRMbmcmJighYS5fcmFkaXVzfHxhLl9yYWRpdXM8PTEwKSxoLmNvbnRhaW5lclBvaW50PXI/dGhpcy5sYXRMbmdUb0NvbnRhaW5lclBvaW50KGEuZ2V0TGF0TG5nKCkpOnRoaXMubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQodCksaC5sYXllclBvaW50PXRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoaC5jb250YWluZXJQb2ludCksaC5sYXRsbmc9cj9hLmdldExhdExuZygpOnRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKGgubGF5ZXJQb2ludCkpLHM9MDtzPG4ubGVuZ3RoO3MrKylpZihuW3NdLmZpcmUoZSxoLCEwKSxoLm9yaWdpbmFsRXZlbnQuX3N0b3BwZWR8fCExPT09bltzXS5vcHRpb25zLmJ1YmJsaW5nTW91c2VFdmVudHMmJi0xIT09Ryh0aGlzLl9tb3VzZUV2ZW50cyxlKSlyZXR1cm59fSxfZHJhZ2dhYmxlTW92ZWQ6ZnVuY3Rpb24odCl7cmV0dXJuKHQ9dC5kcmFnZ2luZyYmdC5kcmFnZ2luZy5lbmFibGVkKCk/dDp0aGlzKS5kcmFnZ2luZyYmdC5kcmFnZ2luZy5tb3ZlZCgpfHx0aGlzLmJveFpvb20mJnRoaXMuYm94Wm9vbS5tb3ZlZCgpfSxfY2xlYXJIYW5kbGVyczpmdW5jdGlvbigpe2Zvcih2YXIgdD0wLGU9dGhpcy5faGFuZGxlcnMubGVuZ3RoO3Q8ZTt0KyspdGhpcy5faGFuZGxlcnNbdF0uZGlzYWJsZSgpfSx3aGVuUmVhZHk6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5fbG9hZGVkP3QuY2FsbChlfHx0aGlzLHt0YXJnZXQ6dGhpc30pOnRoaXMub24oXCJsb2FkXCIsdCxlKSx0aGlzfSxfZ2V0TWFwUGFuZVBvczpmdW5jdGlvbigpe3JldHVybiBQZSh0aGlzLl9tYXBQYW5lKXx8bmV3IHAoMCwwKX0sX21vdmVkOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fZ2V0TWFwUGFuZVBvcygpO3JldHVybiB0JiYhdC5lcXVhbHMoWzAsMF0pfSxfZ2V0VG9wTGVmdFBvaW50OmZ1bmN0aW9uKHQsZSl7cmV0dXJuKHQmJnZvaWQgMCE9PWU/dGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4odCxlKTp0aGlzLmdldFBpeGVsT3JpZ2luKCkpLnN1YnRyYWN0KHRoaXMuX2dldE1hcFBhbmVQb3MoKSl9LF9nZXROZXdQaXhlbE9yaWdpbjpmdW5jdGlvbih0LGUpe3ZhciBpPXRoaXMuZ2V0U2l6ZSgpLl9kaXZpZGVCeSgyKTtyZXR1cm4gdGhpcy5wcm9qZWN0KHQsZSkuX3N1YnRyYWN0KGkpLl9hZGQodGhpcy5fZ2V0TWFwUGFuZVBvcygpKS5fcm91bmQoKX0sX2xhdExuZ1RvTmV3TGF5ZXJQb2ludDpmdW5jdGlvbih0LGUsaSl7aT10aGlzLl9nZXROZXdQaXhlbE9yaWdpbihpLGUpO3JldHVybiB0aGlzLnByb2plY3QodCxlKS5fc3VidHJhY3QoaSl9LF9sYXRMbmdCb3VuZHNUb05ld0xheWVyQm91bmRzOmZ1bmN0aW9uKHQsZSxpKXtpPXRoaXMuX2dldE5ld1BpeGVsT3JpZ2luKGksZSk7cmV0dXJuIF8oW3RoaXMucHJvamVjdCh0LmdldFNvdXRoV2VzdCgpLGUpLl9zdWJ0cmFjdChpKSx0aGlzLnByb2plY3QodC5nZXROb3J0aFdlc3QoKSxlKS5fc3VidHJhY3QoaSksdGhpcy5wcm9qZWN0KHQuZ2V0U291dGhFYXN0KCksZSkuX3N1YnRyYWN0KGkpLHRoaXMucHJvamVjdCh0LmdldE5vcnRoRWFzdCgpLGUpLl9zdWJ0cmFjdChpKV0pfSxfZ2V0Q2VudGVyTGF5ZXJQb2ludDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHRoaXMuZ2V0U2l6ZSgpLl9kaXZpZGVCeSgyKSl9LF9nZXRDZW50ZXJPZmZzZXQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubGF0TG5nVG9MYXllclBvaW50KHQpLnN1YnRyYWN0KHRoaXMuX2dldENlbnRlckxheWVyUG9pbnQoKSl9LF9saW1pdENlbnRlcjpmdW5jdGlvbih0LGUsaSl7dmFyIG4sbztyZXR1cm4haXx8KG49dGhpcy5wcm9qZWN0KHQsZSksbz10aGlzLmdldFNpemUoKS5kaXZpZGVCeSgyKSxvPW5ldyBmKG4uc3VidHJhY3Qobyksbi5hZGQobykpLG89dGhpcy5fZ2V0Qm91bmRzT2Zmc2V0KG8saSxlKSxNYXRoLmFicyhvLngpPD0xJiZNYXRoLmFicyhvLnkpPD0xKT90OnRoaXMudW5wcm9qZWN0KG4uYWRkKG8pLGUpfSxfbGltaXRPZmZzZXQ6ZnVuY3Rpb24odCxlKXt2YXIgaTtyZXR1cm4gZT8oaT1uZXcgZigoaT10aGlzLmdldFBpeGVsQm91bmRzKCkpLm1pbi5hZGQodCksaS5tYXguYWRkKHQpKSx0LmFkZCh0aGlzLl9nZXRCb3VuZHNPZmZzZXQoaSxlKSkpOnR9LF9nZXRCb3VuZHNPZmZzZXQ6ZnVuY3Rpb24odCxlLGkpe2U9Xyh0aGlzLnByb2plY3QoZS5nZXROb3J0aEVhc3QoKSxpKSx0aGlzLnByb2plY3QoZS5nZXRTb3V0aFdlc3QoKSxpKSksaT1lLm1pbi5zdWJ0cmFjdCh0Lm1pbiksZT1lLm1heC5zdWJ0cmFjdCh0Lm1heCk7cmV0dXJuIG5ldyBwKHRoaXMuX3JlYm91bmQoaS54LC1lLngpLHRoaXMuX3JlYm91bmQoaS55LC1lLnkpKX0sX3JlYm91bmQ6ZnVuY3Rpb24odCxlKXtyZXR1cm4gMDx0K2U/TWF0aC5yb3VuZCh0LWUpLzI6TWF0aC5tYXgoMCxNYXRoLmNlaWwodCkpLU1hdGgubWF4KDAsTWF0aC5mbG9vcihlKSl9LF9saW1pdFpvb206ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5nZXRNaW5ab29tKCksaT10aGlzLmdldE1heFpvb20oKSxuPWIuYW55M2Q/dGhpcy5vcHRpb25zLnpvb21TbmFwOjE7cmV0dXJuIG4mJih0PU1hdGgucm91bmQodC9uKSpuKSxNYXRoLm1heChlLE1hdGgubWluKGksdCkpfSxfb25QYW5UcmFuc2l0aW9uU3RlcDpmdW5jdGlvbigpe3RoaXMuZmlyZShcIm1vdmVcIil9LF9vblBhblRyYW5zaXRpb25FbmQ6ZnVuY3Rpb24oKXt6KHRoaXMuX21hcFBhbmUsXCJsZWFmbGV0LXBhbi1hbmltXCIpLHRoaXMuZmlyZShcIm1vdmVlbmRcIil9LF90cnlBbmltYXRlZFBhbjpmdW5jdGlvbih0LGUpe3Q9dGhpcy5fZ2V0Q2VudGVyT2Zmc2V0KHQpLl90cnVuYygpO3JldHVybiEoITAhPT0oZSYmZS5hbmltYXRlKSYmIXRoaXMuZ2V0U2l6ZSgpLmNvbnRhaW5zKHQpKSYmKHRoaXMucGFuQnkodCxlKSwhMCl9LF9jcmVhdGVBbmltUHJveHk6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9wcm94eT1QKFwiZGl2XCIsXCJsZWFmbGV0LXByb3h5IGxlYWZsZXQtem9vbS1hbmltYXRlZFwiKTt0aGlzLl9wYW5lcy5tYXBQYW5lLmFwcGVuZENoaWxkKHQpLHRoaXMub24oXCJ6b29tYW5pbVwiLGZ1bmN0aW9uKHQpe3ZhciBlPXVlLGk9dGhpcy5fcHJveHkuc3R5bGVbZV07YmUodGhpcy5fcHJveHksdGhpcy5wcm9qZWN0KHQuY2VudGVyLHQuem9vbSksdGhpcy5nZXRab29tU2NhbGUodC56b29tLDEpKSxpPT09dGhpcy5fcHJveHkuc3R5bGVbZV0mJnRoaXMuX2FuaW1hdGluZ1pvb20mJnRoaXMuX29uWm9vbVRyYW5zaXRpb25FbmQoKX0sdGhpcyksdGhpcy5vbihcImxvYWQgbW92ZWVuZFwiLHRoaXMuX2FuaW1Nb3ZlRW5kLHRoaXMpLHRoaXMuX29uKFwidW5sb2FkXCIsdGhpcy5fZGVzdHJveUFuaW1Qcm94eSx0aGlzKX0sX2Rlc3Ryb3lBbmltUHJveHk6ZnVuY3Rpb24oKXtUKHRoaXMuX3Byb3h5KSx0aGlzLm9mZihcImxvYWQgbW92ZWVuZFwiLHRoaXMuX2FuaW1Nb3ZlRW5kLHRoaXMpLGRlbGV0ZSB0aGlzLl9wcm94eX0sX2FuaW1Nb3ZlRW5kOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5nZXRDZW50ZXIoKSxlPXRoaXMuZ2V0Wm9vbSgpO2JlKHRoaXMuX3Byb3h5LHRoaXMucHJvamVjdCh0LGUpLHRoaXMuZ2V0Wm9vbVNjYWxlKGUsMSkpfSxfY2F0Y2hUcmFuc2l0aW9uRW5kOmZ1bmN0aW9uKHQpe3RoaXMuX2FuaW1hdGluZ1pvb20mJjA8PXQucHJvcGVydHlOYW1lLmluZGV4T2YoXCJ0cmFuc2Zvcm1cIikmJnRoaXMuX29uWm9vbVRyYW5zaXRpb25FbmQoKX0sX25vdGhpbmdUb0FuaW1hdGU6ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy5fY29udGFpbmVyLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJsZWFmbGV0LXpvb20tYW5pbWF0ZWRcIikubGVuZ3RofSxfdHJ5QW5pbWF0ZWRab29tOmZ1bmN0aW9uKHQsZSxpKXtpZighdGhpcy5fYW5pbWF0aW5nWm9vbSl7aWYoaT1pfHx7fSwhdGhpcy5fem9vbUFuaW1hdGVkfHwhMT09PWkuYW5pbWF0ZXx8dGhpcy5fbm90aGluZ1RvQW5pbWF0ZSgpfHxNYXRoLmFicyhlLXRoaXMuX3pvb20pPnRoaXMub3B0aW9ucy56b29tQW5pbWF0aW9uVGhyZXNob2xkKXJldHVybiExO3ZhciBuPXRoaXMuZ2V0Wm9vbVNjYWxlKGUpLG49dGhpcy5fZ2V0Q2VudGVyT2Zmc2V0KHQpLl9kaXZpZGVCeSgxLTEvbik7aWYoITAhPT1pLmFuaW1hdGUmJiF0aGlzLmdldFNpemUoKS5jb250YWlucyhuKSlyZXR1cm4hMTt4KGZ1bmN0aW9uKCl7dGhpcy5fbW92ZVN0YXJ0KCEwLCExKS5fYW5pbWF0ZVpvb20odCxlLCEwKX0sdGhpcyl9cmV0dXJuITB9LF9hbmltYXRlWm9vbTpmdW5jdGlvbih0LGUsaSxuKXt0aGlzLl9tYXBQYW5lJiYoaSYmKHRoaXMuX2FuaW1hdGluZ1pvb209ITAsdGhpcy5fYW5pbWF0ZVRvQ2VudGVyPXQsdGhpcy5fYW5pbWF0ZVRvWm9vbT1lLE0odGhpcy5fbWFwUGFuZSxcImxlYWZsZXQtem9vbS1hbmltXCIpKSx0aGlzLmZpcmUoXCJ6b29tYW5pbVwiLHtjZW50ZXI6dCx6b29tOmUsbm9VcGRhdGU6bn0pLHRoaXMuX3RlbXBGaXJlWm9vbUV2ZW50fHwodGhpcy5fdGVtcEZpcmVab29tRXZlbnQ9dGhpcy5fem9vbSE9PXRoaXMuX2FuaW1hdGVUb1pvb20pLHRoaXMuX21vdmUodGhpcy5fYW5pbWF0ZVRvQ2VudGVyLHRoaXMuX2FuaW1hdGVUb1pvb20sdm9pZCAwLCEwKSxzZXRUaW1lb3V0KGEodGhpcy5fb25ab29tVHJhbnNpdGlvbkVuZCx0aGlzKSwyNTApKX0sX29uWm9vbVRyYW5zaXRpb25FbmQ6ZnVuY3Rpb24oKXt0aGlzLl9hbmltYXRpbmdab29tJiYodGhpcy5fbWFwUGFuZSYmeih0aGlzLl9tYXBQYW5lLFwibGVhZmxldC16b29tLWFuaW1cIiksdGhpcy5fYW5pbWF0aW5nWm9vbT0hMSx0aGlzLl9tb3ZlKHRoaXMuX2FuaW1hdGVUb0NlbnRlcix0aGlzLl9hbmltYXRlVG9ab29tLHZvaWQgMCwhMCksdGhpcy5fdGVtcEZpcmVab29tRXZlbnQmJnRoaXMuZmlyZShcInpvb21cIiksZGVsZXRlIHRoaXMuX3RlbXBGaXJlWm9vbUV2ZW50LHRoaXMuZmlyZShcIm1vdmVcIiksdGhpcy5fbW92ZUVuZCghMCkpfX0pO2Z1bmN0aW9uIFVlKHQpe3JldHVybiBuZXcgQih0KX12YXIgVmUsQj1ldC5leHRlbmQoe29wdGlvbnM6e3Bvc2l0aW9uOlwidG9wcmlnaHRcIn0saW5pdGlhbGl6ZTpmdW5jdGlvbih0KXtjKHRoaXMsdCl9LGdldFBvc2l0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub3B0aW9ucy5wb3NpdGlvbn0sc2V0UG9zaXRpb246ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5fbWFwO3JldHVybiBlJiZlLnJlbW92ZUNvbnRyb2wodGhpcyksdGhpcy5vcHRpb25zLnBvc2l0aW9uPXQsZSYmZS5hZGRDb250cm9sKHRoaXMpLHRoaXN9LGdldENvbnRhaW5lcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9jb250YWluZXJ9LGFkZFRvOmZ1bmN0aW9uKHQpe3RoaXMucmVtb3ZlKCksdGhpcy5fbWFwPXQ7dmFyIGU9dGhpcy5fY29udGFpbmVyPXRoaXMub25BZGQodCksaT10aGlzLmdldFBvc2l0aW9uKCksdD10Ll9jb250cm9sQ29ybmVyc1tpXTtyZXR1cm4gTShlLFwibGVhZmxldC1jb250cm9sXCIpLC0xIT09aS5pbmRleE9mKFwiYm90dG9tXCIpP3QuaW5zZXJ0QmVmb3JlKGUsdC5maXJzdENoaWxkKTp0LmFwcGVuZENoaWxkKGUpLHRoaXMuX21hcC5vbihcInVubG9hZFwiLHRoaXMucmVtb3ZlLHRoaXMpLHRoaXN9LHJlbW92ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9tYXAmJihUKHRoaXMuX2NvbnRhaW5lciksdGhpcy5vblJlbW92ZSYmdGhpcy5vblJlbW92ZSh0aGlzLl9tYXApLHRoaXMuX21hcC5vZmYoXCJ1bmxvYWRcIix0aGlzLnJlbW92ZSx0aGlzKSx0aGlzLl9tYXA9bnVsbCksdGhpc30sX3JlZm9jdXNPbk1hcDpmdW5jdGlvbih0KXt0aGlzLl9tYXAmJnQmJjA8dC5zY3JlZW5YJiYwPHQuc2NyZWVuWSYmdGhpcy5fbWFwLmdldENvbnRhaW5lcigpLmZvY3VzKCl9fSkscWU9KEEuaW5jbHVkZSh7YWRkQ29udHJvbDpmdW5jdGlvbih0KXtyZXR1cm4gdC5hZGRUbyh0aGlzKSx0aGlzfSxyZW1vdmVDb250cm9sOmZ1bmN0aW9uKHQpe3JldHVybiB0LnJlbW92ZSgpLHRoaXN9LF9pbml0Q29udHJvbFBvczpmdW5jdGlvbigpe3ZhciBpPXRoaXMuX2NvbnRyb2xDb3JuZXJzPXt9LG49XCJsZWFmbGV0LVwiLG89dGhpcy5fY29udHJvbENvbnRhaW5lcj1QKFwiZGl2XCIsbitcImNvbnRyb2wtY29udGFpbmVyXCIsdGhpcy5fY29udGFpbmVyKTtmdW5jdGlvbiB0KHQsZSl7aVt0K2VdPVAoXCJkaXZcIixuK3QrXCIgXCIrbitlLG8pfXQoXCJ0b3BcIixcImxlZnRcIiksdChcInRvcFwiLFwicmlnaHRcIiksdChcImJvdHRvbVwiLFwibGVmdFwiKSx0KFwiYm90dG9tXCIsXCJyaWdodFwiKX0sX2NsZWFyQ29udHJvbFBvczpmdW5jdGlvbigpe2Zvcih2YXIgdCBpbiB0aGlzLl9jb250cm9sQ29ybmVycylUKHRoaXMuX2NvbnRyb2xDb3JuZXJzW3RdKTtUKHRoaXMuX2NvbnRyb2xDb250YWluZXIpLGRlbGV0ZSB0aGlzLl9jb250cm9sQ29ybmVycyxkZWxldGUgdGhpcy5fY29udHJvbENvbnRhaW5lcn19KSxCLmV4dGVuZCh7b3B0aW9uczp7Y29sbGFwc2VkOiEwLHBvc2l0aW9uOlwidG9wcmlnaHRcIixhdXRvWkluZGV4OiEwLGhpZGVTaW5nbGVCYXNlOiExLHNvcnRMYXllcnM6ITEsc29ydEZ1bmN0aW9uOmZ1bmN0aW9uKHQsZSxpLG4pe3JldHVybiBpPG4/LTE6bjxpPzE6MH19LGluaXRpYWxpemU6ZnVuY3Rpb24odCxlLGkpe2Zvcih2YXIgbiBpbiBjKHRoaXMsaSksdGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzPVtdLHRoaXMuX2xheWVycz1bXSx0aGlzLl9sYXN0WkluZGV4PTAsdGhpcy5faGFuZGxpbmdDbGljaz0hMSx0KXRoaXMuX2FkZExheWVyKHRbbl0sbik7Zm9yKG4gaW4gZSl0aGlzLl9hZGRMYXllcihlW25dLG4sITApfSxvbkFkZDpmdW5jdGlvbih0KXt0aGlzLl9pbml0TGF5b3V0KCksdGhpcy5fdXBkYXRlKCksKHRoaXMuX21hcD10KS5vbihcInpvb21lbmRcIix0aGlzLl9jaGVja0Rpc2FibGVkTGF5ZXJzLHRoaXMpO2Zvcih2YXIgZT0wO2U8dGhpcy5fbGF5ZXJzLmxlbmd0aDtlKyspdGhpcy5fbGF5ZXJzW2VdLmxheWVyLm9uKFwiYWRkIHJlbW92ZVwiLHRoaXMuX29uTGF5ZXJDaGFuZ2UsdGhpcyk7cmV0dXJuIHRoaXMuX2NvbnRhaW5lcn0sYWRkVG86ZnVuY3Rpb24odCl7cmV0dXJuIEIucHJvdG90eXBlLmFkZFRvLmNhbGwodGhpcyx0KSx0aGlzLl9leHBhbmRJZk5vdENvbGxhcHNlZCgpfSxvblJlbW92ZTpmdW5jdGlvbigpe3RoaXMuX21hcC5vZmYoXCJ6b29tZW5kXCIsdGhpcy5fY2hlY2tEaXNhYmxlZExheWVycyx0aGlzKTtmb3IodmFyIHQ9MDt0PHRoaXMuX2xheWVycy5sZW5ndGg7dCsrKXRoaXMuX2xheWVyc1t0XS5sYXllci5vZmYoXCJhZGQgcmVtb3ZlXCIsdGhpcy5fb25MYXllckNoYW5nZSx0aGlzKX0sYWRkQmFzZUxheWVyOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuX2FkZExheWVyKHQsZSksdGhpcy5fbWFwP3RoaXMuX3VwZGF0ZSgpOnRoaXN9LGFkZE92ZXJsYXk6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5fYWRkTGF5ZXIodCxlLCEwKSx0aGlzLl9tYXA/dGhpcy5fdXBkYXRlKCk6dGhpc30scmVtb3ZlTGF5ZXI6ZnVuY3Rpb24odCl7dC5vZmYoXCJhZGQgcmVtb3ZlXCIsdGhpcy5fb25MYXllckNoYW5nZSx0aGlzKTt0PXRoaXMuX2dldExheWVyKGgodCkpO3JldHVybiB0JiZ0aGlzLl9sYXllcnMuc3BsaWNlKHRoaXMuX2xheWVycy5pbmRleE9mKHQpLDEpLHRoaXMuX21hcD90aGlzLl91cGRhdGUoKTp0aGlzfSxleHBhbmQ6ZnVuY3Rpb24oKXtNKHRoaXMuX2NvbnRhaW5lcixcImxlYWZsZXQtY29udHJvbC1sYXllcnMtZXhwYW5kZWRcIiksdGhpcy5fc2VjdGlvbi5zdHlsZS5oZWlnaHQ9bnVsbDt2YXIgdD10aGlzLl9tYXAuZ2V0U2l6ZSgpLnktKHRoaXMuX2NvbnRhaW5lci5vZmZzZXRUb3ArNTApO3JldHVybiB0PHRoaXMuX3NlY3Rpb24uY2xpZW50SGVpZ2h0PyhNKHRoaXMuX3NlY3Rpb24sXCJsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNjcm9sbGJhclwiKSx0aGlzLl9zZWN0aW9uLnN0eWxlLmhlaWdodD10K1wicHhcIik6eih0aGlzLl9zZWN0aW9uLFwibGVhZmxldC1jb250cm9sLWxheWVycy1zY3JvbGxiYXJcIiksdGhpcy5fY2hlY2tEaXNhYmxlZExheWVycygpLHRoaXN9LGNvbGxhcHNlOmZ1bmN0aW9uKCl7cmV0dXJuIHoodGhpcy5fY29udGFpbmVyLFwibGVhZmxldC1jb250cm9sLWxheWVycy1leHBhbmRlZFwiKSx0aGlzfSxfaW5pdExheW91dDpmdW5jdGlvbigpe3ZhciB0PVwibGVhZmxldC1jb250cm9sLWxheWVyc1wiLGU9dGhpcy5fY29udGFpbmVyPVAoXCJkaXZcIix0KSxpPXRoaXMub3B0aW9ucy5jb2xsYXBzZWQsbj0oZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhhc3BvcHVwXCIsITApLEllKGUpLEJlKGUpLHRoaXMuX3NlY3Rpb249UChcInNlY3Rpb25cIix0K1wiLWxpc3RcIikpLG89KGkmJih0aGlzLl9tYXAub24oXCJjbGlja1wiLHRoaXMuY29sbGFwc2UsdGhpcyksUyhlLHttb3VzZWVudGVyOnRoaXMuX2V4cGFuZFNhZmVseSxtb3VzZWxlYXZlOnRoaXMuY29sbGFwc2V9LHRoaXMpKSx0aGlzLl9sYXllcnNMaW5rPVAoXCJhXCIsdCtcIi10b2dnbGVcIixlKSk7by5ocmVmPVwiI1wiLG8udGl0bGU9XCJMYXllcnNcIixvLnNldEF0dHJpYnV0ZShcInJvbGVcIixcImJ1dHRvblwiKSxTKG8se2tleWRvd246ZnVuY3Rpb24odCl7MTM9PT10LmtleUNvZGUmJnRoaXMuX2V4cGFuZFNhZmVseSgpfSxjbGljazpmdW5jdGlvbih0KXtPKHQpLHRoaXMuX2V4cGFuZFNhZmVseSgpfX0sdGhpcyksaXx8dGhpcy5leHBhbmQoKSx0aGlzLl9iYXNlTGF5ZXJzTGlzdD1QKFwiZGl2XCIsdCtcIi1iYXNlXCIsbiksdGhpcy5fc2VwYXJhdG9yPVAoXCJkaXZcIix0K1wiLXNlcGFyYXRvclwiLG4pLHRoaXMuX292ZXJsYXlzTGlzdD1QKFwiZGl2XCIsdCtcIi1vdmVybGF5c1wiLG4pLGUuYXBwZW5kQ2hpbGQobil9LF9nZXRMYXllcjpmdW5jdGlvbih0KXtmb3IodmFyIGU9MDtlPHRoaXMuX2xheWVycy5sZW5ndGg7ZSsrKWlmKHRoaXMuX2xheWVyc1tlXSYmaCh0aGlzLl9sYXllcnNbZV0ubGF5ZXIpPT09dClyZXR1cm4gdGhpcy5fbGF5ZXJzW2VdfSxfYWRkTGF5ZXI6ZnVuY3Rpb24odCxlLGkpe3RoaXMuX21hcCYmdC5vbihcImFkZCByZW1vdmVcIix0aGlzLl9vbkxheWVyQ2hhbmdlLHRoaXMpLHRoaXMuX2xheWVycy5wdXNoKHtsYXllcjp0LG5hbWU6ZSxvdmVybGF5Oml9KSx0aGlzLm9wdGlvbnMuc29ydExheWVycyYmdGhpcy5fbGF5ZXJzLnNvcnQoYShmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLm9wdGlvbnMuc29ydEZ1bmN0aW9uKHQubGF5ZXIsZS5sYXllcix0Lm5hbWUsZS5uYW1lKX0sdGhpcykpLHRoaXMub3B0aW9ucy5hdXRvWkluZGV4JiZ0LnNldFpJbmRleCYmKHRoaXMuX2xhc3RaSW5kZXgrKyx0LnNldFpJbmRleCh0aGlzLl9sYXN0WkluZGV4KSksdGhpcy5fZXhwYW5kSWZOb3RDb2xsYXBzZWQoKX0sX3VwZGF0ZTpmdW5jdGlvbigpe2lmKHRoaXMuX2NvbnRhaW5lcil7bWUodGhpcy5fYmFzZUxheWVyc0xpc3QpLG1lKHRoaXMuX292ZXJsYXlzTGlzdCksdGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzPVtdO2Zvcih2YXIgdCxlLGksbj0wLG89MDtvPHRoaXMuX2xheWVycy5sZW5ndGg7bysrKWk9dGhpcy5fbGF5ZXJzW29dLHRoaXMuX2FkZEl0ZW0oaSksZT1lfHxpLm92ZXJsYXksdD10fHwhaS5vdmVybGF5LG4rPWkub3ZlcmxheT8wOjE7dGhpcy5vcHRpb25zLmhpZGVTaW5nbGVCYXNlJiYodGhpcy5fYmFzZUxheWVyc0xpc3Quc3R5bGUuZGlzcGxheT0odD10JiYxPG4pP1wiXCI6XCJub25lXCIpLHRoaXMuX3NlcGFyYXRvci5zdHlsZS5kaXNwbGF5PWUmJnQ/XCJcIjpcIm5vbmVcIn1yZXR1cm4gdGhpc30sX29uTGF5ZXJDaGFuZ2U6ZnVuY3Rpb24odCl7dGhpcy5faGFuZGxpbmdDbGlja3x8dGhpcy5fdXBkYXRlKCk7dmFyIGU9dGhpcy5fZ2V0TGF5ZXIoaCh0LnRhcmdldCkpLHQ9ZS5vdmVybGF5P1wiYWRkXCI9PT10LnR5cGU/XCJvdmVybGF5YWRkXCI6XCJvdmVybGF5cmVtb3ZlXCI6XCJhZGRcIj09PXQudHlwZT9cImJhc2VsYXllcmNoYW5nZVwiOm51bGw7dCYmdGhpcy5fbWFwLmZpcmUodCxlKX0sX2NyZWF0ZVJhZGlvRWxlbWVudDpmdW5jdGlvbih0LGUpe3Q9JzxpbnB1dCB0eXBlPVwicmFkaW9cIiBjbGFzcz1cImxlYWZsZXQtY29udHJvbC1sYXllcnMtc2VsZWN0b3JcIiBuYW1lPVwiJyt0KydcIicrKGU/JyBjaGVja2VkPVwiY2hlY2tlZFwiJzpcIlwiKStcIi8+XCIsZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO3JldHVybiBlLmlubmVySFRNTD10LGUuZmlyc3RDaGlsZH0sX2FkZEl0ZW06ZnVuY3Rpb24odCl7dmFyIGUsaT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGFiZWxcIiksbj10aGlzLl9tYXAuaGFzTGF5ZXIodC5sYXllciksbj0odC5vdmVybGF5PygoZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIikpLnR5cGU9XCJjaGVja2JveFwiLGUuY2xhc3NOYW1lPVwibGVhZmxldC1jb250cm9sLWxheWVycy1zZWxlY3RvclwiLGUuZGVmYXVsdENoZWNrZWQ9bik6ZT10aGlzLl9jcmVhdGVSYWRpb0VsZW1lbnQoXCJsZWFmbGV0LWJhc2UtbGF5ZXJzX1wiK2godGhpcyksbiksdGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzLnB1c2goZSksZS5sYXllcklkPWgodC5sYXllciksUyhlLFwiY2xpY2tcIix0aGlzLl9vbklucHV0Q2xpY2ssdGhpcyksZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIikpLG89KG4uaW5uZXJIVE1MPVwiIFwiK3QubmFtZSxkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKSk7cmV0dXJuIGkuYXBwZW5kQ2hpbGQobyksby5hcHBlbmRDaGlsZChlKSxvLmFwcGVuZENoaWxkKG4pLCh0Lm92ZXJsYXk/dGhpcy5fb3ZlcmxheXNMaXN0OnRoaXMuX2Jhc2VMYXllcnNMaXN0KS5hcHBlbmRDaGlsZChpKSx0aGlzLl9jaGVja0Rpc2FibGVkTGF5ZXJzKCksaX0sX29uSW5wdXRDbGljazpmdW5jdGlvbigpe3ZhciB0LGUsaT10aGlzLl9sYXllckNvbnRyb2xJbnB1dHMsbj1bXSxvPVtdO3RoaXMuX2hhbmRsaW5nQ2xpY2s9ITA7Zm9yKHZhciBzPWkubGVuZ3RoLTE7MDw9cztzLS0pdD1pW3NdLGU9dGhpcy5fZ2V0TGF5ZXIodC5sYXllcklkKS5sYXllcix0LmNoZWNrZWQ/bi5wdXNoKGUpOnQuY2hlY2tlZHx8by5wdXNoKGUpO2ZvcihzPTA7czxvLmxlbmd0aDtzKyspdGhpcy5fbWFwLmhhc0xheWVyKG9bc10pJiZ0aGlzLl9tYXAucmVtb3ZlTGF5ZXIob1tzXSk7Zm9yKHM9MDtzPG4ubGVuZ3RoO3MrKyl0aGlzLl9tYXAuaGFzTGF5ZXIobltzXSl8fHRoaXMuX21hcC5hZGRMYXllcihuW3NdKTt0aGlzLl9oYW5kbGluZ0NsaWNrPSExLHRoaXMuX3JlZm9jdXNPbk1hcCgpfSxfY2hlY2tEaXNhYmxlZExheWVyczpmdW5jdGlvbigpe2Zvcih2YXIgdCxlLGk9dGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzLG49dGhpcy5fbWFwLmdldFpvb20oKSxvPWkubGVuZ3RoLTE7MDw9bztvLS0pdD1pW29dLGU9dGhpcy5fZ2V0TGF5ZXIodC5sYXllcklkKS5sYXllcix0LmRpc2FibGVkPXZvaWQgMCE9PWUub3B0aW9ucy5taW5ab29tJiZuPGUub3B0aW9ucy5taW5ab29tfHx2b2lkIDAhPT1lLm9wdGlvbnMubWF4Wm9vbSYmbj5lLm9wdGlvbnMubWF4Wm9vbX0sX2V4cGFuZElmTm90Q29sbGFwc2VkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX21hcCYmIXRoaXMub3B0aW9ucy5jb2xsYXBzZWQmJnRoaXMuZXhwYW5kKCksdGhpc30sX2V4cGFuZFNhZmVseTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX3NlY3Rpb247Uyh0LFwiY2xpY2tcIixPKSx0aGlzLmV4cGFuZCgpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtrKHQsXCJjbGlja1wiLE8pfSl9fSkpLEdlPUIuZXh0ZW5kKHtvcHRpb25zOntwb3NpdGlvbjpcInRvcGxlZnRcIix6b29tSW5UZXh0Oic8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4rPC9zcGFuPicsem9vbUluVGl0bGU6XCJab29tIGluXCIsem9vbU91dFRleHQ6JzxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiYjeDIyMTI7PC9zcGFuPicsem9vbU91dFRpdGxlOlwiWm9vbSBvdXRcIn0sb25BZGQ6ZnVuY3Rpb24odCl7dmFyIGU9XCJsZWFmbGV0LWNvbnRyb2wtem9vbVwiLGk9UChcImRpdlwiLGUrXCIgbGVhZmxldC1iYXJcIiksbj10aGlzLm9wdGlvbnM7cmV0dXJuIHRoaXMuX3pvb21JbkJ1dHRvbj10aGlzLl9jcmVhdGVCdXR0b24obi56b29tSW5UZXh0LG4uem9vbUluVGl0bGUsZStcIi1pblwiLGksdGhpcy5fem9vbUluKSx0aGlzLl96b29tT3V0QnV0dG9uPXRoaXMuX2NyZWF0ZUJ1dHRvbihuLnpvb21PdXRUZXh0LG4uem9vbU91dFRpdGxlLGUrXCItb3V0XCIsaSx0aGlzLl96b29tT3V0KSx0aGlzLl91cGRhdGVEaXNhYmxlZCgpLHQub24oXCJ6b29tZW5kIHpvb21sZXZlbHNjaGFuZ2VcIix0aGlzLl91cGRhdGVEaXNhYmxlZCx0aGlzKSxpfSxvblJlbW92ZTpmdW5jdGlvbih0KXt0Lm9mZihcInpvb21lbmQgem9vbWxldmVsc2NoYW5nZVwiLHRoaXMuX3VwZGF0ZURpc2FibGVkLHRoaXMpfSxkaXNhYmxlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2Rpc2FibGVkPSEwLHRoaXMuX3VwZGF0ZURpc2FibGVkKCksdGhpc30sZW5hYmxlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2Rpc2FibGVkPSExLHRoaXMuX3VwZGF0ZURpc2FibGVkKCksdGhpc30sX3pvb21JbjpmdW5jdGlvbih0KXshdGhpcy5fZGlzYWJsZWQmJnRoaXMuX21hcC5fem9vbTx0aGlzLl9tYXAuZ2V0TWF4Wm9vbSgpJiZ0aGlzLl9tYXAuem9vbUluKHRoaXMuX21hcC5vcHRpb25zLnpvb21EZWx0YSoodC5zaGlmdEtleT8zOjEpKX0sX3pvb21PdXQ6ZnVuY3Rpb24odCl7IXRoaXMuX2Rpc2FibGVkJiZ0aGlzLl9tYXAuX3pvb20+dGhpcy5fbWFwLmdldE1pblpvb20oKSYmdGhpcy5fbWFwLnpvb21PdXQodGhpcy5fbWFwLm9wdGlvbnMuem9vbURlbHRhKih0LnNoaWZ0S2V5PzM6MSkpfSxfY3JlYXRlQnV0dG9uOmZ1bmN0aW9uKHQsZSxpLG4sbyl7aT1QKFwiYVwiLGksbik7cmV0dXJuIGkuaW5uZXJIVE1MPXQsaS5ocmVmPVwiI1wiLGkudGl0bGU9ZSxpLnNldEF0dHJpYnV0ZShcInJvbGVcIixcImJ1dHRvblwiKSxpLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIixlKSxJZShpKSxTKGksXCJjbGlja1wiLFJlKSxTKGksXCJjbGlja1wiLG8sdGhpcyksUyhpLFwiY2xpY2tcIix0aGlzLl9yZWZvY3VzT25NYXAsdGhpcyksaX0sX3VwZGF0ZURpc2FibGVkOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fbWFwLGU9XCJsZWFmbGV0LWRpc2FibGVkXCI7eih0aGlzLl96b29tSW5CdXR0b24sZSkseih0aGlzLl96b29tT3V0QnV0dG9uLGUpLHRoaXMuX3pvb21JbkJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWRpc2FibGVkXCIsXCJmYWxzZVwiKSx0aGlzLl96b29tT3V0QnV0dG9uLnNldEF0dHJpYnV0ZShcImFyaWEtZGlzYWJsZWRcIixcImZhbHNlXCIpLCF0aGlzLl9kaXNhYmxlZCYmdC5fem9vbSE9PXQuZ2V0TWluWm9vbSgpfHwoTSh0aGlzLl96b29tT3V0QnV0dG9uLGUpLHRoaXMuX3pvb21PdXRCdXR0b24uc2V0QXR0cmlidXRlKFwiYXJpYS1kaXNhYmxlZFwiLFwidHJ1ZVwiKSksIXRoaXMuX2Rpc2FibGVkJiZ0Ll96b29tIT09dC5nZXRNYXhab29tKCl8fChNKHRoaXMuX3pvb21JbkJ1dHRvbixlKSx0aGlzLl96b29tSW5CdXR0b24uc2V0QXR0cmlidXRlKFwiYXJpYS1kaXNhYmxlZFwiLFwidHJ1ZVwiKSl9fSksS2U9KEEubWVyZ2VPcHRpb25zKHt6b29tQ29udHJvbDohMH0pLEEuYWRkSW5pdEhvb2soZnVuY3Rpb24oKXt0aGlzLm9wdGlvbnMuem9vbUNvbnRyb2wmJih0aGlzLnpvb21Db250cm9sPW5ldyBHZSx0aGlzLmFkZENvbnRyb2wodGhpcy56b29tQ29udHJvbCkpfSksQi5leHRlbmQoe29wdGlvbnM6e3Bvc2l0aW9uOlwiYm90dG9tbGVmdFwiLG1heFdpZHRoOjEwMCxtZXRyaWM6ITAsaW1wZXJpYWw6ITB9LG9uQWRkOmZ1bmN0aW9uKHQpe3ZhciBlPVwibGVhZmxldC1jb250cm9sLXNjYWxlXCIsaT1QKFwiZGl2XCIsZSksbj10aGlzLm9wdGlvbnM7cmV0dXJuIHRoaXMuX2FkZFNjYWxlcyhuLGUrXCItbGluZVwiLGkpLHQub24obi51cGRhdGVXaGVuSWRsZT9cIm1vdmVlbmRcIjpcIm1vdmVcIix0aGlzLl91cGRhdGUsdGhpcyksdC53aGVuUmVhZHkodGhpcy5fdXBkYXRlLHRoaXMpLGl9LG9uUmVtb3ZlOmZ1bmN0aW9uKHQpe3Qub2ZmKHRoaXMub3B0aW9ucy51cGRhdGVXaGVuSWRsZT9cIm1vdmVlbmRcIjpcIm1vdmVcIix0aGlzLl91cGRhdGUsdGhpcyl9LF9hZGRTY2FsZXM6ZnVuY3Rpb24odCxlLGkpe3QubWV0cmljJiYodGhpcy5fbVNjYWxlPVAoXCJkaXZcIixlLGkpKSx0LmltcGVyaWFsJiYodGhpcy5faVNjYWxlPVAoXCJkaXZcIixlLGkpKX0sX3VwZGF0ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX21hcCxlPXQuZ2V0U2l6ZSgpLnkvMix0PXQuZGlzdGFuY2UodC5jb250YWluZXJQb2ludFRvTGF0TG5nKFswLGVdKSx0LmNvbnRhaW5lclBvaW50VG9MYXRMbmcoW3RoaXMub3B0aW9ucy5tYXhXaWR0aCxlXSkpO3RoaXMuX3VwZGF0ZVNjYWxlcyh0KX0sX3VwZGF0ZVNjYWxlczpmdW5jdGlvbih0KXt0aGlzLm9wdGlvbnMubWV0cmljJiZ0JiZ0aGlzLl91cGRhdGVNZXRyaWModCksdGhpcy5vcHRpb25zLmltcGVyaWFsJiZ0JiZ0aGlzLl91cGRhdGVJbXBlcmlhbCh0KX0sX3VwZGF0ZU1ldHJpYzpmdW5jdGlvbih0KXt2YXIgZT10aGlzLl9nZXRSb3VuZE51bSh0KTt0aGlzLl91cGRhdGVTY2FsZSh0aGlzLl9tU2NhbGUsZTwxZTM/ZStcIiBtXCI6ZS8xZTMrXCIga21cIixlL3QpfSxfdXBkYXRlSW1wZXJpYWw6ZnVuY3Rpb24odCl7dmFyIGUsaSx0PTMuMjgwODM5OSp0OzUyODA8dD8oaT10aGlzLl9nZXRSb3VuZE51bShlPXQvNTI4MCksdGhpcy5fdXBkYXRlU2NhbGUodGhpcy5faVNjYWxlLGkrXCIgbWlcIixpL2UpKTooaT10aGlzLl9nZXRSb3VuZE51bSh0KSx0aGlzLl91cGRhdGVTY2FsZSh0aGlzLl9pU2NhbGUsaStcIiBmdFwiLGkvdCkpfSxfdXBkYXRlU2NhbGU6ZnVuY3Rpb24odCxlLGkpe3Quc3R5bGUud2lkdGg9TWF0aC5yb3VuZCh0aGlzLm9wdGlvbnMubWF4V2lkdGgqaSkrXCJweFwiLHQuaW5uZXJIVE1MPWV9LF9nZXRSb3VuZE51bTpmdW5jdGlvbih0KXt2YXIgZT1NYXRoLnBvdygxMCwoTWF0aC5mbG9vcih0KStcIlwiKS5sZW5ndGgtMSksdD10L2U7cmV0dXJuIGUqKHQ9MTA8PXQ/MTA6NTw9dD81OjM8PXQ/MzoyPD10PzI6MSl9fSkpLFllPUIuZXh0ZW5kKHtvcHRpb25zOntwb3NpdGlvbjpcImJvdHRvbXJpZ2h0XCIscHJlZml4Oic8YSBocmVmPVwiaHR0cHM6Ly9sZWFmbGV0anMuY29tXCIgdGl0bGU9XCJBIEphdmFTY3JpcHQgbGlicmFyeSBmb3IgaW50ZXJhY3RpdmUgbWFwc1wiPicrKGIuaW5saW5lU3ZnPyc8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjEyXCIgaGVpZ2h0PVwiOFwiIHZpZXdCb3g9XCIwIDAgMTIgOFwiIGNsYXNzPVwibGVhZmxldC1hdHRyaWJ1dGlvbi1mbGFnXCI+PHBhdGggZmlsbD1cIiM0QzdCRTFcIiBkPVwiTTAgMGgxMnY0SDB6XCIvPjxwYXRoIGZpbGw9XCIjRkZENTAwXCIgZD1cIk0wIDRoMTJ2M0gwelwiLz48cGF0aCBmaWxsPVwiI0UwQkMwMFwiIGQ9XCJNMCA3aDEydjFIMHpcIi8+PC9zdmc+ICc6XCJcIikrXCJMZWFmbGV0PC9hPlwifSxpbml0aWFsaXplOmZ1bmN0aW9uKHQpe2ModGhpcyx0KSx0aGlzLl9hdHRyaWJ1dGlvbnM9e319LG9uQWRkOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZSBpbih0LmF0dHJpYnV0aW9uQ29udHJvbD10aGlzKS5fY29udGFpbmVyPVAoXCJkaXZcIixcImxlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvblwiKSxJZSh0aGlzLl9jb250YWluZXIpLHQuX2xheWVycyl0Ll9sYXllcnNbZV0uZ2V0QXR0cmlidXRpb24mJnRoaXMuYWRkQXR0cmlidXRpb24odC5fbGF5ZXJzW2VdLmdldEF0dHJpYnV0aW9uKCkpO3JldHVybiB0aGlzLl91cGRhdGUoKSx0Lm9uKFwibGF5ZXJhZGRcIix0aGlzLl9hZGRBdHRyaWJ1dGlvbix0aGlzKSx0aGlzLl9jb250YWluZXJ9LG9uUmVtb3ZlOmZ1bmN0aW9uKHQpe3Qub2ZmKFwibGF5ZXJhZGRcIix0aGlzLl9hZGRBdHRyaWJ1dGlvbix0aGlzKX0sX2FkZEF0dHJpYnV0aW9uOmZ1bmN0aW9uKHQpe3QubGF5ZXIuZ2V0QXR0cmlidXRpb24mJih0aGlzLmFkZEF0dHJpYnV0aW9uKHQubGF5ZXIuZ2V0QXR0cmlidXRpb24oKSksdC5sYXllci5vbmNlKFwicmVtb3ZlXCIsZnVuY3Rpb24oKXt0aGlzLnJlbW92ZUF0dHJpYnV0aW9uKHQubGF5ZXIuZ2V0QXR0cmlidXRpb24oKSl9LHRoaXMpKX0sc2V0UHJlZml4OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm9wdGlvbnMucHJlZml4PXQsdGhpcy5fdXBkYXRlKCksdGhpc30sYWRkQXR0cmlidXRpb246ZnVuY3Rpb24odCl7cmV0dXJuIHQmJih0aGlzLl9hdHRyaWJ1dGlvbnNbdF18fCh0aGlzLl9hdHRyaWJ1dGlvbnNbdF09MCksdGhpcy5fYXR0cmlidXRpb25zW3RdKyssdGhpcy5fdXBkYXRlKCkpLHRoaXN9LHJlbW92ZUF0dHJpYnV0aW9uOmZ1bmN0aW9uKHQpe3JldHVybiB0JiZ0aGlzLl9hdHRyaWJ1dGlvbnNbdF0mJih0aGlzLl9hdHRyaWJ1dGlvbnNbdF0tLSx0aGlzLl91cGRhdGUoKSksdGhpc30sX3VwZGF0ZTpmdW5jdGlvbigpe2lmKHRoaXMuX21hcCl7dmFyIHQsZT1bXTtmb3IodCBpbiB0aGlzLl9hdHRyaWJ1dGlvbnMpdGhpcy5fYXR0cmlidXRpb25zW3RdJiZlLnB1c2godCk7dmFyIGk9W107dGhpcy5vcHRpb25zLnByZWZpeCYmaS5wdXNoKHRoaXMub3B0aW9ucy5wcmVmaXgpLGUubGVuZ3RoJiZpLnB1c2goZS5qb2luKFwiLCBcIikpLHRoaXMuX2NvbnRhaW5lci5pbm5lckhUTUw9aS5qb2luKCcgPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+fDwvc3Bhbj4gJyl9fX0pLG49KEEubWVyZ2VPcHRpb25zKHthdHRyaWJ1dGlvbkNvbnRyb2w6ITB9KSxBLmFkZEluaXRIb29rKGZ1bmN0aW9uKCl7dGhpcy5vcHRpb25zLmF0dHJpYnV0aW9uQ29udHJvbCYmKG5ldyBZZSkuYWRkVG8odGhpcyl9KSxCLkxheWVycz1xZSxCLlpvb209R2UsQi5TY2FsZT1LZSxCLkF0dHJpYnV0aW9uPVllLFVlLmxheWVycz1mdW5jdGlvbih0LGUsaSl7cmV0dXJuIG5ldyBxZSh0LGUsaSl9LFVlLnpvb209ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBHZSh0KX0sVWUuc2NhbGU9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBLZSh0KX0sVWUuYXR0cmlidXRpb249ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBZZSh0KX0sZXQuZXh0ZW5kKHtpbml0aWFsaXplOmZ1bmN0aW9uKHQpe3RoaXMuX21hcD10fSxlbmFibGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZW5hYmxlZHx8KHRoaXMuX2VuYWJsZWQ9ITAsdGhpcy5hZGRIb29rcygpKSx0aGlzfSxkaXNhYmxlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2VuYWJsZWQmJih0aGlzLl9lbmFibGVkPSExLHRoaXMucmVtb3ZlSG9va3MoKSksdGhpc30sZW5hYmxlZDpmdW5jdGlvbigpe3JldHVybiEhdGhpcy5fZW5hYmxlZH19KSksZnQ9KG4uYWRkVG89ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5hZGRIYW5kbGVyKGUsdGhpcyksdGhpc30se0V2ZW50czplfSksWGU9Yi50b3VjaD9cInRvdWNoc3RhcnQgbW91c2Vkb3duXCI6XCJtb3VzZWRvd25cIixKZT1pdC5leHRlbmQoe29wdGlvbnM6e2NsaWNrVG9sZXJhbmNlOjN9LGluaXRpYWxpemU6ZnVuY3Rpb24odCxlLGksbil7Yyh0aGlzLG4pLHRoaXMuX2VsZW1lbnQ9dCx0aGlzLl9kcmFnU3RhcnRUYXJnZXQ9ZXx8dCx0aGlzLl9wcmV2ZW50T3V0bGluZT1pfSxlbmFibGU6ZnVuY3Rpb24oKXt0aGlzLl9lbmFibGVkfHwoUyh0aGlzLl9kcmFnU3RhcnRUYXJnZXQsWGUsdGhpcy5fb25Eb3duLHRoaXMpLHRoaXMuX2VuYWJsZWQ9ITApfSxkaXNhYmxlOmZ1bmN0aW9uKCl7dGhpcy5fZW5hYmxlZCYmKEplLl9kcmFnZ2luZz09PXRoaXMmJnRoaXMuZmluaXNoRHJhZyghMCksayh0aGlzLl9kcmFnU3RhcnRUYXJnZXQsWGUsdGhpcy5fb25Eb3duLHRoaXMpLHRoaXMuX2VuYWJsZWQ9ITEsdGhpcy5fbW92ZWQ9ITEpfSxfb25Eb3duOmZ1bmN0aW9uKHQpe3ZhciBlLGk7dGhpcy5fZW5hYmxlZCYmKHRoaXMuX21vdmVkPSExLHZlKHRoaXMuX2VsZW1lbnQsXCJsZWFmbGV0LXpvb20tYW5pbVwiKXx8KHQudG91Y2hlcyYmMSE9PXQudG91Y2hlcy5sZW5ndGg/SmUuX2RyYWdnaW5nPT09dGhpcyYmdGhpcy5maW5pc2hEcmFnKCk6SmUuX2RyYWdnaW5nfHx0LnNoaWZ0S2V5fHwxIT09dC53aGljaCYmMSE9PXQuYnV0dG9uJiYhdC50b3VjaGVzfHwoKEplLl9kcmFnZ2luZz10aGlzKS5fcHJldmVudE91dGxpbmUmJk1lKHRoaXMuX2VsZW1lbnQpLExlKCkscmUoKSx0aGlzLl9tb3Zpbmd8fCh0aGlzLmZpcmUoXCJkb3duXCIpLGk9dC50b3VjaGVzP3QudG91Y2hlc1swXTp0LGU9Q2UodGhpcy5fZWxlbWVudCksdGhpcy5fc3RhcnRQb2ludD1uZXcgcChpLmNsaWVudFgsaS5jbGllbnRZKSx0aGlzLl9zdGFydFBvcz1QZSh0aGlzLl9lbGVtZW50KSx0aGlzLl9wYXJlbnRTY2FsZT1aZShlKSxpPVwibW91c2Vkb3duXCI9PT10LnR5cGUsUyhkb2N1bWVudCxpP1wibW91c2Vtb3ZlXCI6XCJ0b3VjaG1vdmVcIix0aGlzLl9vbk1vdmUsdGhpcyksUyhkb2N1bWVudCxpP1wibW91c2V1cFwiOlwidG91Y2hlbmQgdG91Y2hjYW5jZWxcIix0aGlzLl9vblVwLHRoaXMpKSkpKX0sX29uTW92ZTpmdW5jdGlvbih0KXt2YXIgZTt0aGlzLl9lbmFibGVkJiYodC50b3VjaGVzJiYxPHQudG91Y2hlcy5sZW5ndGg/dGhpcy5fbW92ZWQ9ITA6IShlPW5ldyBwKChlPXQudG91Y2hlcyYmMT09PXQudG91Y2hlcy5sZW5ndGg/dC50b3VjaGVzWzBdOnQpLmNsaWVudFgsZS5jbGllbnRZKS5fc3VidHJhY3QodGhpcy5fc3RhcnRQb2ludCkpLngmJiFlLnl8fE1hdGguYWJzKGUueCkrTWF0aC5hYnMoZS55KTx0aGlzLm9wdGlvbnMuY2xpY2tUb2xlcmFuY2V8fChlLngvPXRoaXMuX3BhcmVudFNjYWxlLngsZS55Lz10aGlzLl9wYXJlbnRTY2FsZS55LE8odCksdGhpcy5fbW92ZWR8fCh0aGlzLmZpcmUoXCJkcmFnc3RhcnRcIiksdGhpcy5fbW92ZWQ9ITAsTShkb2N1bWVudC5ib2R5LFwibGVhZmxldC1kcmFnZ2luZ1wiKSx0aGlzLl9sYXN0VGFyZ2V0PXQudGFyZ2V0fHx0LnNyY0VsZW1lbnQsd2luZG93LlNWR0VsZW1lbnRJbnN0YW5jZSYmdGhpcy5fbGFzdFRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5TVkdFbGVtZW50SW5zdGFuY2UmJih0aGlzLl9sYXN0VGFyZ2V0PXRoaXMuX2xhc3RUYXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQpLE0odGhpcy5fbGFzdFRhcmdldCxcImxlYWZsZXQtZHJhZy10YXJnZXRcIikpLHRoaXMuX25ld1Bvcz10aGlzLl9zdGFydFBvcy5hZGQoZSksdGhpcy5fbW92aW5nPSEwLHRoaXMuX2xhc3RFdmVudD10LHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCkpKX0sX3VwZGF0ZVBvc2l0aW9uOmZ1bmN0aW9uKCl7dmFyIHQ9e29yaWdpbmFsRXZlbnQ6dGhpcy5fbGFzdEV2ZW50fTt0aGlzLmZpcmUoXCJwcmVkcmFnXCIsdCksWih0aGlzLl9lbGVtZW50LHRoaXMuX25ld1BvcyksdGhpcy5maXJlKFwiZHJhZ1wiLHQpfSxfb25VcDpmdW5jdGlvbigpe3RoaXMuX2VuYWJsZWQmJnRoaXMuZmluaXNoRHJhZygpfSxmaW5pc2hEcmFnOmZ1bmN0aW9uKHQpe3ooZG9jdW1lbnQuYm9keSxcImxlYWZsZXQtZHJhZ2dpbmdcIiksdGhpcy5fbGFzdFRhcmdldCYmKHoodGhpcy5fbGFzdFRhcmdldCxcImxlYWZsZXQtZHJhZy10YXJnZXRcIiksdGhpcy5fbGFzdFRhcmdldD1udWxsKSxrKGRvY3VtZW50LFwibW91c2Vtb3ZlIHRvdWNobW92ZVwiLHRoaXMuX29uTW92ZSx0aGlzKSxrKGRvY3VtZW50LFwibW91c2V1cCB0b3VjaGVuZCB0b3VjaGNhbmNlbFwiLHRoaXMuX29uVXAsdGhpcyksVGUoKSxhZSgpLHRoaXMuX21vdmVkJiZ0aGlzLl9tb3ZpbmcmJnRoaXMuZmlyZShcImRyYWdlbmRcIix7bm9JbmVydGlhOnQsZGlzdGFuY2U6dGhpcy5fbmV3UG9zLmRpc3RhbmNlVG8odGhpcy5fc3RhcnRQb3MpfSksdGhpcy5fbW92aW5nPSExLEplLl9kcmFnZ2luZz0hMX19KTtmdW5jdGlvbiAkZSh0LGUpe2lmKGUmJnQubGVuZ3RoKXt2YXIgaT10PWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBpPVt0WzBdXSxuPTEsbz0wLHM9dC5sZW5ndGg7bjxzO24rKykoZnVuY3Rpb24odCxlKXt2YXIgaT1lLngtdC54LGU9ZS55LXQueTtyZXR1cm4gaSppK2UqZX0pKHRbbl0sdFtvXSk+ZSYmKGkucHVzaCh0W25dKSxvPW4pO288cy0xJiZpLnB1c2godFtzLTFdKTtyZXR1cm4gaX0odCxlPWUqZSksbj1pLmxlbmd0aCxvPW5ldyh0eXBlb2YgVWludDhBcnJheSE9dm9pZCAwK1wiXCI/VWludDhBcnJheTpBcnJheSkobik7b1swXT1vW24tMV09MSxmdW5jdGlvbiB0KGUsaSxuLG8scyl7dmFyIHIsYSxoLGw9MDtmb3IoYT1vKzE7YTw9cy0xO2ErKyloPW5pKGVbYV0sZVtvXSxlW3NdLCEwKSxsPGgmJihyPWEsbD1oKTtuPGwmJihpW3JdPTEsdChlLGksbixvLHIpLHQoZSxpLG4scixzKSl9KGksbyxlLDAsbi0xKTt2YXIgcyxyPVtdO2ZvcihzPTA7czxuO3MrKylvW3NdJiZyLnB1c2goaVtzXSk7cmV0dXJuIHJ9cmV0dXJuIHQuc2xpY2UoKX1mdW5jdGlvbiBRZSh0LGUsaSl7cmV0dXJuIE1hdGguc3FydChuaSh0LGUsaSwhMCkpfWZ1bmN0aW9uIHRpKHQsZSxpLG4sbyl7dmFyIHMscixhLGg9bj9WZTppaSh0LGkpLGw9aWkoZSxpKTtmb3IoVmU9bDs7KXtpZighKGh8bCkpcmV0dXJuW3QsZV07aWYoaCZsKXJldHVybiExO2E9aWkocj1laSh0LGUscz1ofHxsLGksbyksaSkscz09PWg/KHQ9cixoPWEpOihlPXIsbD1hKX19ZnVuY3Rpb24gZWkodCxlLGksbixvKXt2YXIgcyxyLGE9ZS54LXQueCxlPWUueS10LnksaD1uLm1pbixuPW4ubWF4O3JldHVybiA4Jmk/KHM9dC54K2EqKG4ueS10LnkpL2Uscj1uLnkpOjQmaT8ocz10LngrYSooaC55LXQueSkvZSxyPWgueSk6MiZpPyhzPW4ueCxyPXQueStlKihuLngtdC54KS9hKToxJmkmJihzPWgueCxyPXQueStlKihoLngtdC54KS9hKSxuZXcgcChzLHIsbyl9ZnVuY3Rpb24gaWkodCxlKXt2YXIgaT0wO3JldHVybiB0Lng8ZS5taW4ueD9pfD0xOnQueD5lLm1heC54JiYoaXw9MiksdC55PGUubWluLnk/aXw9NDp0Lnk+ZS5tYXgueSYmKGl8PTgpLGl9ZnVuY3Rpb24gbmkodCxlLGksbil7dmFyIG89ZS54LGU9ZS55LHM9aS54LW8scj1pLnktZSxhPXMqcytyKnI7cmV0dXJuIDA8YSYmKDE8KGE9KCh0LngtbykqcysodC55LWUpKnIpL2EpPyhvPWkueCxlPWkueSk6MDxhJiYobys9cyphLGUrPXIqYSkpLHM9dC54LW8scj10LnktZSxuP3MqcytyKnI6bmV3IHAobyxlKX1mdW5jdGlvbiBJKHQpe3JldHVybiFkKHRbMF0pfHxcIm9iamVjdFwiIT10eXBlb2YgdFswXVswXSYmdm9pZCAwIT09dFswXVswXX1mdW5jdGlvbiBvaSh0KXtyZXR1cm4gY29uc29sZS53YXJuKFwiRGVwcmVjYXRlZCB1c2Ugb2YgX2ZsYXQsIHBsZWFzZSB1c2UgTC5MaW5lVXRpbC5pc0ZsYXQgaW5zdGVhZC5cIiksSSh0KX1mdW5jdGlvbiBzaSh0LGUpe3ZhciBpLG4sbyxzLHI7aWYoIXR8fDA9PT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJsYXRsbmdzIG5vdCBwYXNzZWRcIik7SSh0KXx8KGNvbnNvbGUud2FybihcImxhdGxuZ3MgYXJlIG5vdCBmbGF0ISBPbmx5IHRoZSBmaXJzdCByaW5nIHdpbGwgYmUgdXNlZFwiKSx0PXRbMF0pO3ZhciBhLGg9W107Zm9yKGEgaW4gdCloLnB1c2goZS5wcm9qZWN0KHcodFthXSkpKTtmb3IodmFyIGw9aC5sZW5ndGgsdT0wLGM9MDt1PGwtMTt1KyspYys9aFt1XS5kaXN0YW5jZVRvKGhbdSsxXSkvMjtpZigwPT09YylyPWhbMF07ZWxzZSBmb3IoaT11PTA7dTxsLTE7dSsrKWlmKG49aFt1XSxvPWhbdSsxXSxjPChpKz1zPW4uZGlzdGFuY2VUbyhvKSkpe3I9W28ueC0ocz0oaS1jKS9zKSooby54LW4ueCksby55LXMqKG8ueS1uLnkpXTticmVha31yZXR1cm4gZS51bnByb2plY3QobShyKSl9Z3Q9e19fcHJvdG9fXzpudWxsLHNpbXBsaWZ5OiRlLHBvaW50VG9TZWdtZW50RGlzdGFuY2U6UWUsY2xvc2VzdFBvaW50T25TZWdtZW50OmZ1bmN0aW9uKHQsZSxpKXtyZXR1cm4gbmkodCxlLGkpfSxjbGlwU2VnbWVudDp0aSxfZ2V0RWRnZUludGVyc2VjdGlvbjplaSxfZ2V0Qml0Q29kZTppaSxfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQ6bmksaXNGbGF0OkksX2ZsYXQ6b2kscG9seWxpbmVDZW50ZXI6c2l9O2Z1bmN0aW9uIHJpKHQsZSxpKXtmb3IodmFyIG4sbyxzLHIsYSxoLGwsdT1bMSw0LDIsOF0sYz0wLGQ9dC5sZW5ndGg7YzxkO2MrKyl0W2NdLl9jb2RlPWlpKHRbY10sZSk7Zm9yKHM9MDtzPDQ7cysrKXtmb3IoaD11W3NdLG49W10sYz0wLG89KGQ9dC5sZW5ndGgpLTE7YzxkO289YysrKXI9dFtjXSxhPXRbb10sci5fY29kZSZoP2EuX2NvZGUmaHx8KChsPWVpKGEscixoLGUsaSkpLl9jb2RlPWlpKGwsZSksbi5wdXNoKGwpKTooYS5fY29kZSZoJiYoKGw9ZWkoYSxyLGgsZSxpKSkuX2NvZGU9aWkobCxlKSxuLnB1c2gobCkpLG4ucHVzaChyKSk7dD1ufXJldHVybiB0fWZ1bmN0aW9uIGFpKHQsZSl7dmFyIGksbixvLHMscixhO2lmKCF0fHwwPT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwibGF0bG5ncyBub3QgcGFzc2VkXCIpO0kodCl8fChjb25zb2xlLndhcm4oXCJsYXRsbmdzIGFyZSBub3QgZmxhdCEgT25seSB0aGUgZmlyc3QgcmluZyB3aWxsIGJlIHVzZWRcIiksdD10WzBdKTt2YXIgaCxsPVtdO2ZvcihoIGluIHQpbC5wdXNoKGUucHJvamVjdCh3KHRbaF0pKSk7Zm9yKHZhciB1PWwubGVuZ3RoLGM9cz1yPTAsZD0wLF89dS0xO2Q8dTtfPWQrKylpPWxbZF0sbj1sW19dLG89aS55Km4ueC1uLnkqaS54LHMrPShpLngrbi54KSpvLHIrPShpLnkrbi55KSpvLGMrPTMqbztyZXR1cm4gYT0wPT09Yz9sWzBdOltzL2Msci9jXSxlLnVucHJvamVjdChtKGEpKX12YXIgdnQ9e19fcHJvdG9fXzpudWxsLGNsaXBQb2x5Z29uOnJpLHBvbHlnb25DZW50ZXI6YWl9LHl0PXtwcm9qZWN0OmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgcCh0LmxuZyx0LmxhdCl9LHVucHJvamVjdDpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IHYodC55LHQueCl9LGJvdW5kczpuZXcgZihbLTE4MCwtOTBdLFsxODAsOTBdKX0seHQ9e1I6NjM3ODEzNyxSX01JTk9SOjYzNTY3NTIuMzE0MjQ1MTc5LGJvdW5kczpuZXcgZihbLTIwMDM3NTA4LjM0Mjc5LC0xNTQ5NjU3MC43Mzk3Ml0sWzIwMDM3NTA4LjM0Mjc5LDE4NzY0NjU2LjIzMTM4XSkscHJvamVjdDpmdW5jdGlvbih0KXt2YXIgZT1NYXRoLlBJLzE4MCxpPXRoaXMuUixuPXQubGF0KmUsbz10aGlzLlJfTUlOT1IvaSxvPU1hdGguc3FydCgxLW8qbykscz1vKk1hdGguc2luKG4pLHM9TWF0aC50YW4oTWF0aC5QSS80LW4vMikvTWF0aC5wb3coKDEtcykvKDErcyksby8yKSxuPS1pKk1hdGgubG9nKE1hdGgubWF4KHMsMWUtMTApKTtyZXR1cm4gbmV3IHAodC5sbmcqZSppLG4pfSx1bnByb2plY3Q6ZnVuY3Rpb24odCl7Zm9yKHZhciBlLGk9MTgwL01hdGguUEksbj10aGlzLlIsbz10aGlzLlJfTUlOT1IvbixzPU1hdGguc3FydCgxLW8qbykscj1NYXRoLmV4cCgtdC55L24pLGE9TWF0aC5QSS8yLTIqTWF0aC5hdGFuKHIpLGg9MCxsPS4xO2g8MTUmJjFlLTc8TWF0aC5hYnMobCk7aCsrKWU9cypNYXRoLnNpbihhKSxlPU1hdGgucG93KCgxLWUpLygxK2UpLHMvMiksYSs9bD1NYXRoLlBJLzItMipNYXRoLmF0YW4ociplKS1hO3JldHVybiBuZXcgdihhKmksdC54Kmkvbil9fSx3dD17X19wcm90b19fOm51bGwsTG9uTGF0Onl0LE1lcmNhdG9yOnh0LFNwaGVyaWNhbE1lcmNhdG9yOnJ0fSxQdD1sKHt9LHN0LHtjb2RlOlwiRVBTRzozMzk1XCIscHJvamVjdGlvbjp4dCx0cmFuc2Zvcm1hdGlvbjpodChidD0uNS8oTWF0aC5QSSp4dC5SKSwuNSwtYnQsLjUpfSksaGk9bCh7fSxzdCx7Y29kZTpcIkVQU0c6NDMyNlwiLHByb2plY3Rpb246eXQsdHJhbnNmb3JtYXRpb246aHQoMS8xODAsMSwtMS8xODAsLjUpfSksTHQ9bCh7fSxvdCx7cHJvamVjdGlvbjp5dCx0cmFuc2Zvcm1hdGlvbjpodCgxLDAsLTEsMCksc2NhbGU6ZnVuY3Rpb24odCl7cmV0dXJuIE1hdGgucG93KDIsdCl9LHpvb206ZnVuY3Rpb24odCl7cmV0dXJuIE1hdGgubG9nKHQpL01hdGguTE4yfSxkaXN0YW5jZTpmdW5jdGlvbih0LGUpe3ZhciBpPWUubG5nLXQubG5nLGU9ZS5sYXQtdC5sYXQ7cmV0dXJuIE1hdGguc3FydChpKmkrZSplKX0saW5maW5pdGU6ITB9KSxvPShvdC5FYXJ0aD1zdCxvdC5FUFNHMzM5NT1QdCxvdC5FUFNHMzg1Nz1sdCxvdC5FUFNHOTAwOTEzPXV0LG90LkVQU0c0MzI2PWhpLG90LlNpbXBsZT1MdCxpdC5leHRlbmQoe29wdGlvbnM6e3BhbmU6XCJvdmVybGF5UGFuZVwiLGF0dHJpYnV0aW9uOm51bGwsYnViYmxpbmdNb3VzZUV2ZW50czohMH0sYWRkVG86ZnVuY3Rpb24odCl7cmV0dXJuIHQuYWRkTGF5ZXIodGhpcyksdGhpc30scmVtb3ZlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVtb3ZlRnJvbSh0aGlzLl9tYXB8fHRoaXMuX21hcFRvQWRkKX0scmVtb3ZlRnJvbTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmdC5yZW1vdmVMYXllcih0aGlzKSx0aGlzfSxnZXRQYW5lOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9tYXAuZ2V0UGFuZSh0P3RoaXMub3B0aW9uc1t0XXx8dDp0aGlzLm9wdGlvbnMucGFuZSl9LGFkZEludGVyYWN0aXZlVGFyZ2V0OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9tYXAuX3RhcmdldHNbaCh0KV09dGhpc30scmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQ6ZnVuY3Rpb24odCl7cmV0dXJuIGRlbGV0ZSB0aGlzLl9tYXAuX3RhcmdldHNbaCh0KV0sdGhpc30sZ2V0QXR0cmlidXRpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vcHRpb25zLmF0dHJpYnV0aW9ufSxfbGF5ZXJBZGQ6ZnVuY3Rpb24odCl7dmFyIGUsaT10LnRhcmdldDtpLmhhc0xheWVyKHRoaXMpJiYodGhpcy5fbWFwPWksdGhpcy5fem9vbUFuaW1hdGVkPWkuX3pvb21BbmltYXRlZCx0aGlzLmdldEV2ZW50cyYmKGU9dGhpcy5nZXRFdmVudHMoKSxpLm9uKGUsdGhpcyksdGhpcy5vbmNlKFwicmVtb3ZlXCIsZnVuY3Rpb24oKXtpLm9mZihlLHRoaXMpfSx0aGlzKSksdGhpcy5vbkFkZChpKSx0aGlzLmZpcmUoXCJhZGRcIiksaS5maXJlKFwibGF5ZXJhZGRcIix7bGF5ZXI6dGhpc30pKX19KSksbGk9KEEuaW5jbHVkZSh7YWRkTGF5ZXI6ZnVuY3Rpb24odCl7dmFyIGU7aWYodC5fbGF5ZXJBZGQpcmV0dXJuIGU9aCh0KSx0aGlzLl9sYXllcnNbZV18fCgodGhpcy5fbGF5ZXJzW2VdPXQpLl9tYXBUb0FkZD10aGlzLHQuYmVmb3JlQWRkJiZ0LmJlZm9yZUFkZCh0aGlzKSx0aGlzLndoZW5SZWFkeSh0Ll9sYXllckFkZCx0KSksdGhpczt0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcHJvdmlkZWQgb2JqZWN0IGlzIG5vdCBhIExheWVyLlwiKX0scmVtb3ZlTGF5ZXI6ZnVuY3Rpb24odCl7dmFyIGU9aCh0KTtyZXR1cm4gdGhpcy5fbGF5ZXJzW2VdJiYodGhpcy5fbG9hZGVkJiZ0Lm9uUmVtb3ZlKHRoaXMpLGRlbGV0ZSB0aGlzLl9sYXllcnNbZV0sdGhpcy5fbG9hZGVkJiYodGhpcy5maXJlKFwibGF5ZXJyZW1vdmVcIix7bGF5ZXI6dH0pLHQuZmlyZShcInJlbW92ZVwiKSksdC5fbWFwPXQuX21hcFRvQWRkPW51bGwpLHRoaXN9LGhhc0xheWVyOmZ1bmN0aW9uKHQpe3JldHVybiBoKHQpaW4gdGhpcy5fbGF5ZXJzfSxlYWNoTGF5ZXI6ZnVuY3Rpb24odCxlKXtmb3IodmFyIGkgaW4gdGhpcy5fbGF5ZXJzKXQuY2FsbChlLHRoaXMuX2xheWVyc1tpXSk7cmV0dXJuIHRoaXN9LF9hZGRMYXllcnM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTAsaT0odD10P2QodCk/dDpbdF06W10pLmxlbmd0aDtlPGk7ZSsrKXRoaXMuYWRkTGF5ZXIodFtlXSl9LF9hZGRab29tTGltaXQ6ZnVuY3Rpb24odCl7aXNOYU4odC5vcHRpb25zLm1heFpvb20pJiZpc05hTih0Lm9wdGlvbnMubWluWm9vbSl8fCh0aGlzLl96b29tQm91bmRMYXllcnNbaCh0KV09dCx0aGlzLl91cGRhdGVab29tTGV2ZWxzKCkpfSxfcmVtb3ZlWm9vbUxpbWl0OmZ1bmN0aW9uKHQpe3Q9aCh0KTt0aGlzLl96b29tQm91bmRMYXllcnNbdF0mJihkZWxldGUgdGhpcy5fem9vbUJvdW5kTGF5ZXJzW3RdLHRoaXMuX3VwZGF0ZVpvb21MZXZlbHMoKSl9LF91cGRhdGVab29tTGV2ZWxzOmZ1bmN0aW9uKCl7dmFyIHQsZT0xLzAsaT0tMS8wLG49dGhpcy5fZ2V0Wm9vbVNwYW4oKTtmb3IodCBpbiB0aGlzLl96b29tQm91bmRMYXllcnMpdmFyIG89dGhpcy5fem9vbUJvdW5kTGF5ZXJzW3RdLm9wdGlvbnMsZT12b2lkIDA9PT1vLm1pblpvb20/ZTpNYXRoLm1pbihlLG8ubWluWm9vbSksaT12b2lkIDA9PT1vLm1heFpvb20/aTpNYXRoLm1heChpLG8ubWF4Wm9vbSk7dGhpcy5fbGF5ZXJzTWF4Wm9vbT1pPT09LTEvMD92b2lkIDA6aSx0aGlzLl9sYXllcnNNaW5ab29tPWU9PT0xLzA/dm9pZCAwOmUsbiE9PXRoaXMuX2dldFpvb21TcGFuKCkmJnRoaXMuZmlyZShcInpvb21sZXZlbHNjaGFuZ2VcIiksdm9pZCAwPT09dGhpcy5vcHRpb25zLm1heFpvb20mJnRoaXMuX2xheWVyc01heFpvb20mJnRoaXMuZ2V0Wm9vbSgpPnRoaXMuX2xheWVyc01heFpvb20mJnRoaXMuc2V0Wm9vbSh0aGlzLl9sYXllcnNNYXhab29tKSx2b2lkIDA9PT10aGlzLm9wdGlvbnMubWluWm9vbSYmdGhpcy5fbGF5ZXJzTWluWm9vbSYmdGhpcy5nZXRab29tKCk8dGhpcy5fbGF5ZXJzTWluWm9vbSYmdGhpcy5zZXRab29tKHRoaXMuX2xheWVyc01pblpvb20pfX0pLG8uZXh0ZW5kKHtpbml0aWFsaXplOmZ1bmN0aW9uKHQsZSl7dmFyIGksbjtpZihjKHRoaXMsZSksdGhpcy5fbGF5ZXJzPXt9LHQpZm9yKGk9MCxuPXQubGVuZ3RoO2k8bjtpKyspdGhpcy5hZGRMYXllcih0W2ldKX0sYWRkTGF5ZXI6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5nZXRMYXllcklkKHQpO3JldHVybiB0aGlzLl9sYXllcnNbZV09dCx0aGlzLl9tYXAmJnRoaXMuX21hcC5hZGRMYXllcih0KSx0aGlzfSxyZW1vdmVMYXllcjpmdW5jdGlvbih0KXt0PXQgaW4gdGhpcy5fbGF5ZXJzP3Q6dGhpcy5nZXRMYXllcklkKHQpO3JldHVybiB0aGlzLl9tYXAmJnRoaXMuX2xheWVyc1t0XSYmdGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX2xheWVyc1t0XSksZGVsZXRlIHRoaXMuX2xheWVyc1t0XSx0aGlzfSxoYXNMYXllcjpmdW5jdGlvbih0KXtyZXR1cm4oXCJudW1iZXJcIj09dHlwZW9mIHQ/dDp0aGlzLmdldExheWVySWQodCkpaW4gdGhpcy5fbGF5ZXJzfSxjbGVhckxheWVyczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVhY2hMYXllcih0aGlzLnJlbW92ZUxheWVyLHRoaXMpfSxpbnZva2U6ZnVuY3Rpb24odCl7dmFyIGUsaSxuPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKTtmb3IoZSBpbiB0aGlzLl9sYXllcnMpKGk9dGhpcy5fbGF5ZXJzW2VdKVt0XSYmaVt0XS5hcHBseShpLG4pO3JldHVybiB0aGlzfSxvbkFkZDpmdW5jdGlvbih0KXt0aGlzLmVhY2hMYXllcih0LmFkZExheWVyLHQpfSxvblJlbW92ZTpmdW5jdGlvbih0KXt0aGlzLmVhY2hMYXllcih0LnJlbW92ZUxheWVyLHQpfSxlYWNoTGF5ZXI6ZnVuY3Rpb24odCxlKXtmb3IodmFyIGkgaW4gdGhpcy5fbGF5ZXJzKXQuY2FsbChlLHRoaXMuX2xheWVyc1tpXSk7cmV0dXJuIHRoaXN9LGdldExheWVyOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9sYXllcnNbdF19LGdldExheWVyczpmdW5jdGlvbigpe3ZhciB0PVtdO3JldHVybiB0aGlzLmVhY2hMYXllcih0LnB1c2gsdCksdH0sc2V0WkluZGV4OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmludm9rZShcInNldFpJbmRleFwiLHQpfSxnZXRMYXllcklkOmh9KSksdWk9bGkuZXh0ZW5kKHthZGRMYXllcjpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5oYXNMYXllcih0KT90aGlzOih0LmFkZEV2ZW50UGFyZW50KHRoaXMpLGxpLnByb3RvdHlwZS5hZGRMYXllci5jYWxsKHRoaXMsdCksdGhpcy5maXJlKFwibGF5ZXJhZGRcIix7bGF5ZXI6dH0pKX0scmVtb3ZlTGF5ZXI6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuaGFzTGF5ZXIodCk/KCh0PXQgaW4gdGhpcy5fbGF5ZXJzP3RoaXMuX2xheWVyc1t0XTp0KS5yZW1vdmVFdmVudFBhcmVudCh0aGlzKSxsaS5wcm90b3R5cGUucmVtb3ZlTGF5ZXIuY2FsbCh0aGlzLHQpLHRoaXMuZmlyZShcImxheWVycmVtb3ZlXCIse2xheWVyOnR9KSk6dGhpc30sc2V0U3R5bGU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuaW52b2tlKFwic2V0U3R5bGVcIix0KX0sYnJpbmdUb0Zyb250OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW52b2tlKFwiYnJpbmdUb0Zyb250XCIpfSxicmluZ1RvQmFjazpmdW5jdGlvbigpe3JldHVybiB0aGlzLmludm9rZShcImJyaW5nVG9CYWNrXCIpfSxnZXRCb3VuZHM6ZnVuY3Rpb24oKXt2YXIgdCxlPW5ldyBzO2Zvcih0IGluIHRoaXMuX2xheWVycyl7dmFyIGk9dGhpcy5fbGF5ZXJzW3RdO2UuZXh0ZW5kKGkuZ2V0Qm91bmRzP2kuZ2V0Qm91bmRzKCk6aS5nZXRMYXRMbmcoKSl9cmV0dXJuIGV9fSksY2k9ZXQuZXh0ZW5kKHtvcHRpb25zOntwb3B1cEFuY2hvcjpbMCwwXSx0b29sdGlwQW5jaG9yOlswLDBdLGNyb3NzT3JpZ2luOiExfSxpbml0aWFsaXplOmZ1bmN0aW9uKHQpe2ModGhpcyx0KX0sY3JlYXRlSWNvbjpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fY3JlYXRlSWNvbihcImljb25cIix0KX0sY3JlYXRlU2hhZG93OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9jcmVhdGVJY29uKFwic2hhZG93XCIsdCl9LF9jcmVhdGVJY29uOmZ1bmN0aW9uKHQsZSl7dmFyIGk9dGhpcy5fZ2V0SWNvblVybCh0KTtpZihpKXJldHVybiBpPXRoaXMuX2NyZWF0ZUltZyhpLGUmJlwiSU1HXCI9PT1lLnRhZ05hbWU/ZTpudWxsKSx0aGlzLl9zZXRJY29uU3R5bGVzKGksdCksIXRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiYmXCJcIiE9PXRoaXMub3B0aW9ucy5jcm9zc09yaWdpbnx8KGkuY3Jvc3NPcmlnaW49ITA9PT10aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4/XCJcIjp0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4pLGk7aWYoXCJpY29uXCI9PT10KXRocm93IG5ldyBFcnJvcihcImljb25Vcmwgbm90IHNldCBpbiBJY29uIG9wdGlvbnMgKHNlZSB0aGUgZG9jcykuXCIpO3JldHVybiBudWxsfSxfc2V0SWNvblN0eWxlczpmdW5jdGlvbih0LGUpe3ZhciBpPXRoaXMub3B0aW9ucyxuPWlbZStcIlNpemVcIl0sbj1tKG49XCJudW1iZXJcIj09dHlwZW9mIG4/W24sbl06biksbz1tKFwic2hhZG93XCI9PT1lJiZpLnNoYWRvd0FuY2hvcnx8aS5pY29uQW5jaG9yfHxuJiZuLmRpdmlkZUJ5KDIsITApKTt0LmNsYXNzTmFtZT1cImxlYWZsZXQtbWFya2VyLVwiK2UrXCIgXCIrKGkuY2xhc3NOYW1lfHxcIlwiKSxvJiYodC5zdHlsZS5tYXJnaW5MZWZ0PS1vLngrXCJweFwiLHQuc3R5bGUubWFyZ2luVG9wPS1vLnkrXCJweFwiKSxuJiYodC5zdHlsZS53aWR0aD1uLngrXCJweFwiLHQuc3R5bGUuaGVpZ2h0PW4ueStcInB4XCIpfSxfY3JlYXRlSW1nOmZ1bmN0aW9uKHQsZSl7cmV0dXJuKGU9ZXx8ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKSkuc3JjPXQsZX0sX2dldEljb25Vcmw6ZnVuY3Rpb24odCl7cmV0dXJuIGIucmV0aW5hJiZ0aGlzLm9wdGlvbnNbdCtcIlJldGluYVVybFwiXXx8dGhpcy5vcHRpb25zW3QrXCJVcmxcIl19fSk7dmFyIGRpPWNpLmV4dGVuZCh7b3B0aW9uczp7aWNvblVybDpcIm1hcmtlci1pY29uLnBuZ1wiLGljb25SZXRpbmFVcmw6XCJtYXJrZXItaWNvbi0yeC5wbmdcIixzaGFkb3dVcmw6XCJtYXJrZXItc2hhZG93LnBuZ1wiLGljb25TaXplOlsyNSw0MV0saWNvbkFuY2hvcjpbMTIsNDFdLHBvcHVwQW5jaG9yOlsxLC0zNF0sdG9vbHRpcEFuY2hvcjpbMTYsLTI4XSxzaGFkb3dTaXplOls0MSw0MV19LF9nZXRJY29uVXJsOmZ1bmN0aW9uKHQpe3JldHVyblwic3RyaW5nXCIhPXR5cGVvZiBkaS5pbWFnZVBhdGgmJihkaS5pbWFnZVBhdGg9dGhpcy5fZGV0ZWN0SWNvblBhdGgoKSksKHRoaXMub3B0aW9ucy5pbWFnZVBhdGh8fGRpLmltYWdlUGF0aCkrY2kucHJvdG90eXBlLl9nZXRJY29uVXJsLmNhbGwodGhpcyx0KX0sX3N0cmlwVXJsOmZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUodCxlLGkpe3JldHVybihlPWUuZXhlYyh0KSkmJmVbaV19cmV0dXJuKHQ9ZSh0LC9edXJsXFwoKFsnXCJdKT8oLispXFwxXFwpJC8sMikpJiZlKHQsL14oLiopbWFya2VyLWljb25cXC5wbmckLywxKX0sX2RldGVjdEljb25QYXRoOmZ1bmN0aW9uKCl7dmFyIHQ9UChcImRpdlwiLFwibGVhZmxldC1kZWZhdWx0LWljb24tcGF0aFwiLGRvY3VtZW50LmJvZHkpLGU9cGUodCxcImJhY2tncm91bmQtaW1hZ2VcIil8fHBlKHQsXCJiYWNrZ3JvdW5kSW1hZ2VcIik7cmV0dXJuIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodCksKGU9dGhpcy5fc3RyaXBVcmwoZSkpP2U6KHQ9ZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbGlua1tocmVmJD1cImxlYWZsZXQuY3NzXCJdJykpP3QuaHJlZi5zdWJzdHJpbmcoMCx0LmhyZWYubGVuZ3RoLVwibGVhZmxldC5jc3NcIi5sZW5ndGgtMSk6XCJcIn19KSxfaT1uLmV4dGVuZCh7aW5pdGlhbGl6ZTpmdW5jdGlvbih0KXt0aGlzLl9tYXJrZXI9dH0sYWRkSG9va3M6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9tYXJrZXIuX2ljb247dGhpcy5fZHJhZ2dhYmxlfHwodGhpcy5fZHJhZ2dhYmxlPW5ldyBKZSh0LHQsITApKSx0aGlzLl9kcmFnZ2FibGUub24oe2RyYWdzdGFydDp0aGlzLl9vbkRyYWdTdGFydCxwcmVkcmFnOnRoaXMuX29uUHJlRHJhZyxkcmFnOnRoaXMuX29uRHJhZyxkcmFnZW5kOnRoaXMuX29uRHJhZ0VuZH0sdGhpcykuZW5hYmxlKCksTSh0LFwibGVhZmxldC1tYXJrZXItZHJhZ2dhYmxlXCIpfSxyZW1vdmVIb29rczpmdW5jdGlvbigpe3RoaXMuX2RyYWdnYWJsZS5vZmYoe2RyYWdzdGFydDp0aGlzLl9vbkRyYWdTdGFydCxwcmVkcmFnOnRoaXMuX29uUHJlRHJhZyxkcmFnOnRoaXMuX29uRHJhZyxkcmFnZW5kOnRoaXMuX29uRHJhZ0VuZH0sdGhpcykuZGlzYWJsZSgpLHRoaXMuX21hcmtlci5faWNvbiYmeih0aGlzLl9tYXJrZXIuX2ljb24sXCJsZWFmbGV0LW1hcmtlci1kcmFnZ2FibGVcIil9LG1vdmVkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2RyYWdnYWJsZSYmdGhpcy5fZHJhZ2dhYmxlLl9tb3ZlZH0sX2FkanVzdFBhbjpmdW5jdGlvbih0KXt2YXIgZT10aGlzLl9tYXJrZXIsaT1lLl9tYXAsbj10aGlzLl9tYXJrZXIub3B0aW9ucy5hdXRvUGFuU3BlZWQsbz10aGlzLl9tYXJrZXIub3B0aW9ucy5hdXRvUGFuUGFkZGluZyxzPVBlKGUuX2ljb24pLHI9aS5nZXRQaXhlbEJvdW5kcygpLGE9aS5nZXRQaXhlbE9yaWdpbigpLGE9XyhyLm1pbi5fc3VidHJhY3QoYSkuYWRkKG8pLHIubWF4Ll9zdWJ0cmFjdChhKS5zdWJ0cmFjdChvKSk7YS5jb250YWlucyhzKXx8KG89bSgoTWF0aC5tYXgoYS5tYXgueCxzLngpLWEubWF4LngpLyhyLm1heC54LWEubWF4LngpLShNYXRoLm1pbihhLm1pbi54LHMueCktYS5taW4ueCkvKHIubWluLngtYS5taW4ueCksKE1hdGgubWF4KGEubWF4Lnkscy55KS1hLm1heC55KS8oci5tYXgueS1hLm1heC55KS0oTWF0aC5taW4oYS5taW4ueSxzLnkpLWEubWluLnkpLyhyLm1pbi55LWEubWluLnkpKS5tdWx0aXBseUJ5KG4pLGkucGFuQnkobyx7YW5pbWF0ZTohMX0pLHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLl9hZGQobyksdGhpcy5fZHJhZ2dhYmxlLl9zdGFydFBvcy5fYWRkKG8pLFooZS5faWNvbix0aGlzLl9kcmFnZ2FibGUuX25ld1BvcyksdGhpcy5fb25EcmFnKHQpLHRoaXMuX3BhblJlcXVlc3Q9eCh0aGlzLl9hZGp1c3RQYW4uYmluZCh0aGlzLHQpKSl9LF9vbkRyYWdTdGFydDpmdW5jdGlvbigpe3RoaXMuX29sZExhdExuZz10aGlzLl9tYXJrZXIuZ2V0TGF0TG5nKCksdGhpcy5fbWFya2VyLmNsb3NlUG9wdXAmJnRoaXMuX21hcmtlci5jbG9zZVBvcHVwKCksdGhpcy5fbWFya2VyLmZpcmUoXCJtb3Zlc3RhcnRcIikuZmlyZShcImRyYWdzdGFydFwiKX0sX29uUHJlRHJhZzpmdW5jdGlvbih0KXt0aGlzLl9tYXJrZXIub3B0aW9ucy5hdXRvUGFuJiYocih0aGlzLl9wYW5SZXF1ZXN0KSx0aGlzLl9wYW5SZXF1ZXN0PXgodGhpcy5fYWRqdXN0UGFuLmJpbmQodGhpcyx0KSkpfSxfb25EcmFnOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuX21hcmtlcixpPWUuX3NoYWRvdyxuPVBlKGUuX2ljb24pLG89ZS5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhuKTtpJiZaKGksbiksZS5fbGF0bG5nPW8sdC5sYXRsbmc9byx0Lm9sZExhdExuZz10aGlzLl9vbGRMYXRMbmcsZS5maXJlKFwibW92ZVwiLHQpLmZpcmUoXCJkcmFnXCIsdCl9LF9vbkRyYWdFbmQ6ZnVuY3Rpb24odCl7cih0aGlzLl9wYW5SZXF1ZXN0KSxkZWxldGUgdGhpcy5fb2xkTGF0TG5nLHRoaXMuX21hcmtlci5maXJlKFwibW92ZWVuZFwiKS5maXJlKFwiZHJhZ2VuZFwiLHQpfX0pLHBpPW8uZXh0ZW5kKHtvcHRpb25zOntpY29uOm5ldyBkaSxpbnRlcmFjdGl2ZTohMCxrZXlib2FyZDohMCx0aXRsZTpcIlwiLGFsdDpcIk1hcmtlclwiLHpJbmRleE9mZnNldDowLG9wYWNpdHk6MSxyaXNlT25Ib3ZlcjohMSxyaXNlT2Zmc2V0OjI1MCxwYW5lOlwibWFya2VyUGFuZVwiLHNoYWRvd1BhbmU6XCJzaGFkb3dQYW5lXCIsYnViYmxpbmdNb3VzZUV2ZW50czohMSxhdXRvUGFuT25Gb2N1czohMCxkcmFnZ2FibGU6ITEsYXV0b1BhbjohMSxhdXRvUGFuUGFkZGluZzpbNTAsNTBdLGF1dG9QYW5TcGVlZDoxMH0saW5pdGlhbGl6ZTpmdW5jdGlvbih0LGUpe2ModGhpcyxlKSx0aGlzLl9sYXRsbmc9dyh0KX0sb25BZGQ6ZnVuY3Rpb24odCl7dGhpcy5fem9vbUFuaW1hdGVkPXRoaXMuX3pvb21BbmltYXRlZCYmdC5vcHRpb25zLm1hcmtlclpvb21BbmltYXRpb24sdGhpcy5fem9vbUFuaW1hdGVkJiZ0Lm9uKFwiem9vbWFuaW1cIix0aGlzLl9hbmltYXRlWm9vbSx0aGlzKSx0aGlzLl9pbml0SWNvbigpLHRoaXMudXBkYXRlKCl9LG9uUmVtb3ZlOmZ1bmN0aW9uKHQpe3RoaXMuZHJhZ2dpbmcmJnRoaXMuZHJhZ2dpbmcuZW5hYmxlZCgpJiYodGhpcy5vcHRpb25zLmRyYWdnYWJsZT0hMCx0aGlzLmRyYWdnaW5nLnJlbW92ZUhvb2tzKCkpLGRlbGV0ZSB0aGlzLmRyYWdnaW5nLHRoaXMuX3pvb21BbmltYXRlZCYmdC5vZmYoXCJ6b29tYW5pbVwiLHRoaXMuX2FuaW1hdGVab29tLHRoaXMpLHRoaXMuX3JlbW92ZUljb24oKSx0aGlzLl9yZW1vdmVTaGFkb3coKX0sZ2V0RXZlbnRzOmZ1bmN0aW9uKCl7cmV0dXJue3pvb206dGhpcy51cGRhdGUsdmlld3Jlc2V0OnRoaXMudXBkYXRlfX0sZ2V0TGF0TG5nOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2xhdGxuZ30sc2V0TGF0TG5nOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuX2xhdGxuZztyZXR1cm4gdGhpcy5fbGF0bG5nPXcodCksdGhpcy51cGRhdGUoKSx0aGlzLmZpcmUoXCJtb3ZlXCIse29sZExhdExuZzplLGxhdGxuZzp0aGlzLl9sYXRsbmd9KX0sc2V0WkluZGV4T2Zmc2V0OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm9wdGlvbnMuekluZGV4T2Zmc2V0PXQsdGhpcy51cGRhdGUoKX0sZ2V0SWNvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLm9wdGlvbnMuaWNvbn0sc2V0SWNvbjpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5vcHRpb25zLmljb249dCx0aGlzLl9tYXAmJih0aGlzLl9pbml0SWNvbigpLHRoaXMudXBkYXRlKCkpLHRoaXMuX3BvcHVwJiZ0aGlzLmJpbmRQb3B1cCh0aGlzLl9wb3B1cCx0aGlzLl9wb3B1cC5vcHRpb25zKSx0aGlzfSxnZXRFbGVtZW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2ljb259LHVwZGF0ZTpmdW5jdGlvbigpe3ZhciB0O3JldHVybiB0aGlzLl9pY29uJiZ0aGlzLl9tYXAmJih0PXRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKS5yb3VuZCgpLHRoaXMuX3NldFBvcyh0KSksdGhpc30sX2luaXRJY29uOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5vcHRpb25zLGU9XCJsZWFmbGV0LXpvb20tXCIrKHRoaXMuX3pvb21BbmltYXRlZD9cImFuaW1hdGVkXCI6XCJoaWRlXCIpLGk9dC5pY29uLmNyZWF0ZUljb24odGhpcy5faWNvbiksbj0hMSxpPShpIT09dGhpcy5faWNvbiYmKHRoaXMuX2ljb24mJnRoaXMuX3JlbW92ZUljb24oKSxuPSEwLHQudGl0bGUmJihpLnRpdGxlPXQudGl0bGUpLFwiSU1HXCI9PT1pLnRhZ05hbWUmJihpLmFsdD10LmFsdHx8XCJcIikpLE0oaSxlKSx0LmtleWJvYXJkJiYoaS50YWJJbmRleD1cIjBcIixpLnNldEF0dHJpYnV0ZShcInJvbGVcIixcImJ1dHRvblwiKSksdGhpcy5faWNvbj1pLHQucmlzZU9uSG92ZXImJnRoaXMub24oe21vdXNlb3Zlcjp0aGlzLl9icmluZ1RvRnJvbnQsbW91c2VvdXQ6dGhpcy5fcmVzZXRaSW5kZXh9KSx0aGlzLm9wdGlvbnMuYXV0b1Bhbk9uRm9jdXMmJlMoaSxcImZvY3VzXCIsdGhpcy5fcGFuT25Gb2N1cyx0aGlzKSx0Lmljb24uY3JlYXRlU2hhZG93KHRoaXMuX3NoYWRvdykpLG89ITE7aSE9PXRoaXMuX3NoYWRvdyYmKHRoaXMuX3JlbW92ZVNoYWRvdygpLG89ITApLGkmJihNKGksZSksaS5hbHQ9XCJcIiksdGhpcy5fc2hhZG93PWksdC5vcGFjaXR5PDEmJnRoaXMuX3VwZGF0ZU9wYWNpdHkoKSxuJiZ0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9pY29uKSx0aGlzLl9pbml0SW50ZXJhY3Rpb24oKSxpJiZvJiZ0aGlzLmdldFBhbmUodC5zaGFkb3dQYW5lKS5hcHBlbmRDaGlsZCh0aGlzLl9zaGFkb3cpfSxfcmVtb3ZlSWNvbjpmdW5jdGlvbigpe3RoaXMub3B0aW9ucy5yaXNlT25Ib3ZlciYmdGhpcy5vZmYoe21vdXNlb3Zlcjp0aGlzLl9icmluZ1RvRnJvbnQsbW91c2VvdXQ6dGhpcy5fcmVzZXRaSW5kZXh9KSx0aGlzLm9wdGlvbnMuYXV0b1Bhbk9uRm9jdXMmJmsodGhpcy5faWNvbixcImZvY3VzXCIsdGhpcy5fcGFuT25Gb2N1cyx0aGlzKSxUKHRoaXMuX2ljb24pLHRoaXMucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faWNvbiksdGhpcy5faWNvbj1udWxsfSxfcmVtb3ZlU2hhZG93OmZ1bmN0aW9uKCl7dGhpcy5fc2hhZG93JiZUKHRoaXMuX3NoYWRvdyksdGhpcy5fc2hhZG93PW51bGx9LF9zZXRQb3M6ZnVuY3Rpb24odCl7dGhpcy5faWNvbiYmWih0aGlzLl9pY29uLHQpLHRoaXMuX3NoYWRvdyYmWih0aGlzLl9zaGFkb3csdCksdGhpcy5fekluZGV4PXQueSt0aGlzLm9wdGlvbnMuekluZGV4T2Zmc2V0LHRoaXMuX3Jlc2V0WkluZGV4KCl9LF91cGRhdGVaSW5kZXg6ZnVuY3Rpb24odCl7dGhpcy5faWNvbiYmKHRoaXMuX2ljb24uc3R5bGUuekluZGV4PXRoaXMuX3pJbmRleCt0KX0sX2FuaW1hdGVab29tOmZ1bmN0aW9uKHQpe3Q9dGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLHQuem9vbSx0LmNlbnRlcikucm91bmQoKTt0aGlzLl9zZXRQb3ModCl9LF9pbml0SW50ZXJhY3Rpb246ZnVuY3Rpb24oKXt2YXIgdDt0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUmJihNKHRoaXMuX2ljb24sXCJsZWFmbGV0LWludGVyYWN0aXZlXCIpLHRoaXMuYWRkSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faWNvbiksX2kmJih0PXRoaXMub3B0aW9ucy5kcmFnZ2FibGUsdGhpcy5kcmFnZ2luZyYmKHQ9dGhpcy5kcmFnZ2luZy5lbmFibGVkKCksdGhpcy5kcmFnZ2luZy5kaXNhYmxlKCkpLHRoaXMuZHJhZ2dpbmc9bmV3IF9pKHRoaXMpLHQmJnRoaXMuZHJhZ2dpbmcuZW5hYmxlKCkpKX0sc2V0T3BhY2l0eTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5vcHRpb25zLm9wYWNpdHk9dCx0aGlzLl9tYXAmJnRoaXMuX3VwZGF0ZU9wYWNpdHkoKSx0aGlzfSxfdXBkYXRlT3BhY2l0eTpmdW5jdGlvbigpe3ZhciB0PXRoaXMub3B0aW9ucy5vcGFjaXR5O3RoaXMuX2ljb24mJkModGhpcy5faWNvbix0KSx0aGlzLl9zaGFkb3cmJkModGhpcy5fc2hhZG93LHQpfSxfYnJpbmdUb0Zyb250OmZ1bmN0aW9uKCl7dGhpcy5fdXBkYXRlWkluZGV4KHRoaXMub3B0aW9ucy5yaXNlT2Zmc2V0KX0sX3Jlc2V0WkluZGV4OmZ1bmN0aW9uKCl7dGhpcy5fdXBkYXRlWkluZGV4KDApfSxfcGFuT25Gb2N1czpmdW5jdGlvbigpe3ZhciB0LGUsaT10aGlzLl9tYXA7aSYmKHQ9KGU9dGhpcy5vcHRpb25zLmljb24ub3B0aW9ucykuaWNvblNpemU/bShlLmljb25TaXplKTptKDAsMCksZT1lLmljb25BbmNob3I/bShlLmljb25BbmNob3IpOm0oMCwwKSxpLnBhbkluc2lkZSh0aGlzLl9sYXRsbmcse3BhZGRpbmdUb3BMZWZ0OmUscGFkZGluZ0JvdHRvbVJpZ2h0OnQuc3VidHJhY3QoZSl9KSl9LF9nZXRQb3B1cEFuY2hvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLm9wdGlvbnMuaWNvbi5vcHRpb25zLnBvcHVwQW5jaG9yfSxfZ2V0VG9vbHRpcEFuY2hvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLm9wdGlvbnMuaWNvbi5vcHRpb25zLnRvb2x0aXBBbmNob3J9fSk7dmFyIG1pPW8uZXh0ZW5kKHtvcHRpb25zOntzdHJva2U6ITAsY29sb3I6XCIjMzM4OGZmXCIsd2VpZ2h0OjMsb3BhY2l0eToxLGxpbmVDYXA6XCJyb3VuZFwiLGxpbmVKb2luOlwicm91bmRcIixkYXNoQXJyYXk6bnVsbCxkYXNoT2Zmc2V0Om51bGwsZmlsbDohMSxmaWxsQ29sb3I6bnVsbCxmaWxsT3BhY2l0eTouMixmaWxsUnVsZTpcImV2ZW5vZGRcIixpbnRlcmFjdGl2ZTohMCxidWJibGluZ01vdXNlRXZlbnRzOiEwfSxiZWZvcmVBZGQ6ZnVuY3Rpb24odCl7dGhpcy5fcmVuZGVyZXI9dC5nZXRSZW5kZXJlcih0aGlzKX0sb25BZGQ6ZnVuY3Rpb24oKXt0aGlzLl9yZW5kZXJlci5faW5pdFBhdGgodGhpcyksdGhpcy5fcmVzZXQoKSx0aGlzLl9yZW5kZXJlci5fYWRkUGF0aCh0aGlzKX0sb25SZW1vdmU6ZnVuY3Rpb24oKXt0aGlzLl9yZW5kZXJlci5fcmVtb3ZlUGF0aCh0aGlzKX0scmVkcmF3OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX21hcCYmdGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVBhdGgodGhpcyksdGhpc30sc2V0U3R5bGU6ZnVuY3Rpb24odCl7cmV0dXJuIGModGhpcyx0KSx0aGlzLl9yZW5kZXJlciYmKHRoaXMuX3JlbmRlcmVyLl91cGRhdGVTdHlsZSh0aGlzKSx0aGlzLm9wdGlvbnMuc3Ryb2tlJiZ0JiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxcIndlaWdodFwiKSYmdGhpcy5fdXBkYXRlQm91bmRzKCkpLHRoaXN9LGJyaW5nVG9Gcm9udDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9yZW5kZXJlciYmdGhpcy5fcmVuZGVyZXIuX2JyaW5nVG9Gcm9udCh0aGlzKSx0aGlzfSxicmluZ1RvQmFjazpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9yZW5kZXJlciYmdGhpcy5fcmVuZGVyZXIuX2JyaW5nVG9CYWNrKHRoaXMpLHRoaXN9LGdldEVsZW1lbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcGF0aH0sX3Jlc2V0OmZ1bmN0aW9uKCl7dGhpcy5fcHJvamVjdCgpLHRoaXMuX3VwZGF0ZSgpfSxfY2xpY2tUb2xlcmFuY2U6ZnVuY3Rpb24oKXtyZXR1cm4odGhpcy5vcHRpb25zLnN0cm9rZT90aGlzLm9wdGlvbnMud2VpZ2h0LzI6MCkrKHRoaXMuX3JlbmRlcmVyLm9wdGlvbnMudG9sZXJhbmNlfHwwKX19KSxmaT1taS5leHRlbmQoe29wdGlvbnM6e2ZpbGw6ITAscmFkaXVzOjEwfSxpbml0aWFsaXplOmZ1bmN0aW9uKHQsZSl7Yyh0aGlzLGUpLHRoaXMuX2xhdGxuZz13KHQpLHRoaXMuX3JhZGl1cz10aGlzLm9wdGlvbnMucmFkaXVzfSxzZXRMYXRMbmc6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5fbGF0bG5nO3JldHVybiB0aGlzLl9sYXRsbmc9dyh0KSx0aGlzLnJlZHJhdygpLHRoaXMuZmlyZShcIm1vdmVcIix7b2xkTGF0TG5nOmUsbGF0bG5nOnRoaXMuX2xhdGxuZ30pfSxnZXRMYXRMbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbGF0bG5nfSxzZXRSYWRpdXM6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMub3B0aW9ucy5yYWRpdXM9dGhpcy5fcmFkaXVzPXQsdGhpcy5yZWRyYXcoKX0sZ2V0UmFkaXVzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3JhZGl1c30sc2V0U3R5bGU6ZnVuY3Rpb24odCl7dmFyIGU9dCYmdC5yYWRpdXN8fHRoaXMuX3JhZGl1cztyZXR1cm4gbWkucHJvdG90eXBlLnNldFN0eWxlLmNhbGwodGhpcyx0KSx0aGlzLnNldFJhZGl1cyhlKSx0aGlzfSxfcHJvamVjdDpmdW5jdGlvbigpe3RoaXMuX3BvaW50PXRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKSx0aGlzLl91cGRhdGVCb3VuZHMoKX0sX3VwZGF0ZUJvdW5kczpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX3JhZGl1cyxlPXRoaXMuX3JhZGl1c1l8fHQsaT10aGlzLl9jbGlja1RvbGVyYW5jZSgpLHQ9W3QraSxlK2ldO3RoaXMuX3B4Qm91bmRzPW5ldyBmKHRoaXMuX3BvaW50LnN1YnRyYWN0KHQpLHRoaXMuX3BvaW50LmFkZCh0KSl9LF91cGRhdGU6ZnVuY3Rpb24oKXt0aGlzLl9tYXAmJnRoaXMuX3VwZGF0ZVBhdGgoKX0sX3VwZGF0ZVBhdGg6ZnVuY3Rpb24oKXt0aGlzLl9yZW5kZXJlci5fdXBkYXRlQ2lyY2xlKHRoaXMpfSxfZW1wdHk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcmFkaXVzJiYhdGhpcy5fcmVuZGVyZXIuX2JvdW5kcy5pbnRlcnNlY3RzKHRoaXMuX3B4Qm91bmRzKX0sX2NvbnRhaW5zUG9pbnQ6ZnVuY3Rpb24odCl7cmV0dXJuIHQuZGlzdGFuY2VUbyh0aGlzLl9wb2ludCk8PXRoaXMuX3JhZGl1cyt0aGlzLl9jbGlja1RvbGVyYW5jZSgpfX0pO3ZhciBnaT1maS5leHRlbmQoe2luaXRpYWxpemU6ZnVuY3Rpb24odCxlLGkpe2lmKGModGhpcyxlPVwibnVtYmVyXCI9PXR5cGVvZiBlP2woe30saSx7cmFkaXVzOmV9KTplKSx0aGlzLl9sYXRsbmc9dyh0KSxpc05hTih0aGlzLm9wdGlvbnMucmFkaXVzKSl0aHJvdyBuZXcgRXJyb3IoXCJDaXJjbGUgcmFkaXVzIGNhbm5vdCBiZSBOYU5cIik7dGhpcy5fbVJhZGl1cz10aGlzLm9wdGlvbnMucmFkaXVzfSxzZXRSYWRpdXM6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX21SYWRpdXM9dCx0aGlzLnJlZHJhdygpfSxnZXRSYWRpdXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbVJhZGl1c30sZ2V0Qm91bmRzOmZ1bmN0aW9uKCl7dmFyIHQ9W3RoaXMuX3JhZGl1cyx0aGlzLl9yYWRpdXNZfHx0aGlzLl9yYWRpdXNdO3JldHVybiBuZXcgcyh0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMuX3BvaW50LnN1YnRyYWN0KHQpKSx0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMuX3BvaW50LmFkZCh0KSkpfSxzZXRTdHlsZTptaS5wcm90b3R5cGUuc2V0U3R5bGUsX3Byb2plY3Q6ZnVuY3Rpb24oKXt2YXIgdCxlLGksbixvLHM9dGhpcy5fbGF0bG5nLmxuZyxyPXRoaXMuX2xhdGxuZy5sYXQsYT10aGlzLl9tYXAsaD1hLm9wdGlvbnMuY3JzO2guZGlzdGFuY2U9PT1zdC5kaXN0YW5jZT8obj1NYXRoLlBJLzE4MCxvPXRoaXMuX21SYWRpdXMvc3QuUi9uLHQ9YS5wcm9qZWN0KFtyK28sc10pLGU9YS5wcm9qZWN0KFtyLW8sc10pLGU9dC5hZGQoZSkuZGl2aWRlQnkoMiksaT1hLnVucHJvamVjdChlKS5sYXQsbj1NYXRoLmFjb3MoKE1hdGguY29zKG8qbiktTWF0aC5zaW4ocipuKSpNYXRoLnNpbihpKm4pKS8oTWF0aC5jb3MocipuKSpNYXRoLmNvcyhpKm4pKSkvbiwhaXNOYU4obikmJjAhPT1ufHwobj1vL01hdGguY29zKE1hdGguUEkvMTgwKnIpKSx0aGlzLl9wb2ludD1lLnN1YnRyYWN0KGEuZ2V0UGl4ZWxPcmlnaW4oKSksdGhpcy5fcmFkaXVzPWlzTmFOKG4pPzA6ZS54LWEucHJvamVjdChbaSxzLW5dKS54LHRoaXMuX3JhZGl1c1k9ZS55LXQueSk6KG89aC51bnByb2plY3QoaC5wcm9qZWN0KHRoaXMuX2xhdGxuZykuc3VidHJhY3QoW3RoaXMuX21SYWRpdXMsMF0pKSx0aGlzLl9wb2ludD1hLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpLHRoaXMuX3JhZGl1cz10aGlzLl9wb2ludC54LWEubGF0TG5nVG9MYXllclBvaW50KG8pLngpLHRoaXMuX3VwZGF0ZUJvdW5kcygpfX0pO3ZhciB2aT1taS5leHRlbmQoe29wdGlvbnM6e3Ntb290aEZhY3RvcjoxLG5vQ2xpcDohMX0saW5pdGlhbGl6ZTpmdW5jdGlvbih0LGUpe2ModGhpcyxlKSx0aGlzLl9zZXRMYXRMbmdzKHQpfSxnZXRMYXRMbmdzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2xhdGxuZ3N9LHNldExhdExuZ3M6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX3NldExhdExuZ3ModCksdGhpcy5yZWRyYXcoKX0saXNFbXB0eTpmdW5jdGlvbigpe3JldHVybiF0aGlzLl9sYXRsbmdzLmxlbmd0aH0sY2xvc2VzdExheWVyUG9pbnQ6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTEvMCxpPW51bGwsbj1uaSxvPTAscz10aGlzLl9wYXJ0cy5sZW5ndGg7bzxzO28rKylmb3IodmFyIHI9dGhpcy5fcGFydHNbb10sYT0xLGg9ci5sZW5ndGg7YTxoO2ErKyl7dmFyIGwsdSxjPW4odCxsPXJbYS0xXSx1PXJbYV0sITApO2M8ZSYmKGU9YyxpPW4odCxsLHUpKX1yZXR1cm4gaSYmKGkuZGlzdGFuY2U9TWF0aC5zcXJ0KGUpKSxpfSxnZXRDZW50ZXI6ZnVuY3Rpb24oKXtpZih0aGlzLl9tYXApcmV0dXJuIHNpKHRoaXMuX2RlZmF1bHRTaGFwZSgpLHRoaXMuX21hcC5vcHRpb25zLmNycyk7dGhyb3cgbmV3IEVycm9yKFwiTXVzdCBhZGQgbGF5ZXIgdG8gbWFwIGJlZm9yZSB1c2luZyBnZXRDZW50ZXIoKVwiKX0sZ2V0Qm91bmRzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2JvdW5kc30sYWRkTGF0TG5nOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIGU9ZXx8dGhpcy5fZGVmYXVsdFNoYXBlKCksdD13KHQpLGUucHVzaCh0KSx0aGlzLl9ib3VuZHMuZXh0ZW5kKHQpLHRoaXMucmVkcmF3KCl9LF9zZXRMYXRMbmdzOmZ1bmN0aW9uKHQpe3RoaXMuX2JvdW5kcz1uZXcgcyx0aGlzLl9sYXRsbmdzPXRoaXMuX2NvbnZlcnRMYXRMbmdzKHQpfSxfZGVmYXVsdFNoYXBlOmZ1bmN0aW9uKCl7cmV0dXJuIEkodGhpcy5fbGF0bG5ncyk/dGhpcy5fbGF0bG5nczp0aGlzLl9sYXRsbmdzWzBdfSxfY29udmVydExhdExuZ3M6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLGk9SSh0KSxuPTAsbz10Lmxlbmd0aDtuPG87bisrKWk/KGVbbl09dyh0W25dKSx0aGlzLl9ib3VuZHMuZXh0ZW5kKGVbbl0pKTplW25dPXRoaXMuX2NvbnZlcnRMYXRMbmdzKHRbbl0pO3JldHVybiBlfSxfcHJvamVjdDpmdW5jdGlvbigpe3ZhciB0PW5ldyBmO3RoaXMuX3JpbmdzPVtdLHRoaXMuX3Byb2plY3RMYXRsbmdzKHRoaXMuX2xhdGxuZ3MsdGhpcy5fcmluZ3MsdCksdGhpcy5fYm91bmRzLmlzVmFsaWQoKSYmdC5pc1ZhbGlkKCkmJih0aGlzLl9yYXdQeEJvdW5kcz10LHRoaXMuX3VwZGF0ZUJvdW5kcygpKX0sX3VwZGF0ZUJvdW5kczpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX2NsaWNrVG9sZXJhbmNlKCksdD1uZXcgcCh0LHQpO3RoaXMuX3Jhd1B4Qm91bmRzJiYodGhpcy5fcHhCb3VuZHM9bmV3IGYoW3RoaXMuX3Jhd1B4Qm91bmRzLm1pbi5zdWJ0cmFjdCh0KSx0aGlzLl9yYXdQeEJvdW5kcy5tYXguYWRkKHQpXSkpfSxfcHJvamVjdExhdGxuZ3M6ZnVuY3Rpb24odCxlLGkpe3ZhciBuLG8scz10WzBdaW5zdGFuY2VvZiB2LHI9dC5sZW5ndGg7aWYocyl7Zm9yKG89W10sbj0wO248cjtuKyspb1tuXT10aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRbbl0pLGkuZXh0ZW5kKG9bbl0pO2UucHVzaChvKX1lbHNlIGZvcihuPTA7bjxyO24rKyl0aGlzLl9wcm9qZWN0TGF0bG5ncyh0W25dLGUsaSl9LF9jbGlwUG9pbnRzOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fcmVuZGVyZXIuX2JvdW5kcztpZih0aGlzLl9wYXJ0cz1bXSx0aGlzLl9weEJvdW5kcyYmdGhpcy5fcHhCb3VuZHMuaW50ZXJzZWN0cyh0KSlpZih0aGlzLm9wdGlvbnMubm9DbGlwKXRoaXMuX3BhcnRzPXRoaXMuX3JpbmdzO2Vsc2UgZm9yKHZhciBlLGksbixvLHM9dGhpcy5fcGFydHMscj0wLGE9MCxoPXRoaXMuX3JpbmdzLmxlbmd0aDtyPGg7cisrKWZvcihlPTAsaT0obz10aGlzLl9yaW5nc1tyXSkubGVuZ3RoO2U8aS0xO2UrKykobj10aShvW2VdLG9bZSsxXSx0LGUsITApKSYmKHNbYV09c1thXXx8W10sc1thXS5wdXNoKG5bMF0pLG5bMV09PT1vW2UrMV0mJmUhPT1pLTJ8fChzW2FdLnB1c2goblsxXSksYSsrKSl9LF9zaW1wbGlmeVBvaW50czpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLl9wYXJ0cyxlPXRoaXMub3B0aW9ucy5zbW9vdGhGYWN0b3IsaT0wLG49dC5sZW5ndGg7aTxuO2krKyl0W2ldPSRlKHRbaV0sZSl9LF91cGRhdGU6ZnVuY3Rpb24oKXt0aGlzLl9tYXAmJih0aGlzLl9jbGlwUG9pbnRzKCksdGhpcy5fc2ltcGxpZnlQb2ludHMoKSx0aGlzLl91cGRhdGVQYXRoKCkpfSxfdXBkYXRlUGF0aDpmdW5jdGlvbigpe3RoaXMuX3JlbmRlcmVyLl91cGRhdGVQb2x5KHRoaXMpfSxfY29udGFpbnNQb2ludDpmdW5jdGlvbih0LGUpe3ZhciBpLG4sbyxzLHIsYSxoPXRoaXMuX2NsaWNrVG9sZXJhbmNlKCk7aWYodGhpcy5fcHhCb3VuZHMmJnRoaXMuX3B4Qm91bmRzLmNvbnRhaW5zKHQpKWZvcihpPTAscz10aGlzLl9wYXJ0cy5sZW5ndGg7aTxzO2krKylmb3Iobj0wLG89KHI9KGE9dGhpcy5fcGFydHNbaV0pLmxlbmd0aCktMTtuPHI7bz1uKyspaWYoKGV8fDAhPT1uKSYmUWUodCxhW29dLGFbbl0pPD1oKXJldHVybiEwO3JldHVybiExfX0pO3ZpLl9mbGF0PW9pO3ZhciB5aT12aS5leHRlbmQoe29wdGlvbnM6e2ZpbGw6ITB9LGlzRW1wdHk6ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy5fbGF0bG5ncy5sZW5ndGh8fCF0aGlzLl9sYXRsbmdzWzBdLmxlbmd0aH0sZ2V0Q2VudGVyOmZ1bmN0aW9uKCl7aWYodGhpcy5fbWFwKXJldHVybiBhaSh0aGlzLl9kZWZhdWx0U2hhcGUoKSx0aGlzLl9tYXAub3B0aW9ucy5jcnMpO3Rocm93IG5ldyBFcnJvcihcIk11c3QgYWRkIGxheWVyIHRvIG1hcCBiZWZvcmUgdXNpbmcgZ2V0Q2VudGVyKClcIil9LF9jb252ZXJ0TGF0TG5nczpmdW5jdGlvbih0KXt2YXIgdD12aS5wcm90b3R5cGUuX2NvbnZlcnRMYXRMbmdzLmNhbGwodGhpcyx0KSxlPXQubGVuZ3RoO3JldHVybiAyPD1lJiZ0WzBdaW5zdGFuY2VvZiB2JiZ0WzBdLmVxdWFscyh0W2UtMV0pJiZ0LnBvcCgpLHR9LF9zZXRMYXRMbmdzOmZ1bmN0aW9uKHQpe3ZpLnByb3RvdHlwZS5fc2V0TGF0TG5ncy5jYWxsKHRoaXMsdCksSSh0aGlzLl9sYXRsbmdzKSYmKHRoaXMuX2xhdGxuZ3M9W3RoaXMuX2xhdGxuZ3NdKX0sX2RlZmF1bHRTaGFwZTpmdW5jdGlvbigpe3JldHVybihJKHRoaXMuX2xhdGxuZ3NbMF0pP3RoaXMuX2xhdGxuZ3M6dGhpcy5fbGF0bG5nc1swXSlbMF19LF9jbGlwUG9pbnRzOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fcmVuZGVyZXIuX2JvdW5kcyxlPXRoaXMub3B0aW9ucy53ZWlnaHQsZT1uZXcgcChlLGUpLHQ9bmV3IGYodC5taW4uc3VidHJhY3QoZSksdC5tYXguYWRkKGUpKTtpZih0aGlzLl9wYXJ0cz1bXSx0aGlzLl9weEJvdW5kcyYmdGhpcy5fcHhCb3VuZHMuaW50ZXJzZWN0cyh0KSlpZih0aGlzLm9wdGlvbnMubm9DbGlwKXRoaXMuX3BhcnRzPXRoaXMuX3JpbmdzO2Vsc2UgZm9yKHZhciBpLG49MCxvPXRoaXMuX3JpbmdzLmxlbmd0aDtuPG87bisrKShpPXJpKHRoaXMuX3JpbmdzW25dLHQsITApKS5sZW5ndGgmJnRoaXMuX3BhcnRzLnB1c2goaSl9LF91cGRhdGVQYXRoOmZ1bmN0aW9uKCl7dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVBvbHkodGhpcywhMCl9LF9jb250YWluc1BvaW50OmZ1bmN0aW9uKHQpe3ZhciBlLGksbixvLHMscixhLGgsbD0hMTtpZighdGhpcy5fcHhCb3VuZHN8fCF0aGlzLl9weEJvdW5kcy5jb250YWlucyh0KSlyZXR1cm4hMTtmb3Iobz0wLGE9dGhpcy5fcGFydHMubGVuZ3RoO288YTtvKyspZm9yKHM9MCxyPShoPShlPXRoaXMuX3BhcnRzW29dKS5sZW5ndGgpLTE7czxoO3I9cysrKWk9ZVtzXSxuPWVbcl0saS55PnQueSE9bi55PnQueSYmdC54PChuLngtaS54KSoodC55LWkueSkvKG4ueS1pLnkpK2kueCYmKGw9IWwpO3JldHVybiBsfHx2aS5wcm90b3R5cGUuX2NvbnRhaW5zUG9pbnQuY2FsbCh0aGlzLHQsITApfX0pO3ZhciB4aT11aS5leHRlbmQoe2luaXRpYWxpemU6ZnVuY3Rpb24odCxlKXtjKHRoaXMsZSksdGhpcy5fbGF5ZXJzPXt9LHQmJnRoaXMuYWRkRGF0YSh0KX0sYWRkRGF0YTpmdW5jdGlvbih0KXt2YXIgZSxpLG4sbz1kKHQpP3Q6dC5mZWF0dXJlcztpZihvKXtmb3IoZT0wLGk9by5sZW5ndGg7ZTxpO2UrKykoKG49b1tlXSkuZ2VvbWV0cmllc3x8bi5nZW9tZXRyeXx8bi5mZWF0dXJlc3x8bi5jb29yZGluYXRlcykmJnRoaXMuYWRkRGF0YShuKTtyZXR1cm4gdGhpc312YXIgcyxyPXRoaXMub3B0aW9ucztyZXR1cm4oIXIuZmlsdGVyfHxyLmZpbHRlcih0KSkmJihzPXdpKHQscikpPyhzLmZlYXR1cmU9Q2kodCkscy5kZWZhdWx0T3B0aW9ucz1zLm9wdGlvbnMsdGhpcy5yZXNldFN0eWxlKHMpLHIub25FYWNoRmVhdHVyZSYmci5vbkVhY2hGZWF0dXJlKHQscyksdGhpcy5hZGRMYXllcihzKSk6dGhpc30scmVzZXRTdHlsZTpmdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dD90aGlzLmVhY2hMYXllcih0aGlzLnJlc2V0U3R5bGUsdGhpcyk6KHQub3B0aW9ucz1sKHt9LHQuZGVmYXVsdE9wdGlvbnMpLHRoaXMuX3NldExheWVyU3R5bGUodCx0aGlzLm9wdGlvbnMuc3R5bGUpLHRoaXMpfSxzZXRTdHlsZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24odCl7dGhpcy5fc2V0TGF5ZXJTdHlsZSh0LGUpfSx0aGlzKX0sX3NldExheWVyU3R5bGU6ZnVuY3Rpb24odCxlKXt0LnNldFN0eWxlJiYoXCJmdW5jdGlvblwiPT10eXBlb2YgZSYmKGU9ZSh0LmZlYXR1cmUpKSx0LnNldFN0eWxlKGUpKX19KTtmdW5jdGlvbiB3aSh0LGUpe3ZhciBpLG4sbyxzLHI9XCJGZWF0dXJlXCI9PT10LnR5cGU/dC5nZW9tZXRyeTp0LGE9cj9yLmNvb3JkaW5hdGVzOm51bGwsaD1bXSxsPWUmJmUucG9pbnRUb0xheWVyLHU9ZSYmZS5jb29yZHNUb0xhdExuZ3x8UGk7aWYoIWEmJiFyKXJldHVybiBudWxsO3N3aXRjaChyLnR5cGUpe2Nhc2VcIlBvaW50XCI6cmV0dXJuIGJpKGwsdCxpPXUoYSksZSk7Y2FzZVwiTXVsdGlQb2ludFwiOmZvcihvPTAscz1hLmxlbmd0aDtvPHM7bysrKWk9dShhW29dKSxoLnB1c2goYmkobCx0LGksZSkpO3JldHVybiBuZXcgdWkoaCk7Y2FzZVwiTGluZVN0cmluZ1wiOmNhc2VcIk11bHRpTGluZVN0cmluZ1wiOnJldHVybiBuPUxpKGEsXCJMaW5lU3RyaW5nXCI9PT1yLnR5cGU/MDoxLHUpLG5ldyB2aShuLGUpO2Nhc2VcIlBvbHlnb25cIjpjYXNlXCJNdWx0aVBvbHlnb25cIjpyZXR1cm4gbj1MaShhLFwiUG9seWdvblwiPT09ci50eXBlPzE6Mix1KSxuZXcgeWkobixlKTtjYXNlXCJHZW9tZXRyeUNvbGxlY3Rpb25cIjpmb3Iobz0wLHM9ci5nZW9tZXRyaWVzLmxlbmd0aDtvPHM7bysrKXt2YXIgYz13aSh7Z2VvbWV0cnk6ci5nZW9tZXRyaWVzW29dLHR5cGU6XCJGZWF0dXJlXCIscHJvcGVydGllczp0LnByb3BlcnRpZXN9LGUpO2MmJmgucHVzaChjKX1yZXR1cm4gbmV3IHVpKGgpO2Nhc2VcIkZlYXR1cmVDb2xsZWN0aW9uXCI6Zm9yKG89MCxzPXIuZmVhdHVyZXMubGVuZ3RoO288cztvKyspe3ZhciBkPXdpKHIuZmVhdHVyZXNbb10sZSk7ZCYmaC5wdXNoKGQpfXJldHVybiBuZXcgdWkoaCk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIEdlb0pTT04gb2JqZWN0LlwiKX19ZnVuY3Rpb24gYmkodCxlLGksbil7cmV0dXJuIHQ/dChlLGkpOm5ldyBwaShpLG4mJm4ubWFya2Vyc0luaGVyaXRPcHRpb25zJiZuKX1mdW5jdGlvbiBQaSh0KXtyZXR1cm4gbmV3IHYodFsxXSx0WzBdLHRbMl0pfWZ1bmN0aW9uIExpKHQsZSxpKXtmb3IodmFyIG4sbz1bXSxzPTAscj10Lmxlbmd0aDtzPHI7cysrKW49ZT9MaSh0W3NdLGUtMSxpKTooaXx8UGkpKHRbc10pLG8ucHVzaChuKTtyZXR1cm4gb31mdW5jdGlvbiBUaSh0LGUpe3JldHVybiB2b2lkIDAhPT0odD13KHQpKS5hbHQ/W2kodC5sbmcsZSksaSh0LmxhdCxlKSxpKHQuYWx0LGUpXTpbaSh0LmxuZyxlKSxpKHQubGF0LGUpXX1mdW5jdGlvbiBNaSh0LGUsaSxuKXtmb3IodmFyIG89W10scz0wLHI9dC5sZW5ndGg7czxyO3MrKylvLnB1c2goZT9NaSh0W3NdLEkodFtzXSk/MDplLTEsaSxuKTpUaSh0W3NdLG4pKTtyZXR1cm4hZSYmaSYmby5wdXNoKG9bMF0uc2xpY2UoKSksb31mdW5jdGlvbiB6aSh0LGUpe3JldHVybiB0LmZlYXR1cmU/bCh7fSx0LmZlYXR1cmUse2dlb21ldHJ5OmV9KTpDaShlKX1mdW5jdGlvbiBDaSh0KXtyZXR1cm5cIkZlYXR1cmVcIj09PXQudHlwZXx8XCJGZWF0dXJlQ29sbGVjdGlvblwiPT09dC50eXBlP3Q6e3R5cGU6XCJGZWF0dXJlXCIscHJvcGVydGllczp7fSxnZW9tZXRyeTp0fX1UdD17dG9HZW9KU09OOmZ1bmN0aW9uKHQpe3JldHVybiB6aSh0aGlzLHt0eXBlOlwiUG9pbnRcIixjb29yZGluYXRlczpUaSh0aGlzLmdldExhdExuZygpLHQpfSl9fTtmdW5jdGlvbiBaaSh0LGUpe3JldHVybiBuZXcgeGkodCxlKX1waS5pbmNsdWRlKFR0KSxnaS5pbmNsdWRlKFR0KSxmaS5pbmNsdWRlKFR0KSx2aS5pbmNsdWRlKHt0b0dlb0pTT046ZnVuY3Rpb24odCl7dmFyIGU9IUkodGhpcy5fbGF0bG5ncyk7cmV0dXJuIHppKHRoaXMse3R5cGU6KGU/XCJNdWx0aVwiOlwiXCIpK1wiTGluZVN0cmluZ1wiLGNvb3JkaW5hdGVzOk1pKHRoaXMuX2xhdGxuZ3MsZT8xOjAsITEsdCl9KX19KSx5aS5pbmNsdWRlKHt0b0dlb0pTT046ZnVuY3Rpb24odCl7dmFyIGU9IUkodGhpcy5fbGF0bG5ncyksaT1lJiYhSSh0aGlzLl9sYXRsbmdzWzBdKSx0PU1pKHRoaXMuX2xhdGxuZ3MsaT8yOmU/MTowLCEwLHQpO3JldHVybiB6aSh0aGlzLHt0eXBlOihpP1wiTXVsdGlcIjpcIlwiKStcIlBvbHlnb25cIixjb29yZGluYXRlczp0PWU/dDpbdF19KX19KSxsaS5pbmNsdWRlKHt0b011bHRpUG9pbnQ6ZnVuY3Rpb24oZSl7dmFyIGk9W107cmV0dXJuIHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uKHQpe2kucHVzaCh0LnRvR2VvSlNPTihlKS5nZW9tZXRyeS5jb29yZGluYXRlcyl9KSx6aSh0aGlzLHt0eXBlOlwiTXVsdGlQb2ludFwiLGNvb3JkaW5hdGVzOml9KX0sdG9HZW9KU09OOmZ1bmN0aW9uKGUpe3ZhciBpLG4sdD10aGlzLmZlYXR1cmUmJnRoaXMuZmVhdHVyZS5nZW9tZXRyeSYmdGhpcy5mZWF0dXJlLmdlb21ldHJ5LnR5cGU7cmV0dXJuXCJNdWx0aVBvaW50XCI9PT10P3RoaXMudG9NdWx0aVBvaW50KGUpOihpPVwiR2VvbWV0cnlDb2xsZWN0aW9uXCI9PT10LG49W10sdGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24odCl7dC50b0dlb0pTT04mJih0PXQudG9HZW9KU09OKGUpLGk/bi5wdXNoKHQuZ2VvbWV0cnkpOlwiRmVhdHVyZUNvbGxlY3Rpb25cIj09PSh0PUNpKHQpKS50eXBlP24ucHVzaC5hcHBseShuLHQuZmVhdHVyZXMpOm4ucHVzaCh0KSl9KSxpP3ppKHRoaXMse2dlb21ldHJpZXM6bix0eXBlOlwiR2VvbWV0cnlDb2xsZWN0aW9uXCJ9KTp7dHlwZTpcIkZlYXR1cmVDb2xsZWN0aW9uXCIsZmVhdHVyZXM6bn0pfX0pO3ZhciBNdD1aaSxTaT1vLmV4dGVuZCh7b3B0aW9uczp7b3BhY2l0eToxLGFsdDpcIlwiLGludGVyYWN0aXZlOiExLGNyb3NzT3JpZ2luOiExLGVycm9yT3ZlcmxheVVybDpcIlwiLHpJbmRleDoxLGNsYXNzTmFtZTpcIlwifSxpbml0aWFsaXplOmZ1bmN0aW9uKHQsZSxpKXt0aGlzLl91cmw9dCx0aGlzLl9ib3VuZHM9ZyhlKSxjKHRoaXMsaSl9LG9uQWRkOmZ1bmN0aW9uKCl7dGhpcy5faW1hZ2V8fCh0aGlzLl9pbml0SW1hZ2UoKSx0aGlzLm9wdGlvbnMub3BhY2l0eTwxJiZ0aGlzLl91cGRhdGVPcGFjaXR5KCkpLHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSYmKE0odGhpcy5faW1hZ2UsXCJsZWFmbGV0LWludGVyYWN0aXZlXCIpLHRoaXMuYWRkSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faW1hZ2UpKSx0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9pbWFnZSksdGhpcy5fcmVzZXQoKX0sb25SZW1vdmU6ZnVuY3Rpb24oKXtUKHRoaXMuX2ltYWdlKSx0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUmJnRoaXMucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faW1hZ2UpfSxzZXRPcGFjaXR5OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm9wdGlvbnMub3BhY2l0eT10LHRoaXMuX2ltYWdlJiZ0aGlzLl91cGRhdGVPcGFjaXR5KCksdGhpc30sc2V0U3R5bGU6ZnVuY3Rpb24odCl7cmV0dXJuIHQub3BhY2l0eSYmdGhpcy5zZXRPcGFjaXR5KHQub3BhY2l0eSksdGhpc30sYnJpbmdUb0Zyb250OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX21hcCYmZmUodGhpcy5faW1hZ2UpLHRoaXN9LGJyaW5nVG9CYWNrOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX21hcCYmZ2UodGhpcy5faW1hZ2UpLHRoaXN9LHNldFVybDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fdXJsPXQsdGhpcy5faW1hZ2UmJih0aGlzLl9pbWFnZS5zcmM9dCksdGhpc30sc2V0Qm91bmRzOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9ib3VuZHM9Zyh0KSx0aGlzLl9tYXAmJnRoaXMuX3Jlc2V0KCksdGhpc30sZ2V0RXZlbnRzOmZ1bmN0aW9uKCl7dmFyIHQ9e3pvb206dGhpcy5fcmVzZXQsdmlld3Jlc2V0OnRoaXMuX3Jlc2V0fTtyZXR1cm4gdGhpcy5fem9vbUFuaW1hdGVkJiYodC56b29tYW5pbT10aGlzLl9hbmltYXRlWm9vbSksdH0sc2V0WkluZGV4OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm9wdGlvbnMuekluZGV4PXQsdGhpcy5fdXBkYXRlWkluZGV4KCksdGhpc30sZ2V0Qm91bmRzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2JvdW5kc30sZ2V0RWxlbWVudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pbWFnZX0sX2luaXRJbWFnZTpmdW5jdGlvbigpe3ZhciB0PVwiSU1HXCI9PT10aGlzLl91cmwudGFnTmFtZSxlPXRoaXMuX2ltYWdlPXQ/dGhpcy5fdXJsOlAoXCJpbWdcIik7TShlLFwibGVhZmxldC1pbWFnZS1sYXllclwiKSx0aGlzLl96b29tQW5pbWF0ZWQmJk0oZSxcImxlYWZsZXQtem9vbS1hbmltYXRlZFwiKSx0aGlzLm9wdGlvbnMuY2xhc3NOYW1lJiZNKGUsdGhpcy5vcHRpb25zLmNsYXNzTmFtZSksZS5vbnNlbGVjdHN0YXJ0PXUsZS5vbm1vdXNlbW92ZT11LGUub25sb2FkPWEodGhpcy5maXJlLHRoaXMsXCJsb2FkXCIpLGUub25lcnJvcj1hKHRoaXMuX292ZXJsYXlPbkVycm9yLHRoaXMsXCJlcnJvclwiKSwhdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luJiZcIlwiIT09dGhpcy5vcHRpb25zLmNyb3NzT3JpZ2lufHwoZS5jcm9zc09yaWdpbj0hMD09PXRoaXMub3B0aW9ucy5jcm9zc09yaWdpbj9cIlwiOnRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiksdGhpcy5vcHRpb25zLnpJbmRleCYmdGhpcy5fdXBkYXRlWkluZGV4KCksdD90aGlzLl91cmw9ZS5zcmM6KGUuc3JjPXRoaXMuX3VybCxlLmFsdD10aGlzLm9wdGlvbnMuYWx0KX0sX2FuaW1hdGVab29tOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuX21hcC5nZXRab29tU2NhbGUodC56b29tKSx0PXRoaXMuX21hcC5fbGF0TG5nQm91bmRzVG9OZXdMYXllckJvdW5kcyh0aGlzLl9ib3VuZHMsdC56b29tLHQuY2VudGVyKS5taW47YmUodGhpcy5faW1hZ2UsdCxlKX0sX3Jlc2V0OmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5faW1hZ2UsZT1uZXcgZih0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2JvdW5kcy5nZXROb3J0aFdlc3QoKSksdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9ib3VuZHMuZ2V0U291dGhFYXN0KCkpKSxpPWUuZ2V0U2l6ZSgpO1oodCxlLm1pbiksdC5zdHlsZS53aWR0aD1pLngrXCJweFwiLHQuc3R5bGUuaGVpZ2h0PWkueStcInB4XCJ9LF91cGRhdGVPcGFjaXR5OmZ1bmN0aW9uKCl7Qyh0aGlzLl9pbWFnZSx0aGlzLm9wdGlvbnMub3BhY2l0eSl9LF91cGRhdGVaSW5kZXg6ZnVuY3Rpb24oKXt0aGlzLl9pbWFnZSYmdm9pZCAwIT09dGhpcy5vcHRpb25zLnpJbmRleCYmbnVsbCE9PXRoaXMub3B0aW9ucy56SW5kZXgmJih0aGlzLl9pbWFnZS5zdHlsZS56SW5kZXg9dGhpcy5vcHRpb25zLnpJbmRleCl9LF9vdmVybGF5T25FcnJvcjpmdW5jdGlvbigpe3RoaXMuZmlyZShcImVycm9yXCIpO3ZhciB0PXRoaXMub3B0aW9ucy5lcnJvck92ZXJsYXlVcmw7dCYmdGhpcy5fdXJsIT09dCYmKHRoaXMuX3VybD10LHRoaXMuX2ltYWdlLnNyYz10KX0sZ2V0Q2VudGVyOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2JvdW5kcy5nZXRDZW50ZXIoKX19KSxFaT1TaS5leHRlbmQoe29wdGlvbnM6e2F1dG9wbGF5OiEwLGxvb3A6ITAsa2VlcEFzcGVjdFJhdGlvOiEwLG11dGVkOiExLHBsYXlzSW5saW5lOiEwfSxfaW5pdEltYWdlOmZ1bmN0aW9uKCl7dmFyIHQ9XCJWSURFT1wiPT09dGhpcy5fdXJsLnRhZ05hbWUsZT10aGlzLl9pbWFnZT10P3RoaXMuX3VybDpQKFwidmlkZW9cIik7aWYoTShlLFwibGVhZmxldC1pbWFnZS1sYXllclwiKSx0aGlzLl96b29tQW5pbWF0ZWQmJk0oZSxcImxlYWZsZXQtem9vbS1hbmltYXRlZFwiKSx0aGlzLm9wdGlvbnMuY2xhc3NOYW1lJiZNKGUsdGhpcy5vcHRpb25zLmNsYXNzTmFtZSksZS5vbnNlbGVjdHN0YXJ0PXUsZS5vbm1vdXNlbW92ZT11LGUub25sb2FkZWRkYXRhPWEodGhpcy5maXJlLHRoaXMsXCJsb2FkXCIpLHQpe2Zvcih2YXIgaT1lLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic291cmNlXCIpLG49W10sbz0wO288aS5sZW5ndGg7bysrKW4ucHVzaChpW29dLnNyYyk7dGhpcy5fdXJsPTA8aS5sZW5ndGg/bjpbZS5zcmNdfWVsc2V7ZCh0aGlzLl91cmwpfHwodGhpcy5fdXJsPVt0aGlzLl91cmxdKSwhdGhpcy5vcHRpb25zLmtlZXBBc3BlY3RSYXRpbyYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUuc3R5bGUsXCJvYmplY3RGaXRcIikmJihlLnN0eWxlLm9iamVjdEZpdD1cImZpbGxcIiksZS5hdXRvcGxheT0hIXRoaXMub3B0aW9ucy5hdXRvcGxheSxlLmxvb3A9ISF0aGlzLm9wdGlvbnMubG9vcCxlLm11dGVkPSEhdGhpcy5vcHRpb25zLm11dGVkLGUucGxheXNJbmxpbmU9ISF0aGlzLm9wdGlvbnMucGxheXNJbmxpbmU7Zm9yKHZhciBzPTA7czx0aGlzLl91cmwubGVuZ3RoO3MrKyl7dmFyIHI9UChcInNvdXJjZVwiKTtyLnNyYz10aGlzLl91cmxbc10sZS5hcHBlbmRDaGlsZChyKX19fX0pO3ZhciBraT1TaS5leHRlbmQoe19pbml0SW1hZ2U6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9pbWFnZT10aGlzLl91cmw7TSh0LFwibGVhZmxldC1pbWFnZS1sYXllclwiKSx0aGlzLl96b29tQW5pbWF0ZWQmJk0odCxcImxlYWZsZXQtem9vbS1hbmltYXRlZFwiKSx0aGlzLm9wdGlvbnMuY2xhc3NOYW1lJiZNKHQsdGhpcy5vcHRpb25zLmNsYXNzTmFtZSksdC5vbnNlbGVjdHN0YXJ0PXUsdC5vbm1vdXNlbW92ZT11fX0pO3ZhciBPaT1vLmV4dGVuZCh7b3B0aW9uczp7aW50ZXJhY3RpdmU6ITEsb2Zmc2V0OlswLDBdLGNsYXNzTmFtZTpcIlwiLHBhbmU6dm9pZCAwLGNvbnRlbnQ6XCJcIn0saW5pdGlhbGl6ZTpmdW5jdGlvbih0LGUpe3QmJih0IGluc3RhbmNlb2Ygdnx8ZCh0KSk/KHRoaXMuX2xhdGxuZz13KHQpLGModGhpcyxlKSk6KGModGhpcyx0KSx0aGlzLl9zb3VyY2U9ZSksdGhpcy5vcHRpb25zLmNvbnRlbnQmJih0aGlzLl9jb250ZW50PXRoaXMub3B0aW9ucy5jb250ZW50KX0sb3Blbk9uOmZ1bmN0aW9uKHQpe3JldHVybih0PWFyZ3VtZW50cy5sZW5ndGg/dDp0aGlzLl9zb3VyY2UuX21hcCkuaGFzTGF5ZXIodGhpcyl8fHQuYWRkTGF5ZXIodGhpcyksdGhpc30sY2xvc2U6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbWFwJiZ0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcyksdGhpc30sdG9nZ2xlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9tYXA/dGhpcy5jbG9zZSgpOihhcmd1bWVudHMubGVuZ3RoP3RoaXMuX3NvdXJjZT10OnQ9dGhpcy5fc291cmNlLHRoaXMuX3ByZXBhcmVPcGVuKCksdGhpcy5vcGVuT24odC5fbWFwKSksdGhpc30sb25BZGQ6ZnVuY3Rpb24odCl7dGhpcy5fem9vbUFuaW1hdGVkPXQuX3pvb21BbmltYXRlZCx0aGlzLl9jb250YWluZXJ8fHRoaXMuX2luaXRMYXlvdXQoKSx0Ll9mYWRlQW5pbWF0ZWQmJkModGhpcy5fY29udGFpbmVyLDApLGNsZWFyVGltZW91dCh0aGlzLl9yZW1vdmVUaW1lb3V0KSx0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpLHRoaXMudXBkYXRlKCksdC5fZmFkZUFuaW1hdGVkJiZDKHRoaXMuX2NvbnRhaW5lciwxKSx0aGlzLmJyaW5nVG9Gcm9udCgpLHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSYmKE0odGhpcy5fY29udGFpbmVyLFwibGVhZmxldC1pbnRlcmFjdGl2ZVwiKSx0aGlzLmFkZEludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2NvbnRhaW5lcikpfSxvblJlbW92ZTpmdW5jdGlvbih0KXt0Ll9mYWRlQW5pbWF0ZWQ/KEModGhpcy5fY29udGFpbmVyLDApLHRoaXMuX3JlbW92ZVRpbWVvdXQ9c2V0VGltZW91dChhKFQsdm9pZCAwLHRoaXMuX2NvbnRhaW5lciksMjAwKSk6VCh0aGlzLl9jb250YWluZXIpLHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSYmKHoodGhpcy5fY29udGFpbmVyLFwibGVhZmxldC1pbnRlcmFjdGl2ZVwiKSx0aGlzLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2NvbnRhaW5lcikpfSxnZXRMYXRMbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbGF0bG5nfSxzZXRMYXRMbmc6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX2xhdGxuZz13KHQpLHRoaXMuX21hcCYmKHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCksdGhpcy5fYWRqdXN0UGFuKCkpLHRoaXN9LGdldENvbnRlbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fY29udGVudH0sc2V0Q29udGVudDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fY29udGVudD10LHRoaXMudXBkYXRlKCksdGhpc30sZ2V0RWxlbWVudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9jb250YWluZXJ9LHVwZGF0ZTpmdW5jdGlvbigpe3RoaXMuX21hcCYmKHRoaXMuX2NvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5PVwiaGlkZGVuXCIsdGhpcy5fdXBkYXRlQ29udGVudCgpLHRoaXMuX3VwZGF0ZUxheW91dCgpLHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCksdGhpcy5fY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHk9XCJcIix0aGlzLl9hZGp1c3RQYW4oKSl9LGdldEV2ZW50czpmdW5jdGlvbigpe3ZhciB0PXt6b29tOnRoaXMuX3VwZGF0ZVBvc2l0aW9uLHZpZXdyZXNldDp0aGlzLl91cGRhdGVQb3NpdGlvbn07cmV0dXJuIHRoaXMuX3pvb21BbmltYXRlZCYmKHQuem9vbWFuaW09dGhpcy5fYW5pbWF0ZVpvb20pLHR9LGlzT3BlbjpmdW5jdGlvbigpe3JldHVybiEhdGhpcy5fbWFwJiZ0aGlzLl9tYXAuaGFzTGF5ZXIodGhpcyl9LGJyaW5nVG9Gcm9udDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9tYXAmJmZlKHRoaXMuX2NvbnRhaW5lciksdGhpc30sYnJpbmdUb0JhY2s6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbWFwJiZnZSh0aGlzLl9jb250YWluZXIpLHRoaXN9LF9wcmVwYXJlT3BlbjpmdW5jdGlvbih0KXtpZighKGk9dGhpcy5fc291cmNlKS5fbWFwKXJldHVybiExO2lmKGkgaW5zdGFuY2VvZiB1aSl7dmFyIGUsaT1udWxsLG49dGhpcy5fc291cmNlLl9sYXllcnM7Zm9yKGUgaW4gbilpZihuW2VdLl9tYXApe2k9bltlXTticmVha31pZighaSlyZXR1cm4hMTt0aGlzLl9zb3VyY2U9aX1pZighdClpZihpLmdldENlbnRlcil0PWkuZ2V0Q2VudGVyKCk7ZWxzZSBpZihpLmdldExhdExuZyl0PWkuZ2V0TGF0TG5nKCk7ZWxzZXtpZighaS5nZXRCb3VuZHMpdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGdldCBzb3VyY2UgbGF5ZXIgTGF0TG5nLlwiKTt0PWkuZ2V0Qm91bmRzKCkuZ2V0Q2VudGVyKCl9cmV0dXJuIHRoaXMuc2V0TGF0TG5nKHQpLHRoaXMuX21hcCYmdGhpcy51cGRhdGUoKSwhMH0sX3VwZGF0ZUNvbnRlbnQ6ZnVuY3Rpb24oKXtpZih0aGlzLl9jb250ZW50KXt2YXIgdD10aGlzLl9jb250ZW50Tm9kZSxlPVwiZnVuY3Rpb25cIj09dHlwZW9mIHRoaXMuX2NvbnRlbnQ/dGhpcy5fY29udGVudCh0aGlzLl9zb3VyY2V8fHRoaXMpOnRoaXMuX2NvbnRlbnQ7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpdC5pbm5lckhUTUw9ZTtlbHNle2Zvcig7dC5oYXNDaGlsZE5vZGVzKCk7KXQucmVtb3ZlQ2hpbGQodC5maXJzdENoaWxkKTt0LmFwcGVuZENoaWxkKGUpfXRoaXMuZmlyZShcImNvbnRlbnR1cGRhdGVcIil9fSxfdXBkYXRlUG9zaXRpb246ZnVuY3Rpb24oKXt2YXIgdCxlLGk7dGhpcy5fbWFwJiYoZT10aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyksdD1tKHRoaXMub3B0aW9ucy5vZmZzZXQpLGk9dGhpcy5fZ2V0QW5jaG9yKCksdGhpcy5fem9vbUFuaW1hdGVkP1oodGhpcy5fY29udGFpbmVyLGUuYWRkKGkpKTp0PXQuYWRkKGUpLmFkZChpKSxlPXRoaXMuX2NvbnRhaW5lckJvdHRvbT0tdC55LGk9dGhpcy5fY29udGFpbmVyTGVmdD0tTWF0aC5yb3VuZCh0aGlzLl9jb250YWluZXJXaWR0aC8yKSt0LngsdGhpcy5fY29udGFpbmVyLnN0eWxlLmJvdHRvbT1lK1wicHhcIix0aGlzLl9jb250YWluZXIuc3R5bGUubGVmdD1pK1wicHhcIil9LF9nZXRBbmNob3I6ZnVuY3Rpb24oKXtyZXR1cm5bMCwwXX19KSxBaT0oQS5pbmNsdWRlKHtfaW5pdE92ZXJsYXk6ZnVuY3Rpb24odCxlLGksbil7dmFyIG89ZTtyZXR1cm4gbyBpbnN0YW5jZW9mIHR8fChvPW5ldyB0KG4pLnNldENvbnRlbnQoZSkpLGkmJm8uc2V0TGF0TG5nKGkpLG99fSksby5pbmNsdWRlKHtfaW5pdE92ZXJsYXk6ZnVuY3Rpb24odCxlLGksbil7dmFyIG89aTtyZXR1cm4gbyBpbnN0YW5jZW9mIHQ/KGMobyxuKSxvLl9zb3VyY2U9dGhpcyk6KG89ZSYmIW4/ZTpuZXcgdChuLHRoaXMpKS5zZXRDb250ZW50KGkpLG99fSksT2kuZXh0ZW5kKHtvcHRpb25zOntwYW5lOlwicG9wdXBQYW5lXCIsb2Zmc2V0OlswLDddLG1heFdpZHRoOjMwMCxtaW5XaWR0aDo1MCxtYXhIZWlnaHQ6bnVsbCxhdXRvUGFuOiEwLGF1dG9QYW5QYWRkaW5nVG9wTGVmdDpudWxsLGF1dG9QYW5QYWRkaW5nQm90dG9tUmlnaHQ6bnVsbCxhdXRvUGFuUGFkZGluZzpbNSw1XSxrZWVwSW5WaWV3OiExLGNsb3NlQnV0dG9uOiEwLGF1dG9DbG9zZTohMCxjbG9zZU9uRXNjYXBlS2V5OiEwLGNsYXNzTmFtZTpcIlwifSxvcGVuT246ZnVuY3Rpb24odCl7cmV0dXJuISh0PWFyZ3VtZW50cy5sZW5ndGg/dDp0aGlzLl9zb3VyY2UuX21hcCkuaGFzTGF5ZXIodGhpcykmJnQuX3BvcHVwJiZ0Ll9wb3B1cC5vcHRpb25zLmF1dG9DbG9zZSYmdC5yZW1vdmVMYXllcih0Ll9wb3B1cCksdC5fcG9wdXA9dGhpcyxPaS5wcm90b3R5cGUub3Blbk9uLmNhbGwodGhpcyx0KX0sb25BZGQ6ZnVuY3Rpb24odCl7T2kucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcyx0KSx0LmZpcmUoXCJwb3B1cG9wZW5cIix7cG9wdXA6dGhpc30pLHRoaXMuX3NvdXJjZSYmKHRoaXMuX3NvdXJjZS5maXJlKFwicG9wdXBvcGVuXCIse3BvcHVwOnRoaXN9LCEwKSx0aGlzLl9zb3VyY2UgaW5zdGFuY2VvZiBtaXx8dGhpcy5fc291cmNlLm9uKFwicHJlY2xpY2tcIixBZSkpfSxvblJlbW92ZTpmdW5jdGlvbih0KXtPaS5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLHQpLHQuZmlyZShcInBvcHVwY2xvc2VcIix7cG9wdXA6dGhpc30pLHRoaXMuX3NvdXJjZSYmKHRoaXMuX3NvdXJjZS5maXJlKFwicG9wdXBjbG9zZVwiLHtwb3B1cDp0aGlzfSwhMCksdGhpcy5fc291cmNlIGluc3RhbmNlb2YgbWl8fHRoaXMuX3NvdXJjZS5vZmYoXCJwcmVjbGlja1wiLEFlKSl9LGdldEV2ZW50czpmdW5jdGlvbigpe3ZhciB0PU9pLnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtyZXR1cm4odm9pZCAwIT09dGhpcy5vcHRpb25zLmNsb3NlT25DbGljaz90aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrOnRoaXMuX21hcC5vcHRpb25zLmNsb3NlUG9wdXBPbkNsaWNrKSYmKHQucHJlY2xpY2s9dGhpcy5jbG9zZSksdGhpcy5vcHRpb25zLmtlZXBJblZpZXcmJih0Lm1vdmVlbmQ9dGhpcy5fYWRqdXN0UGFuKSx0fSxfaW5pdExheW91dDpmdW5jdGlvbigpe3ZhciB0PVwibGVhZmxldC1wb3B1cFwiLGU9dGhpcy5fY29udGFpbmVyPVAoXCJkaXZcIix0K1wiIFwiKyh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lfHxcIlwiKStcIiBsZWFmbGV0LXpvb20tYW5pbWF0ZWRcIiksaT10aGlzLl93cmFwcGVyPVAoXCJkaXZcIix0K1wiLWNvbnRlbnQtd3JhcHBlclwiLGUpO3RoaXMuX2NvbnRlbnROb2RlPVAoXCJkaXZcIix0K1wiLWNvbnRlbnRcIixpKSxJZShlKSxCZSh0aGlzLl9jb250ZW50Tm9kZSksUyhlLFwiY29udGV4dG1lbnVcIixBZSksdGhpcy5fdGlwQ29udGFpbmVyPVAoXCJkaXZcIix0K1wiLXRpcC1jb250YWluZXJcIixlKSx0aGlzLl90aXA9UChcImRpdlwiLHQrXCItdGlwXCIsdGhpcy5fdGlwQ29udGFpbmVyKSx0aGlzLm9wdGlvbnMuY2xvc2VCdXR0b24mJigoaT10aGlzLl9jbG9zZUJ1dHRvbj1QKFwiYVwiLHQrXCItY2xvc2UtYnV0dG9uXCIsZSkpLnNldEF0dHJpYnV0ZShcInJvbGVcIixcImJ1dHRvblwiKSxpLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIixcIkNsb3NlIHBvcHVwXCIpLGkuaHJlZj1cIiNjbG9zZVwiLGkuaW5uZXJIVE1MPSc8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mIzIxNTs8L3NwYW4+JyxTKGksXCJjbGlja1wiLGZ1bmN0aW9uKHQpe08odCksdGhpcy5jbG9zZSgpfSx0aGlzKSl9LF91cGRhdGVMYXlvdXQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9jb250ZW50Tm9kZSxlPXQuc3R5bGUsaT0oZS53aWR0aD1cIlwiLGUud2hpdGVTcGFjZT1cIm5vd3JhcFwiLHQub2Zmc2V0V2lkdGgpLGk9TWF0aC5taW4oaSx0aGlzLm9wdGlvbnMubWF4V2lkdGgpLGk9KGk9TWF0aC5tYXgoaSx0aGlzLm9wdGlvbnMubWluV2lkdGgpLGUud2lkdGg9aSsxK1wicHhcIixlLndoaXRlU3BhY2U9XCJcIixlLmhlaWdodD1cIlwiLHQub2Zmc2V0SGVpZ2h0KSxuPXRoaXMub3B0aW9ucy5tYXhIZWlnaHQsbz1cImxlYWZsZXQtcG9wdXAtc2Nyb2xsZWRcIjsobiYmbjxpPyhlLmhlaWdodD1uK1wicHhcIixNKTp6KSh0LG8pLHRoaXMuX2NvbnRhaW5lcldpZHRoPXRoaXMuX2NvbnRhaW5lci5vZmZzZXRXaWR0aH0sX2FuaW1hdGVab29tOmZ1bmN0aW9uKHQpe3ZhciB0PXRoaXMuX21hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KHRoaXMuX2xhdGxuZyx0Lnpvb20sdC5jZW50ZXIpLGU9dGhpcy5fZ2V0QW5jaG9yKCk7Wih0aGlzLl9jb250YWluZXIsdC5hZGQoZSkpfSxfYWRqdXN0UGFuOmZ1bmN0aW9uKCl7dmFyIHQsZSxpLG4sbyxzLHIsYTt0aGlzLm9wdGlvbnMuYXV0b1BhbiYmKHRoaXMuX21hcC5fcGFuQW5pbSYmdGhpcy5fbWFwLl9wYW5BbmltLnN0b3AoKSx0aGlzLl9hdXRvcGFubmluZz90aGlzLl9hdXRvcGFubmluZz0hMToodD10aGlzLl9tYXAsZT1wYXJzZUludChwZSh0aGlzLl9jb250YWluZXIsXCJtYXJnaW5Cb3R0b21cIiksMTApfHwwLGU9dGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodCtlLGE9dGhpcy5fY29udGFpbmVyV2lkdGgsKGk9bmV3IHAodGhpcy5fY29udGFpbmVyTGVmdCwtZS10aGlzLl9jb250YWluZXJCb3R0b20pKS5fYWRkKFBlKHRoaXMuX2NvbnRhaW5lcikpLGk9dC5sYXllclBvaW50VG9Db250YWluZXJQb2ludChpKSxvPW0odGhpcy5vcHRpb25zLmF1dG9QYW5QYWRkaW5nKSxuPW0odGhpcy5vcHRpb25zLmF1dG9QYW5QYWRkaW5nVG9wTGVmdHx8byksbz1tKHRoaXMub3B0aW9ucy5hdXRvUGFuUGFkZGluZ0JvdHRvbVJpZ2h0fHxvKSxzPXQuZ2V0U2l6ZSgpLHI9MCxpLngrYStvLng+cy54JiYocj1pLngrYS1zLngrby54KSxpLngtci1uLng8KGE9MCkmJihyPWkueC1uLngpLGkueStlK28ueT5zLnkmJihhPWkueStlLXMueStvLnkpLGkueS1hLW4ueTwwJiYoYT1pLnktbi55KSwocnx8YSkmJih0aGlzLm9wdGlvbnMua2VlcEluVmlldyYmKHRoaXMuX2F1dG9wYW5uaW5nPSEwKSx0LmZpcmUoXCJhdXRvcGFuc3RhcnRcIikucGFuQnkoW3IsYV0pKSkpfSxfZ2V0QW5jaG9yOmZ1bmN0aW9uKCl7cmV0dXJuIG0odGhpcy5fc291cmNlJiZ0aGlzLl9zb3VyY2UuX2dldFBvcHVwQW5jaG9yP3RoaXMuX3NvdXJjZS5fZ2V0UG9wdXBBbmNob3IoKTpbMCwwXSl9fSkpLEJpPShBLm1lcmdlT3B0aW9ucyh7Y2xvc2VQb3B1cE9uQ2xpY2s6ITB9KSxBLmluY2x1ZGUoe29wZW5Qb3B1cDpmdW5jdGlvbih0LGUsaSl7cmV0dXJuIHRoaXMuX2luaXRPdmVybGF5KEFpLHQsZSxpKS5vcGVuT24odGhpcyksdGhpc30sY2xvc2VQb3B1cDpmdW5jdGlvbih0KXtyZXR1cm4odD1hcmd1bWVudHMubGVuZ3RoP3Q6dGhpcy5fcG9wdXApJiZ0LmNsb3NlKCksdGhpc319KSxvLmluY2x1ZGUoe2JpbmRQb3B1cDpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLl9wb3B1cD10aGlzLl9pbml0T3ZlcmxheShBaSx0aGlzLl9wb3B1cCx0LGUpLHRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZHx8KHRoaXMub24oe2NsaWNrOnRoaXMuX29wZW5Qb3B1cCxrZXlwcmVzczp0aGlzLl9vbktleVByZXNzLHJlbW92ZTp0aGlzLmNsb3NlUG9wdXAsbW92ZTp0aGlzLl9tb3ZlUG9wdXB9KSx0aGlzLl9wb3B1cEhhbmRsZXJzQWRkZWQ9ITApLHRoaXN9LHVuYmluZFBvcHVwOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3BvcHVwJiYodGhpcy5vZmYoe2NsaWNrOnRoaXMuX29wZW5Qb3B1cCxrZXlwcmVzczp0aGlzLl9vbktleVByZXNzLHJlbW92ZTp0aGlzLmNsb3NlUG9wdXAsbW92ZTp0aGlzLl9tb3ZlUG9wdXB9KSx0aGlzLl9wb3B1cEhhbmRsZXJzQWRkZWQ9ITEsdGhpcy5fcG9wdXA9bnVsbCksdGhpc30sb3BlblBvcHVwOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9wb3B1cCYmKHRoaXMgaW5zdGFuY2VvZiB1aXx8KHRoaXMuX3BvcHVwLl9zb3VyY2U9dGhpcyksdGhpcy5fcG9wdXAuX3ByZXBhcmVPcGVuKHR8fHRoaXMuX2xhdGxuZykmJnRoaXMuX3BvcHVwLm9wZW5Pbih0aGlzLl9tYXApKSx0aGlzfSxjbG9zZVBvcHVwOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3BvcHVwJiZ0aGlzLl9wb3B1cC5jbG9zZSgpLHRoaXN9LHRvZ2dsZVBvcHVwOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3BvcHVwJiZ0aGlzLl9wb3B1cC50b2dnbGUodGhpcyksdGhpc30saXNQb3B1cE9wZW46ZnVuY3Rpb24oKXtyZXR1cm4hIXRoaXMuX3BvcHVwJiZ0aGlzLl9wb3B1cC5pc09wZW4oKX0sc2V0UG9wdXBDb250ZW50OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9wb3B1cCYmdGhpcy5fcG9wdXAuc2V0Q29udGVudCh0KSx0aGlzfSxnZXRQb3B1cDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9wb3B1cH0sX29wZW5Qb3B1cDpmdW5jdGlvbih0KXt2YXIgZTt0aGlzLl9wb3B1cCYmdGhpcy5fbWFwJiYoUmUodCksZT10LmxheWVyfHx0LnRhcmdldCx0aGlzLl9wb3B1cC5fc291cmNlIT09ZXx8ZSBpbnN0YW5jZW9mIG1pPyh0aGlzLl9wb3B1cC5fc291cmNlPWUsdGhpcy5vcGVuUG9wdXAodC5sYXRsbmcpKTp0aGlzLl9tYXAuaGFzTGF5ZXIodGhpcy5fcG9wdXApP3RoaXMuY2xvc2VQb3B1cCgpOnRoaXMub3BlblBvcHVwKHQubGF0bG5nKSl9LF9tb3ZlUG9wdXA6ZnVuY3Rpb24odCl7dGhpcy5fcG9wdXAuc2V0TGF0TG5nKHQubGF0bG5nKX0sX29uS2V5UHJlc3M6ZnVuY3Rpb24odCl7MTM9PT10Lm9yaWdpbmFsRXZlbnQua2V5Q29kZSYmdGhpcy5fb3BlblBvcHVwKHQpfX0pLE9pLmV4dGVuZCh7b3B0aW9uczp7cGFuZTpcInRvb2x0aXBQYW5lXCIsb2Zmc2V0OlswLDBdLGRpcmVjdGlvbjpcImF1dG9cIixwZXJtYW5lbnQ6ITEsc3RpY2t5OiExLG9wYWNpdHk6Ljl9LG9uQWRkOmZ1bmN0aW9uKHQpe09pLnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsdCksdGhpcy5zZXRPcGFjaXR5KHRoaXMub3B0aW9ucy5vcGFjaXR5KSx0LmZpcmUoXCJ0b29sdGlwb3BlblwiLHt0b29sdGlwOnRoaXN9KSx0aGlzLl9zb3VyY2UmJih0aGlzLmFkZEV2ZW50UGFyZW50KHRoaXMuX3NvdXJjZSksdGhpcy5fc291cmNlLmZpcmUoXCJ0b29sdGlwb3BlblwiLHt0b29sdGlwOnRoaXN9LCEwKSl9LG9uUmVtb3ZlOmZ1bmN0aW9uKHQpe09pLnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsdCksdC5maXJlKFwidG9vbHRpcGNsb3NlXCIse3Rvb2x0aXA6dGhpc30pLHRoaXMuX3NvdXJjZSYmKHRoaXMucmVtb3ZlRXZlbnRQYXJlbnQodGhpcy5fc291cmNlKSx0aGlzLl9zb3VyY2UuZmlyZShcInRvb2x0aXBjbG9zZVwiLHt0b29sdGlwOnRoaXN9LCEwKSl9LGdldEV2ZW50czpmdW5jdGlvbigpe3ZhciB0PU9pLnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtyZXR1cm4gdGhpcy5vcHRpb25zLnBlcm1hbmVudHx8KHQucHJlY2xpY2s9dGhpcy5jbG9zZSksdH0sX2luaXRMYXlvdXQ6ZnVuY3Rpb24oKXt2YXIgdD1cImxlYWZsZXQtdG9vbHRpcCBcIisodGhpcy5vcHRpb25zLmNsYXNzTmFtZXx8XCJcIikrXCIgbGVhZmxldC16b29tLVwiKyh0aGlzLl96b29tQW5pbWF0ZWQ/XCJhbmltYXRlZFwiOlwiaGlkZVwiKTt0aGlzLl9jb250ZW50Tm9kZT10aGlzLl9jb250YWluZXI9UChcImRpdlwiLHQpLHRoaXMuX2NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsXCJ0b29sdGlwXCIpLHRoaXMuX2NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJpZFwiLFwibGVhZmxldC10b29sdGlwLVwiK2godGhpcykpfSxfdXBkYXRlTGF5b3V0OmZ1bmN0aW9uKCl7fSxfYWRqdXN0UGFuOmZ1bmN0aW9uKCl7fSxfc2V0UG9zaXRpb246ZnVuY3Rpb24odCl7dmFyIGUsaT10aGlzLl9tYXAsbj10aGlzLl9jb250YWluZXIsbz1pLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQoaS5nZXRDZW50ZXIoKSksaT1pLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHQpLHM9dGhpcy5vcHRpb25zLmRpcmVjdGlvbixyPW4ub2Zmc2V0V2lkdGgsYT1uLm9mZnNldEhlaWdodCxoPW0odGhpcy5vcHRpb25zLm9mZnNldCksbD10aGlzLl9nZXRBbmNob3IoKSxpPVwidG9wXCI9PT1zPyhlPXIvMixhKTpcImJvdHRvbVwiPT09cz8oZT1yLzIsMCk6KGU9XCJjZW50ZXJcIj09PXM/ci8yOlwicmlnaHRcIj09PXM/MDpcImxlZnRcIj09PXM/cjppLng8by54PyhzPVwicmlnaHRcIiwwKToocz1cImxlZnRcIixyKzIqKGgueCtsLngpKSxhLzIpO3Q9dC5zdWJ0cmFjdChtKGUsaSwhMCkpLmFkZChoKS5hZGQobCkseihuLFwibGVhZmxldC10b29sdGlwLXJpZ2h0XCIpLHoobixcImxlYWZsZXQtdG9vbHRpcC1sZWZ0XCIpLHoobixcImxlYWZsZXQtdG9vbHRpcC10b3BcIikseihuLFwibGVhZmxldC10b29sdGlwLWJvdHRvbVwiKSxNKG4sXCJsZWFmbGV0LXRvb2x0aXAtXCIrcyksWihuLHQpfSxfdXBkYXRlUG9zaXRpb246ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyk7dGhpcy5fc2V0UG9zaXRpb24odCl9LHNldE9wYWNpdHk6ZnVuY3Rpb24odCl7dGhpcy5vcHRpb25zLm9wYWNpdHk9dCx0aGlzLl9jb250YWluZXImJkModGhpcy5fY29udGFpbmVyLHQpfSxfYW5pbWF0ZVpvb206ZnVuY3Rpb24odCl7dD10aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsdC56b29tLHQuY2VudGVyKTt0aGlzLl9zZXRQb3NpdGlvbih0KX0sX2dldEFuY2hvcjpmdW5jdGlvbigpe3JldHVybiBtKHRoaXMuX3NvdXJjZSYmdGhpcy5fc291cmNlLl9nZXRUb29sdGlwQW5jaG9yJiYhdGhpcy5vcHRpb25zLnN0aWNreT90aGlzLl9zb3VyY2UuX2dldFRvb2x0aXBBbmNob3IoKTpbMCwwXSl9fSkpLElpPShBLmluY2x1ZGUoe29wZW5Ub29sdGlwOmZ1bmN0aW9uKHQsZSxpKXtyZXR1cm4gdGhpcy5faW5pdE92ZXJsYXkoQmksdCxlLGkpLm9wZW5Pbih0aGlzKSx0aGlzfSxjbG9zZVRvb2x0aXA6ZnVuY3Rpb24odCl7cmV0dXJuIHQuY2xvc2UoKSx0aGlzfX0pLG8uaW5jbHVkZSh7YmluZFRvb2x0aXA6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5fdG9vbHRpcCYmdGhpcy5pc1Rvb2x0aXBPcGVuKCkmJnRoaXMudW5iaW5kVG9vbHRpcCgpLHRoaXMuX3Rvb2x0aXA9dGhpcy5faW5pdE92ZXJsYXkoQmksdGhpcy5fdG9vbHRpcCx0LGUpLHRoaXMuX2luaXRUb29sdGlwSW50ZXJhY3Rpb25zKCksdGhpcy5fdG9vbHRpcC5vcHRpb25zLnBlcm1hbmVudCYmdGhpcy5fbWFwJiZ0aGlzLl9tYXAuaGFzTGF5ZXIodGhpcykmJnRoaXMub3BlblRvb2x0aXAoKSx0aGlzfSx1bmJpbmRUb29sdGlwOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3Rvb2x0aXAmJih0aGlzLl9pbml0VG9vbHRpcEludGVyYWN0aW9ucyghMCksdGhpcy5jbG9zZVRvb2x0aXAoKSx0aGlzLl90b29sdGlwPW51bGwpLHRoaXN9LF9pbml0VG9vbHRpcEludGVyYWN0aW9uczpmdW5jdGlvbih0KXt2YXIgZSxpOyF0JiZ0aGlzLl90b29sdGlwSGFuZGxlcnNBZGRlZHx8KGU9dD9cIm9mZlwiOlwib25cIixpPXtyZW1vdmU6dGhpcy5jbG9zZVRvb2x0aXAsbW92ZTp0aGlzLl9tb3ZlVG9vbHRpcH0sdGhpcy5fdG9vbHRpcC5vcHRpb25zLnBlcm1hbmVudD9pLmFkZD10aGlzLl9vcGVuVG9vbHRpcDooaS5tb3VzZW92ZXI9dGhpcy5fb3BlblRvb2x0aXAsaS5tb3VzZW91dD10aGlzLmNsb3NlVG9vbHRpcCxpLmNsaWNrPXRoaXMuX29wZW5Ub29sdGlwLHRoaXMuX21hcD90aGlzLl9hZGRGb2N1c0xpc3RlbmVycygpOmkuYWRkPXRoaXMuX2FkZEZvY3VzTGlzdGVuZXJzKSx0aGlzLl90b29sdGlwLm9wdGlvbnMuc3RpY2t5JiYoaS5tb3VzZW1vdmU9dGhpcy5fbW92ZVRvb2x0aXApLHRoaXNbZV0oaSksdGhpcy5fdG9vbHRpcEhhbmRsZXJzQWRkZWQ9IXQpfSxvcGVuVG9vbHRpcDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fdG9vbHRpcCYmKHRoaXMgaW5zdGFuY2VvZiB1aXx8KHRoaXMuX3Rvb2x0aXAuX3NvdXJjZT10aGlzKSx0aGlzLl90b29sdGlwLl9wcmVwYXJlT3Blbih0KSYmKHRoaXMuX3Rvb2x0aXAub3Blbk9uKHRoaXMuX21hcCksdGhpcy5nZXRFbGVtZW50P3RoaXMuX3NldEFyaWFEZXNjcmliZWRCeU9uTGF5ZXIodGhpcyk6dGhpcy5lYWNoTGF5ZXImJnRoaXMuZWFjaExheWVyKHRoaXMuX3NldEFyaWFEZXNjcmliZWRCeU9uTGF5ZXIsdGhpcykpKSx0aGlzfSxjbG9zZVRvb2x0aXA6ZnVuY3Rpb24oKXtpZih0aGlzLl90b29sdGlwKXJldHVybiB0aGlzLl90b29sdGlwLmNsb3NlKCl9LHRvZ2dsZVRvb2x0aXA6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdG9vbHRpcCYmdGhpcy5fdG9vbHRpcC50b2dnbGUodGhpcyksdGhpc30saXNUb29sdGlwT3BlbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLl90b29sdGlwLmlzT3BlbigpfSxzZXRUb29sdGlwQ29udGVudDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fdG9vbHRpcCYmdGhpcy5fdG9vbHRpcC5zZXRDb250ZW50KHQpLHRoaXN9LGdldFRvb2x0aXA6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdG9vbHRpcH0sX2FkZEZvY3VzTGlzdGVuZXJzOmZ1bmN0aW9uKCl7dGhpcy5nZXRFbGVtZW50P3RoaXMuX2FkZEZvY3VzTGlzdGVuZXJzT25MYXllcih0aGlzKTp0aGlzLmVhY2hMYXllciYmdGhpcy5lYWNoTGF5ZXIodGhpcy5fYWRkRm9jdXNMaXN0ZW5lcnNPbkxheWVyLHRoaXMpfSxfYWRkRm9jdXNMaXN0ZW5lcnNPbkxheWVyOmZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0RWxlbWVudCgpO2UmJihTKGUsXCJmb2N1c1wiLGZ1bmN0aW9uKCl7dGhpcy5fdG9vbHRpcC5fc291cmNlPXQsdGhpcy5vcGVuVG9vbHRpcCgpfSx0aGlzKSxTKGUsXCJibHVyXCIsdGhpcy5jbG9zZVRvb2x0aXAsdGhpcykpfSxfc2V0QXJpYURlc2NyaWJlZEJ5T25MYXllcjpmdW5jdGlvbih0KXt0PXQuZ2V0RWxlbWVudCgpO3QmJnQuc2V0QXR0cmlidXRlKFwiYXJpYS1kZXNjcmliZWRieVwiLHRoaXMuX3Rvb2x0aXAuX2NvbnRhaW5lci5pZCl9LF9vcGVuVG9vbHRpcDpmdW5jdGlvbih0KXshdGhpcy5fdG9vbHRpcHx8IXRoaXMuX21hcHx8dGhpcy5fbWFwLmRyYWdnaW5nJiZ0aGlzLl9tYXAuZHJhZ2dpbmcubW92aW5nKCl8fCh0aGlzLl90b29sdGlwLl9zb3VyY2U9dC5sYXllcnx8dC50YXJnZXQsdGhpcy5vcGVuVG9vbHRpcCh0aGlzLl90b29sdGlwLm9wdGlvbnMuc3RpY2t5P3QubGF0bG5nOnZvaWQgMCkpfSxfbW92ZVRvb2x0aXA6ZnVuY3Rpb24odCl7dmFyIGU9dC5sYXRsbmc7dGhpcy5fdG9vbHRpcC5vcHRpb25zLnN0aWNreSYmdC5vcmlnaW5hbEV2ZW50JiYodD10aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQodC5vcmlnaW5hbEV2ZW50KSx0PXRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCh0KSxlPXRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcodCkpLHRoaXMuX3Rvb2x0aXAuc2V0TGF0TG5nKGUpfX0pLGNpLmV4dGVuZCh7b3B0aW9uczp7aWNvblNpemU6WzEyLDEyXSxodG1sOiExLGJnUG9zOm51bGwsY2xhc3NOYW1lOlwibGVhZmxldC1kaXYtaWNvblwifSxjcmVhdGVJY29uOmZ1bmN0aW9uKHQpe3ZhciB0PXQmJlwiRElWXCI9PT10LnRhZ05hbWU/dDpkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLGU9dGhpcy5vcHRpb25zO3JldHVybiBlLmh0bWwgaW5zdGFuY2VvZiBFbGVtZW50PyhtZSh0KSx0LmFwcGVuZENoaWxkKGUuaHRtbCkpOnQuaW5uZXJIVE1MPSExIT09ZS5odG1sP2UuaHRtbDpcIlwiLGUuYmdQb3MmJihlPW0oZS5iZ1BvcyksdC5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb249LWUueCtcInB4IFwiKy1lLnkrXCJweFwiKSx0aGlzLl9zZXRJY29uU3R5bGVzKHQsXCJpY29uXCIpLHR9LGNyZWF0ZVNoYWRvdzpmdW5jdGlvbigpe3JldHVybiBudWxsfX0pKTtjaS5EZWZhdWx0PWRpO3ZhciBSaT1vLmV4dGVuZCh7b3B0aW9uczp7dGlsZVNpemU6MjU2LG9wYWNpdHk6MSx1cGRhdGVXaGVuSWRsZTpiLm1vYmlsZSx1cGRhdGVXaGVuWm9vbWluZzohMCx1cGRhdGVJbnRlcnZhbDoyMDAsekluZGV4OjEsYm91bmRzOm51bGwsbWluWm9vbTowLG1heFpvb206dm9pZCAwLG1heE5hdGl2ZVpvb206dm9pZCAwLG1pbk5hdGl2ZVpvb206dm9pZCAwLG5vV3JhcDohMSxwYW5lOlwidGlsZVBhbmVcIixjbGFzc05hbWU6XCJcIixrZWVwQnVmZmVyOjJ9LGluaXRpYWxpemU6ZnVuY3Rpb24odCl7Yyh0aGlzLHQpfSxvbkFkZDpmdW5jdGlvbigpe3RoaXMuX2luaXRDb250YWluZXIoKSx0aGlzLl9sZXZlbHM9e30sdGhpcy5fdGlsZXM9e30sdGhpcy5fcmVzZXRWaWV3KCl9LGJlZm9yZUFkZDpmdW5jdGlvbih0KXt0Ll9hZGRab29tTGltaXQodGhpcyl9LG9uUmVtb3ZlOmZ1bmN0aW9uKHQpe3RoaXMuX3JlbW92ZUFsbFRpbGVzKCksVCh0aGlzLl9jb250YWluZXIpLHQuX3JlbW92ZVpvb21MaW1pdCh0aGlzKSx0aGlzLl9jb250YWluZXI9bnVsbCx0aGlzLl90aWxlWm9vbT12b2lkIDB9LGJyaW5nVG9Gcm9udDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9tYXAmJihmZSh0aGlzLl9jb250YWluZXIpLHRoaXMuX3NldEF1dG9aSW5kZXgoTWF0aC5tYXgpKSx0aGlzfSxicmluZ1RvQmFjazpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9tYXAmJihnZSh0aGlzLl9jb250YWluZXIpLHRoaXMuX3NldEF1dG9aSW5kZXgoTWF0aC5taW4pKSx0aGlzfSxnZXRDb250YWluZXI6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fY29udGFpbmVyfSxzZXRPcGFjaXR5OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm9wdGlvbnMub3BhY2l0eT10LHRoaXMuX3VwZGF0ZU9wYWNpdHkoKSx0aGlzfSxzZXRaSW5kZXg6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMub3B0aW9ucy56SW5kZXg9dCx0aGlzLl91cGRhdGVaSW5kZXgoKSx0aGlzfSxpc0xvYWRpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbG9hZGluZ30scmVkcmF3OmZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuIHRoaXMuX21hcCYmKHRoaXMuX3JlbW92ZUFsbFRpbGVzKCksKHQ9dGhpcy5fY2xhbXBab29tKHRoaXMuX21hcC5nZXRab29tKCkpKSE9PXRoaXMuX3RpbGVab29tJiYodGhpcy5fdGlsZVpvb209dCx0aGlzLl91cGRhdGVMZXZlbHMoKSksdGhpcy5fdXBkYXRlKCkpLHRoaXN9LGdldEV2ZW50czpmdW5jdGlvbigpe3ZhciB0PXt2aWV3cHJlcmVzZXQ6dGhpcy5faW52YWxpZGF0ZUFsbCx2aWV3cmVzZXQ6dGhpcy5fcmVzZXRWaWV3LHpvb206dGhpcy5fcmVzZXRWaWV3LG1vdmVlbmQ6dGhpcy5fb25Nb3ZlRW5kfTtyZXR1cm4gdGhpcy5vcHRpb25zLnVwZGF0ZVdoZW5JZGxlfHwodGhpcy5fb25Nb3ZlfHwodGhpcy5fb25Nb3ZlPWoodGhpcy5fb25Nb3ZlRW5kLHRoaXMub3B0aW9ucy51cGRhdGVJbnRlcnZhbCx0aGlzKSksdC5tb3ZlPXRoaXMuX29uTW92ZSksdGhpcy5fem9vbUFuaW1hdGVkJiYodC56b29tYW5pbT10aGlzLl9hbmltYXRlWm9vbSksdH0sY3JlYXRlVGlsZTpmdW5jdGlvbigpe3JldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpfSxnZXRUaWxlU2l6ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMub3B0aW9ucy50aWxlU2l6ZTtyZXR1cm4gdCBpbnN0YW5jZW9mIHA/dDpuZXcgcCh0LHQpfSxfdXBkYXRlWkluZGV4OmZ1bmN0aW9uKCl7dGhpcy5fY29udGFpbmVyJiZ2b2lkIDAhPT10aGlzLm9wdGlvbnMuekluZGV4JiZudWxsIT09dGhpcy5vcHRpb25zLnpJbmRleCYmKHRoaXMuX2NvbnRhaW5lci5zdHlsZS56SW5kZXg9dGhpcy5vcHRpb25zLnpJbmRleCl9LF9zZXRBdXRvWkluZGV4OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZSxpPXRoaXMuZ2V0UGFuZSgpLmNoaWxkcmVuLG49LXQoLTEvMCwxLzApLG89MCxzPWkubGVuZ3RoO288cztvKyspZT1pW29dLnN0eWxlLnpJbmRleCxpW29dIT09dGhpcy5fY29udGFpbmVyJiZlJiYobj10KG4sK2UpKTtpc0Zpbml0ZShuKSYmKHRoaXMub3B0aW9ucy56SW5kZXg9bit0KC0xLDEpLHRoaXMuX3VwZGF0ZVpJbmRleCgpKX0sX3VwZGF0ZU9wYWNpdHk6ZnVuY3Rpb24oKXtpZih0aGlzLl9tYXAmJiFiLmllbHQ5KXtDKHRoaXMuX2NvbnRhaW5lcix0aGlzLm9wdGlvbnMub3BhY2l0eSk7dmFyIHQsZT0rbmV3IERhdGUsaT0hMSxuPSExO2Zvcih0IGluIHRoaXMuX3RpbGVzKXt2YXIgbyxzPXRoaXMuX3RpbGVzW3RdO3MuY3VycmVudCYmcy5sb2FkZWQmJihvPU1hdGgubWluKDEsKGUtcy5sb2FkZWQpLzIwMCksQyhzLmVsLG8pLG88MT9pPSEwOihzLmFjdGl2ZT9uPSEwOnRoaXMuX29uT3BhcXVlVGlsZShzKSxzLmFjdGl2ZT0hMCkpfW4mJiF0aGlzLl9ub1BydW5lJiZ0aGlzLl9wcnVuZVRpbGVzKCksaSYmKHIodGhpcy5fZmFkZUZyYW1lKSx0aGlzLl9mYWRlRnJhbWU9eCh0aGlzLl91cGRhdGVPcGFjaXR5LHRoaXMpKX19LF9vbk9wYXF1ZVRpbGU6dSxfaW5pdENvbnRhaW5lcjpmdW5jdGlvbigpe3RoaXMuX2NvbnRhaW5lcnx8KHRoaXMuX2NvbnRhaW5lcj1QKFwiZGl2XCIsXCJsZWFmbGV0LWxheWVyIFwiKyh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lfHxcIlwiKSksdGhpcy5fdXBkYXRlWkluZGV4KCksdGhpcy5vcHRpb25zLm9wYWNpdHk8MSYmdGhpcy5fdXBkYXRlT3BhY2l0eSgpLHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRhaW5lcikpfSxfdXBkYXRlTGV2ZWxzOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fdGlsZVpvb20sZT10aGlzLm9wdGlvbnMubWF4Wm9vbTtpZih2b2lkIDAhPT10KXtmb3IodmFyIGkgaW4gdGhpcy5fbGV2ZWxzKWk9TnVtYmVyKGkpLHRoaXMuX2xldmVsc1tpXS5lbC5jaGlsZHJlbi5sZW5ndGh8fGk9PT10Pyh0aGlzLl9sZXZlbHNbaV0uZWwuc3R5bGUuekluZGV4PWUtTWF0aC5hYnModC1pKSx0aGlzLl9vblVwZGF0ZUxldmVsKGkpKTooVCh0aGlzLl9sZXZlbHNbaV0uZWwpLHRoaXMuX3JlbW92ZVRpbGVzQXRab29tKGkpLHRoaXMuX29uUmVtb3ZlTGV2ZWwoaSksZGVsZXRlIHRoaXMuX2xldmVsc1tpXSk7dmFyIG49dGhpcy5fbGV2ZWxzW3RdLG89dGhpcy5fbWFwO3JldHVybiBufHwoKG49dGhpcy5fbGV2ZWxzW3RdPXt9KS5lbD1QKFwiZGl2XCIsXCJsZWFmbGV0LXRpbGUtY29udGFpbmVyIGxlYWZsZXQtem9vbS1hbmltYXRlZFwiLHRoaXMuX2NvbnRhaW5lciksbi5lbC5zdHlsZS56SW5kZXg9ZSxuLm9yaWdpbj1vLnByb2plY3Qoby51bnByb2plY3Qoby5nZXRQaXhlbE9yaWdpbigpKSx0KS5yb3VuZCgpLG4uem9vbT10LHRoaXMuX3NldFpvb21UcmFuc2Zvcm0obixvLmdldENlbnRlcigpLG8uZ2V0Wm9vbSgpKSx1KG4uZWwub2Zmc2V0V2lkdGgpLHRoaXMuX29uQ3JlYXRlTGV2ZWwobikpLHRoaXMuX2xldmVsPW59fSxfb25VcGRhdGVMZXZlbDp1LF9vblJlbW92ZUxldmVsOnUsX29uQ3JlYXRlTGV2ZWw6dSxfcHJ1bmVUaWxlczpmdW5jdGlvbigpe2lmKHRoaXMuX21hcCl7dmFyIHQsZSxpLG49dGhpcy5fbWFwLmdldFpvb20oKTtpZihuPnRoaXMub3B0aW9ucy5tYXhab29tfHxuPHRoaXMub3B0aW9ucy5taW5ab29tKXRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7ZWxzZXtmb3IodCBpbiB0aGlzLl90aWxlcykoaT10aGlzLl90aWxlc1t0XSkucmV0YWluPWkuY3VycmVudDtmb3IodCBpbiB0aGlzLl90aWxlcykoaT10aGlzLl90aWxlc1t0XSkuY3VycmVudCYmIWkuYWN0aXZlJiYoZT1pLmNvb3Jkcyx0aGlzLl9yZXRhaW5QYXJlbnQoZS54LGUueSxlLnosZS56LTUpfHx0aGlzLl9yZXRhaW5DaGlsZHJlbihlLngsZS55LGUueixlLnorMikpO2Zvcih0IGluIHRoaXMuX3RpbGVzKXRoaXMuX3RpbGVzW3RdLnJldGFpbnx8dGhpcy5fcmVtb3ZlVGlsZSh0KX19fSxfcmVtb3ZlVGlsZXNBdFpvb206ZnVuY3Rpb24odCl7Zm9yKHZhciBlIGluIHRoaXMuX3RpbGVzKXRoaXMuX3RpbGVzW2VdLmNvb3Jkcy56PT09dCYmdGhpcy5fcmVtb3ZlVGlsZShlKX0sX3JlbW92ZUFsbFRpbGVzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0IGluIHRoaXMuX3RpbGVzKXRoaXMuX3JlbW92ZVRpbGUodCl9LF9pbnZhbGlkYXRlQWxsOmZ1bmN0aW9uKCl7Zm9yKHZhciB0IGluIHRoaXMuX2xldmVscylUKHRoaXMuX2xldmVsc1t0XS5lbCksdGhpcy5fb25SZW1vdmVMZXZlbChOdW1iZXIodCkpLGRlbGV0ZSB0aGlzLl9sZXZlbHNbdF07dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKSx0aGlzLl90aWxlWm9vbT12b2lkIDB9LF9yZXRhaW5QYXJlbnQ6ZnVuY3Rpb24odCxlLGksbil7dmFyIHQ9TWF0aC5mbG9vcih0LzIpLGU9TWF0aC5mbG9vcihlLzIpLGk9aS0xLG89bmV3IHAoK3QsK2UpLG89KG8uej1pLHRoaXMuX3RpbGVDb29yZHNUb0tleShvKSksbz10aGlzLl90aWxlc1tvXTtyZXR1cm4gbyYmby5hY3RpdmU/by5yZXRhaW49ITA6KG8mJm8ubG9hZGVkJiYoby5yZXRhaW49ITApLG48aSYmdGhpcy5fcmV0YWluUGFyZW50KHQsZSxpLG4pKX0sX3JldGFpbkNoaWxkcmVuOmZ1bmN0aW9uKHQsZSxpLG4pe2Zvcih2YXIgbz0yKnQ7bzwyKnQrMjtvKyspZm9yKHZhciBzPTIqZTtzPDIqZSsyO3MrKyl7dmFyIHI9bmV3IHAobyxzKSxyPShyLno9aSsxLHRoaXMuX3RpbGVDb29yZHNUb0tleShyKSkscj10aGlzLl90aWxlc1tyXTtyJiZyLmFjdGl2ZT9yLnJldGFpbj0hMDoociYmci5sb2FkZWQmJihyLnJldGFpbj0hMCksaSsxPG4mJnRoaXMuX3JldGFpbkNoaWxkcmVuKG8scyxpKzEsbikpfX0sX3Jlc2V0VmlldzpmdW5jdGlvbih0KXt0PXQmJih0LnBpbmNofHx0LmZseVRvKTt0aGlzLl9zZXRWaWV3KHRoaXMuX21hcC5nZXRDZW50ZXIoKSx0aGlzLl9tYXAuZ2V0Wm9vbSgpLHQsdCl9LF9hbmltYXRlWm9vbTpmdW5jdGlvbih0KXt0aGlzLl9zZXRWaWV3KHQuY2VudGVyLHQuem9vbSwhMCx0Lm5vVXBkYXRlKX0sX2NsYW1wWm9vbTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLm9wdGlvbnM7cmV0dXJuIHZvaWQgMCE9PWUubWluTmF0aXZlWm9vbSYmdDxlLm1pbk5hdGl2ZVpvb20/ZS5taW5OYXRpdmVab29tOnZvaWQgMCE9PWUubWF4TmF0aXZlWm9vbSYmZS5tYXhOYXRpdmVab29tPHQ/ZS5tYXhOYXRpdmVab29tOnR9LF9zZXRWaWV3OmZ1bmN0aW9uKHQsZSxpLG4pe3ZhciBvPU1hdGgucm91bmQoZSksbz12b2lkIDAhPT10aGlzLm9wdGlvbnMubWF4Wm9vbSYmbz50aGlzLm9wdGlvbnMubWF4Wm9vbXx8dm9pZCAwIT09dGhpcy5vcHRpb25zLm1pblpvb20mJm88dGhpcy5vcHRpb25zLm1pblpvb20/dm9pZCAwOnRoaXMuX2NsYW1wWm9vbShvKSxzPXRoaXMub3B0aW9ucy51cGRhdGVXaGVuWm9vbWluZyYmbyE9PXRoaXMuX3RpbGVab29tO24mJiFzfHwodGhpcy5fdGlsZVpvb209byx0aGlzLl9hYm9ydExvYWRpbmcmJnRoaXMuX2Fib3J0TG9hZGluZygpLHRoaXMuX3VwZGF0ZUxldmVscygpLHRoaXMuX3Jlc2V0R3JpZCgpLHZvaWQgMCE9PW8mJnRoaXMuX3VwZGF0ZSh0KSxpfHx0aGlzLl9wcnVuZVRpbGVzKCksdGhpcy5fbm9QcnVuZT0hIWkpLHRoaXMuX3NldFpvb21UcmFuc2Zvcm1zKHQsZSl9LF9zZXRab29tVHJhbnNmb3JtczpmdW5jdGlvbih0LGUpe2Zvcih2YXIgaSBpbiB0aGlzLl9sZXZlbHMpdGhpcy5fc2V0Wm9vbVRyYW5zZm9ybSh0aGlzLl9sZXZlbHNbaV0sdCxlKX0sX3NldFpvb21UcmFuc2Zvcm06ZnVuY3Rpb24odCxlLGkpe3ZhciBuPXRoaXMuX21hcC5nZXRab29tU2NhbGUoaSx0Lnpvb20pLGU9dC5vcmlnaW4ubXVsdGlwbHlCeShuKS5zdWJ0cmFjdCh0aGlzLl9tYXAuX2dldE5ld1BpeGVsT3JpZ2luKGUsaSkpLnJvdW5kKCk7Yi5hbnkzZD9iZSh0LmVsLGUsbik6Wih0LmVsLGUpfSxfcmVzZXRHcmlkOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fbWFwLGU9dC5vcHRpb25zLmNycyxpPXRoaXMuX3RpbGVTaXplPXRoaXMuZ2V0VGlsZVNpemUoKSxuPXRoaXMuX3RpbGVab29tLG89dGhpcy5fbWFwLmdldFBpeGVsV29ybGRCb3VuZHModGhpcy5fdGlsZVpvb20pO28mJih0aGlzLl9nbG9iYWxUaWxlUmFuZ2U9dGhpcy5fcHhCb3VuZHNUb1RpbGVSYW5nZShvKSksdGhpcy5fd3JhcFg9ZS53cmFwTG5nJiYhdGhpcy5vcHRpb25zLm5vV3JhcCYmW01hdGguZmxvb3IodC5wcm9qZWN0KFswLGUud3JhcExuZ1swXV0sbikueC9pLngpLE1hdGguY2VpbCh0LnByb2plY3QoWzAsZS53cmFwTG5nWzFdXSxuKS54L2kueSldLHRoaXMuX3dyYXBZPWUud3JhcExhdCYmIXRoaXMub3B0aW9ucy5ub1dyYXAmJltNYXRoLmZsb29yKHQucHJvamVjdChbZS53cmFwTGF0WzBdLDBdLG4pLnkvaS54KSxNYXRoLmNlaWwodC5wcm9qZWN0KFtlLndyYXBMYXRbMV0sMF0sbikueS9pLnkpXX0sX29uTW92ZUVuZDpmdW5jdGlvbigpe3RoaXMuX21hcCYmIXRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSYmdGhpcy5fdXBkYXRlKCl9LF9nZXRUaWxlZFBpeGVsQm91bmRzOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuX21hcCxpPWUuX2FuaW1hdGluZ1pvb20/TWF0aC5tYXgoZS5fYW5pbWF0ZVRvWm9vbSxlLmdldFpvb20oKSk6ZS5nZXRab29tKCksaT1lLmdldFpvb21TY2FsZShpLHRoaXMuX3RpbGVab29tKSx0PWUucHJvamVjdCh0LHRoaXMuX3RpbGVab29tKS5mbG9vcigpLGU9ZS5nZXRTaXplKCkuZGl2aWRlQnkoMippKTtyZXR1cm4gbmV3IGYodC5zdWJ0cmFjdChlKSx0LmFkZChlKSl9LF91cGRhdGU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5fbWFwO2lmKGUpe3ZhciBpPXRoaXMuX2NsYW1wWm9vbShlLmdldFpvb20oKSk7aWYodm9pZCAwPT09dCYmKHQ9ZS5nZXRDZW50ZXIoKSksdm9pZCAwIT09dGhpcy5fdGlsZVpvb20pe3ZhciBuLGU9dGhpcy5fZ2V0VGlsZWRQaXhlbEJvdW5kcyh0KSxvPXRoaXMuX3B4Qm91bmRzVG9UaWxlUmFuZ2UoZSkscz1vLmdldENlbnRlcigpLHI9W10sZT10aGlzLm9wdGlvbnMua2VlcEJ1ZmZlcixhPW5ldyBmKG8uZ2V0Qm90dG9tTGVmdCgpLnN1YnRyYWN0KFtlLC1lXSksby5nZXRUb3BSaWdodCgpLmFkZChbZSwtZV0pKTtpZighKGlzRmluaXRlKG8ubWluLngpJiZpc0Zpbml0ZShvLm1pbi55KSYmaXNGaW5pdGUoby5tYXgueCkmJmlzRmluaXRlKG8ubWF4LnkpKSl0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gbG9hZCBhbiBpbmZpbml0ZSBudW1iZXIgb2YgdGlsZXNcIik7Zm9yKG4gaW4gdGhpcy5fdGlsZXMpe3ZhciBoPXRoaXMuX3RpbGVzW25dLmNvb3JkcztoLno9PT10aGlzLl90aWxlWm9vbSYmYS5jb250YWlucyhuZXcgcChoLngsaC55KSl8fCh0aGlzLl90aWxlc1tuXS5jdXJyZW50PSExKX1pZigxPE1hdGguYWJzKGktdGhpcy5fdGlsZVpvb20pKXRoaXMuX3NldFZpZXcodCxpKTtlbHNle2Zvcih2YXIgbD1vLm1pbi55O2w8PW8ubWF4Lnk7bCsrKWZvcih2YXIgdT1vLm1pbi54O3U8PW8ubWF4Lng7dSsrKXt2YXIgYyxkPW5ldyBwKHUsbCk7ZC56PXRoaXMuX3RpbGVab29tLHRoaXMuX2lzVmFsaWRUaWxlKGQpJiYoKGM9dGhpcy5fdGlsZXNbdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGQpXSk/Yy5jdXJyZW50PSEwOnIucHVzaChkKSl9aWYoci5zb3J0KGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuZGlzdGFuY2VUbyhzKS1lLmRpc3RhbmNlVG8ocyl9KSwwIT09ci5sZW5ndGgpe3RoaXMuX2xvYWRpbmd8fCh0aGlzLl9sb2FkaW5nPSEwLHRoaXMuZmlyZShcImxvYWRpbmdcIikpO2Zvcih2YXIgXz1kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksdT0wO3U8ci5sZW5ndGg7dSsrKXRoaXMuX2FkZFRpbGUoclt1XSxfKTt0aGlzLl9sZXZlbC5lbC5hcHBlbmRDaGlsZChfKX19fX19LF9pc1ZhbGlkVGlsZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLl9tYXAub3B0aW9ucy5jcnM7aWYoIWUuaW5maW5pdGUpe3ZhciBpPXRoaXMuX2dsb2JhbFRpbGVSYW5nZTtpZighZS53cmFwTG5nJiYodC54PGkubWluLnh8fHQueD5pLm1heC54KXx8IWUud3JhcExhdCYmKHQueTxpLm1pbi55fHx0Lnk+aS5tYXgueSkpcmV0dXJuITF9cmV0dXJuIXRoaXMub3B0aW9ucy5ib3VuZHN8fChlPXRoaXMuX3RpbGVDb29yZHNUb0JvdW5kcyh0KSxnKHRoaXMub3B0aW9ucy5ib3VuZHMpLm92ZXJsYXBzKGUpKX0sX2tleVRvQm91bmRzOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl90aWxlQ29vcmRzVG9Cb3VuZHModGhpcy5fa2V5VG9UaWxlQ29vcmRzKHQpKX0sX3RpbGVDb29yZHNUb053U2U6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5fbWFwLGk9dGhpcy5nZXRUaWxlU2l6ZSgpLG49dC5zY2FsZUJ5KGkpLGk9bi5hZGQoaSk7cmV0dXJuW2UudW5wcm9qZWN0KG4sdC56KSxlLnVucHJvamVjdChpLHQueildfSxfdGlsZUNvb3Jkc1RvQm91bmRzOmZ1bmN0aW9uKHQpe3Q9dGhpcy5fdGlsZUNvb3Jkc1RvTndTZSh0KSx0PW5ldyBzKHRbMF0sdFsxXSk7cmV0dXJuIHQ9dGhpcy5vcHRpb25zLm5vV3JhcD90OnRoaXMuX21hcC53cmFwTGF0TG5nQm91bmRzKHQpfSxfdGlsZUNvb3Jkc1RvS2V5OmZ1bmN0aW9uKHQpe3JldHVybiB0LngrXCI6XCIrdC55K1wiOlwiK3Quen0sX2tleVRvVGlsZUNvb3JkczpmdW5jdGlvbih0KXt2YXIgdD10LnNwbGl0KFwiOlwiKSxlPW5ldyBwKCt0WzBdLCt0WzFdKTtyZXR1cm4gZS56PSt0WzJdLGV9LF9yZW1vdmVUaWxlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuX3RpbGVzW3RdO2UmJihUKGUuZWwpLGRlbGV0ZSB0aGlzLl90aWxlc1t0XSx0aGlzLmZpcmUoXCJ0aWxldW5sb2FkXCIse3RpbGU6ZS5lbCxjb29yZHM6dGhpcy5fa2V5VG9UaWxlQ29vcmRzKHQpfSkpfSxfaW5pdFRpbGU6ZnVuY3Rpb24odCl7TSh0LFwibGVhZmxldC10aWxlXCIpO3ZhciBlPXRoaXMuZ2V0VGlsZVNpemUoKTt0LnN0eWxlLndpZHRoPWUueCtcInB4XCIsdC5zdHlsZS5oZWlnaHQ9ZS55K1wicHhcIix0Lm9uc2VsZWN0c3RhcnQ9dSx0Lm9ubW91c2Vtb3ZlPXUsYi5pZWx0OSYmdGhpcy5vcHRpb25zLm9wYWNpdHk8MSYmQyh0LHRoaXMub3B0aW9ucy5vcGFjaXR5KX0sX2FkZFRpbGU6ZnVuY3Rpb24odCxlKXt2YXIgaT10aGlzLl9nZXRUaWxlUG9zKHQpLG49dGhpcy5fdGlsZUNvb3Jkc1RvS2V5KHQpLG89dGhpcy5jcmVhdGVUaWxlKHRoaXMuX3dyYXBDb29yZHModCksYSh0aGlzLl90aWxlUmVhZHksdGhpcyx0KSk7dGhpcy5faW5pdFRpbGUobyksdGhpcy5jcmVhdGVUaWxlLmxlbmd0aDwyJiZ4KGEodGhpcy5fdGlsZVJlYWR5LHRoaXMsdCxudWxsLG8pKSxaKG8saSksdGhpcy5fdGlsZXNbbl09e2VsOm8sY29vcmRzOnQsY3VycmVudDohMH0sZS5hcHBlbmRDaGlsZChvKSx0aGlzLmZpcmUoXCJ0aWxlbG9hZHN0YXJ0XCIse3RpbGU6byxjb29yZHM6dH0pfSxfdGlsZVJlYWR5OmZ1bmN0aW9uKHQsZSxpKXtlJiZ0aGlzLmZpcmUoXCJ0aWxlZXJyb3JcIix7ZXJyb3I6ZSx0aWxlOmksY29vcmRzOnR9KTt2YXIgbj10aGlzLl90aWxlQ29vcmRzVG9LZXkodCk7KGk9dGhpcy5fdGlsZXNbbl0pJiYoaS5sb2FkZWQ9K25ldyBEYXRlLHRoaXMuX21hcC5fZmFkZUFuaW1hdGVkPyhDKGkuZWwsMCkscih0aGlzLl9mYWRlRnJhbWUpLHRoaXMuX2ZhZGVGcmFtZT14KHRoaXMuX3VwZGF0ZU9wYWNpdHksdGhpcykpOihpLmFjdGl2ZT0hMCx0aGlzLl9wcnVuZVRpbGVzKCkpLGV8fChNKGkuZWwsXCJsZWFmbGV0LXRpbGUtbG9hZGVkXCIpLHRoaXMuZmlyZShcInRpbGVsb2FkXCIse3RpbGU6aS5lbCxjb29yZHM6dH0pKSx0aGlzLl9ub1RpbGVzVG9Mb2FkKCkmJih0aGlzLl9sb2FkaW5nPSExLHRoaXMuZmlyZShcImxvYWRcIiksYi5pZWx0OXx8IXRoaXMuX21hcC5fZmFkZUFuaW1hdGVkP3godGhpcy5fcHJ1bmVUaWxlcyx0aGlzKTpzZXRUaW1lb3V0KGEodGhpcy5fcHJ1bmVUaWxlcyx0aGlzKSwyNTApKSl9LF9nZXRUaWxlUG9zOmZ1bmN0aW9uKHQpe3JldHVybiB0LnNjYWxlQnkodGhpcy5nZXRUaWxlU2l6ZSgpKS5zdWJ0cmFjdCh0aGlzLl9sZXZlbC5vcmlnaW4pfSxfd3JhcENvb3JkczpmdW5jdGlvbih0KXt2YXIgZT1uZXcgcCh0aGlzLl93cmFwWD9IKHQueCx0aGlzLl93cmFwWCk6dC54LHRoaXMuX3dyYXBZP0godC55LHRoaXMuX3dyYXBZKTp0LnkpO3JldHVybiBlLno9dC56LGV9LF9weEJvdW5kc1RvVGlsZVJhbmdlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZ2V0VGlsZVNpemUoKTtyZXR1cm4gbmV3IGYodC5taW4udW5zY2FsZUJ5KGUpLmZsb29yKCksdC5tYXgudW5zY2FsZUJ5KGUpLmNlaWwoKS5zdWJ0cmFjdChbMSwxXSkpfSxfbm9UaWxlc1RvTG9hZDpmdW5jdGlvbigpe2Zvcih2YXIgdCBpbiB0aGlzLl90aWxlcylpZighdGhpcy5fdGlsZXNbdF0ubG9hZGVkKXJldHVybiExO3JldHVybiEwfX0pO3ZhciBOaT1SaS5leHRlbmQoe29wdGlvbnM6e21pblpvb206MCxtYXhab29tOjE4LHN1YmRvbWFpbnM6XCJhYmNcIixlcnJvclRpbGVVcmw6XCJcIix6b29tT2Zmc2V0OjAsdG1zOiExLHpvb21SZXZlcnNlOiExLGRldGVjdFJldGluYTohMSxjcm9zc09yaWdpbjohMSxyZWZlcnJlclBvbGljeTohMX0saW5pdGlhbGl6ZTpmdW5jdGlvbih0LGUpe3RoaXMuX3VybD10LChlPWModGhpcyxlKSkuZGV0ZWN0UmV0aW5hJiZiLnJldGluYSYmMDxlLm1heFpvb20/KGUudGlsZVNpemU9TWF0aC5mbG9vcihlLnRpbGVTaXplLzIpLGUuem9vbVJldmVyc2U/KGUuem9vbU9mZnNldC0tLGUubWluWm9vbT1NYXRoLm1pbihlLm1heFpvb20sZS5taW5ab29tKzEpKTooZS56b29tT2Zmc2V0KyssZS5tYXhab29tPU1hdGgubWF4KGUubWluWm9vbSxlLm1heFpvb20tMSkpLGUubWluWm9vbT1NYXRoLm1heCgwLGUubWluWm9vbSkpOmUuem9vbVJldmVyc2U/ZS5taW5ab29tPU1hdGgubWluKGUubWF4Wm9vbSxlLm1pblpvb20pOmUubWF4Wm9vbT1NYXRoLm1heChlLm1pblpvb20sZS5tYXhab29tKSxcInN0cmluZ1wiPT10eXBlb2YgZS5zdWJkb21haW5zJiYoZS5zdWJkb21haW5zPWUuc3ViZG9tYWlucy5zcGxpdChcIlwiKSksdGhpcy5vbihcInRpbGV1bmxvYWRcIix0aGlzLl9vblRpbGVSZW1vdmUpfSxzZXRVcmw6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5fdXJsPT09dCYmdm9pZCAwPT09ZSYmKGU9ITApLHRoaXMuX3VybD10LGV8fHRoaXMucmVkcmF3KCksdGhpc30sY3JlYXRlVGlsZTpmdW5jdGlvbih0LGUpe3ZhciBpPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7cmV0dXJuIFMoaSxcImxvYWRcIixhKHRoaXMuX3RpbGVPbkxvYWQsdGhpcyxlLGkpKSxTKGksXCJlcnJvclwiLGEodGhpcy5fdGlsZU9uRXJyb3IsdGhpcyxlLGkpKSwhdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luJiZcIlwiIT09dGhpcy5vcHRpb25zLmNyb3NzT3JpZ2lufHwoaS5jcm9zc09yaWdpbj0hMD09PXRoaXMub3B0aW9ucy5jcm9zc09yaWdpbj9cIlwiOnRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiksXCJzdHJpbmdcIj09dHlwZW9mIHRoaXMub3B0aW9ucy5yZWZlcnJlclBvbGljeSYmKGkucmVmZXJyZXJQb2xpY3k9dGhpcy5vcHRpb25zLnJlZmVycmVyUG9saWN5KSxpLmFsdD1cIlwiLGkuc3JjPXRoaXMuZ2V0VGlsZVVybCh0KSxpfSxnZXRUaWxlVXJsOmZ1bmN0aW9uKHQpe3ZhciBlPXtyOmIucmV0aW5hP1wiQDJ4XCI6XCJcIixzOnRoaXMuX2dldFN1YmRvbWFpbih0KSx4OnQueCx5OnQueSx6OnRoaXMuX2dldFpvb21Gb3JVcmwoKX07cmV0dXJuIHRoaXMuX21hcCYmIXRoaXMuX21hcC5vcHRpb25zLmNycy5pbmZpbml0ZSYmKHQ9dGhpcy5fZ2xvYmFsVGlsZVJhbmdlLm1heC55LXQueSx0aGlzLm9wdGlvbnMudG1zJiYoZS55PXQpLGVbXCIteVwiXT10KSxxKHRoaXMuX3VybCxsKGUsdGhpcy5vcHRpb25zKSl9LF90aWxlT25Mb2FkOmZ1bmN0aW9uKHQsZSl7Yi5pZWx0OT9zZXRUaW1lb3V0KGEodCx0aGlzLG51bGwsZSksMCk6dChudWxsLGUpfSxfdGlsZU9uRXJyb3I6ZnVuY3Rpb24odCxlLGkpe3ZhciBuPXRoaXMub3B0aW9ucy5lcnJvclRpbGVVcmw7biYmZS5nZXRBdHRyaWJ1dGUoXCJzcmNcIikhPT1uJiYoZS5zcmM9biksdChpLGUpfSxfb25UaWxlUmVtb3ZlOmZ1bmN0aW9uKHQpe3QudGlsZS5vbmxvYWQ9bnVsbH0sX2dldFpvb21Gb3JVcmw6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl90aWxlWm9vbSxlPXRoaXMub3B0aW9ucy5tYXhab29tO3JldHVybih0PXRoaXMub3B0aW9ucy56b29tUmV2ZXJzZT9lLXQ6dCkrdGhpcy5vcHRpb25zLnpvb21PZmZzZXR9LF9nZXRTdWJkb21haW46ZnVuY3Rpb24odCl7dD1NYXRoLmFicyh0LngrdC55KSV0aGlzLm9wdGlvbnMuc3ViZG9tYWlucy5sZW5ndGg7cmV0dXJuIHRoaXMub3B0aW9ucy5zdWJkb21haW5zW3RdfSxfYWJvcnRMb2FkaW5nOmZ1bmN0aW9uKCl7dmFyIHQsZSxpO2Zvcih0IGluIHRoaXMuX3RpbGVzKXRoaXMuX3RpbGVzW3RdLmNvb3Jkcy56IT09dGhpcy5fdGlsZVpvb20mJigoaT10aGlzLl90aWxlc1t0XS5lbCkub25sb2FkPXUsaS5vbmVycm9yPXUsaS5jb21wbGV0ZXx8KGkuc3JjPUssZT10aGlzLl90aWxlc1t0XS5jb29yZHMsVChpKSxkZWxldGUgdGhpcy5fdGlsZXNbdF0sdGhpcy5maXJlKFwidGlsZWFib3J0XCIse3RpbGU6aSxjb29yZHM6ZX0pKSl9LF9yZW1vdmVUaWxlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuX3RpbGVzW3RdO2lmKGUpcmV0dXJuIGUuZWwuc2V0QXR0cmlidXRlKFwic3JjXCIsSyksUmkucHJvdG90eXBlLl9yZW1vdmVUaWxlLmNhbGwodGhpcyx0KX0sX3RpbGVSZWFkeTpmdW5jdGlvbih0LGUsaSl7aWYodGhpcy5fbWFwJiYoIWl8fGkuZ2V0QXR0cmlidXRlKFwic3JjXCIpIT09SykpcmV0dXJuIFJpLnByb3RvdHlwZS5fdGlsZVJlYWR5LmNhbGwodGhpcyx0LGUsaSl9fSk7ZnVuY3Rpb24gRGkodCxlKXtyZXR1cm4gbmV3IE5pKHQsZSl9dmFyIGppPU5pLmV4dGVuZCh7ZGVmYXVsdFdtc1BhcmFtczp7c2VydmljZTpcIldNU1wiLHJlcXVlc3Q6XCJHZXRNYXBcIixsYXllcnM6XCJcIixzdHlsZXM6XCJcIixmb3JtYXQ6XCJpbWFnZS9qcGVnXCIsdHJhbnNwYXJlbnQ6ITEsdmVyc2lvbjpcIjEuMS4xXCJ9LG9wdGlvbnM6e2NyczpudWxsLHVwcGVyY2FzZTohMX0saW5pdGlhbGl6ZTpmdW5jdGlvbih0LGUpe3RoaXMuX3VybD10O3ZhciBpLG49bCh7fSx0aGlzLmRlZmF1bHRXbXNQYXJhbXMpO2ZvcihpIGluIGUpaSBpbiB0aGlzLm9wdGlvbnN8fChuW2ldPWVbaV0pO3ZhciB0PShlPWModGhpcyxlKSkuZGV0ZWN0UmV0aW5hJiZiLnJldGluYT8yOjEsbz10aGlzLmdldFRpbGVTaXplKCk7bi53aWR0aD1vLngqdCxuLmhlaWdodD1vLnkqdCx0aGlzLndtc1BhcmFtcz1ufSxvbkFkZDpmdW5jdGlvbih0KXt0aGlzLl9jcnM9dGhpcy5vcHRpb25zLmNyc3x8dC5vcHRpb25zLmNycyx0aGlzLl93bXNWZXJzaW9uPXBhcnNlRmxvYXQodGhpcy53bXNQYXJhbXMudmVyc2lvbik7dmFyIGU9MS4zPD10aGlzLl93bXNWZXJzaW9uP1wiY3JzXCI6XCJzcnNcIjt0aGlzLndtc1BhcmFtc1tlXT10aGlzLl9jcnMuY29kZSxOaS5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLHQpfSxnZXRUaWxlVXJsOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuX3RpbGVDb29yZHNUb053U2UodCksaT10aGlzLl9jcnMsaT1fKGkucHJvamVjdChlWzBdKSxpLnByb2plY3QoZVsxXSkpLGU9aS5taW4saT1pLm1heCxlPSgxLjM8PXRoaXMuX3dtc1ZlcnNpb24mJnRoaXMuX2Nycz09PWhpP1tlLnksZS54LGkueSxpLnhdOltlLngsZS55LGkueCxpLnldKS5qb2luKFwiLFwiKSxpPU5pLnByb3RvdHlwZS5nZXRUaWxlVXJsLmNhbGwodGhpcyx0KTtyZXR1cm4gaStVKHRoaXMud21zUGFyYW1zLGksdGhpcy5vcHRpb25zLnVwcGVyY2FzZSkrKHRoaXMub3B0aW9ucy51cHBlcmNhc2U/XCImQkJPWD1cIjpcIiZiYm94PVwiKStlfSxzZXRQYXJhbXM6ZnVuY3Rpb24odCxlKXtyZXR1cm4gbCh0aGlzLndtc1BhcmFtcyx0KSxlfHx0aGlzLnJlZHJhdygpLHRoaXN9fSk7TmkuV01TPWppLERpLndtcz1mdW5jdGlvbih0LGUpe3JldHVybiBuZXcgamkodCxlKX07dmFyIEhpPW8uZXh0ZW5kKHtvcHRpb25zOntwYWRkaW5nOi4xfSxpbml0aWFsaXplOmZ1bmN0aW9uKHQpe2ModGhpcyx0KSxoKHRoaXMpLHRoaXMuX2xheWVycz10aGlzLl9sYXllcnN8fHt9fSxvbkFkZDpmdW5jdGlvbigpe3RoaXMuX2NvbnRhaW5lcnx8KHRoaXMuX2luaXRDb250YWluZXIoKSx0aGlzLl96b29tQW5pbWF0ZWQmJk0odGhpcy5fY29udGFpbmVyLFwibGVhZmxldC16b29tLWFuaW1hdGVkXCIpKSx0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpLHRoaXMuX3VwZGF0ZSgpLHRoaXMub24oXCJ1cGRhdGVcIix0aGlzLl91cGRhdGVQYXRocyx0aGlzKX0sb25SZW1vdmU6ZnVuY3Rpb24oKXt0aGlzLm9mZihcInVwZGF0ZVwiLHRoaXMuX3VwZGF0ZVBhdGhzLHRoaXMpLHRoaXMuX2Rlc3Ryb3lDb250YWluZXIoKX0sZ2V0RXZlbnRzOmZ1bmN0aW9uKCl7dmFyIHQ9e3ZpZXdyZXNldDp0aGlzLl9yZXNldCx6b29tOnRoaXMuX29uWm9vbSxtb3ZlZW5kOnRoaXMuX3VwZGF0ZSx6b29tZW5kOnRoaXMuX29uWm9vbUVuZH07cmV0dXJuIHRoaXMuX3pvb21BbmltYXRlZCYmKHQuem9vbWFuaW09dGhpcy5fb25BbmltWm9vbSksdH0sX29uQW5pbVpvb206ZnVuY3Rpb24odCl7dGhpcy5fdXBkYXRlVHJhbnNmb3JtKHQuY2VudGVyLHQuem9vbSl9LF9vblpvb206ZnVuY3Rpb24oKXt0aGlzLl91cGRhdGVUcmFuc2Zvcm0odGhpcy5fbWFwLmdldENlbnRlcigpLHRoaXMuX21hcC5nZXRab29tKCkpfSxfdXBkYXRlVHJhbnNmb3JtOmZ1bmN0aW9uKHQsZSl7dmFyIGk9dGhpcy5fbWFwLmdldFpvb21TY2FsZShlLHRoaXMuX3pvb20pLG49dGhpcy5fbWFwLmdldFNpemUoKS5tdWx0aXBseUJ5KC41K3RoaXMub3B0aW9ucy5wYWRkaW5nKSxvPXRoaXMuX21hcC5wcm9qZWN0KHRoaXMuX2NlbnRlcixlKSxuPW4ubXVsdGlwbHlCeSgtaSkuYWRkKG8pLnN1YnRyYWN0KHRoaXMuX21hcC5fZ2V0TmV3UGl4ZWxPcmlnaW4odCxlKSk7Yi5hbnkzZD9iZSh0aGlzLl9jb250YWluZXIsbixpKTpaKHRoaXMuX2NvbnRhaW5lcixuKX0sX3Jlc2V0OmZ1bmN0aW9uKCl7Zm9yKHZhciB0IGluIHRoaXMuX3VwZGF0ZSgpLHRoaXMuX3VwZGF0ZVRyYW5zZm9ybSh0aGlzLl9jZW50ZXIsdGhpcy5fem9vbSksdGhpcy5fbGF5ZXJzKXRoaXMuX2xheWVyc1t0XS5fcmVzZXQoKX0sX29uWm9vbUVuZDpmdW5jdGlvbigpe2Zvcih2YXIgdCBpbiB0aGlzLl9sYXllcnMpdGhpcy5fbGF5ZXJzW3RdLl9wcm9qZWN0KCl9LF91cGRhdGVQYXRoczpmdW5jdGlvbigpe2Zvcih2YXIgdCBpbiB0aGlzLl9sYXllcnMpdGhpcy5fbGF5ZXJzW3RdLl91cGRhdGUoKX0sX3VwZGF0ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMub3B0aW9ucy5wYWRkaW5nLGU9dGhpcy5fbWFwLmdldFNpemUoKSxpPXRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChlLm11bHRpcGx5QnkoLXQpKS5yb3VuZCgpO3RoaXMuX2JvdW5kcz1uZXcgZihpLGkuYWRkKGUubXVsdGlwbHlCeSgxKzIqdCkpLnJvdW5kKCkpLHRoaXMuX2NlbnRlcj10aGlzLl9tYXAuZ2V0Q2VudGVyKCksdGhpcy5fem9vbT10aGlzLl9tYXAuZ2V0Wm9vbSgpfX0pLEZpPUhpLmV4dGVuZCh7b3B0aW9uczp7dG9sZXJhbmNlOjB9LGdldEV2ZW50czpmdW5jdGlvbigpe3ZhciB0PUhpLnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtyZXR1cm4gdC52aWV3cHJlcmVzZXQ9dGhpcy5fb25WaWV3UHJlUmVzZXQsdH0sX29uVmlld1ByZVJlc2V0OmZ1bmN0aW9uKCl7dGhpcy5fcG9zdHBvbmVVcGRhdGVQYXRocz0hMH0sb25BZGQ6ZnVuY3Rpb24oKXtIaS5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzKSx0aGlzLl9kcmF3KCl9LF9pbml0Q29udGFpbmVyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fY29udGFpbmVyPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7Uyh0LFwibW91c2Vtb3ZlXCIsdGhpcy5fb25Nb3VzZU1vdmUsdGhpcyksUyh0LFwiY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgY29udGV4dG1lbnVcIix0aGlzLl9vbkNsaWNrLHRoaXMpLFModCxcIm1vdXNlb3V0XCIsdGhpcy5faGFuZGxlTW91c2VPdXQsdGhpcyksdC5fbGVhZmxldF9kaXNhYmxlX2V2ZW50cz0hMCx0aGlzLl9jdHg9dC5nZXRDb250ZXh0KFwiMmRcIil9LF9kZXN0cm95Q29udGFpbmVyOmZ1bmN0aW9uKCl7cih0aGlzLl9yZWRyYXdSZXF1ZXN0KSxkZWxldGUgdGhpcy5fY3R4LFQodGhpcy5fY29udGFpbmVyKSxrKHRoaXMuX2NvbnRhaW5lciksZGVsZXRlIHRoaXMuX2NvbnRhaW5lcn0sX3VwZGF0ZVBhdGhzOmZ1bmN0aW9uKCl7aWYoIXRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMpe2Zvcih2YXIgdCBpbiB0aGlzLl9yZWRyYXdCb3VuZHM9bnVsbCx0aGlzLl9sYXllcnMpdGhpcy5fbGF5ZXJzW3RdLl91cGRhdGUoKTt0aGlzLl9yZWRyYXcoKX19LF91cGRhdGU6ZnVuY3Rpb24oKXt2YXIgdCxlLGksbjt0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20mJnRoaXMuX2JvdW5kc3x8KEhpLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyksdD10aGlzLl9ib3VuZHMsZT10aGlzLl9jb250YWluZXIsaT10LmdldFNpemUoKSxuPWIucmV0aW5hPzI6MSxaKGUsdC5taW4pLGUud2lkdGg9bippLngsZS5oZWlnaHQ9bippLnksZS5zdHlsZS53aWR0aD1pLngrXCJweFwiLGUuc3R5bGUuaGVpZ2h0PWkueStcInB4XCIsYi5yZXRpbmEmJnRoaXMuX2N0eC5zY2FsZSgyLDIpLHRoaXMuX2N0eC50cmFuc2xhdGUoLXQubWluLngsLXQubWluLnkpLHRoaXMuZmlyZShcInVwZGF0ZVwiKSl9LF9yZXNldDpmdW5jdGlvbigpe0hpLnByb3RvdHlwZS5fcmVzZXQuY2FsbCh0aGlzKSx0aGlzLl9wb3N0cG9uZVVwZGF0ZVBhdGhzJiYodGhpcy5fcG9zdHBvbmVVcGRhdGVQYXRocz0hMSx0aGlzLl91cGRhdGVQYXRocygpKX0sX2luaXRQYXRoOmZ1bmN0aW9uKHQpe3RoaXMuX3VwZGF0ZURhc2hBcnJheSh0KTt0PSh0aGlzLl9sYXllcnNbaCh0KV09dCkuX29yZGVyPXtsYXllcjp0LHByZXY6dGhpcy5fZHJhd0xhc3QsbmV4dDpudWxsfTt0aGlzLl9kcmF3TGFzdCYmKHRoaXMuX2RyYXdMYXN0Lm5leHQ9dCksdGhpcy5fZHJhd0xhc3Q9dCx0aGlzLl9kcmF3Rmlyc3Q9dGhpcy5fZHJhd0ZpcnN0fHx0aGlzLl9kcmF3TGFzdH0sX2FkZFBhdGg6ZnVuY3Rpb24odCl7dGhpcy5fcmVxdWVzdFJlZHJhdyh0KX0sX3JlbW92ZVBhdGg6ZnVuY3Rpb24odCl7dmFyIGU9dC5fb3JkZXIsaT1lLm5leHQsZT1lLnByZXY7aT9pLnByZXY9ZTp0aGlzLl9kcmF3TGFzdD1lLGU/ZS5uZXh0PWk6dGhpcy5fZHJhd0ZpcnN0PWksZGVsZXRlIHQuX29yZGVyLGRlbGV0ZSB0aGlzLl9sYXllcnNbaCh0KV0sdGhpcy5fcmVxdWVzdFJlZHJhdyh0KX0sX3VwZGF0ZVBhdGg6ZnVuY3Rpb24odCl7dGhpcy5fZXh0ZW5kUmVkcmF3Qm91bmRzKHQpLHQuX3Byb2plY3QoKSx0Ll91cGRhdGUoKSx0aGlzLl9yZXF1ZXN0UmVkcmF3KHQpfSxfdXBkYXRlU3R5bGU6ZnVuY3Rpb24odCl7dGhpcy5fdXBkYXRlRGFzaEFycmF5KHQpLHRoaXMuX3JlcXVlc3RSZWRyYXcodCl9LF91cGRhdGVEYXNoQXJyYXk6ZnVuY3Rpb24odCl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQub3B0aW9ucy5kYXNoQXJyYXkpe2Zvcih2YXIgZSxpPXQub3B0aW9ucy5kYXNoQXJyYXkuc3BsaXQoL1ssIF0rLyksbj1bXSxvPTA7bzxpLmxlbmd0aDtvKyspe2lmKGU9TnVtYmVyKGlbb10pLGlzTmFOKGUpKXJldHVybjtuLnB1c2goZSl9dC5vcHRpb25zLl9kYXNoQXJyYXk9bn1lbHNlIHQub3B0aW9ucy5fZGFzaEFycmF5PXQub3B0aW9ucy5kYXNoQXJyYXl9LF9yZXF1ZXN0UmVkcmF3OmZ1bmN0aW9uKHQpe3RoaXMuX21hcCYmKHRoaXMuX2V4dGVuZFJlZHJhd0JvdW5kcyh0KSx0aGlzLl9yZWRyYXdSZXF1ZXN0PXRoaXMuX3JlZHJhd1JlcXVlc3R8fHgodGhpcy5fcmVkcmF3LHRoaXMpKX0sX2V4dGVuZFJlZHJhd0JvdW5kczpmdW5jdGlvbih0KXt2YXIgZTt0Ll9weEJvdW5kcyYmKGU9KHQub3B0aW9ucy53ZWlnaHR8fDApKzEsdGhpcy5fcmVkcmF3Qm91bmRzPXRoaXMuX3JlZHJhd0JvdW5kc3x8bmV3IGYsdGhpcy5fcmVkcmF3Qm91bmRzLmV4dGVuZCh0Ll9weEJvdW5kcy5taW4uc3VidHJhY3QoW2UsZV0pKSx0aGlzLl9yZWRyYXdCb3VuZHMuZXh0ZW5kKHQuX3B4Qm91bmRzLm1heC5hZGQoW2UsZV0pKSl9LF9yZWRyYXc6ZnVuY3Rpb24oKXt0aGlzLl9yZWRyYXdSZXF1ZXN0PW51bGwsdGhpcy5fcmVkcmF3Qm91bmRzJiYodGhpcy5fcmVkcmF3Qm91bmRzLm1pbi5fZmxvb3IoKSx0aGlzLl9yZWRyYXdCb3VuZHMubWF4Ll9jZWlsKCkpLHRoaXMuX2NsZWFyKCksdGhpcy5fZHJhdygpLHRoaXMuX3JlZHJhd0JvdW5kcz1udWxsfSxfY2xlYXI6ZnVuY3Rpb24oKXt2YXIgdCxlPXRoaXMuX3JlZHJhd0JvdW5kcztlPyh0PWUuZ2V0U2l6ZSgpLHRoaXMuX2N0eC5jbGVhclJlY3QoZS5taW4ueCxlLm1pbi55LHQueCx0LnkpKToodGhpcy5fY3R4LnNhdmUoKSx0aGlzLl9jdHguc2V0VHJhbnNmb3JtKDEsMCwwLDEsMCwwKSx0aGlzLl9jdHguY2xlYXJSZWN0KDAsMCx0aGlzLl9jb250YWluZXIud2lkdGgsdGhpcy5fY29udGFpbmVyLmhlaWdodCksdGhpcy5fY3R4LnJlc3RvcmUoKSl9LF9kcmF3OmZ1bmN0aW9uKCl7dmFyIHQsZSxpPXRoaXMuX3JlZHJhd0JvdW5kczt0aGlzLl9jdHguc2F2ZSgpLGkmJihlPWkuZ2V0U2l6ZSgpLHRoaXMuX2N0eC5iZWdpblBhdGgoKSx0aGlzLl9jdHgucmVjdChpLm1pbi54LGkubWluLnksZS54LGUueSksdGhpcy5fY3R4LmNsaXAoKSksdGhpcy5fZHJhd2luZz0hMDtmb3IodmFyIG49dGhpcy5fZHJhd0ZpcnN0O247bj1uLm5leHQpdD1uLmxheWVyLCghaXx8dC5fcHhCb3VuZHMmJnQuX3B4Qm91bmRzLmludGVyc2VjdHMoaSkpJiZ0Ll91cGRhdGVQYXRoKCk7dGhpcy5fZHJhd2luZz0hMSx0aGlzLl9jdHgucmVzdG9yZSgpfSxfdXBkYXRlUG9seTpmdW5jdGlvbih0LGUpe2lmKHRoaXMuX2RyYXdpbmcpe3ZhciBpLG4sbyxzLHI9dC5fcGFydHMsYT1yLmxlbmd0aCxoPXRoaXMuX2N0eDtpZihhKXtmb3IoaC5iZWdpblBhdGgoKSxpPTA7aTxhO2krKyl7Zm9yKG49MCxvPXJbaV0ubGVuZ3RoO248bztuKyspcz1yW2ldW25dLGhbbj9cImxpbmVUb1wiOlwibW92ZVRvXCJdKHMueCxzLnkpO2UmJmguY2xvc2VQYXRoKCl9dGhpcy5fZmlsbFN0cm9rZShoLHQpfX19LF91cGRhdGVDaXJjbGU6ZnVuY3Rpb24odCl7dmFyIGUsaSxuLG87dGhpcy5fZHJhd2luZyYmIXQuX2VtcHR5KCkmJihlPXQuX3BvaW50LGk9dGhpcy5fY3R4LG49TWF0aC5tYXgoTWF0aC5yb3VuZCh0Ll9yYWRpdXMpLDEpLDEhPShvPShNYXRoLm1heChNYXRoLnJvdW5kKHQuX3JhZGl1c1kpLDEpfHxuKS9uKSYmKGkuc2F2ZSgpLGkuc2NhbGUoMSxvKSksaS5iZWdpblBhdGgoKSxpLmFyYyhlLngsZS55L28sbiwwLDIqTWF0aC5QSSwhMSksMSE9byYmaS5yZXN0b3JlKCksdGhpcy5fZmlsbFN0cm9rZShpLHQpKX0sX2ZpbGxTdHJva2U6ZnVuY3Rpb24odCxlKXt2YXIgaT1lLm9wdGlvbnM7aS5maWxsJiYodC5nbG9iYWxBbHBoYT1pLmZpbGxPcGFjaXR5LHQuZmlsbFN0eWxlPWkuZmlsbENvbG9yfHxpLmNvbG9yLHQuZmlsbChpLmZpbGxSdWxlfHxcImV2ZW5vZGRcIikpLGkuc3Ryb2tlJiYwIT09aS53ZWlnaHQmJih0LnNldExpbmVEYXNoJiZ0LnNldExpbmVEYXNoKGUub3B0aW9ucyYmZS5vcHRpb25zLl9kYXNoQXJyYXl8fFtdKSx0Lmdsb2JhbEFscGhhPWkub3BhY2l0eSx0LmxpbmVXaWR0aD1pLndlaWdodCx0LnN0cm9rZVN0eWxlPWkuY29sb3IsdC5saW5lQ2FwPWkubGluZUNhcCx0LmxpbmVKb2luPWkubGluZUpvaW4sdC5zdHJva2UoKSl9LF9vbkNsaWNrOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZSxpLG49dGhpcy5fbWFwLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQodCksbz10aGlzLl9kcmF3Rmlyc3Q7bztvPW8ubmV4dCkoZT1vLmxheWVyKS5vcHRpb25zLmludGVyYWN0aXZlJiZlLl9jb250YWluc1BvaW50KG4pJiYoKFwiY2xpY2tcIj09PXQudHlwZXx8XCJwcmVjbGlja1wiPT09dC50eXBlKSYmdGhpcy5fbWFwLl9kcmFnZ2FibGVNb3ZlZChlKXx8KGk9ZSkpO3RoaXMuX2ZpcmVFdmVudCghIWkmJltpXSx0KX0sX29uTW91c2VNb3ZlOmZ1bmN0aW9uKHQpe3ZhciBlOyF0aGlzLl9tYXB8fHRoaXMuX21hcC5kcmFnZ2luZy5tb3ZpbmcoKXx8dGhpcy5fbWFwLl9hbmltYXRpbmdab29tfHwoZT10aGlzLl9tYXAubW91c2VFdmVudFRvTGF5ZXJQb2ludCh0KSx0aGlzLl9oYW5kbGVNb3VzZUhvdmVyKHQsZSkpfSxfaGFuZGxlTW91c2VPdXQ6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5faG92ZXJlZExheWVyO2UmJih6KHRoaXMuX2NvbnRhaW5lcixcImxlYWZsZXQtaW50ZXJhY3RpdmVcIiksdGhpcy5fZmlyZUV2ZW50KFtlXSx0LFwibW91c2VvdXRcIiksdGhpcy5faG92ZXJlZExheWVyPW51bGwsdGhpcy5fbW91c2VIb3ZlclRocm90dGxlZD0hMSl9LF9oYW5kbGVNb3VzZUhvdmVyOmZ1bmN0aW9uKHQsZSl7aWYoIXRoaXMuX21vdXNlSG92ZXJUaHJvdHRsZWQpe2Zvcih2YXIgaSxuLG89dGhpcy5fZHJhd0ZpcnN0O287bz1vLm5leHQpKGk9by5sYXllcikub3B0aW9ucy5pbnRlcmFjdGl2ZSYmaS5fY29udGFpbnNQb2ludChlKSYmKG49aSk7biE9PXRoaXMuX2hvdmVyZWRMYXllciYmKHRoaXMuX2hhbmRsZU1vdXNlT3V0KHQpLG4mJihNKHRoaXMuX2NvbnRhaW5lcixcImxlYWZsZXQtaW50ZXJhY3RpdmVcIiksdGhpcy5fZmlyZUV2ZW50KFtuXSx0LFwibW91c2VvdmVyXCIpLHRoaXMuX2hvdmVyZWRMYXllcj1uKSksdGhpcy5fZmlyZUV2ZW50KCEhdGhpcy5faG92ZXJlZExheWVyJiZbdGhpcy5faG92ZXJlZExheWVyXSx0KSx0aGlzLl9tb3VzZUhvdmVyVGhyb3R0bGVkPSEwLHNldFRpbWVvdXQoYShmdW5jdGlvbigpe3RoaXMuX21vdXNlSG92ZXJUaHJvdHRsZWQ9ITF9LHRoaXMpLDMyKX19LF9maXJlRXZlbnQ6ZnVuY3Rpb24odCxlLGkpe3RoaXMuX21hcC5fZmlyZURPTUV2ZW50KGUsaXx8ZS50eXBlLHQpfSxfYnJpbmdUb0Zyb250OmZ1bmN0aW9uKHQpe3ZhciBlLGksbj10Ll9vcmRlcjtuJiYoZT1uLm5leHQsaT1uLnByZXYsZSYmKChlLnByZXY9aSk/aS5uZXh0PWU6ZSYmKHRoaXMuX2RyYXdGaXJzdD1lKSxuLnByZXY9dGhpcy5fZHJhd0xhc3QsKHRoaXMuX2RyYXdMYXN0Lm5leHQ9bikubmV4dD1udWxsLHRoaXMuX2RyYXdMYXN0PW4sdGhpcy5fcmVxdWVzdFJlZHJhdyh0KSkpfSxfYnJpbmdUb0JhY2s6ZnVuY3Rpb24odCl7dmFyIGUsaSxuPXQuX29yZGVyO24mJihlPW4ubmV4dCwoaT1uLnByZXYpJiYoKGkubmV4dD1lKT9lLnByZXY9aTppJiYodGhpcy5fZHJhd0xhc3Q9aSksbi5wcmV2PW51bGwsbi5uZXh0PXRoaXMuX2RyYXdGaXJzdCx0aGlzLl9kcmF3Rmlyc3QucHJldj1uLHRoaXMuX2RyYXdGaXJzdD1uLHRoaXMuX3JlcXVlc3RSZWRyYXcodCkpKX19KTtmdW5jdGlvbiBXaSh0KXtyZXR1cm4gYi5jYW52YXM/bmV3IEZpKHQpOm51bGx9dmFyIFVpPWZ1bmN0aW9uKCl7dHJ5e3JldHVybiBkb2N1bWVudC5uYW1lc3BhY2VzLmFkZChcImx2bWxcIixcInVybjpzY2hlbWFzLW1pY3Jvc29mdC1jb206dm1sXCIpLGZ1bmN0aW9uKHQpe3JldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiPGx2bWw6XCIrdCsnIGNsYXNzPVwibHZtbFwiPicpfX1jYXRjaCh0KXt9cmV0dXJuIGZ1bmN0aW9uKHQpe3JldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiPFwiK3QrJyB4bWxucz1cInVybjpzY2hlbWFzLW1pY3Jvc29mdC5jb206dm1sXCIgY2xhc3M9XCJsdm1sXCI+Jyl9fSgpLHp0PXtfaW5pdENvbnRhaW5lcjpmdW5jdGlvbigpe3RoaXMuX2NvbnRhaW5lcj1QKFwiZGl2XCIsXCJsZWFmbGV0LXZtbC1jb250YWluZXJcIil9LF91cGRhdGU6ZnVuY3Rpb24oKXt0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb218fChIaS5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpLHRoaXMuZmlyZShcInVwZGF0ZVwiKSl9LF9pbml0UGF0aDpmdW5jdGlvbih0KXt2YXIgZT10Ll9jb250YWluZXI9VWkoXCJzaGFwZVwiKTtNKGUsXCJsZWFmbGV0LXZtbC1zaGFwZSBcIisodGhpcy5vcHRpb25zLmNsYXNzTmFtZXx8XCJcIikpLGUuY29vcmRzaXplPVwiMSAxXCIsdC5fcGF0aD1VaShcInBhdGhcIiksZS5hcHBlbmRDaGlsZCh0Ll9wYXRoKSx0aGlzLl91cGRhdGVTdHlsZSh0KSx0aGlzLl9sYXllcnNbaCh0KV09dH0sX2FkZFBhdGg6ZnVuY3Rpb24odCl7dmFyIGU9dC5fY29udGFpbmVyO3RoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZChlKSx0Lm9wdGlvbnMuaW50ZXJhY3RpdmUmJnQuYWRkSW50ZXJhY3RpdmVUYXJnZXQoZSl9LF9yZW1vdmVQYXRoOmZ1bmN0aW9uKHQpe3ZhciBlPXQuX2NvbnRhaW5lcjtUKGUpLHQucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQoZSksZGVsZXRlIHRoaXMuX2xheWVyc1toKHQpXX0sX3VwZGF0ZVN0eWxlOmZ1bmN0aW9uKHQpe3ZhciBlPXQuX3N0cm9rZSxpPXQuX2ZpbGwsbj10Lm9wdGlvbnMsbz10Ll9jb250YWluZXI7by5zdHJva2VkPSEhbi5zdHJva2Usby5maWxsZWQ9ISFuLmZpbGwsbi5zdHJva2U/KGU9ZXx8KHQuX3N0cm9rZT1VaShcInN0cm9rZVwiKSksby5hcHBlbmRDaGlsZChlKSxlLndlaWdodD1uLndlaWdodCtcInB4XCIsZS5jb2xvcj1uLmNvbG9yLGUub3BhY2l0eT1uLm9wYWNpdHksbi5kYXNoQXJyYXk/ZS5kYXNoU3R5bGU9ZChuLmRhc2hBcnJheSk/bi5kYXNoQXJyYXkuam9pbihcIiBcIik6bi5kYXNoQXJyYXkucmVwbGFjZSgvKCAqLCAqKS9nLFwiIFwiKTplLmRhc2hTdHlsZT1cIlwiLGUuZW5kY2FwPW4ubGluZUNhcC5yZXBsYWNlKFwiYnV0dFwiLFwiZmxhdFwiKSxlLmpvaW5zdHlsZT1uLmxpbmVKb2luKTplJiYoby5yZW1vdmVDaGlsZChlKSx0Ll9zdHJva2U9bnVsbCksbi5maWxsPyhpPWl8fCh0Ll9maWxsPVVpKFwiZmlsbFwiKSksby5hcHBlbmRDaGlsZChpKSxpLmNvbG9yPW4uZmlsbENvbG9yfHxuLmNvbG9yLGkub3BhY2l0eT1uLmZpbGxPcGFjaXR5KTppJiYoby5yZW1vdmVDaGlsZChpKSx0Ll9maWxsPW51bGwpfSxfdXBkYXRlQ2lyY2xlOmZ1bmN0aW9uKHQpe3ZhciBlPXQuX3BvaW50LnJvdW5kKCksaT1NYXRoLnJvdW5kKHQuX3JhZGl1cyksbj1NYXRoLnJvdW5kKHQuX3JhZGl1c1l8fGkpO3RoaXMuX3NldFBhdGgodCx0Ll9lbXB0eSgpP1wiTTAgMFwiOlwiQUwgXCIrZS54K1wiLFwiK2UueStcIiBcIitpK1wiLFwiK24rXCIgMCwyMzU5MjYwMFwiKX0sX3NldFBhdGg6ZnVuY3Rpb24odCxlKXt0Ll9wYXRoLnY9ZX0sX2JyaW5nVG9Gcm9udDpmdW5jdGlvbih0KXtmZSh0Ll9jb250YWluZXIpfSxfYnJpbmdUb0JhY2s6ZnVuY3Rpb24odCl7Z2UodC5fY29udGFpbmVyKX19LFZpPWIudm1sP1VpOmN0LHFpPUhpLmV4dGVuZCh7X2luaXRDb250YWluZXI6ZnVuY3Rpb24oKXt0aGlzLl9jb250YWluZXI9VmkoXCJzdmdcIiksdGhpcy5fY29udGFpbmVyLnNldEF0dHJpYnV0ZShcInBvaW50ZXItZXZlbnRzXCIsXCJub25lXCIpLHRoaXMuX3Jvb3RHcm91cD1WaShcImdcIiksdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX3Jvb3RHcm91cCl9LF9kZXN0cm95Q29udGFpbmVyOmZ1bmN0aW9uKCl7VCh0aGlzLl9jb250YWluZXIpLGsodGhpcy5fY29udGFpbmVyKSxkZWxldGUgdGhpcy5fY29udGFpbmVyLGRlbGV0ZSB0aGlzLl9yb290R3JvdXAsZGVsZXRlIHRoaXMuX3N2Z1NpemV9LF91cGRhdGU6ZnVuY3Rpb24oKXt2YXIgdCxlLGk7dGhpcy5fbWFwLl9hbmltYXRpbmdab29tJiZ0aGlzLl9ib3VuZHN8fChIaS5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpLGU9KHQ9dGhpcy5fYm91bmRzKS5nZXRTaXplKCksaT10aGlzLl9jb250YWluZXIsdGhpcy5fc3ZnU2l6ZSYmdGhpcy5fc3ZnU2l6ZS5lcXVhbHMoZSl8fCh0aGlzLl9zdmdTaXplPWUsaS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLGUueCksaS5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIixlLnkpKSxaKGksdC5taW4pLGkuc2V0QXR0cmlidXRlKFwidmlld0JveFwiLFt0Lm1pbi54LHQubWluLnksZS54LGUueV0uam9pbihcIiBcIikpLHRoaXMuZmlyZShcInVwZGF0ZVwiKSl9LF9pbml0UGF0aDpmdW5jdGlvbih0KXt2YXIgZT10Ll9wYXRoPVZpKFwicGF0aFwiKTt0Lm9wdGlvbnMuY2xhc3NOYW1lJiZNKGUsdC5vcHRpb25zLmNsYXNzTmFtZSksdC5vcHRpb25zLmludGVyYWN0aXZlJiZNKGUsXCJsZWFmbGV0LWludGVyYWN0aXZlXCIpLHRoaXMuX3VwZGF0ZVN0eWxlKHQpLHRoaXMuX2xheWVyc1toKHQpXT10fSxfYWRkUGF0aDpmdW5jdGlvbih0KXt0aGlzLl9yb290R3JvdXB8fHRoaXMuX2luaXRDb250YWluZXIoKSx0aGlzLl9yb290R3JvdXAuYXBwZW5kQ2hpbGQodC5fcGF0aCksdC5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0Ll9wYXRoKX0sX3JlbW92ZVBhdGg6ZnVuY3Rpb24odCl7VCh0Ll9wYXRoKSx0LnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KHQuX3BhdGgpLGRlbGV0ZSB0aGlzLl9sYXllcnNbaCh0KV19LF91cGRhdGVQYXRoOmZ1bmN0aW9uKHQpe3QuX3Byb2plY3QoKSx0Ll91cGRhdGUoKX0sX3VwZGF0ZVN0eWxlOmZ1bmN0aW9uKHQpe3ZhciBlPXQuX3BhdGgsdD10Lm9wdGlvbnM7ZSYmKHQuc3Ryb2tlPyhlLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLHQuY29sb3IpLGUuc2V0QXR0cmlidXRlKFwic3Ryb2tlLW9wYWNpdHlcIix0Lm9wYWNpdHkpLGUuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsdC53ZWlnaHQpLGUuc2V0QXR0cmlidXRlKFwic3Ryb2tlLWxpbmVjYXBcIix0LmxpbmVDYXApLGUuc2V0QXR0cmlidXRlKFwic3Ryb2tlLWxpbmVqb2luXCIsdC5saW5lSm9pbiksdC5kYXNoQXJyYXk/ZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2UtZGFzaGFycmF5XCIsdC5kYXNoQXJyYXkpOmUucmVtb3ZlQXR0cmlidXRlKFwic3Ryb2tlLWRhc2hhcnJheVwiKSx0LmRhc2hPZmZzZXQ/ZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2UtZGFzaG9mZnNldFwiLHQuZGFzaE9mZnNldCk6ZS5yZW1vdmVBdHRyaWJ1dGUoXCJzdHJva2UtZGFzaG9mZnNldFwiKSk6ZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIixcIm5vbmVcIiksdC5maWxsPyhlLnNldEF0dHJpYnV0ZShcImZpbGxcIix0LmZpbGxDb2xvcnx8dC5jb2xvciksZS5zZXRBdHRyaWJ1dGUoXCJmaWxsLW9wYWNpdHlcIix0LmZpbGxPcGFjaXR5KSxlLnNldEF0dHJpYnV0ZShcImZpbGwtcnVsZVwiLHQuZmlsbFJ1bGV8fFwiZXZlbm9kZFwiKSk6ZS5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsXCJub25lXCIpKX0sX3VwZGF0ZVBvbHk6ZnVuY3Rpb24odCxlKXt0aGlzLl9zZXRQYXRoKHQsZHQodC5fcGFydHMsZSkpfSxfdXBkYXRlQ2lyY2xlOmZ1bmN0aW9uKHQpe3ZhciBlPXQuX3BvaW50LGk9TWF0aC5tYXgoTWF0aC5yb3VuZCh0Ll9yYWRpdXMpLDEpLG49XCJhXCIraStcIixcIisoTWF0aC5tYXgoTWF0aC5yb3VuZCh0Ll9yYWRpdXNZKSwxKXx8aSkrXCIgMCAxLDAgXCIsZT10Ll9lbXB0eSgpP1wiTTAgMFwiOlwiTVwiKyhlLngtaSkrXCIsXCIrZS55K24rMippK1wiLDAgXCIrbisyKi1pK1wiLDAgXCI7dGhpcy5fc2V0UGF0aCh0LGUpfSxfc2V0UGF0aDpmdW5jdGlvbih0LGUpe3QuX3BhdGguc2V0QXR0cmlidXRlKFwiZFwiLGUpfSxfYnJpbmdUb0Zyb250OmZ1bmN0aW9uKHQpe2ZlKHQuX3BhdGgpfSxfYnJpbmdUb0JhY2s6ZnVuY3Rpb24odCl7Z2UodC5fcGF0aCl9fSk7ZnVuY3Rpb24gR2kodCl7cmV0dXJuIGIuc3ZnfHxiLnZtbD9uZXcgcWkodCk6bnVsbH1iLnZtbCYmcWkuaW5jbHVkZSh6dCksQS5pbmNsdWRlKHtnZXRSZW5kZXJlcjpmdW5jdGlvbih0KXt0PSh0PXQub3B0aW9ucy5yZW5kZXJlcnx8dGhpcy5fZ2V0UGFuZVJlbmRlcmVyKHQub3B0aW9ucy5wYW5lKXx8dGhpcy5vcHRpb25zLnJlbmRlcmVyfHx0aGlzLl9yZW5kZXJlcil8fCh0aGlzLl9yZW5kZXJlcj10aGlzLl9jcmVhdGVSZW5kZXJlcigpKTtyZXR1cm4gdGhpcy5oYXNMYXllcih0KXx8dGhpcy5hZGRMYXllcih0KSx0fSxfZ2V0UGFuZVJlbmRlcmVyOmZ1bmN0aW9uKHQpe3ZhciBlO3JldHVyblwib3ZlcmxheVBhbmVcIiE9PXQmJnZvaWQgMCE9PXQmJih2b2lkIDA9PT0oZT10aGlzLl9wYW5lUmVuZGVyZXJzW3RdKSYmKGU9dGhpcy5fY3JlYXRlUmVuZGVyZXIoe3BhbmU6dH0pLHRoaXMuX3BhbmVSZW5kZXJlcnNbdF09ZSksZSl9LF9jcmVhdGVSZW5kZXJlcjpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5vcHRpb25zLnByZWZlckNhbnZhcyYmV2kodCl8fEdpKHQpfX0pO3ZhciBLaT15aS5leHRlbmQoe2luaXRpYWxpemU6ZnVuY3Rpb24odCxlKXt5aS5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsdGhpcy5fYm91bmRzVG9MYXRMbmdzKHQpLGUpfSxzZXRCb3VuZHM6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuc2V0TGF0TG5ncyh0aGlzLl9ib3VuZHNUb0xhdExuZ3ModCkpfSxfYm91bmRzVG9MYXRMbmdzOmZ1bmN0aW9uKHQpe3JldHVyblsodD1nKHQpKS5nZXRTb3V0aFdlc3QoKSx0LmdldE5vcnRoV2VzdCgpLHQuZ2V0Tm9ydGhFYXN0KCksdC5nZXRTb3V0aEVhc3QoKV19fSk7cWkuY3JlYXRlPVZpLHFpLnBvaW50c1RvUGF0aD1kdCx4aS5nZW9tZXRyeVRvTGF5ZXI9d2kseGkuY29vcmRzVG9MYXRMbmc9UGkseGkuY29vcmRzVG9MYXRMbmdzPUxpLHhpLmxhdExuZ1RvQ29vcmRzPVRpLHhpLmxhdExuZ3NUb0Nvb3Jkcz1NaSx4aS5nZXRGZWF0dXJlPXppLHhpLmFzRmVhdHVyZT1DaSxBLm1lcmdlT3B0aW9ucyh7Ym94Wm9vbTohMH0pO3ZhciBfdD1uLmV4dGVuZCh7aW5pdGlhbGl6ZTpmdW5jdGlvbih0KXt0aGlzLl9tYXA9dCx0aGlzLl9jb250YWluZXI9dC5fY29udGFpbmVyLHRoaXMuX3BhbmU9dC5fcGFuZXMub3ZlcmxheVBhbmUsdGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQ9MCx0Lm9uKFwidW5sb2FkXCIsdGhpcy5fZGVzdHJveSx0aGlzKX0sYWRkSG9va3M6ZnVuY3Rpb24oKXtTKHRoaXMuX2NvbnRhaW5lcixcIm1vdXNlZG93blwiLHRoaXMuX29uTW91c2VEb3duLHRoaXMpfSxyZW1vdmVIb29rczpmdW5jdGlvbigpe2sodGhpcy5fY29udGFpbmVyLFwibW91c2Vkb3duXCIsdGhpcy5fb25Nb3VzZURvd24sdGhpcyl9LG1vdmVkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX21vdmVkfSxfZGVzdHJveTpmdW5jdGlvbigpe1QodGhpcy5fcGFuZSksZGVsZXRlIHRoaXMuX3BhbmV9LF9yZXNldFN0YXRlOmZ1bmN0aW9uKCl7dGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQ9MCx0aGlzLl9tb3ZlZD0hMX0sX2NsZWFyRGVmZXJyZWRSZXNldFN0YXRlOmZ1bmN0aW9uKCl7MCE9PXRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0JiYoY2xlYXJUaW1lb3V0KHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0KSx0aGlzLl9yZXNldFN0YXRlVGltZW91dD0wKX0sX29uTW91c2VEb3duOmZ1bmN0aW9uKHQpe2lmKCF0LnNoaWZ0S2V5fHwxIT09dC53aGljaCYmMSE9PXQuYnV0dG9uKXJldHVybiExO3RoaXMuX2NsZWFyRGVmZXJyZWRSZXNldFN0YXRlKCksdGhpcy5fcmVzZXRTdGF0ZSgpLHJlKCksTGUoKSx0aGlzLl9zdGFydFBvaW50PXRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludCh0KSxTKGRvY3VtZW50LHtjb250ZXh0bWVudTpSZSxtb3VzZW1vdmU6dGhpcy5fb25Nb3VzZU1vdmUsbW91c2V1cDp0aGlzLl9vbk1vdXNlVXAsa2V5ZG93bjp0aGlzLl9vbktleURvd259LHRoaXMpfSxfb25Nb3VzZU1vdmU6ZnVuY3Rpb24odCl7dGhpcy5fbW92ZWR8fCh0aGlzLl9tb3ZlZD0hMCx0aGlzLl9ib3g9UChcImRpdlwiLFwibGVhZmxldC16b29tLWJveFwiLHRoaXMuX2NvbnRhaW5lciksTSh0aGlzLl9jb250YWluZXIsXCJsZWFmbGV0LWNyb3NzaGFpclwiKSx0aGlzLl9tYXAuZmlyZShcImJveHpvb21zdGFydFwiKSksdGhpcy5fcG9pbnQ9dGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KHQpO3ZhciB0PW5ldyBmKHRoaXMuX3BvaW50LHRoaXMuX3N0YXJ0UG9pbnQpLGU9dC5nZXRTaXplKCk7Wih0aGlzLl9ib3gsdC5taW4pLHRoaXMuX2JveC5zdHlsZS53aWR0aD1lLngrXCJweFwiLHRoaXMuX2JveC5zdHlsZS5oZWlnaHQ9ZS55K1wicHhcIn0sX2ZpbmlzaDpmdW5jdGlvbigpe3RoaXMuX21vdmVkJiYoVCh0aGlzLl9ib3gpLHoodGhpcy5fY29udGFpbmVyLFwibGVhZmxldC1jcm9zc2hhaXJcIikpLGFlKCksVGUoKSxrKGRvY3VtZW50LHtjb250ZXh0bWVudTpSZSxtb3VzZW1vdmU6dGhpcy5fb25Nb3VzZU1vdmUsbW91c2V1cDp0aGlzLl9vbk1vdXNlVXAsa2V5ZG93bjp0aGlzLl9vbktleURvd259LHRoaXMpfSxfb25Nb3VzZVVwOmZ1bmN0aW9uKHQpezEhPT10LndoaWNoJiYxIT09dC5idXR0b258fCh0aGlzLl9maW5pc2goKSx0aGlzLl9tb3ZlZCYmKHRoaXMuX2NsZWFyRGVmZXJyZWRSZXNldFN0YXRlKCksdGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQ9c2V0VGltZW91dChhKHRoaXMuX3Jlc2V0U3RhdGUsdGhpcyksMCksdD1uZXcgcyh0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyh0aGlzLl9zdGFydFBvaW50KSx0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyh0aGlzLl9wb2ludCkpLHRoaXMuX21hcC5maXRCb3VuZHModCkuZmlyZShcImJveHpvb21lbmRcIix7Ym94Wm9vbUJvdW5kczp0fSkpKX0sX29uS2V5RG93bjpmdW5jdGlvbih0KXsyNz09PXQua2V5Q29kZSYmKHRoaXMuX2ZpbmlzaCgpLHRoaXMuX2NsZWFyRGVmZXJyZWRSZXNldFN0YXRlKCksdGhpcy5fcmVzZXRTdGF0ZSgpKX19KSxDdD0oQS5hZGRJbml0SG9vayhcImFkZEhhbmRsZXJcIixcImJveFpvb21cIixfdCksQS5tZXJnZU9wdGlvbnMoe2RvdWJsZUNsaWNrWm9vbTohMH0pLG4uZXh0ZW5kKHthZGRIb29rczpmdW5jdGlvbigpe3RoaXMuX21hcC5vbihcImRibGNsaWNrXCIsdGhpcy5fb25Eb3VibGVDbGljayx0aGlzKX0scmVtb3ZlSG9va3M6ZnVuY3Rpb24oKXt0aGlzLl9tYXAub2ZmKFwiZGJsY2xpY2tcIix0aGlzLl9vbkRvdWJsZUNsaWNrLHRoaXMpfSxfb25Eb3VibGVDbGljazpmdW5jdGlvbih0KXt2YXIgZT10aGlzLl9tYXAsaT1lLmdldFpvb20oKSxuPWUub3B0aW9ucy56b29tRGVsdGEsaT10Lm9yaWdpbmFsRXZlbnQuc2hpZnRLZXk/aS1uOmkrbjtcImNlbnRlclwiPT09ZS5vcHRpb25zLmRvdWJsZUNsaWNrWm9vbT9lLnNldFpvb20oaSk6ZS5zZXRab29tQXJvdW5kKHQuY29udGFpbmVyUG9pbnQsaSl9fSkpLFp0PShBLmFkZEluaXRIb29rKFwiYWRkSGFuZGxlclwiLFwiZG91YmxlQ2xpY2tab29tXCIsQ3QpLEEubWVyZ2VPcHRpb25zKHtkcmFnZ2luZzohMCxpbmVydGlhOiEwLGluZXJ0aWFEZWNlbGVyYXRpb246MzQwMCxpbmVydGlhTWF4U3BlZWQ6MS8wLGVhc2VMaW5lYXJpdHk6LjIsd29ybGRDb3B5SnVtcDohMSxtYXhCb3VuZHNWaXNjb3NpdHk6MH0pLG4uZXh0ZW5kKHthZGRIb29rczpmdW5jdGlvbigpe3ZhciB0O3RoaXMuX2RyYWdnYWJsZXx8KHQ9dGhpcy5fbWFwLHRoaXMuX2RyYWdnYWJsZT1uZXcgSmUodC5fbWFwUGFuZSx0Ll9jb250YWluZXIpLHRoaXMuX2RyYWdnYWJsZS5vbih7ZHJhZ3N0YXJ0OnRoaXMuX29uRHJhZ1N0YXJ0LGRyYWc6dGhpcy5fb25EcmFnLGRyYWdlbmQ6dGhpcy5fb25EcmFnRW5kfSx0aGlzKSx0aGlzLl9kcmFnZ2FibGUub24oXCJwcmVkcmFnXCIsdGhpcy5fb25QcmVEcmFnTGltaXQsdGhpcyksdC5vcHRpb25zLndvcmxkQ29weUp1bXAmJih0aGlzLl9kcmFnZ2FibGUub24oXCJwcmVkcmFnXCIsdGhpcy5fb25QcmVEcmFnV3JhcCx0aGlzKSx0Lm9uKFwiem9vbWVuZFwiLHRoaXMuX29uWm9vbUVuZCx0aGlzKSx0LndoZW5SZWFkeSh0aGlzLl9vblpvb21FbmQsdGhpcykpKSxNKHRoaXMuX21hcC5fY29udGFpbmVyLFwibGVhZmxldC1ncmFiIGxlYWZsZXQtdG91Y2gtZHJhZ1wiKSx0aGlzLl9kcmFnZ2FibGUuZW5hYmxlKCksdGhpcy5fcG9zaXRpb25zPVtdLHRoaXMuX3RpbWVzPVtdfSxyZW1vdmVIb29rczpmdW5jdGlvbigpe3oodGhpcy5fbWFwLl9jb250YWluZXIsXCJsZWFmbGV0LWdyYWJcIikseih0aGlzLl9tYXAuX2NvbnRhaW5lcixcImxlYWZsZXQtdG91Y2gtZHJhZ1wiKSx0aGlzLl9kcmFnZ2FibGUuZGlzYWJsZSgpfSxtb3ZlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9kcmFnZ2FibGUmJnRoaXMuX2RyYWdnYWJsZS5fbW92ZWR9LG1vdmluZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9kcmFnZ2FibGUmJnRoaXMuX2RyYWdnYWJsZS5fbW92aW5nfSxfb25EcmFnU3RhcnQ6ZnVuY3Rpb24oKXt2YXIgdCxlPXRoaXMuX21hcDtlLl9zdG9wKCksdGhpcy5fbWFwLm9wdGlvbnMubWF4Qm91bmRzJiZ0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHNWaXNjb3NpdHk/KHQ9Zyh0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHMpLHRoaXMuX29mZnNldExpbWl0PV8odGhpcy5fbWFwLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQodC5nZXROb3J0aFdlc3QoKSkubXVsdGlwbHlCeSgtMSksdGhpcy5fbWFwLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQodC5nZXRTb3V0aEVhc3QoKSkubXVsdGlwbHlCeSgtMSkuYWRkKHRoaXMuX21hcC5nZXRTaXplKCkpKSx0aGlzLl92aXNjb3NpdHk9TWF0aC5taW4oMSxNYXRoLm1heCgwLHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kc1Zpc2Nvc2l0eSkpKTp0aGlzLl9vZmZzZXRMaW1pdD1udWxsLGUuZmlyZShcIm1vdmVzdGFydFwiKS5maXJlKFwiZHJhZ3N0YXJ0XCIpLGUub3B0aW9ucy5pbmVydGlhJiYodGhpcy5fcG9zaXRpb25zPVtdLHRoaXMuX3RpbWVzPVtdKX0sX29uRHJhZzpmdW5jdGlvbih0KXt2YXIgZSxpO3RoaXMuX21hcC5vcHRpb25zLmluZXJ0aWEmJihlPXRoaXMuX2xhc3RUaW1lPStuZXcgRGF0ZSxpPXRoaXMuX2xhc3RQb3M9dGhpcy5fZHJhZ2dhYmxlLl9hYnNQb3N8fHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLHRoaXMuX3Bvc2l0aW9ucy5wdXNoKGkpLHRoaXMuX3RpbWVzLnB1c2goZSksdGhpcy5fcHJ1bmVQb3NpdGlvbnMoZSkpLHRoaXMuX21hcC5maXJlKFwibW92ZVwiLHQpLmZpcmUoXCJkcmFnXCIsdCl9LF9wcnVuZVBvc2l0aW9uczpmdW5jdGlvbih0KXtmb3IoOzE8dGhpcy5fcG9zaXRpb25zLmxlbmd0aCYmNTA8dC10aGlzLl90aW1lc1swXTspdGhpcy5fcG9zaXRpb25zLnNoaWZ0KCksdGhpcy5fdGltZXMuc2hpZnQoKX0sX29uWm9vbUVuZDpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX21hcC5nZXRTaXplKCkuZGl2aWRlQnkoMiksZT10aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KFswLDBdKTt0aGlzLl9pbml0aWFsV29ybGRPZmZzZXQ9ZS5zdWJ0cmFjdCh0KS54LHRoaXMuX3dvcmxkV2lkdGg9dGhpcy5fbWFwLmdldFBpeGVsV29ybGRCb3VuZHMoKS5nZXRTaXplKCkueH0sX3Zpc2NvdXNMaW1pdDpmdW5jdGlvbih0LGUpe3JldHVybiB0LSh0LWUpKnRoaXMuX3Zpc2Nvc2l0eX0sX29uUHJlRHJhZ0xpbWl0OmZ1bmN0aW9uKCl7dmFyIHQsZTt0aGlzLl92aXNjb3NpdHkmJnRoaXMuX29mZnNldExpbWl0JiYodD10aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy5zdWJ0cmFjdCh0aGlzLl9kcmFnZ2FibGUuX3N0YXJ0UG9zKSxlPXRoaXMuX29mZnNldExpbWl0LHQueDxlLm1pbi54JiYodC54PXRoaXMuX3Zpc2NvdXNMaW1pdCh0LngsZS5taW4ueCkpLHQueTxlLm1pbi55JiYodC55PXRoaXMuX3Zpc2NvdXNMaW1pdCh0LnksZS5taW4ueSkpLHQueD5lLm1heC54JiYodC54PXRoaXMuX3Zpc2NvdXNMaW1pdCh0LngsZS5tYXgueCkpLHQueT5lLm1heC55JiYodC55PXRoaXMuX3Zpc2NvdXNMaW1pdCh0LnksZS5tYXgueSkpLHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zPXRoaXMuX2RyYWdnYWJsZS5fc3RhcnRQb3MuYWRkKHQpKX0sX29uUHJlRHJhZ1dyYXA6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl93b3JsZFdpZHRoLGU9TWF0aC5yb3VuZCh0LzIpLGk9dGhpcy5faW5pdGlhbFdvcmxkT2Zmc2V0LG49dGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MueCxvPShuLWUraSkldCtlLWksbj0obitlK2kpJXQtZS1pLHQ9TWF0aC5hYnMobytpKTxNYXRoLmFicyhuK2kpP286bjt0aGlzLl9kcmFnZ2FibGUuX2Fic1Bvcz10aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy5jbG9uZSgpLHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLng9dH0sX29uRHJhZ0VuZDpmdW5jdGlvbih0KXt2YXIgZSxpLG4sbyxzPXRoaXMuX21hcCxyPXMub3B0aW9ucyxhPSFyLmluZXJ0aWF8fHQubm9JbmVydGlhfHx0aGlzLl90aW1lcy5sZW5ndGg8MjtzLmZpcmUoXCJkcmFnZW5kXCIsdCksIWEmJih0aGlzLl9wcnVuZVBvc2l0aW9ucygrbmV3IERhdGUpLHQ9dGhpcy5fbGFzdFBvcy5zdWJ0cmFjdCh0aGlzLl9wb3NpdGlvbnNbMF0pLGE9KHRoaXMuX2xhc3RUaW1lLXRoaXMuX3RpbWVzWzBdKS8xZTMsZT1yLmVhc2VMaW5lYXJpdHksYT0odD10Lm11bHRpcGx5QnkoZS9hKSkuZGlzdGFuY2VUbyhbMCwwXSksaT1NYXRoLm1pbihyLmluZXJ0aWFNYXhTcGVlZCxhKSx0PXQubXVsdGlwbHlCeShpL2EpLG49aS8oci5pbmVydGlhRGVjZWxlcmF0aW9uKmUpLChvPXQubXVsdGlwbHlCeSgtbi8yKS5yb3VuZCgpKS54fHxvLnkpPyhvPXMuX2xpbWl0T2Zmc2V0KG8scy5vcHRpb25zLm1heEJvdW5kcykseChmdW5jdGlvbigpe3MucGFuQnkobyx7ZHVyYXRpb246bixlYXNlTGluZWFyaXR5OmUsbm9Nb3ZlU3RhcnQ6ITAsYW5pbWF0ZTohMH0pfSkpOnMuZmlyZShcIm1vdmVlbmRcIil9fSkpLFN0PShBLmFkZEluaXRIb29rKFwiYWRkSGFuZGxlclwiLFwiZHJhZ2dpbmdcIixadCksQS5tZXJnZU9wdGlvbnMoe2tleWJvYXJkOiEwLGtleWJvYXJkUGFuRGVsdGE6ODB9KSxuLmV4dGVuZCh7a2V5Q29kZXM6e2xlZnQ6WzM3XSxyaWdodDpbMzldLGRvd246WzQwXSx1cDpbMzhdLHpvb21JbjpbMTg3LDEwNyw2MSwxNzFdLHpvb21PdXQ6WzE4OSwxMDksNTQsMTczXX0saW5pdGlhbGl6ZTpmdW5jdGlvbih0KXt0aGlzLl9tYXA9dCx0aGlzLl9zZXRQYW5EZWx0YSh0Lm9wdGlvbnMua2V5Ym9hcmRQYW5EZWx0YSksdGhpcy5fc2V0Wm9vbURlbHRhKHQub3B0aW9ucy56b29tRGVsdGEpfSxhZGRIb29rczpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX21hcC5fY29udGFpbmVyO3QudGFiSW5kZXg8PTAmJih0LnRhYkluZGV4PVwiMFwiKSxTKHQse2ZvY3VzOnRoaXMuX29uRm9jdXMsYmx1cjp0aGlzLl9vbkJsdXIsbW91c2Vkb3duOnRoaXMuX29uTW91c2VEb3dufSx0aGlzKSx0aGlzLl9tYXAub24oe2ZvY3VzOnRoaXMuX2FkZEhvb2tzLGJsdXI6dGhpcy5fcmVtb3ZlSG9va3N9LHRoaXMpfSxyZW1vdmVIb29rczpmdW5jdGlvbigpe3RoaXMuX3JlbW92ZUhvb2tzKCksayh0aGlzLl9tYXAuX2NvbnRhaW5lcix7Zm9jdXM6dGhpcy5fb25Gb2N1cyxibHVyOnRoaXMuX29uQmx1cixtb3VzZWRvd246dGhpcy5fb25Nb3VzZURvd259LHRoaXMpLHRoaXMuX21hcC5vZmYoe2ZvY3VzOnRoaXMuX2FkZEhvb2tzLGJsdXI6dGhpcy5fcmVtb3ZlSG9va3N9LHRoaXMpfSxfb25Nb3VzZURvd246ZnVuY3Rpb24oKXt2YXIgdCxlLGk7dGhpcy5fZm9jdXNlZHx8KGk9ZG9jdW1lbnQuYm9keSx0PWRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxlPWkuc2Nyb2xsVG9wfHx0LnNjcm9sbFRvcCxpPWkuc2Nyb2xsTGVmdHx8dC5zY3JvbGxMZWZ0LHRoaXMuX21hcC5fY29udGFpbmVyLmZvY3VzKCksd2luZG93LnNjcm9sbFRvKGksZSkpfSxfb25Gb2N1czpmdW5jdGlvbigpe3RoaXMuX2ZvY3VzZWQ9ITAsdGhpcy5fbWFwLmZpcmUoXCJmb2N1c1wiKX0sX29uQmx1cjpmdW5jdGlvbigpe3RoaXMuX2ZvY3VzZWQ9ITEsdGhpcy5fbWFwLmZpcmUoXCJibHVyXCIpfSxfc2V0UGFuRGVsdGE6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMuX3BhbktleXM9e30saT10aGlzLmtleUNvZGVzLG49MCxvPWkubGVmdC5sZW5ndGg7bjxvO24rKyllW2kubGVmdFtuXV09Wy0xKnQsMF07Zm9yKG49MCxvPWkucmlnaHQubGVuZ3RoO248bztuKyspZVtpLnJpZ2h0W25dXT1bdCwwXTtmb3Iobj0wLG89aS5kb3duLmxlbmd0aDtuPG87bisrKWVbaS5kb3duW25dXT1bMCx0XTtmb3Iobj0wLG89aS51cC5sZW5ndGg7bjxvO24rKyllW2kudXBbbl1dPVswLC0xKnRdfSxfc2V0Wm9vbURlbHRhOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLl96b29tS2V5cz17fSxpPXRoaXMua2V5Q29kZXMsbj0wLG89aS56b29tSW4ubGVuZ3RoO248bztuKyspZVtpLnpvb21JbltuXV09dDtmb3Iobj0wLG89aS56b29tT3V0Lmxlbmd0aDtuPG87bisrKWVbaS56b29tT3V0W25dXT0tdH0sX2FkZEhvb2tzOmZ1bmN0aW9uKCl7Uyhkb2N1bWVudCxcImtleWRvd25cIix0aGlzLl9vbktleURvd24sdGhpcyl9LF9yZW1vdmVIb29rczpmdW5jdGlvbigpe2soZG9jdW1lbnQsXCJrZXlkb3duXCIsdGhpcy5fb25LZXlEb3duLHRoaXMpfSxfb25LZXlEb3duOmZ1bmN0aW9uKHQpe2lmKCEodC5hbHRLZXl8fHQuY3RybEtleXx8dC5tZXRhS2V5KSl7dmFyIGUsaSxuPXQua2V5Q29kZSxvPXRoaXMuX21hcDtpZihuIGluIHRoaXMuX3BhbktleXMpby5fcGFuQW5pbSYmby5fcGFuQW5pbS5faW5Qcm9ncmVzc3x8KGk9dGhpcy5fcGFuS2V5c1tuXSx0LnNoaWZ0S2V5JiYoaT1tKGkpLm11bHRpcGx5QnkoMykpLG8ub3B0aW9ucy5tYXhCb3VuZHMmJihpPW8uX2xpbWl0T2Zmc2V0KG0oaSksby5vcHRpb25zLm1heEJvdW5kcykpLG8ub3B0aW9ucy53b3JsZENvcHlKdW1wPyhlPW8ud3JhcExhdExuZyhvLnVucHJvamVjdChvLnByb2plY3Qoby5nZXRDZW50ZXIoKSkuYWRkKGkpKSksby5wYW5UbyhlKSk6by5wYW5CeShpKSk7ZWxzZSBpZihuIGluIHRoaXMuX3pvb21LZXlzKW8uc2V0Wm9vbShvLmdldFpvb20oKSsodC5zaGlmdEtleT8zOjEpKnRoaXMuX3pvb21LZXlzW25dKTtlbHNle2lmKDI3IT09bnx8IW8uX3BvcHVwfHwhby5fcG9wdXAub3B0aW9ucy5jbG9zZU9uRXNjYXBlS2V5KXJldHVybjtvLmNsb3NlUG9wdXAoKX1SZSh0KX19fSkpLEV0PShBLmFkZEluaXRIb29rKFwiYWRkSGFuZGxlclwiLFwia2V5Ym9hcmRcIixTdCksQS5tZXJnZU9wdGlvbnMoe3Njcm9sbFdoZWVsWm9vbTohMCx3aGVlbERlYm91bmNlVGltZTo0MCx3aGVlbFB4UGVyWm9vbUxldmVsOjYwfSksbi5leHRlbmQoe2FkZEhvb2tzOmZ1bmN0aW9uKCl7Uyh0aGlzLl9tYXAuX2NvbnRhaW5lcixcIndoZWVsXCIsdGhpcy5fb25XaGVlbFNjcm9sbCx0aGlzKSx0aGlzLl9kZWx0YT0wfSxyZW1vdmVIb29rczpmdW5jdGlvbigpe2sodGhpcy5fbWFwLl9jb250YWluZXIsXCJ3aGVlbFwiLHRoaXMuX29uV2hlZWxTY3JvbGwsdGhpcyl9LF9vbldoZWVsU2Nyb2xsOmZ1bmN0aW9uKHQpe3ZhciBlPUhlKHQpLGk9dGhpcy5fbWFwLm9wdGlvbnMud2hlZWxEZWJvdW5jZVRpbWUsZT0odGhpcy5fZGVsdGErPWUsdGhpcy5fbGFzdE1vdXNlUG9zPXRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludCh0KSx0aGlzLl9zdGFydFRpbWV8fCh0aGlzLl9zdGFydFRpbWU9K25ldyBEYXRlKSxNYXRoLm1heChpLSgrbmV3IERhdGUtdGhpcy5fc3RhcnRUaW1lKSwwKSk7Y2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKSx0aGlzLl90aW1lcj1zZXRUaW1lb3V0KGEodGhpcy5fcGVyZm9ybVpvb20sdGhpcyksZSksUmUodCl9LF9wZXJmb3JtWm9vbTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX21hcCxlPXQuZ2V0Wm9vbSgpLGk9dGhpcy5fbWFwLm9wdGlvbnMuem9vbVNuYXB8fDAsbj0odC5fc3RvcCgpLHRoaXMuX2RlbHRhLyg0KnRoaXMuX21hcC5vcHRpb25zLndoZWVsUHhQZXJab29tTGV2ZWwpKSxuPTQqTWF0aC5sb2coMi8oMStNYXRoLmV4cCgtTWF0aC5hYnMobikpKSkvTWF0aC5MTjIsaT1pP01hdGguY2VpbChuL2kpKmk6bixuPXQuX2xpbWl0Wm9vbShlKygwPHRoaXMuX2RlbHRhP2k6LWkpKS1lO3RoaXMuX2RlbHRhPTAsdGhpcy5fc3RhcnRUaW1lPW51bGwsbiYmKFwiY2VudGVyXCI9PT10Lm9wdGlvbnMuc2Nyb2xsV2hlZWxab29tP3Quc2V0Wm9vbShlK24pOnQuc2V0Wm9vbUFyb3VuZCh0aGlzLl9sYXN0TW91c2VQb3MsZStuKSl9fSkpLGt0PShBLmFkZEluaXRIb29rKFwiYWRkSGFuZGxlclwiLFwic2Nyb2xsV2hlZWxab29tXCIsRXQpLEEubWVyZ2VPcHRpb25zKHt0YXBIb2xkOmIudG91Y2hOYXRpdmUmJmIuc2FmYXJpJiZiLm1vYmlsZSx0YXBUb2xlcmFuY2U6MTV9KSxuLmV4dGVuZCh7YWRkSG9va3M6ZnVuY3Rpb24oKXtTKHRoaXMuX21hcC5fY29udGFpbmVyLFwidG91Y2hzdGFydFwiLHRoaXMuX29uRG93bix0aGlzKX0scmVtb3ZlSG9va3M6ZnVuY3Rpb24oKXtrKHRoaXMuX21hcC5fY29udGFpbmVyLFwidG91Y2hzdGFydFwiLHRoaXMuX29uRG93bix0aGlzKX0sX29uRG93bjpmdW5jdGlvbih0KXt2YXIgZTtjbGVhclRpbWVvdXQodGhpcy5faG9sZFRpbWVvdXQpLDE9PT10LnRvdWNoZXMubGVuZ3RoJiYoZT10LnRvdWNoZXNbMF0sdGhpcy5fc3RhcnRQb3M9dGhpcy5fbmV3UG9zPW5ldyBwKGUuY2xpZW50WCxlLmNsaWVudFkpLHRoaXMuX2hvbGRUaW1lb3V0PXNldFRpbWVvdXQoYShmdW5jdGlvbigpe3RoaXMuX2NhbmNlbCgpLHRoaXMuX2lzVGFwVmFsaWQoKSYmKFMoZG9jdW1lbnQsXCJ0b3VjaGVuZFwiLE8pLFMoZG9jdW1lbnQsXCJ0b3VjaGVuZCB0b3VjaGNhbmNlbFwiLHRoaXMuX2NhbmNlbENsaWNrUHJldmVudCksdGhpcy5fc2ltdWxhdGVFdmVudChcImNvbnRleHRtZW51XCIsZSkpfSx0aGlzKSw2MDApLFMoZG9jdW1lbnQsXCJ0b3VjaGVuZCB0b3VjaGNhbmNlbCBjb250ZXh0bWVudVwiLHRoaXMuX2NhbmNlbCx0aGlzKSxTKGRvY3VtZW50LFwidG91Y2htb3ZlXCIsdGhpcy5fb25Nb3ZlLHRoaXMpKX0sX2NhbmNlbENsaWNrUHJldmVudDpmdW5jdGlvbiB0KCl7ayhkb2N1bWVudCxcInRvdWNoZW5kXCIsTyksayhkb2N1bWVudCxcInRvdWNoZW5kIHRvdWNoY2FuY2VsXCIsdCl9LF9jYW5jZWw6ZnVuY3Rpb24oKXtjbGVhclRpbWVvdXQodGhpcy5faG9sZFRpbWVvdXQpLGsoZG9jdW1lbnQsXCJ0b3VjaGVuZCB0b3VjaGNhbmNlbCBjb250ZXh0bWVudVwiLHRoaXMuX2NhbmNlbCx0aGlzKSxrKGRvY3VtZW50LFwidG91Y2htb3ZlXCIsdGhpcy5fb25Nb3ZlLHRoaXMpfSxfb25Nb3ZlOmZ1bmN0aW9uKHQpe3Q9dC50b3VjaGVzWzBdO3RoaXMuX25ld1Bvcz1uZXcgcCh0LmNsaWVudFgsdC5jbGllbnRZKX0sX2lzVGFwVmFsaWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbmV3UG9zLmRpc3RhbmNlVG8odGhpcy5fc3RhcnRQb3MpPD10aGlzLl9tYXAub3B0aW9ucy50YXBUb2xlcmFuY2V9LF9zaW11bGF0ZUV2ZW50OmZ1bmN0aW9uKHQsZSl7dD1uZXcgTW91c2VFdmVudCh0LHtidWJibGVzOiEwLGNhbmNlbGFibGU6ITAsdmlldzp3aW5kb3csc2NyZWVuWDplLnNjcmVlblgsc2NyZWVuWTplLnNjcmVlblksY2xpZW50WDplLmNsaWVudFgsY2xpZW50WTplLmNsaWVudFl9KTt0Ll9zaW11bGF0ZWQ9ITAsZS50YXJnZXQuZGlzcGF0Y2hFdmVudCh0KX19KSksT3Q9KEEuYWRkSW5pdEhvb2soXCJhZGRIYW5kbGVyXCIsXCJ0YXBIb2xkXCIsa3QpLEEubWVyZ2VPcHRpb25zKHt0b3VjaFpvb206Yi50b3VjaCxib3VuY2VBdFpvb21MaW1pdHM6ITB9KSxuLmV4dGVuZCh7YWRkSG9va3M6ZnVuY3Rpb24oKXtNKHRoaXMuX21hcC5fY29udGFpbmVyLFwibGVhZmxldC10b3VjaC16b29tXCIpLFModGhpcy5fbWFwLl9jb250YWluZXIsXCJ0b3VjaHN0YXJ0XCIsdGhpcy5fb25Ub3VjaFN0YXJ0LHRoaXMpfSxyZW1vdmVIb29rczpmdW5jdGlvbigpe3oodGhpcy5fbWFwLl9jb250YWluZXIsXCJsZWFmbGV0LXRvdWNoLXpvb21cIiksayh0aGlzLl9tYXAuX2NvbnRhaW5lcixcInRvdWNoc3RhcnRcIix0aGlzLl9vblRvdWNoU3RhcnQsdGhpcyl9LF9vblRvdWNoU3RhcnQ6ZnVuY3Rpb24odCl7dmFyIGUsaSxuPXRoaXMuX21hcDshdC50b3VjaGVzfHwyIT09dC50b3VjaGVzLmxlbmd0aHx8bi5fYW5pbWF0aW5nWm9vbXx8dGhpcy5fem9vbWluZ3x8KGU9bi5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludCh0LnRvdWNoZXNbMF0pLGk9bi5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludCh0LnRvdWNoZXNbMV0pLHRoaXMuX2NlbnRlclBvaW50PW4uZ2V0U2l6ZSgpLl9kaXZpZGVCeSgyKSx0aGlzLl9zdGFydExhdExuZz1uLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodGhpcy5fY2VudGVyUG9pbnQpLFwiY2VudGVyXCIhPT1uLm9wdGlvbnMudG91Y2hab29tJiYodGhpcy5fcGluY2hTdGFydExhdExuZz1uLmNvbnRhaW5lclBvaW50VG9MYXRMbmcoZS5hZGQoaSkuX2RpdmlkZUJ5KDIpKSksdGhpcy5fc3RhcnREaXN0PWUuZGlzdGFuY2VUbyhpKSx0aGlzLl9zdGFydFpvb209bi5nZXRab29tKCksdGhpcy5fbW92ZWQ9ITEsdGhpcy5fem9vbWluZz0hMCxuLl9zdG9wKCksUyhkb2N1bWVudCxcInRvdWNobW92ZVwiLHRoaXMuX29uVG91Y2hNb3ZlLHRoaXMpLFMoZG9jdW1lbnQsXCJ0b3VjaGVuZCB0b3VjaGNhbmNlbFwiLHRoaXMuX29uVG91Y2hFbmQsdGhpcyksTyh0KSl9LF9vblRvdWNoTW92ZTpmdW5jdGlvbih0KXtpZih0LnRvdWNoZXMmJjI9PT10LnRvdWNoZXMubGVuZ3RoJiZ0aGlzLl96b29taW5nKXt2YXIgZT10aGlzLl9tYXAsaT1lLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KHQudG91Y2hlc1swXSksbj1lLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KHQudG91Y2hlc1sxXSksbz1pLmRpc3RhbmNlVG8obikvdGhpcy5fc3RhcnREaXN0O2lmKHRoaXMuX3pvb209ZS5nZXRTY2FsZVpvb20obyx0aGlzLl9zdGFydFpvb20pLCFlLm9wdGlvbnMuYm91bmNlQXRab29tTGltaXRzJiYodGhpcy5fem9vbTxlLmdldE1pblpvb20oKSYmbzwxfHx0aGlzLl96b29tPmUuZ2V0TWF4Wm9vbSgpJiYxPG8pJiYodGhpcy5fem9vbT1lLl9saW1pdFpvb20odGhpcy5fem9vbSkpLFwiY2VudGVyXCI9PT1lLm9wdGlvbnMudG91Y2hab29tKXtpZih0aGlzLl9jZW50ZXI9dGhpcy5fc3RhcnRMYXRMbmcsMT09bylyZXR1cm59ZWxzZXtpPWkuX2FkZChuKS5fZGl2aWRlQnkoMikuX3N1YnRyYWN0KHRoaXMuX2NlbnRlclBvaW50KTtpZigxPT1vJiYwPT09aS54JiYwPT09aS55KXJldHVybjt0aGlzLl9jZW50ZXI9ZS51bnByb2plY3QoZS5wcm9qZWN0KHRoaXMuX3BpbmNoU3RhcnRMYXRMbmcsdGhpcy5fem9vbSkuc3VidHJhY3QoaSksdGhpcy5fem9vbSl9dGhpcy5fbW92ZWR8fChlLl9tb3ZlU3RhcnQoITAsITEpLHRoaXMuX21vdmVkPSEwKSxyKHRoaXMuX2FuaW1SZXF1ZXN0KTtuPWEoZS5fbW92ZSxlLHRoaXMuX2NlbnRlcix0aGlzLl96b29tLHtwaW5jaDohMCxyb3VuZDohMX0sdm9pZCAwKTt0aGlzLl9hbmltUmVxdWVzdD14KG4sdGhpcywhMCksTyh0KX19LF9vblRvdWNoRW5kOmZ1bmN0aW9uKCl7dGhpcy5fbW92ZWQmJnRoaXMuX3pvb21pbmc/KHRoaXMuX3pvb21pbmc9ITEscih0aGlzLl9hbmltUmVxdWVzdCksayhkb2N1bWVudCxcInRvdWNobW92ZVwiLHRoaXMuX29uVG91Y2hNb3ZlLHRoaXMpLGsoZG9jdW1lbnQsXCJ0b3VjaGVuZCB0b3VjaGNhbmNlbFwiLHRoaXMuX29uVG91Y2hFbmQsdGhpcyksdGhpcy5fbWFwLm9wdGlvbnMuem9vbUFuaW1hdGlvbj90aGlzLl9tYXAuX2FuaW1hdGVab29tKHRoaXMuX2NlbnRlcix0aGlzLl9tYXAuX2xpbWl0Wm9vbSh0aGlzLl96b29tKSwhMCx0aGlzLl9tYXAub3B0aW9ucy56b29tU25hcCk6dGhpcy5fbWFwLl9yZXNldFZpZXcodGhpcy5fY2VudGVyLHRoaXMuX21hcC5fbGltaXRab29tKHRoaXMuX3pvb20pKSk6dGhpcy5fem9vbWluZz0hMX19KSksWWk9KEEuYWRkSW5pdEhvb2soXCJhZGRIYW5kbGVyXCIsXCJ0b3VjaFpvb21cIixPdCksQS5Cb3hab29tPV90LEEuRG91YmxlQ2xpY2tab29tPUN0LEEuRHJhZz1adCxBLktleWJvYXJkPVN0LEEuU2Nyb2xsV2hlZWxab29tPUV0LEEuVGFwSG9sZD1rdCxBLlRvdWNoWm9vbT1PdCx0LkJvdW5kcz1mLHQuQnJvd3Nlcj1iLHQuQ1JTPW90LHQuQ2FudmFzPUZpLHQuQ2lyY2xlPWdpLHQuQ2lyY2xlTWFya2VyPWZpLHQuQ2xhc3M9ZXQsdC5Db250cm9sPUIsdC5EaXZJY29uPUlpLHQuRGl2T3ZlcmxheT1PaSx0LkRvbUV2ZW50PW10LHQuRG9tVXRpbD1wdCx0LkRyYWdnYWJsZT1KZSx0LkV2ZW50ZWQ9aXQsdC5GZWF0dXJlR3JvdXA9dWksdC5HZW9KU09OPXhpLHQuR3JpZExheWVyPVJpLHQuSGFuZGxlcj1uLHQuSWNvbj1jaSx0LkltYWdlT3ZlcmxheT1TaSx0LkxhdExuZz12LHQuTGF0TG5nQm91bmRzPXMsdC5MYXllcj1vLHQuTGF5ZXJHcm91cD1saSx0LkxpbmVVdGlsPWd0LHQuTWFwPUEsdC5NYXJrZXI9cGksdC5NaXhpbj1mdCx0LlBhdGg9bWksdC5Qb2ludD1wLHQuUG9seVV0aWw9dnQsdC5Qb2x5Z29uPXlpLHQuUG9seWxpbmU9dmksdC5Qb3B1cD1BaSx0LlBvc0FuaW1hdGlvbj1XZSx0LlByb2plY3Rpb249d3QsdC5SZWN0YW5nbGU9S2ksdC5SZW5kZXJlcj1IaSx0LlNWRz1xaSx0LlNWR092ZXJsYXk9a2ksdC5UaWxlTGF5ZXI9TmksdC5Ub29sdGlwPUJpLHQuVHJhbnNmb3JtYXRpb249YXQsdC5VdGlsPXR0LHQuVmlkZW9PdmVybGF5PUVpLHQuYmluZD1hLHQuYm91bmRzPV8sdC5jYW52YXM9V2ksdC5jaXJjbGU9ZnVuY3Rpb24odCxlLGkpe3JldHVybiBuZXcgZ2kodCxlLGkpfSx0LmNpcmNsZU1hcmtlcj1mdW5jdGlvbih0LGUpe3JldHVybiBuZXcgZmkodCxlKX0sdC5jb250cm9sPVVlLHQuZGl2SWNvbj1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IElpKHQpfSx0LmV4dGVuZD1sLHQuZmVhdHVyZUdyb3VwPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG5ldyB1aSh0LGUpfSx0Lmdlb0pTT049WmksdC5nZW9Kc29uPU10LHQuZ3JpZExheWVyPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgUmkodCl9LHQuaWNvbj1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGNpKHQpfSx0LmltYWdlT3ZlcmxheT1mdW5jdGlvbih0LGUsaSl7cmV0dXJuIG5ldyBTaSh0LGUsaSl9LHQubGF0TG5nPXcsdC5sYXRMbmdCb3VuZHM9Zyx0LmxheWVyR3JvdXA9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbmV3IGxpKHQsZSl9LHQubWFwPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG5ldyBBKHQsZSl9LHQubWFya2VyPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG5ldyBwaSh0LGUpfSx0LnBvaW50PW0sdC5wb2x5Z29uPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG5ldyB5aSh0LGUpfSx0LnBvbHlsaW5lPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG5ldyB2aSh0LGUpfSx0LnBvcHVwPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG5ldyBBaSh0LGUpfSx0LnJlY3RhbmdsZT1mdW5jdGlvbih0LGUpe3JldHVybiBuZXcgS2kodCxlKX0sdC5zZXRPcHRpb25zPWMsdC5zdGFtcD1oLHQuc3ZnPUdpLHQuc3ZnT3ZlcmxheT1mdW5jdGlvbih0LGUsaSl7cmV0dXJuIG5ldyBraSh0LGUsaSl9LHQudGlsZUxheWVyPURpLHQudG9vbHRpcD1mdW5jdGlvbih0LGUpe3JldHVybiBuZXcgQmkodCxlKX0sdC50cmFuc2Zvcm1hdGlvbj1odCx0LnZlcnNpb249XCIxLjkuM1wiLHQudmlkZW9PdmVybGF5PWZ1bmN0aW9uKHQsZSxpKXtyZXR1cm4gbmV3IEVpKHQsZSxpKX0sd2luZG93LkwpO3Qubm9Db25mbGljdD1mdW5jdGlvbigpe3JldHVybiB3aW5kb3cuTD1ZaSx0aGlzfSx3aW5kb3cuTD10fSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sZWFmbGV0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/leaflet/dist/leaflet.js\n");

/***/ }),

/***/ "./node_modules/tiny-binary-search/index.js":
/*!**************************************************!*\
  !*** ./node_modules/tiny-binary-search/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction BinarySearchIndex (values) {\n  this.values = [].concat(values || []);\n}\n\nBinarySearchIndex.prototype.query = function (value) {\n  var index = this.getIndex(value);\n  return this.values[index];\n};\n\nBinarySearchIndex.prototype.getIndex = function getIndex (value) {\n  if (this.dirty) {\n    this.sort();\n  }\n\n  var minIndex = 0;\n  var maxIndex = this.values.length - 1;\n  var currentIndex;\n  var currentElement;\n\n  while (minIndex <= maxIndex) {\n    currentIndex = (minIndex + maxIndex) / 2 | 0;\n    currentElement = this.values[Math.round(currentIndex)];\n    if (+currentElement.value < +value) {\n      minIndex = currentIndex + 1;\n    } else if (+currentElement.value > +value) {\n      maxIndex = currentIndex - 1;\n    } else {\n      return currentIndex;\n    }\n  }\n\n  return Math.abs(~maxIndex);\n};\n\nBinarySearchIndex.prototype.between = function between (start, end) {\n  var startIndex = this.getIndex(start);\n  var endIndex = this.getIndex(end);\n\n  if (startIndex === 0 && endIndex === 0) {\n    return [];\n  }\n\n  while (this.values[startIndex - 1] && this.values[startIndex - 1].value === start) {\n    startIndex--;\n  }\n\n  while (this.values[endIndex + 1] && this.values[endIndex + 1].value === end) {\n    endIndex++;\n  }\n\n  if (this.values[endIndex] && this.values[endIndex].value === end && this.values[endIndex + 1]) {\n    endIndex++;\n  }\n\n  return this.values.slice(startIndex, endIndex);\n};\n\nBinarySearchIndex.prototype.insert = function insert (item) {\n  this.values.splice(this.getIndex(item.value), 0, item);\n  return this;\n};\n\nBinarySearchIndex.prototype.bulkAdd = function bulkAdd (items, sort) {\n  this.values = this.values.concat([].concat(items || []));\n\n  if (sort) {\n    this.sort();\n  } else {\n    this.dirty = true;\n  }\n\n  return this;\n};\n\nBinarySearchIndex.prototype.sort = function sort () {\n  this.values.sort(function (a, b) {\n    return +b.value - +a.value;\n  }).reverse();\n  this.dirty = false;\n  return this;\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BinarySearchIndex);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGlueS1iaW5hcnktc2VhcmNoL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLGlFQUFlLGlCQUFpQixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RpbnktYmluYXJ5LXNlYXJjaC9pbmRleC5qcz9lODg4Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIEJpbmFyeVNlYXJjaEluZGV4ICh2YWx1ZXMpIHtcbiAgdGhpcy52YWx1ZXMgPSBbXS5jb25jYXQodmFsdWVzIHx8IFtdKTtcbn1cblxuQmluYXJ5U2VhcmNoSW5kZXgucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHZhciBpbmRleCA9IHRoaXMuZ2V0SW5kZXgodmFsdWUpO1xuICByZXR1cm4gdGhpcy52YWx1ZXNbaW5kZXhdO1xufTtcblxuQmluYXJ5U2VhcmNoSW5kZXgucHJvdG90eXBlLmdldEluZGV4ID0gZnVuY3Rpb24gZ2V0SW5kZXggKHZhbHVlKSB7XG4gIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgdGhpcy5zb3J0KCk7XG4gIH1cblxuICB2YXIgbWluSW5kZXggPSAwO1xuICB2YXIgbWF4SW5kZXggPSB0aGlzLnZhbHVlcy5sZW5ndGggLSAxO1xuICB2YXIgY3VycmVudEluZGV4O1xuICB2YXIgY3VycmVudEVsZW1lbnQ7XG5cbiAgd2hpbGUgKG1pbkluZGV4IDw9IG1heEluZGV4KSB7XG4gICAgY3VycmVudEluZGV4ID0gKG1pbkluZGV4ICsgbWF4SW5kZXgpIC8gMiB8IDA7XG4gICAgY3VycmVudEVsZW1lbnQgPSB0aGlzLnZhbHVlc1tNYXRoLnJvdW5kKGN1cnJlbnRJbmRleCldO1xuICAgIGlmICgrY3VycmVudEVsZW1lbnQudmFsdWUgPCArdmFsdWUpIHtcbiAgICAgIG1pbkluZGV4ID0gY3VycmVudEluZGV4ICsgMTtcbiAgICB9IGVsc2UgaWYgKCtjdXJyZW50RWxlbWVudC52YWx1ZSA+ICt2YWx1ZSkge1xuICAgICAgbWF4SW5kZXggPSBjdXJyZW50SW5kZXggLSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3VycmVudEluZGV4O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBNYXRoLmFicyh+bWF4SW5kZXgpO1xufTtcblxuQmluYXJ5U2VhcmNoSW5kZXgucHJvdG90eXBlLmJldHdlZW4gPSBmdW5jdGlvbiBiZXR3ZWVuIChzdGFydCwgZW5kKSB7XG4gIHZhciBzdGFydEluZGV4ID0gdGhpcy5nZXRJbmRleChzdGFydCk7XG4gIHZhciBlbmRJbmRleCA9IHRoaXMuZ2V0SW5kZXgoZW5kKTtcblxuICBpZiAoc3RhcnRJbmRleCA9PT0gMCAmJiBlbmRJbmRleCA9PT0gMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHdoaWxlICh0aGlzLnZhbHVlc1tzdGFydEluZGV4IC0gMV0gJiYgdGhpcy52YWx1ZXNbc3RhcnRJbmRleCAtIDFdLnZhbHVlID09PSBzdGFydCkge1xuICAgIHN0YXJ0SW5kZXgtLTtcbiAgfVxuXG4gIHdoaWxlICh0aGlzLnZhbHVlc1tlbmRJbmRleCArIDFdICYmIHRoaXMudmFsdWVzW2VuZEluZGV4ICsgMV0udmFsdWUgPT09IGVuZCkge1xuICAgIGVuZEluZGV4Kys7XG4gIH1cblxuICBpZiAodGhpcy52YWx1ZXNbZW5kSW5kZXhdICYmIHRoaXMudmFsdWVzW2VuZEluZGV4XS52YWx1ZSA9PT0gZW5kICYmIHRoaXMudmFsdWVzW2VuZEluZGV4ICsgMV0pIHtcbiAgICBlbmRJbmRleCsrO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMudmFsdWVzLnNsaWNlKHN0YXJ0SW5kZXgsIGVuZEluZGV4KTtcbn07XG5cbkJpbmFyeVNlYXJjaEluZGV4LnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiBpbnNlcnQgKGl0ZW0pIHtcbiAgdGhpcy52YWx1ZXMuc3BsaWNlKHRoaXMuZ2V0SW5kZXgoaXRlbS52YWx1ZSksIDAsIGl0ZW0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkJpbmFyeVNlYXJjaEluZGV4LnByb3RvdHlwZS5idWxrQWRkID0gZnVuY3Rpb24gYnVsa0FkZCAoaXRlbXMsIHNvcnQpIHtcbiAgdGhpcy52YWx1ZXMgPSB0aGlzLnZhbHVlcy5jb25jYXQoW10uY29uY2F0KGl0ZW1zIHx8IFtdKSk7XG5cbiAgaWYgKHNvcnQpIHtcbiAgICB0aGlzLnNvcnQoKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuQmluYXJ5U2VhcmNoSW5kZXgucHJvdG90eXBlLnNvcnQgPSBmdW5jdGlvbiBzb3J0ICgpIHtcbiAgdGhpcy52YWx1ZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiArYi52YWx1ZSAtICthLnZhbHVlO1xuICB9KS5yZXZlcnNlKCk7XG4gIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBCaW5hcnlTZWFyY2hJbmRleDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tiny-binary-search/index.js\n");

/***/ }),

/***/ "./node_modules/esri-leaflet/package.json":
/*!************************************************!*\
  !*** ./node_modules/esri-leaflet/package.json ***!
  \************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"esri-leaflet","description":"Leaflet plugins for consuming ArcGIS Online and ArcGIS Server services.","version":"3.0.9","author":"Patrick Arlt <parlt@esri.com> (http://patrickarlt.com)","bugs":{"url":"https://github.com/esri/esri-leaflet/issues"},"contributors":["Patrick Arlt <parlt@esri.com> (http://patrickarlt.com)","John Gravois <jgravois@esri.com> (https://johngravois.com)","Gavin Rehkemper <grehkemper@esri.com> (https://gavinr.com)","Jacob Wasilkowski <jwasilkowski@esri.com> (https://jwasilgeo.github.io)"],"dependencies":{"@terraformer/arcgis":"^2.1.0","tiny-binary-search":"^1.0.3"},"devDependencies":{"@rollup/plugin-json":"^4.1.0","@rollup/plugin-node-resolve":"^13.1.3","chai":"4.3.6","chokidar-cli":"^3.0.0","gh-release":"^6.0.1","highlight.js":"^11.4.0","http-server":"^14.1.0","husky":"^1.1.1","karma":"^6.3.18","karma-chrome-launcher":"^3.1.1","karma-coverage":"^2.2.0","karma-edgium-launcher":"github:matracey/karma-edgium-launcher","karma-firefox-launcher":"^2.1.2","karma-mocha":"^2.0.1","karma-mocha-reporter":"^2.2.5","karma-safari-launcher":"~1.0.0","karma-sinon-chai":"^2.0.2","karma-sourcemap-loader":"^0.3.8","leaflet":"^1.6.0","mkdirp":"^1.0.4","mocha":"^9.2.0","npm-run-all":"^4.1.5","rollup":"^2.67.2","rollup-plugin-terser":"^7.0.2","semistandard":"^14.2.3","sinon":"^13.0.1","sinon-chai":"3.7.0","snazzy":"^9.0.0","uglify-js":"^3.15.1"},"files":["src/**/*.js","dist/esri-leaflet.js","dist/esri-leaflet.js.map","dist/esri-leaflet-debug.js.map","dist/siteData.json","profiles/*.js"],"homepage":"https://developers.arcgis.com/esri-leaflet/","module":"src/EsriLeaflet.js","jsnext:main":"src/EsriLeaflet.js","jspm":{"registry":"npm","format":"es6","main":"src/EsriLeaflet.js"},"keywords":["arcgis","esri","esri leaflet","gis","leaflet plugin","mapping"],"license":"Apache-2.0","main":"dist/esri-leaflet-debug.js","peerDependencies":{"leaflet":"^1.0.0"},"readmeFilename":"README.md","repository":{"type":"git","url":"git@github.com:Esri/esri-leaflet.git"},"scripts":{"build":"rollup -c profiles/debug.js & rollup -c profiles/production.js","lint":"semistandard | snazzy","prebuild":"mkdirp dist","pretest":"npm run build","precommit":"npm run lint","fix":"semistandard --fix","release":"./scripts/release.sh","start-watch":"chokidar src -c \\"npm run build\\"","start":"run-p start-watch serve","serve":"http-server -p 5000 -c-1 -o","test":"npm run lint && karma start"},"semistandard":{"globals":["expect","L","XMLHttpRequest","sinon","xhr","proj4"]},"unpkg":"dist/esri-leaflet-debug.js"}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./resources/assets/core/plugins/custom/leaflet/leaflet.js");
/******/ 	
/******/ })()
;